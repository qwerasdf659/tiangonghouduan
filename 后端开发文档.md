# é¤å…ç§¯åˆ†æŠ½å¥–ç³»ç»Ÿ - åç«¯å¼€å‘æ–‡æ¡£

> **åŸºäºå¼€å‘æ€»æ–‡æ¡£1å·å’Œå‰ç«¯1å·æ–‡æ¡£çš„åç«¯å®ç°æŒ‡å¯¼**

## ğŸ¯ æ–‡æ¡£æ¦‚è¿°

æœ¬æ–‡æ¡£æ ¹æ®å¼€å‘æ€»æ–‡æ¡£1å·å’Œå‰ç«¯1å·æ–‡æ¡£çš„è¦æ±‚ï¼Œè¯¦ç»†è¯´æ˜åç«¯APIå¼€å‘ã€ä¸šåŠ¡é€»è¾‘å®ç°å’Œç³»ç»Ÿéƒ¨ç½²é…ç½®ã€‚åŒ…å«å®Œæ•´çš„æ¥å£è§„èŒƒã€æ•°æ®åº“å¯¹æ¥ã€å®æ—¶é€šä¿¡ã€å®‰å…¨æœºåˆ¶ç­‰åç«¯å¼€å‘çš„æ‰€æœ‰å…³é”®ç‚¹ã€‚

---

## ğŸ—„ï¸ ä¸€ã€æ•°æ®åº“ç¯å¢ƒé…ç½®

### 1.1 æ•°æ®åº“è¿æ¥ä¿¡æ¯
```javascript
// æ•°æ®åº“é…ç½®
const dbConfig = {
  development: {
    host: 'test-db-mysql.ns-br0za7uc.svc',
    port: 3306,
    user: 'root',
    password: 'mc6r9cgb',
    database: 'restaurant_points_dev',
    connectionString: 'mysql://root:mc6r9cgb@test-db-mysql.ns-br0za7uc.svc:3306/restaurant_points_dev'
  },
  production: {
    host: 'dbconn.sealosbja.site',
    port: 42182,
    user: 'root', 
    password: 'mc6r9cgb',
    database: 'restaurant_points_prod',
    connectionString: 'mysql://root:mc6r9cgb@dbconn.sealosbja.site:42182/restaurant_points_prod'
  }
}
```

### 1.2 æœåŠ¡å™¨éƒ¨ç½²é…ç½®
```javascript
// DevboxæœåŠ¡å™¨é…ç½®
const serverConfig = {
  devbox: {
    name: 'devbox1',
    port: 3000,
    internalUrl: 'http://devbox1.ns-br0za7uc.svc.cluster.local:3000',
    publicUrl: 'https://rqchrlqndora.sealosbja.site'
  }
}
```

### 1.3 Sealoså¯¹è±¡å­˜å‚¨é…ç½®
```javascript
// ğŸ”´ Sealoså¯¹è±¡å­˜å‚¨é…ç½® - ç”¨æˆ·æä¾›çš„çœŸå®é…ç½®
const sealosConfig = {
  bucket: 'tiangong',
  accessKeyId: 'br0za7uc',
  secretAccessKey: 'skxg8mk5gqfhf9xz',
  endpoint: {
    internal: 'http://object-storage.objectstorage-system.svc.cluster.local',
    external: 'https://objectstorageapi.bja.sealos.run'
  },
  // æ ¹æ®ç¯å¢ƒè‡ªåŠ¨é€‰æ‹©ç«¯ç‚¹
  getEndpoint: () => {
    return process.env.NODE_ENV === 'production' 
      ? sealosConfig.endpoint.external 
      : sealosConfig.endpoint.internal;
  }
}
```

---

## ğŸ”Œ äºŒã€æ ¸å¿ƒAPIæ¥å£å®ç°

### 2.1 è®¤è¯æˆæƒç³»ç»Ÿ

#### ğŸ”‘ ç”¨æˆ·ç™»å½•è®¤è¯
```javascript
// POST /api/auth/login
// ğŸ”´ å‰ç«¯å¯¹æ¥ç‚¹1ï¼šæ‰‹æœºå·éªŒè¯ç ç™»å½•
app.post('/api/auth/login', async (req, res) => {
  try {
    const { phone, code } = req.body;
    
    // 1. éªŒè¯æ‰‹æœºå·æ ¼å¼
    if (!/^1[3-9]\d{9}$/.test(phone)) {
      return res.json({
        code: 1001,
        msg: 'æ‰‹æœºå·æ ¼å¼ä¸æ­£ç¡®',
        data: null
      });
    }
    
    // 2. éªŒè¯éªŒè¯ç ï¼ˆå¼€å‘ç¯å¢ƒå¯æ”¾å®½ï¼‰
    const isValidCode = await verifyCode(phone, code);
    if (!isValidCode && process.env.NODE_ENV === 'production') {
      return res.json({
        code: 1002,
        msg: 'éªŒè¯ç é”™è¯¯æˆ–å·²è¿‡æœŸ',
        data: null
      });
    }
    
    // 3. æŸ¥è¯¢æˆ–åˆ›å»ºç”¨æˆ·
    let user = await User.findOne({ mobile: phone });
    if (!user) {
      user = await User.create({
        mobile: phone,
        total_points: 1000, // æ–°ç”¨æˆ·å¥–åŠ±1000ç§¯åˆ†
        nickname: `ç”¨æˆ·${phone.slice(-4)}`,
        created_at: new Date()
      });
    }
    
    // 4. ç”ŸæˆJWT Token
    const accessToken = jwt.sign(
      { 
        user_id: user.user_id,
        mobile: user.mobile,
        is_merchant: user.is_merchant 
      },
      process.env.JWT_SECRET,
      { expiresIn: '2h' }
    );
    
    const refreshToken = jwt.sign(
      { user_id: user.user_id },
      process.env.JWT_REFRESH_SECRET,
      { expiresIn: '7d' }
    );
    
    // 5. æ›´æ–°ç™»å½•æ—¶é—´
    await User.update(
      { last_login: new Date() },
      { where: { user_id: user.user_id } }
    );
    
    res.json({
      code: 0,
      msg: 'success',
      data: {
        access_token: accessToken,
        refresh_token: refreshToken,
        expires_in: 7200,
        user_info: {
          user_id: user.user_id,
          mobile: user.mobile.replace(/(\d{3})\d{4}(\d{4})/, '$1****$2'),
          nickname: user.nickname,
          avatar: user.avatar,
          total_points: user.total_points,
          is_merchant: user.is_merchant
        }
      }
    });
  } catch (error) {
    console.error('ç™»å½•å¤±è´¥:', error);
    res.json({
      code: 1000,
      msg: 'ç³»ç»Ÿå¼‚å¸¸ï¼Œè¯·ç¨åé‡è¯•',
      data: null
    });
  }
});
```

#### ğŸ”„ Tokenåˆ·æ–°æœºåˆ¶
```javascript
// POST /api/auth/refresh
// ğŸ”´ å‰ç«¯å¯¹æ¥ç‚¹2ï¼šè‡ªåŠ¨åˆ·æ–°Token
app.post('/api/auth/refresh', async (req, res) => {
  try {
    const refreshToken = req.headers.authorization?.replace('Bearer ', '');
    
    if (!refreshToken) {
      return res.json({
        code: 2001,
        msg: 'Refresh Tokenä¸èƒ½ä¸ºç©º',
        data: null
      });
    }
    
    // éªŒè¯Refresh Token
    const decoded = jwt.verify(refreshToken, process.env.JWT_REFRESH_SECRET);
    const user = await User.findByPk(decoded.user_id);
    
    if (!user) {
      return res.json({
        code: 2002,
        msg: 'ç”¨æˆ·ä¸å­˜åœ¨',
        data: null
      });
    }
    
    // ç”Ÿæˆæ–°çš„Token
    const accessToken = jwt.sign(
      { 
        user_id: user.user_id,
        mobile: user.mobile,
        is_merchant: user.is_merchant 
      },
      process.env.JWT_SECRET,
      { expiresIn: '2h' }
    );
    
    const newRefreshToken = jwt.sign(
      { user_id: user.user_id },
      process.env.JWT_REFRESH_SECRET,
      { expiresIn: '7d' }
    );
    
    res.json({
      code: 0,
      msg: 'success',
      data: {
        access_token: accessToken,
        refresh_token: newRefreshToken,
        expires_in: 7200
      }
    });
  } catch (error) {
    console.error('Tokenåˆ·æ–°å¤±è´¥:', error);
    res.json({
      code: 2000,
      msg: 'Tokenæ— æ•ˆæˆ–å·²è¿‡æœŸ',
      data: null
    });
  }
});
```

### 2.2 æŠ½å¥–ç³»ç»Ÿå®ç°

#### ğŸ° æŠ½å¥–é…ç½®æ¥å£
```javascript
// GET /api/lottery/config
// ğŸ”´ å‰ç«¯å¯¹æ¥ç‚¹3ï¼šè·å–è½¬ç›˜é…ç½®æ•°æ®
app.get('/api/lottery/config', authenticateToken, async (req, res) => {
  try {
    // è·å–æŠ½å¥–é…ç½®
    const prizes = await LotterySetting.findAll({
      where: { status: 'active' },
      order: [['angle', 'ASC']]
    });
    
    // è®¡ç®—æ€»æ¦‚ç‡ï¼ˆéªŒè¯é…ç½®æ­£ç¡®æ€§ï¼‰
    const totalProbability = prizes.reduce((sum, prize) => sum + parseFloat(prize.probability), 0);
    
    if (Math.abs(totalProbability - 1.0) > 0.001) {
      console.error('æŠ½å¥–æ¦‚ç‡é…ç½®é”™è¯¯ï¼Œæ€»æ¦‚ç‡ä¸ç­‰äº1:', totalProbability);
    }
    
    res.json({
      code: 0,
      msg: 'success',
      data: {
        cost_points: 100, // å•æ¬¡æŠ½å¥–æ¶ˆè€—ç§¯åˆ†
        prizes: prizes.map(prize => ({
          id: prize.prize_id,
          name: prize.prize_name,
          type: prize.prize_type,
          value: prize.prize_value,
          angle: prize.angle,
          color: prize.color,
          probability: prize.probability,
          is_activity: prize.is_activity // ğŸ”´ è§¦å‘ç‰¹æ®ŠåŠ¨æ•ˆ
        }))
      }
    });
  } catch (error) {
    console.error('è·å–æŠ½å¥–é…ç½®å¤±è´¥:', error);
    res.json({
      code: 3000,
      msg: 'è·å–é…ç½®å¤±è´¥',
      data: null
    });
  }
});
```

#### ğŸ¯ æ‰§è¡ŒæŠ½å¥–æ¥å£
```javascript
// POST /api/lottery/draw
// ğŸ”´ å‰ç«¯å¯¹æ¥ç‚¹4ï¼šæ‰§è¡ŒæŠ½å¥–é€»è¾‘
app.post('/api/lottery/draw', authenticateToken, async (req, res) => {
  try {
    const { draw_type, count } = req.body;
    const userId = req.user.user_id;
    
    // éªŒè¯æŠ½å¥–æ¬¡æ•°
    const drawCounts = {
      'single': 1,
      'triple': 3, 
      'quintuple': 5,
      'decade': 10
    };
    
    const actualCount = drawCounts[draw_type] || 1;
    const totalCost = actualCount * 100; // æ¯æ¬¡100ç§¯åˆ†
    
    // æ£€æŸ¥ç§¯åˆ†ä½™é¢
    const user = await User.findByPk(userId);
    if (user.total_points < totalCost) {
      return res.json({
        code: 3001,
        msg: 'ç§¯åˆ†ä½™é¢ä¸è¶³',
        data: { required: totalCost, current: user.total_points }
      });
    }
    
    // è·å–æŠ½å¥–é…ç½®
    const prizes = await LotterySetting.findAll({
      where: { status: 'active' },
      order: [['angle', 'ASC']]
    });
    
    // æ‰§è¡ŒæŠ½å¥–
    const results = [];
    for (let i = 0; i < actualCount; i++) {
      const result = await performLottery(prizes, userId);
      results.push(result);
    }
    
    // æ‰£é™¤ç§¯åˆ†
    await User.decrement('total_points', {
      by: totalCost,
      where: { user_id: userId }
    });
    
    // è®°å½•ç§¯åˆ†å˜åŠ¨
    await PointsRecord.create({
      user_id: userId,
      type: 'spend',
      points: -totalCost,
      description: `${draw_type}æŠ½å¥–`,
      source: 'lottery',
      balance_after: user.total_points - totalCost
    });
    
    // ğŸ”´ å‘é€WebSocketé€šçŸ¥ç§¯åˆ†å˜æ›´
    await notifyPointsUpdate(userId, user.total_points - totalCost, -totalCost, 'æŠ½å¥–æ¶ˆè´¹');
    
    res.json({
      code: 0,
      msg: 'success',
      data: {
        results: results,
        points_cost: totalCost,
        remaining_points: user.total_points - totalCost
      }
    });
  } catch (error) {
    console.error('æŠ½å¥–å¤±è´¥:', error);
    res.json({
      code: 3000,
      msg: 'æŠ½å¥–å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•',
      data: null
    });
  }
});

// æŠ½å¥–æ ¸å¿ƒç®—æ³•
async function performLottery(prizes, userId) {
  const random = Math.random();
  let cumulativeProbability = 0;
  
  for (const prize of prizes) {
    cumulativeProbability += parseFloat(prize.probability);
    
    if (random <= cumulativeProbability) {
      // ğŸ”´ æ£€æŸ¥æ˜¯å¦è§¦å‘"å·®ç‚¹ä¸­å¥–"åŠ¨æ•ˆ
      const isNearMiss = checkNearMiss(random, cumulativeProbability, prize);
      
      // è®°å½•æŠ½å¥–ç»“æœ
      await LotteryRecord.create({
        user_id: userId,
        prize_id: prize.prize_id,
        prize_name: prize.prize_name,
        prize_type: prize.prize_type,
        prize_value: prize.prize_value,
        is_near_miss: isNearMiss
      });
      
      return {
        prize_id: prize.prize_id,
        prize_name: prize.prize_name,
        prize_type: prize.prize_type,
        prize_value: prize.prize_value,
        angle: prize.angle,
        is_near_miss: isNearMiss // ğŸ”´ å‰ç«¯æ ¹æ®æ­¤å­—æ®µæ’­æ”¾æŠ–åŠ¨åŠ¨ç”»
      };
    }
  }
  
  // å…œåº•ï¼šè¿”å›æœ€åä¸€ä¸ªå¥–å“ï¼ˆé€šå¸¸æ˜¯è°¢è°¢å‚ä¸ï¼‰
  const lastPrize = prizes[prizes.length - 1];
  return {
    prize_id: lastPrize.prize_id,
    prize_name: lastPrize.prize_name,
    prize_type: lastPrize.prize_type,
    prize_value: lastPrize.prize_value,
    angle: lastPrize.angle,
    is_near_miss: false
  };
}

// æ£€æŸ¥"å·®ç‚¹ä¸­å¥–"é€»è¾‘
function checkNearMiss(random, cumulativeProbability, prize) {
  // å¦‚æœæ˜¯ç‰¹æ®Šå¥–å“ä¸”éšæœºæ•°æ¥è¿‘è¾¹ç•Œï¼Œè§¦å‘å·®ç‚¹ä¸­å¥–
  if (prize.is_activity) {
    const previousBoundary = cumulativeProbability - parseFloat(prize.probability);
    const distanceFromStart = random - previousBoundary;
    const distanceFromEnd = cumulativeProbability - random;
    
    // å¦‚æœè·ç¦»è¾¹ç•Œå¾ˆè¿‘ï¼Œè§¦å‘å·®ç‚¹ä¸­å¥–åŠ¨æ•ˆ
    return distanceFromStart < 0.02 || distanceFromEnd < 0.02;
  }
  return false;
}
```

### 2.3 å•†å“å…‘æ¢ç³»ç»Ÿ

#### ğŸ›ï¸ å•†å“åˆ—è¡¨æ¥å£
```javascript
// GET /api/exchange/products
// ğŸ”´ å‰ç«¯å¯¹æ¥ç‚¹5ï¼šæ”¯æŒç­›é€‰åˆ†é¡µçš„å•†å“åˆ—è¡¨
app.get('/api/exchange/products', authenticateToken, async (req, res) => {
  try {
    const { 
      category, 
      min_points, 
      max_points, 
      stock_status, 
      sort_by = 'sort_order',
      sort_order = 'ASC',
      page = 1, 
      limit = 20 
    } = req.query;
    
    // æ„å»ºæŸ¥è¯¢æ¡ä»¶
    const whereClause = { status: 'active' };
    
    if (category && category !== 'å…¨éƒ¨') {
      whereClause.category = category;
    }
    
    if (min_points) {
      whereClause.exchange_points = { [Op.gte]: parseInt(min_points) };
    }
    
    if (max_points) {
      if (whereClause.exchange_points) {
        whereClause.exchange_points[Op.lte] = parseInt(max_points);
      } else {
        whereClause.exchange_points = { [Op.lte]: parseInt(max_points) };
      }
    }
    
    if (stock_status === 'in_stock') {
      whereClause.stock = { [Op.gt]: 0 };
    } else if (stock_status === 'out_of_stock') {
      whereClause.stock = 0;
    }
    
    // åˆ†é¡µæŸ¥è¯¢
    const offset = (parseInt(page) - 1) * parseInt(limit);
    const { count, rows } = await CommodityPool.findAndCountAll({
      where: whereClause,
      order: [[sort_by, sort_order.toUpperCase()]],
      limit: parseInt(limit),
      offset: offset
    });
    
    res.json({
      code: 0,
      msg: 'success',
      data: {
        products: rows.map(product => ({
          id: product.commodity_id,
          name: product.name,
          description: product.description,
          category: product.category,
          exchange_points: product.exchange_points,
          stock: product.stock, // ğŸ”´ å®æ—¶åº“å­˜æ˜¾ç¤º
          image: product.image,
          is_hot: product.is_hot,
          rating: product.rating,
          sales_count: product.sales_count,
          status: product.stock > 0 ? 'available' : 'sold_out'
        })),
        pagination: {
          total: count,
          page: parseInt(page),
          limit: parseInt(limit),
          total_pages: Math.ceil(count / parseInt(limit))
        }
      }
    });
  } catch (error) {
    console.error('è·å–å•†å“åˆ—è¡¨å¤±è´¥:', error);
    res.json({
      code: 4000,
      msg: 'è·å–å•†å“åˆ—è¡¨å¤±è´¥',
      data: null
    });
  }
});
```

#### ğŸ’° å•†å“å…‘æ¢æ¥å£
```javascript
// POST /api/exchange/redeem
// ğŸ”´ å‰ç«¯å¯¹æ¥ç‚¹6ï¼šæ‰§è¡Œå•†å“å…‘æ¢
app.post('/api/exchange/redeem', authenticateToken, async (req, res) => {
  const transaction = await sequelize.transaction();
  
  try {
    const { commodity_id, quantity = 1, delivery_info } = req.body;
    const userId = req.user.user_id;
    
    // æŸ¥è¯¢å•†å“ä¿¡æ¯
    const product = await CommodityPool.findByPk(commodity_id, { transaction });
    if (!product) {
      await transaction.rollback();
      return res.json({
        code: 4001,
        msg: 'å•†å“ä¸å­˜åœ¨',
        data: null
      });
    }
    
    // æ£€æŸ¥åº“å­˜
    if (product.stock < quantity) {
      await transaction.rollback();
      return res.json({
        code: 4002,
        msg: 'åº“å­˜ä¸è¶³',
        data: { available: product.stock, requested: quantity }
      });
    }
    
    // æ£€æŸ¥ç§¯åˆ†ä½™é¢
    const totalCost = product.exchange_points * quantity;
    const user = await User.findByPk(userId, { transaction });
    
    if (user.total_points < totalCost) {
      await transaction.rollback();
      return res.json({
        code: 4003,
        msg: 'ç§¯åˆ†ä½™é¢ä¸è¶³',
        data: { required: totalCost, current: user.total_points }
      });
    }
    
    // æ‰£å‡åº“å­˜
    await CommodityPool.decrement('stock', {
      by: quantity,
      where: { commodity_id: commodity_id },
      transaction
    });
    
    // æ‰£å‡ç§¯åˆ†
    await User.decrement('total_points', {
      by: totalCost,
      where: { user_id: userId },
      transaction
    });
    
    // åˆ›å»ºå…‘æ¢è®°å½•
    const orderNumber = generateOrderNumber();
    const exchangeRecord = await ExchangeRecord.create({
      user_id: userId,
      commodity_id: commodity_id,
      order_id: orderNumber,
      product_name: product.name,
      quantity: quantity,
      points_cost: totalCost,
      status: 'pending',
      delivery_info: delivery_info
    }, { transaction });
    
    // è®°å½•ç§¯åˆ†å˜åŠ¨
    await PointsRecord.create({
      user_id: userId,
      type: 'spend',
      points: -totalCost,
      description: `å…‘æ¢å•†å“ï¼š${product.name}`,
      source: 'exchange',
      balance_after: user.total_points - totalCost
    }, { transaction });
    
    await transaction.commit();
    
    // ğŸ”´ å‘é€WebSocketåº“å­˜æ›´æ–°é€šçŸ¥
    await notifyStockUpdate(commodity_id, product.stock - quantity, 'purchase');
    
    // ğŸ”´ å‘é€ç§¯åˆ†å˜æ›´é€šçŸ¥
    await notifyPointsUpdate(userId, user.total_points - totalCost, -totalCost, 'å•†å“å…‘æ¢');
    
    res.json({
      code: 0,
      msg: 'success',
      data: {
        order_id: orderNumber,
        product_name: product.name,
        quantity: quantity,
        points_cost: totalCost,
        remaining_points: user.total_points - totalCost,
        status: 'pending'
      }
    });
  } catch (error) {
    await transaction.rollback();
    console.error('å•†å“å…‘æ¢å¤±è´¥:', error);
    res.json({
      code: 4000,
      msg: 'å…‘æ¢å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•',
      data: null
    });
  }
});

// ç”Ÿæˆè®¢å•å·
function generateOrderNumber() {
  const timestamp = Date.now();
  const random = Math.floor(Math.random() * 1000).toString().padStart(3, '0');
  return `EX${timestamp}${random}`;
}
```

### 2.4 æ‹ç…§ä¸Šä¼ ç³»ç»Ÿ

#### ğŸ“¸ å›¾ç‰‡ä¸Šä¼ ä¸AIè¯†åˆ«
```javascript
// POST /api/photo/upload
// ğŸ”´ å‰ç«¯å¯¹æ¥ç‚¹7ï¼šå›¾ç‰‡ä¸Šä¼ +OCRè¯†åˆ«
const multer = require('multer');
const sealosStorage = require('../services/sealosStorage');

const upload = multer({ 
  storage: multer.memoryStorage(),
  limits: { fileSize: 10 * 1024 * 1024 } // 10MBé™åˆ¶
});

app.post('/api/photo/upload', authenticateToken, upload.single('file'), async (req, res) => {
  try {
    const { amount } = req.body;
    const userId = req.user.user_id;
    const file = req.file;
    
    if (!file) {
      return res.json({
        code: 5001,
        msg: 'è¯·é€‰æ‹©è¦ä¸Šä¼ çš„å›¾ç‰‡',
        data: null
      });
    }
    
    // ğŸ”´ ä¸Šä¼ åˆ°Sealoså¯¹è±¡å­˜å‚¨ï¼ˆä½¿ç”¨çœŸå®é…ç½®ï¼‰
    const imageUrl = await sealosStorage.uploadImage(
      file.buffer, 
      file.originalname, 
      'receipt-photos'
    );
    
    // AIè¯†åˆ«é‡‘é¢ï¼ˆè°ƒç”¨OCRæœåŠ¡ï¼‰
    const recognizedAmount = await performOCR(imageUrl);
    
    // è®¡ç®—ç§¯åˆ†å¥–åŠ±ï¼ˆé‡‘é¢Ã—10ï¼‰
    const inputAmount = parseFloat(amount);
    const aiAmount = recognizedAmount || inputAmount;
    const pointsAwarded = Math.floor(aiAmount * 10);
    
    // é™åˆ¶ç§¯åˆ†èŒƒå›´
    const finalPoints = Math.max(50, Math.min(2000, pointsAwarded));
    
    // åˆ¤æ–­åŒ¹é…çŠ¶æ€
    let matchStatus = 'unclear';
    if (recognizedAmount) {
      const difference = Math.abs(recognizedAmount - inputAmount);
      if (difference <= 0.5) {
        matchStatus = 'matched';
      } else {
        matchStatus = 'mismatched';
      }
    }
    
    // ç”Ÿæˆä¸Šä¼ ID
    const uploadId = generateUploadId();
    
    // åˆ›å»ºå®¡æ ¸è®°å½•
    await PhotoReview.create({
      user_id: userId,
      upload_id: uploadId,
      image_url: imageUrl,
      input_amount: inputAmount,
      recognized_amount: recognizedAmount,
      match_status: matchStatus,
      points_awarded: finalPoints,
      review_status: 'pending'
    });
    
    res.json({
      code: 0,
      msg: 'success',
      data: {
        upload_id: uploadId,
        image_url: imageUrl,
        input_amount: inputAmount,
        recognized_amount: recognizedAmount, // ğŸ”´ AIè¯†åˆ«é‡‘é¢
        points_awarded: finalPoints, // ğŸ”´ è®¡ç®—çš„ç§¯åˆ†å¥–åŠ±
        match_status: matchStatus, // ğŸ”´ åŒ¹é…çŠ¶æ€
        review_status: 'pending' // ğŸ”´ å®¡æ ¸çŠ¶æ€
      }
    });
  } catch (error) {
    console.error('å›¾ç‰‡ä¸Šä¼ å¤±è´¥:', error);
    res.json({
      code: 5000,
      msg: 'ä¸Šä¼ å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•',
      data: null
    });
  }
});

// ç”Ÿæˆä¸Šä¼ ID
function generateUploadId() {
  const timestamp = Date.now();
  const random = Math.floor(Math.random() * 1000).toString().padStart(3, '0');
  return `UP${timestamp}${random}`;
}
```

---

## ğŸŒ ä¸‰ã€WebSocketå®æ—¶é€šä¿¡å®ç°

### 3.1 WebSocketæœåŠ¡å™¨é…ç½®
```javascript
const WebSocket = require('ws');
const jwt = require('jsonwebtoken');

// åˆ›å»ºWebSocketæœåŠ¡å™¨
const wss = new WebSocket.Server({ 
  port: 8080,
  verifyClient: (info) => {
    // éªŒè¯WebSocketè¿æ¥çš„Token
    const token = new URL(info.req.url, 'http://localhost').searchParams.get('token');
    try {
      jwt.verify(token, process.env.JWT_SECRET);
      return true;
    } catch (error) {
      return false;
    }
  }
});

// ç”¨æˆ·è¿æ¥æ˜ å°„
const userConnections = new Map();

wss.on('connection', (ws, req) => {
  // æå–ç”¨æˆ·ä¿¡æ¯
  const token = new URL(req.url, 'http://localhost').searchParams.get('token');
  const decoded = jwt.verify(token, process.env.JWT_SECRET);
  const userId = decoded.user_id;
  
  // å­˜å‚¨ç”¨æˆ·è¿æ¥
  userConnections.set(userId, ws);
  
  console.log(`ç”¨æˆ· ${userId} å·²è¿æ¥WebSocket`);
  
  // å¤„ç†æ¶ˆæ¯
  ws.on('message', (message) => {
    try {
      const data = JSON.parse(message);
      handleWebSocketMessage(userId, data, ws);
    } catch (error) {
      console.error('WebSocketæ¶ˆæ¯è§£æå¤±è´¥:', error);
    }
  });
  
  // å¤„ç†æ–­å¼€è¿æ¥
  ws.on('close', () => {
    userConnections.delete(userId);
    console.log(`ç”¨æˆ· ${userId} å·²æ–­å¼€WebSocketè¿æ¥`);
  });
  
  // å‘é€è¿æ¥ç¡®è®¤
  ws.send(JSON.stringify({
    type: 'connected',
    timestamp: new Date().toISOString(),
    message: 'è¿æ¥æˆåŠŸ'
  }));
});

// å¤„ç†WebSocketæ¶ˆæ¯
function handleWebSocketMessage(userId, data, ws) {
  switch (data.type) {
    case 'ping':
      // ğŸ”´ å¿ƒè·³æœºåˆ¶
      ws.send(JSON.stringify({
        type: 'pong',
        timestamp: Date.now(),
        server_time: new Date().toISOString()
      }));
      break;
      
    case 'subscribe_product':
      // è®¢é˜…å•†å“åº“å­˜æ›´æ–°
      ws.subscribedProducts = data.product_ids || [];
      break;
      
    default:
      console.log('æœªçŸ¥çš„WebSocketæ¶ˆæ¯ç±»å‹:', data.type);
  }
}
```

### 3.2 å®æ—¶é€šçŸ¥åŠŸèƒ½
```javascript
// ğŸ”´ åº“å­˜å˜æ›´æ¨é€
async function notifyStockUpdate(productId, newStock, operation) {
  const message = {
    type: 'stock_update',
    data: {
      product_id: productId,
      stock: newStock,
      operation: operation, // purchase/restock/admin_adjust
      timestamp: new Date().toISOString()
    }
  };
  
  // å¹¿æ’­ç»™æ‰€æœ‰è¿æ¥çš„ç”¨æˆ·
  userConnections.forEach((ws, userId) => {
    if (ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify(message));
    }
  });
}

// ğŸ”´ ç§¯åˆ†å˜æ›´æ¨é€
async function notifyPointsUpdate(userId, totalPoints, changePoints, reason) {
  const ws = userConnections.get(userId);
  if (ws && ws.readyState === WebSocket.OPEN) {
    const message = {
      type: 'points_update',
      data: {
        user_id: userId,
        total_points: totalPoints,
        change_points: changePoints,
        reason: reason,
        timestamp: new Date().toISOString()
      }
    };
    
    ws.send(JSON.stringify(message));
  }
}

// ğŸ”´ å®¡æ ¸ç»“æœæ¨é€
async function notifyReviewResult(userId, uploadId, status, pointsAwarded, reason) {
  const ws = userConnections.get(userId);
  if (ws && ws.readyState === WebSocket.OPEN) {
    const message = {
      type: 'review_result',
      data: {
        upload_id: uploadId,
        status: status, // approved/rejected
        points_awarded: pointsAwarded,
        review_reason: reason,
        timestamp: new Date().toISOString()
      }
    };
    
    ws.send(JSON.stringify(message));
  }
}
```

---

## ğŸ”’ å››ã€å®‰å…¨æœºåˆ¶å®ç°

### 4.1 JWTè®¤è¯ä¸­é—´ä»¶
```javascript
// JWTè®¤è¯ä¸­é—´ä»¶
function authenticateToken(req, res, next) {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];
  
  if (!token) {
    return res.json({
      code: 2001,
      msg: 'è®¿é—®ä»¤ç‰Œä¸èƒ½ä¸ºç©º',
      data: null
    });
  }
  
  jwt.verify(token, process.env.JWT_SECRET, (err, user) => {
    if (err) {
      return res.json({
        code: 2002,
        msg: 'è®¿é—®ä»¤ç‰Œæ— æ•ˆæˆ–å·²è¿‡æœŸ',
        data: null
      });
    }
    
    req.user = user;
    next();
  });
}
```

### 4.2 è¯·æ±‚é™æµä¸­é—´ä»¶
```javascript
const rateLimit = require('express-rate-limit');

// ğŸ”´ é˜²åˆ·æœºåˆ¶ï¼šAPIé™æµ
const apiLimiter = rateLimit({
  windowMs: 60 * 1000, // 1åˆ†é’Ÿ
  max: 60, // é™åˆ¶æ¯ä¸ªIPæ¯åˆ†é’Ÿ60æ¬¡è¯·æ±‚
  message: {
    code: 3001,
    msg: 'è¯·æ±‚è¿‡äºé¢‘ç¹ï¼Œè¯·ç¨åå†è¯•',
    data: null
  },
  standardHeaders: true,
  legacyHeaders: false
});

// æŠ½å¥–é™æµï¼ˆæ›´ä¸¥æ ¼ï¼‰
const lotteryLimiter = rateLimit({
  windowMs: 60 * 1000, // 1åˆ†é’Ÿ
  max: 3, // é™åˆ¶æ¯ä¸ªç”¨æˆ·æ¯åˆ†é’Ÿ3æ¬¡æŠ½å¥–
  keyGenerator: (req) => req.user?.user_id || req.ip,
  message: {
    code: 3002,
    msg: 'æŠ½å¥–è¿‡äºé¢‘ç¹ï¼Œè¯·ç¨åå†è¯•',
    data: null
  }
});

// åº”ç”¨é™æµä¸­é—´ä»¶
app.use('/api/', apiLimiter);
app.use('/api/lottery/draw', lotteryLimiter);
```

### 4.3 æ•°æ®åŠ å¯†
```javascript
const crypto = require('crypto');

// æ•æ„Ÿæ•°æ®åŠ å¯†
function encryptSensitiveData(data) {
  const algorithm = 'aes-256-gcm';
  const key = Buffer.from(process.env.ENCRYPTION_KEY, 'hex');
  const iv = crypto.randomBytes(16);
  
  const cipher = crypto.createCipher(algorithm, key);
  cipher.setAAD(Buffer.from('sensitive_data'));
  
  let encrypted = cipher.update(JSON.stringify(data), 'utf8', 'hex');
  encrypted += cipher.final('hex');
  
  const authTag = cipher.getAuthTag();
  
  return {
    encrypted,
    iv: iv.toString('hex'),
    authTag: authTag.toString('hex')
  };
}

// æ•æ„Ÿæ•°æ®è§£å¯†
function decryptSensitiveData(encryptedData) {
  const algorithm = 'aes-256-gcm';
  const key = Buffer.from(process.env.ENCRYPTION_KEY, 'hex');
  
  const decipher = crypto.createDecipher(algorithm, key);
  decipher.setAAD(Buffer.from('sensitive_data'));
  decipher.setAuthTag(Buffer.from(encryptedData.authTag, 'hex'));
  
  let decrypted = decipher.update(encryptedData.encrypted, 'hex', 'utf8');
  decrypted += decipher.final('utf8');
  
  return JSON.parse(decrypted);
}
```

---

## ğŸ“Š äº”ã€æ€§èƒ½ç›‘æ§å®ç°

### 5.1 æ€§èƒ½æŒ‡æ ‡æ”¶é›†
```javascript
// POST /api/monitoring/performance
// ğŸ”´ å‰ç«¯æ€§èƒ½æ•°æ®ä¸ŠæŠ¥
app.post('/api/monitoring/performance', authenticateToken, async (req, res) => {
  try {
    const {
      api_response_time,
      canvas_render_fps,
      page_load_time,
      memory_usage,
      error_rate
    } = req.body;
    
    // å­˜å‚¨æ€§èƒ½æ•°æ®
    await PerformanceMetric.create({
      user_id: req.user.user_id,
      api_response_time,
      canvas_render_fps,
      page_load_time,
      memory_usage,
      error_rate,
      timestamp: new Date()
    });
    
    res.json({
      code: 0,
      msg: 'success',
      data: null
    });
  } catch (error) {
    console.error('æ€§èƒ½æ•°æ®æ”¶é›†å¤±è´¥:', error);
    res.json({
      code: 6000,
      msg: 'æ•°æ®æ”¶é›†å¤±è´¥',
      data: null
    });
  }
});
```

### 5.2 é”™è¯¯æ—¥å¿—æ”¶é›†
```javascript
// POST /api/monitoring/errors
// ğŸ”´ å‰ç«¯é”™è¯¯æ—¥å¿—ä¸ŠæŠ¥
app.post('/api/monitoring/errors', async (req, res) => {
  try {
    const {
      message,
      stack,
      page,
      user_id
    } = req.body;
    
    // å­˜å‚¨é”™è¯¯æ—¥å¿—
    await ErrorLog.create({
      user_id,
      error_message: message,
      error_stack: stack,
      page_route: page,
      timestamp: new Date()
    });
    
    res.json({
      code: 0,
      msg: 'success',
      data: null
    });
  } catch (error) {
    console.error('é”™è¯¯æ—¥å¿—æ”¶é›†å¤±è´¥:', error);
    res.json({
      code: 6001,
      msg: 'æ—¥å¿—æ”¶é›†å¤±è´¥',
      data: null
    });
  }
});
```

---

## ğŸš€ å…­ã€éƒ¨ç½²é…ç½®

### 6.1 ç¯å¢ƒå˜é‡é…ç½®
```bash
# .env ç¯å¢ƒå˜é‡é…ç½®æ–‡ä»¶
NODE_ENV=production
PORT=3000

# æ•°æ®åº“é…ç½®
DB_HOST=test-db-mysql.ns-br0za7uc.svc
DB_PORT=3306
DB_USER=root
DB_PASSWORD=mc6r9cgb
DB_NAME=restaurant_points

# JWTé…ç½®
JWT_SECRET=your_jwt_secret_key_here
JWT_REFRESH_SECRET=your_refresh_secret_key_here

# åŠ å¯†é…ç½®
ENCRYPTION_KEY=your_encryption_key_32_bytes_hex

# ğŸ”´ Sealoså­˜å‚¨é…ç½® - ç”¨æˆ·æä¾›çš„çœŸå®é…ç½®
SEALOS_ENDPOINT=https://objectstorageapi.bja.sealos.run
SEALOS_INTERNAL_ENDPOINT=http://object-storage.objectstorage-system.svc.cluster.local
SEALOS_BUCKET=tiangong
SEALOS_ACCESS_KEY=br0za7uc
SEALOS_SECRET_KEY=skxg8mk5gqfhf9xz

# OCRæœåŠ¡é…ç½®
OCR_API_KEY=your_ocr_api_key
OCR_SECRET_KEY=your_ocr_secret_key

# WebSocketé…ç½®
WS_PORT=8080
```

### 6.2 Dockeréƒ¨ç½²é…ç½®
```dockerfile
# Dockerfile
FROM node:18-alpine

WORKDIR /app

# å¤åˆ¶package.json
COPY package*.json ./

# å®‰è£…ä¾èµ–
RUN npm install --production

# å¤åˆ¶åº”ç”¨ä»£ç 
COPY . .

# æš´éœ²ç«¯å£
EXPOSE 3000 8080

# å¯åŠ¨å‘½ä»¤
CMD ["npm", "start"]
```

### 6.3 éƒ¨ç½²è„šæœ¬
```bash
#!/bin/bash
# deploy.sh - éƒ¨ç½²è„šæœ¬

echo "å¼€å§‹éƒ¨ç½²é¤å…ç§¯åˆ†æŠ½å¥–ç³»ç»Ÿåç«¯..."

# 1. æ„å»ºDockeré•œåƒ
docker build -t restaurant-points-backend .

# 2. åœæ­¢æ—§å®¹å™¨
docker stop restaurant-points-backend 2>/dev/null || true
docker rm restaurant-points-backend 2>/dev/null || true

# 3. å¯åŠ¨æ–°å®¹å™¨
docker run -d \
  --name restaurant-points-backend \
  --restart unless-stopped \
  -p 3000:3000 \
  -p 8080:8080 \
  --env-file .env \
  restaurant-points-backend

echo "éƒ¨ç½²å®Œæˆï¼"
echo "APIæœåŠ¡åœ°å€: http://devbox1.ns-br0za7uc.svc.cluster.local:3000"
echo "WebSocketåœ°å€: ws://devbox1.ns-br0za7uc.svc.cluster.local:8080"
echo "å…¬ç½‘è®¿é—®åœ°å€: https://rqchrlqndora.sealosbja.site"
```

---

## ğŸ“‹ ä¸ƒã€å¯¹æ¥æ£€æŸ¥æ¸…å•

### 7.1 APIæ¥å£æ£€æŸ¥
- [ ] âœ… è®¤è¯æ¥å£ `/api/auth/login` æ­£å¸¸å·¥ä½œ
- [ ] âœ… Tokenåˆ·æ–° `/api/auth/refresh` æ­£å¸¸å·¥ä½œ
- [ ] âœ… æŠ½å¥–é…ç½® `/api/lottery/config` è¿”å›æ­£ç¡®æ•°æ®
- [ ] âœ… æŠ½å¥–æ‰§è¡Œ `/api/lottery/draw` æ”¯æŒæ‰¹é‡æŠ½å¥–
- [ ] âœ… å•†å“åˆ—è¡¨ `/api/exchange/products` æ”¯æŒç­›é€‰åˆ†é¡µ
- [ ] âœ… å•†å“å…‘æ¢ `/api/exchange/redeem` äº‹åŠ¡å®Œæ•´æ€§
- [ ] âœ… å›¾ç‰‡ä¸Šä¼  `/api/photo/upload` é›†æˆOCRè¯†åˆ«
- [ ] âœ… å•†å®¶å®¡æ ¸ `/api/merchant/review` æƒé™éªŒè¯

### 7.2 WebSocketé€šä¿¡æ£€æŸ¥
- [ ] âœ… WebSocketè¿æ¥è®¤è¯æœºåˆ¶
- [ ] âœ… åº“å­˜å˜æ›´å®æ—¶æ¨é€
- [ ] âœ… ç§¯åˆ†å˜æ›´å®æ—¶æ¨é€
- [ ] âœ… å®¡æ ¸ç»“æœå®æ—¶æ¨é€
- [ ] âœ… å¿ƒè·³ä¿æ´»æœºåˆ¶

### 7.3 å®‰å…¨æœºåˆ¶æ£€æŸ¥
- [ ] âœ… JWTåŒä»¤ç‰Œè®¤è¯
- [ ] âœ… APIè¯·æ±‚é™æµ
- [ ] âœ… æ•æ„Ÿæ•°æ®åŠ å¯†
- [ ] âœ… é˜²åˆ·æœºåˆ¶å¯ç”¨
- [ ] âœ… HTTPSå¼ºåˆ¶è·³è½¬

### 7.4 æ•°æ®åº“è¿æ¥æ£€æŸ¥
- [ ] âœ… å†…ç½‘æ•°æ®åº“è¿æ¥æ­£å¸¸
- [ ] âœ… å¤–ç½‘æ•°æ®åº“è¿æ¥æ­£å¸¸
- [ ] âœ… æ•°æ®åº“äº‹åŠ¡æœºåˆ¶
- [ ] âœ… è¿æ¥æ± é…ç½®ä¼˜åŒ–
- [ ] âœ… ç´¢å¼•åˆ›å»ºå®Œæˆ

---

> **ğŸ”´ é‡è¦æé†’**: 
> 1. æ‰€æœ‰APIæ¥å£å¿…é¡»ä¸¥æ ¼æŒ‰ç…§å‰ç«¯1å·æ–‡æ¡£çš„è¦æ±‚å®ç°
> 2. WebSocketæ¶ˆæ¯æ ¼å¼å¿…é¡»ä¸å‰ç«¯ä¿æŒä¸€è‡´
> 3. æ•°æ®åº“å­—æ®µæ˜ å°„å¿…é¡»å®Œå…¨åŒ¹é…å‰ç«¯éœ€æ±‚
> 4. å®‰å…¨æœºåˆ¶å’Œæ€§èƒ½ç›‘æ§å¿…é¡»åœ¨ç”Ÿäº§ç¯å¢ƒå¯ç”¨

> **ğŸš€ éƒ¨ç½²å»ºè®®**:
> 1. ä½¿ç”¨æä¾›çš„æ•°æ®åº“è¿æ¥ä¿¡æ¯è¿›è¡Œå¼€å‘æµ‹è¯•
> 2. åœ¨Devbox1ç¯å¢ƒä¸­éƒ¨ç½²å’Œè°ƒè¯•
> 3. ç¡®ä¿æ‰€æœ‰ç¯å¢ƒå˜é‡æ­£ç¡®é…ç½®
> 4. å»ºç«‹å®Œæ•´çš„ç›‘æ§å’Œæ—¥å¿—ç³»ç»Ÿ 