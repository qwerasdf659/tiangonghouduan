# 奖品概率管理 — 开发任务总览

本文档包含奖品概率管理相关的全部开发任务，共 14 项，分 3 轮实施。

---

## 🔍 后端数据库求证报告（2026-02-22 基于真实代码和数据库核实）

> 以下内容基于后端项目实际代码文件、数据库真实表结构和真实数据核实，不引用任何历史报告。

### 一、实际后端技术栈确认

| 层 | 技术 | 版本 | 说明 |
|---|------|------|------|
| 运行时 | Node.js | 20+ | `engines` 要求 `>=20.18.0` |
| 框架 | Express | 4.18 | RESTful API |
| ORM | Sequelize | 6.35 | MySQL 方言 |
| 数据库 | MySQL | 8.x | Sealos 托管 `restaurant_points_dev` |
| 缓存 | Redis/ioredis | 5.7 | 速率限制、缓存 |
| WebSocket | Socket.io | 4.8 | 实时通信 |
| 认证 | JWT + RBAC | — | Bearer Token + 角色权限 |
| 时区 | Asia/Shanghai | — | 全链路北京时间 |
| 事务管理 | TransactionManager | 自研 | 统一事务边界控制 |
| 服务管理 | ServiceManager | 自研 | `req.app.locals.services.getService('xxx')` |
| 响应格式 | ApiResponse | 自研 | `res.apiSuccess()` / `res.apiError()` / `res.apiInternalError()` |

**API 路径规范**：`/api/v4/{domain}/{resource}`，管理后台统一挂在 `/api/v4/console/` 下。

**现有奖品池路由文件**：`routes/v4/console/prize_pool.js`，挂载于 `/api/v4/console/prize-pool`。

### 二、数据库真实数据核实

**lottery_campaigns 表 — 4 条记录**：

| ID | 名称 | pick_method | segment_resolver_version | status |
|----|------|-------------|--------------------------|--------|
| 1 | 餐厅积分抽奖 | tier_first | v1 | active |
| 25 | 走走走 | tier_first | v1 | ended |
| 26 | 再找找 | tier_first | v1 | paused |
| 27 | 12312 | tier_first | v1 | ended |

- 所有活动均使用 `tier_first`，无活动使用 `fallback` 或 `normalize`。
- `pick_method` 枚举实际值：`ENUM('normalize','fallback','tier_first')`。

**lottery_prizes 表 — 活动 1 共 15 个奖品**：

| 档位 | 奖品数 | 总权重 | 有数据的字段 |
|------|--------|--------|-------------|
| high | 4 | 1,000,000 | `win_weight` 有值（10000~700000），`reward_tier` = 'high' |
| mid | 4 | 1,000,000 | `win_weight` 有值（100000~400000），`reward_tier` = 'mid' |
| low | 7 | 1,000,000 | `win_weight` 有值（120000~240000），6 个是 `is_fallback=1` |

- `win_weight` 和 `reward_tier` 字段**数据库中已有数据**，但 `PrizePoolService.updatePrize()` 的 `allowedFields` **确实未包含这两个字段**，文档任务一描述正确。
- `500积分券`（win_weight=700000）和 `九八折券`（win_weight=200000）库存为 0 但权重 > 0，属于文档任务七描述的风险情况。

**lottery_tier_rules 表 — 活动 1 的档位权重规则**：

| segment_key | high | mid | low | 总计 |
|-------------|------|-----|-----|------|
| default | 50,000 | 150,000 | 800,000 | 1,000,000 |
| new_user | 100,000 | 200,000 | 700,000 | 1,000,000 |
| vip_user | 80,000 | 220,000 | 700,000 | 1,000,000 |

- 已有 3 种用户分群的档位权重配置，与 `segment_resolver_version='v1'` 对应。

**segment_rule_configs 表 — 不存在**：文档任务三需要新建此表。

**admin_operation_logs 表 — 已存在**：包含 `before_data`（JSON）、`after_data`（JSON）、`changed_fields`（JSON）、`risk_level` 等字段，可直接复用于任务八的审计日志，**无需新建审计表**。

### 三、现有后端 API 清单与路径规范

**已有路由**（`/api/v4/console/prize-pool`）：

| 方法 | 路径 | 功能 | 服务方法 |
|------|------|------|---------|
| POST | `/batch-add` | 批量添加奖品 | `PrizePoolService.batchAddPrizes()` |
| GET | `/list` | 全量奖品列表（支持 `?lottery_campaign_id=&status=` 筛选） | `PrizePoolService.getAllPrizes()` |
| GET | `/:code` | 按活动代码查奖品池 | `PrizePoolService.getPrizesByCampaign()` |
| PUT | `/prize/:id` | 更新单个奖品 | `PrizePoolService.updatePrize()` |
| POST | `/prize/:id/add-stock` | 补充库存 | `PrizePoolService.addStock()` |
| DELETE | `/prize/:id` | 删除奖品（硬删除，有中奖记录则拒绝） | `PrizePoolService.deletePrize()` |

**路径规范纠偏**：

文档中部分任务提出的 API 路径与后端实际规范不一致：

| 文档中写的路径 | 后端实际应该用的路径 | 原因 |
|-------------|-------------------|------|
| `/api/v4/console/campaigns/:id/prizes` | `/api/v4/console/prize-pool/:code/grouped` | 奖品池已有独立路由模块，活动使用 `campaign_code` 而非数字 ID |
| `/api/v4/console/lottery/:campaignId/prizes` | `/api/v4/console/prize-pool/:code/prizes` | 同上，保持 prize-pool 模块内聚 |
| `POST /api/v4/console/lottery/:campaignId/prizes` | `POST /api/v4/console/prize-pool/batch-add`（已有）或扩展 | 已有批量添加，单个添加可扩展 |
| `DELETE /api/v4/console/lottery/:campaignId/prizes/:prizeId` | `DELETE /api/v4/console/prize-pool/prize/:id`（已有） | 已有删除接口 |
| `PUT /api/v4/console/lottery/:campaignId/prizes/:prizeId/stock` | `POST /api/v4/console/prize-pool/prize/:id/add-stock`（已有）或扩展 | 已有补货，可扩展为设置绝对值 |
| `PUT /api/v4/console/campaigns/:id/prizes/sort-order` | `PUT /api/v4/console/prize-pool/:code/sort-order` | 新增，放在 prize-pool 模块 |

### 四、各任务后端求证与纠偏

#### 任务一（加白名单）— 🔴 后端改动量比文档描述更大

- **后端问题 1**：`allowedFields` 确实缺少 `win_weight` 和 `reward_tier`，代码第 531-558 行核实。
- **后端问题 2（文档遗漏）**：`getAllPrizes()` 方法（第 398-421 行）的 `attributes` 数组和格式化输出（第 441-466 行）**均未包含** `win_weight`、`reward_tier`、`is_fallback` 三个字段。即使加了白名单，`GET /api/v4/console/prize-pool/list` 返回的数据中依然**看不到**这些字段。
- **后端问题 3（文档遗漏）**：`getPrizesByCampaign()` 方法（第 277-299 行）同样未包含这三个字段，`GET /api/v4/console/prize-pool/:code` 也不返回它们。
- **实际后端改动量**：不是文档说的"2 行"，而是 **~25 行**：`allowedFields` +2 行，`getAllPrizes()` attributes +3 行 + formatting +3 行，`getPrizesByCampaign()` attributes +3 行 + formatting +3 行，加上 `rarity_code` 也应同步加入格式化。
- **Web 前端问题**：`prizeForm` 缺这两个字段、编辑 Modal 缺 UI。
- **小程序前端**：不涉及（小程序不编辑奖品）。

#### 任务二（清理 fallback）— ✅ 确认可执行

- **后端问题**：`pick_method` 枚举仍包含 `fallback`，需要迁移脚本修改 ENUM。`fallback_lottery_prize_id` 字段需标记废弃。
- **数据库确认**：`SELECT COUNT(*) FROM lottery_campaigns WHERE pick_method = 'fallback'` = **0**，安全删除。
- **Web 前端问题**：如有 fallback 相关 UI 选项需移除。
- **小程序前端**：不涉及。
- **纠偏**：MySQL 修改 ENUM 需要 `ALTER TABLE ... MODIFY COLUMN` 而非直接删值，迁移脚本需注意。

#### 任务三（分群动态管理）— 🔴 拍板：完整实施

- **后端现状**：`config/segment_rules.js` 已有 `SegmentResolver` 类，实现了 v1~v4 共 5 个内置版本。包含 `resolveSegment()`、`simulateResolve()`、`getSegmentDistribution()` 等方法，**可直接复用**。
- **数据库现状**：`segment_rule_configs` 表**不存在**，需新建。
- **可复用的后端能力**：`SegmentResolver` 的版本查询、模拟测试方法可直接在新 API 中调用。
- **拍板结论**：选 B 完整实施——新建表 + 6 个 CRUD API + 条件构建器 UI + 测试面板，第三轮交付。

#### 任务四~六（概率可视化、概览面板、同档位对比）— 纯 Web 前端

- **后端**：不需要改动。现有 `GET /api/v4/console/prize-pool/:code` 已返回每个奖品的 `win_weight`、`reward_tier`，前端可自行计算档内占比。
- **Web 前端问题**：需新增前端计算和 UI 展示逻辑。
- **小程序前端**：不涉及。

#### 任务七（库存=0 风险提示）— 后端 + Web 前端

- **后端问题**：`updatePrize()` 保存时需加检测逻辑，返回 warning。
- **Web 前端问题**：奖品列表 UI 需标记。
- **小程序前端**：不涉及。
- **数据库确认**：当前确实有 2 个奖品库存=0 但 win_weight > 0（500积分券、九八折券）。

#### 任务八（审计日志）— 后端可直接复用

- **后端现状**：`admin_operation_logs` 表已有完整字段（`before_data`/`after_data`/`changed_fields`/`risk_level` 等），且 `PrizePoolService.updatePrize()` 已有审计日志调用。
- **需要做的**：确认现有审计日志是否已记录 `win_weight`/`reward_tier` 变更（加入白名单后自然会被记录），如已覆盖则**此任务后端工作量接近零**。
- **Web 前端**：如需独立的审计查看页面，则需前端开发。
- **小程序前端**：不涉及。

#### 任务九（normalize 引擎）— 🔴 拍板：现在做

- **后端问题**：`TierPickStage` 和 `PrizePickStage` 需增加 normalize 分支。
- **数据库确认**：`pick_method` ENUM 已包含 `normalize`，无需改表。
- **Web 前端**：选择 normalize 后的 UI 联动。
- **小程序前端**：抽奖流程走后端引擎，小程序无需感知算法差异。
- **拍板结论**：不推迟，第三轮实施。

#### 任务十（选择选奖方式）— 后端 + Web 前端

- **后端**：`LotteryCampaign` 模型已有 `pick_method` 字段，创建/编辑活动 API 已支持此字段，后端**不需要改**。
- **Web 前端**：需加下拉选择 UI 和条件联动显示。
- **小程序前端**：不涉及。

#### 任务十一~十四（活动级奖品管理、增删、排序、库存）— 需路径纠偏 + batchAddPrizes 修复

- **后端可复用能力**：
  - 查询：`GET /prize-pool/list?lottery_campaign_id=X` 已支持按活动筛选
  - 添加：`POST /prize-pool/batch-add` 已支持（但有 🔴 问题，见下）
  - 更新：`PUT /prize-pool/prize/:id` 已支持
  - 删除：`DELETE /prize-pool/prize/:id` 已支持
  - 补货：`POST /prize-pool/prize/:id/add-stock` 已支持
- **需要新增的后端 API**（仅 3 个）：
  1. `GET /api/v4/console/prize-pool/:code/grouped` — 按档位分组返回奖品（含档内占比计算）
  2. `PUT /api/v4/console/prize-pool/:code/sort-order` — 批量更新排序
  3. `PUT /api/v4/console/prize-pool/prize/:id/stock` — 设置绝对库存值（区别于现有 add-stock 的增量模式）
- **后端删除策略纠偏**：现有 `deletePrize()` 是**硬删除**（有中奖记录则拒绝），文档提出软删除。**拍板结论：改为 Sequelize paranoid 软删除**（加 `deleted_at` 列 + 模型 `paranoid: true`，Sequelize 自动处理，所有现有查询无需改动）。
- **🔴 batchAddPrizes() 两个阻塞问题（文档遗漏）**：
  1. **缺字段**：`batchAddPrizes()` 第 134-164 行创建奖品时，**未包含** `win_weight`、`reward_tier`、`is_fallback` 字段。新增奖品将使用数据库默认值（`win_weight=0`，`reward_tier='low'`，`is_fallback=0`），前端传的值被丢弃。
  2. **概率校验冲突**：`batchAddPrizes()` 第 101-109 行有硬编码校验 `win_probability` 总和必须 = 1.0（±0.001），但 `tier_first` 模式下 `win_probability` 不是生效字段，运营填的是 `win_weight`。当前所有 4 个活动都是 `tier_first`，这个校验会**阻断**任何不以百分比模式添加奖品的操作。
  - **修复方案**：校验逻辑改为按 `pick_method` 分支——`normalize` 模式校验 `win_probability` 总和 = 1.0，`tier_first` 模式跳过此校验（或改为校验 `win_weight` > 0）。

### 五、问题归属分类总表

| 任务 | 后端问题 | Web 管理后台前端问题 | 微信小程序前端问题 |
|------|---------|-------------------|-----------------|
| 1 白名单 | `allowedFields` 加 2 字段 | `prizeForm` + Modal UI + 提交逻辑 | 不涉及 |
| 2 清理 fallback | ENUM 迁移 + 废弃字段标记 | 移除 fallback UI 选项（如有） | 不涉及 |
| 3 分群动态管理 | 新建表 + 新增 6 个 API + 改 SegmentResolver | 新页面：条件构建器 + 测试面板 | 不涉及 |
| 4 档内占比 | 不需要 | 前端计算 + UI 展示 | 不涉及 |
| 5 奖品概览 | 不需要 | 新面板 UI | 不涉及 |
| 6 同档位对比 | 不需要 | 编辑 Modal 增加参照区 | 不涉及 |
| 7 风险提示 | `updatePrize()` 加 warning 返回 | 列表标记 + 底部提示 | 不涉及 |
| 8 审计日志 | 已有基础设施，加白名单后自动覆盖 | 如需查看页则开发 | 不涉及 |
| 9 normalize | 引擎新增分支 + 保存时概率校验 | normalize 模式下的 UI 联动 | 不涉及（走后端引擎） |
| 10 选奖方式 | 不需要（字段已支持） | 下拉选择 + 条件联动 | 不涉及 |
| 11 活动级入口 | 新增 1 个分组查询 API | 入口按钮 + 管理面板 UI | 不涉及 |
| 12 增删奖品 | 已有（batch-add + delete），扩展单个添加 | 新增 Modal + 删除确认 | 不涉及 |
| 13 排序 | 新增 1 个批量排序 API | 排序 UI（拖拽或按钮） | 排序变更后展示顺序同步 |
| 14 库存管理 | 新增 1 个设置绝对值 API，扩展批量接口 | inline 编辑 + 快捷按钮 + 批量弹窗 | 不涉及 |

**小结**：14 个任务中，**后端需改动 8 个**（任务 1/2/3/7/9/11/13/14），**Web 前端需改动 13 个**（除任务 2 外全部），**小程序仅涉及任务 13**（排序影响展示顺序）。

**🔴 本次数据库实查新发现的后端遗漏（跨任务影响）**：

| 遗漏问题 | 影响范围 | 所在代码 |
|---------|---------|---------|
| `getAllPrizes()` 不返回 `win_weight`/`reward_tier`/`is_fallback` | 任务 1/4/5/6/7/11 的前端均依赖这些字段 | `PrizePoolService.js` 第 398-466 行 |
| `getPrizesByCampaign()` 同样不返回这三个字段 | 任务 11 的分组 API 基础数据缺失 | `PrizePoolService.js` 第 277-334 行 |
| `batchAddPrizes()` 创建时不传 `win_weight`/`reward_tier`/`is_fallback` | 任务 12 新增奖品字段被丢弃 | `PrizePoolService.js` 第 134-164 行 |
| `batchAddPrizes()` 强制校验 `win_probability` 总和 = 1.0 | `tier_first` 模式添加奖品被阻断 | `PrizePoolService.js` 第 101-109 行 |
| `deleted_at` 列不存在 | 任务 12 软删除需要先建迁移 | `lottery_prizes` 表 |

这些问题均为**步骤 1 和步骤 3 的前置修复项**，不修复则后续任务全部阻塞。

### 六、后端可复用能力清单

| 已有能力 | 位置 | 可复用于 |
|---------|------|---------|
| `PrizePoolService.getAllPrizes(filters)` | `services/PrizePoolService.js` | 任务 11 活动级查询（已支持 `lottery_campaign_id` 筛选）🔴 **但缺 `win_weight`/`reward_tier`/`is_fallback` 字段，需先修复** |
| `PrizePoolService.batchAddPrizes()` | 同上 | 任务 12 新增奖品 🔴 **但缺 `win_weight`/`reward_tier`/`is_fallback` 传入 + `win_probability` 校验阻断 tier_first 模式，需先修复** |
| `PrizePoolService.updatePrize()` | 同上 | 任务 1/7/14 更新字段 |
| `PrizePoolService.deletePrize()` | 同上 | 任务 12 删除奖品 |
| `PrizePoolService.addStock()` | 同上 | 任务 14 库存补充 |
| `admin_operation_logs` 表 | 数据库 | 任务 8 审计日志（字段齐全，直接写入） |
| `SegmentResolver` 类 | `config/segment_rules.js` | 任务 3 分群管理（`resolveSegment`/`simulateResolve` 可复用） |
| `TransactionManager.execute()` | `utils/TransactionManager.js` | 任务 2/13/14 需要事务的操作 |
| `ServiceManager` 模式 | `app.js` 注册 | 新增的 Service 按此模式注册 |
| `adminAuthMiddleware` | `routes/v4/console/shared/middleware.js` | 所有新增路由复用 |
| `asyncHandler` 包装器 | 同上 | 所有新增路由复用 |
| `idx_prizes_campaign_tier_weight` 索引 | 数据库 | 按活动+档位+权重查询已有索引覆盖 |
| `idx_unique_campaign_sort_order` 唯一索引 | 数据库 | 排序唯一性已有数据库约束 |

### 七、后端可扩展点

| 扩展方向 | 依据 | 扩展成本 |
|---------|------|---------|
| 新增 Service 方法 | `PrizePoolService` 已有完善的 CRUD，新方法按同模式添加 | 低 |
| 新增路由到 `prize_pool.js` | 现有路由文件 362 行，结构清晰，可直接追加 | 低 |
| 新增 Sequelize 模型 | 已有 96 个模型，建表+建模式成熟 | 低 |
| 新增 console 子路由模块 | `routes/v4/console/index.js` 已聚合 89 个模块，加一个 `segment-rules.js` | 低 |
| `lottery_strategy_config` 表 | 已有通用策略配置表，可考虑存放 normalize 引擎参数 | 低 |

### 八、Web 管理后台前端技术栈兼容性

| 层 | 技术 | 版本 | 与文档方案的兼容性 |
|---|------|------|-----------------|
| 构建 | Vite | 6.4 | ✅ 完全兼容，HTML 页面热更新支持 |
| 框架 | Alpine.js | 3.15 | ✅ 文档中的 `x-model`/`x-for`/`x-show` 语法正确 |
| 样式 | Tailwind CSS | 3.4 | ✅ 文档中的 `grid grid-cols-2 gap-4` 等类名正确 |
| 图表 | ECharts | 6.0 | ✅ 可用于任务 5 概率可视化（如饼图/条形图） |
| 拖拽 | SortableJS（文档建议 CDN 引入） | — | ✅ 兼容，Alpine.js 可通过 `x-init` 初始化 SortableJS |
| API 调用 | 项目内 `fetch` / composable 模式 | — | ✅ `admin/src/modules/lottery/composables/prizes.js` 已有模式 |
| WebSocket | socket.io-client | 4.8 | ✅ 已有，但本需求不需要 WebSocket |

**结论**：文档中 Web 前端部分的技术选型与项目现有技术栈**完全兼容**，无需引入新框架。SortableJS 通过 CDN `<script>` 引入是唯一新增依赖，成本极低。

### 九、🔴 需要拍板的决定（6 项）— 含行业调研

#### 决定 1：任务三（分群动态管理）— 先做 API 还是推迟？

**行业做法对比**：

| 公司类型 | 代表 | 做法 | 理由 |
|---------|------|------|------|
| 电商大厂 | 阿里千人千面、美团营销平台 | 数据库驱动，运营自助配置 | 促销活动频繁，分群规则每天都在变，硬编码根本撑不住 |
| 游戏公司 | 米哈游/网易（抽卡系统） | 数据库驱动，策划自助配置 | 不同版本活动对应不同用户群概率，上线前策划要反复调 |
| 社交/内容 | 抖音/快手（红包活动） | 数据库驱动 + AB 测试平台 | 分群直接对接 AB 实验平台，规则变更无需发版 |
| 银行/投行 | 招商银行（积分抽奖） | 数据库驱动，但有审批流程 | 监管要求可追溯，规则变更需审批后生效 |
| 小公司 | 初创餐饮 SaaS | 硬编码，等需求来了再改 | 活动少、迭代慢，运营不会频繁改分群 |

**你项目的实际情况**：
- 当前只有 1 个活动在运营，使用 `segment_resolver_version='v1'`
- 已有 `SegmentResolver` 支持 5 个内置版本（default/v1/v2/v3/v4），覆盖注册时间、积分、活跃度
- 运营还没提出过"想改分群规则"的需求

**🔴 拍板结论：选 B — 完整实施**

一次性做完 `segment_rule_configs` 表 + CRUD API（6 个接口）+ 条件构建器 UI + 测试面板。不推迟，全部在第三轮交付。

#### 决定 2：删除奖品策略 — 硬删除 vs 软删除

**行业做法对比**：

| 公司类型 | 代表 | 做法 | 技术实现 |
|---------|------|------|---------|
| 电商大厂 | 阿里/美团/京东 | **软删除，无例外** | `is_deleted` 字段 或 `deleted_at` 时间戳 |
| 游戏公司 | 米哈游/腾讯游戏 | **软删除** | 道具/奖品永远不物理删除，有回滚和客诉需求 |
| 金融 | 银行/券商/支付宝 | **软删除 + 归档** | 监管要求数据保留 N 年，物理删除违规 |
| 二手平台 | 闲鱼/转转 | **软删除** | 商品下架 ≠ 删除，交易纠纷需要查历史 |
| 内容平台 | 抖音/B站/百度 | **软删除** | 内容审核、用户申诉都需要恢复能力 |
| 小公司 | 初创项目 | 硬删除居多 | 图简单，但上线后经常后悔 |

**Sequelize 原生支持 — `paranoid` 模式**：

你的项目用 Sequelize 6.35，它内置软删除功能 `paranoid: true`：
- 自动添加 `deleted_at` 字段
- `Model.destroy()` 自动变为设置 `deleted_at` 时间戳
- **所有** `findAll()`、`findOne()` 自动过滤已删除记录（不需要手动加 `WHERE`）
- 需要查已删除的：`{ paranoid: false }`
- 需要恢复的：`instance.restore()`
- 需要真删的：`{ force: true }`

你项目中 `ConsumptionRecord.js` 已经写了 `paranoid: false`（显式关闭），说明团队知道这个功能但选择了不用。

**两个方案的真实成本对比**：

| 对比维度 | 硬删除（现状） | 软删除（Sequelize paranoid） |
|---------|-------------|--------------------------|
| 后端改动量 | 0 行 | ~5 行（模型加 `paranoid: true` + 迁移加 `deleted_at` 列） |
| 查询改动 | 不需要 | **不需要**（Sequelize 自动过滤） |
| 数据可恢复 | 不可恢复，靠 `admin_operation_logs` 的 JSON 手动重建 | `prize.restore()` 一行恢复 |
| 审计能力 | 操作日志有记录，但奖品行已消失 | 奖品行还在，可随时查看被删时的完整状态 |
| 运营误删成本 | 高（需要从日志手动重建数据） | 低（restore 即可） |
| 上线后风险 | 用户投诉"奖品消失了"时无法快速恢复 | 可快速恢复 |
| 长期维护 | 有隐患 | 行业标准，无隐患 |

**结论：选软删除（Sequelize paranoid 模式）**

理由：
1. 改动成本极低（5 行代码 + 1 个迁移），因为 Sequelize 自动处理所有查询过滤
2. 你说"愿意一次性投入大量成本、从长期维护成本低的角度出发"——软删除就是典型的"一次投入，长期受益"
3. 大厂/游戏/金融**无一例外**全用软删除，这是行业共识不是偏好
4. 项目未上线，现在改最便宜；上线后再改要处理历史数据迁移

**具体执行**：
- `LotteryPrize.js` 模型选项加 `paranoid: true`
- 迁移脚本加 `deleted_at DATETIME NULL` 列
- `deletePrize()` 方法内的 `prize.destroy()` 不需要改（Sequelize 自动变为软删除）
- 现有所有查询不需要改（Sequelize 自动加 `WHERE deleted_at IS NULL`）
- 后端 `deletePrize()` 中"有中奖记录则拒绝"的保护逻辑保留

#### 决定 3：排序 UI — 拖拽 vs 按钮

**行业做法对比**：

| 公司类型 | 代表 | 做法 | 场景 |
|---------|------|------|------|
| 电商后台 | 美团商家版/淘宝千牛 | **拖拽** | 菜品排序、商品排序、分类排序 |
| CMS 系统 | WordPress/Shopify/Notion | **拖拽** | 页面元素、菜单项、内容块排序 |
| 游戏后台 | 运营配置工具 | **拖拽** | 奖品顺序、关卡顺序、活动位排序 |
| 银行后台 | 保守型企业 | **按钮**（上下箭头） | 合规界面，操作需明确，不允许"手滑" |
| 小程序搭建 | 微信小商店/有赞 | **拖拽** | 商品展示位排序 |

**技术兼容性**：SortableJS (CDN ~10KB) + Alpine.js 的组合在你的技术栈下完全可行，`x-init` 中初始化 SortableJS 实例即可。

**结论：选拖拽（SortableJS）**

理由：15 个奖品用按钮点 30+ 次才能完成一次大调整，拖拽 3 秒搞定。这不是偏好问题，是效率差 10 倍。所有现代管理后台（美团/淘宝/Shopify/Notion）都用拖拽，按钮方案只在银行等强合规场景用。

#### 决定 4：分组查询 — 新增独立 API vs 扩展现有 API

**行业做法对比**：

| 设计理念 | 代表 | 做法 | 适用场景 |
|---------|------|------|---------|
| RESTful 纯粹派 | Google API Design Guide | **同一资源不同表示用查询参数**（`?view=`） | 数据本质相同，只是展示方式不同 |
| 职责分离派 | 阿里/美团内部规范 | **不同响应结构用不同端点** | 响应 JSON 结构完全不同时 |
| GraphQL 派 | Facebook/GitHub | **单端点，客户端自选字段** | 前端驱动，灵活查询 |
| BFF 模式 | 字节跳动/Netflix | **后端按前端页面聚合** | 一个页面一个接口，减少前端请求数 |

**你的具体情况**：
- 现有 `GET /prize-pool/:code` 返回平铺列表
- 新的分组查询返回嵌套结构（`prize_groups[].prizes[]`），JSON 结构完全不同
- 两个接口的消费方不同：平铺列表给编辑弹窗用，分组列表给管理面板用

**结论：选新增独立 API**

理由：响应结构完全不同（平铺 vs 嵌套分组），用查询参数切换会导致前端需要 `if/else` 处理两种完全不同的数据结构，违反"接口职责单一"原则。阿里/美团的内部规范明确要求：响应结构差异大时必须分端点。

路径：`GET /api/v4/console/prize-pool/:code/grouped`

#### 决定 5：normalize 引擎 — 现在做还是推迟？

**行业做法对比**：

| 公司类型 | 代表 | 做法 | 理由 |
|---------|------|------|------|
| 游戏公司 | 米哈游/网易 | **上线前实现所有算法** | 不同活动用不同算法，上线后切换需要零停机 |
| 电商促销 | 美团/阿里 | **按需实现** | 先跑通一种，数据验证后再加新的 |
| 银行抽奖 | 招行/工行 | **按需实现** | 合规审批慢，一种算法审批通过就先上 |
| SaaS 平台 | 有赞/微盟 | **预留扩展点，按需实现** | 枚举值先定义好，代码分支等客户要了再写 |

**你的具体情况**：
- `pick_method` ENUM 已包含 `normalize`，扩展点已就绪
- 所有 4 个活动都用 `tier_first`，运营没提过要百分比模式
- `tier_first` 本身已经很灵活（3 级档位 × 多分群 × 独立权重）

**🔴 拍板结论：现在做，不推迟**

第三轮实施 normalize 引擎（任务九）+ 选奖方式选择 UI（任务十），与其他第三轮任务一起交付。`pick_method` ENUM 已包含 `normalize`，无需改表结构，只需实现引擎代码分支 + 前端联动 UI。

#### 决定 6：奖品创建/编辑的数据校验策略 — 严格阻断 vs 柔性提醒 vs 发布时校验

> 本决定由 2026-02-22 数据库实查发现：`batchAddPrizes()` 有硬编码 `win_probability` 总和 = 1.0 校验，阻断 `tier_first` 模式下的所有奖品新增操作。修复时需要决定新的校验策略。

**问题本质**：运营往活动里添加或编辑奖品时，系统应该在什么时机、以什么力度校验概率/权重分布的正确性？

**三种方案对比**：

| 方案 | 做法 | 优点 | 缺点 |
|------|------|------|------|
| A 严格阻断 | 每次保存单个奖品时，校验该活动所有奖品的分布（normalize 模式 `win_probability` 总和=1.0，tier_first 模式每个档位权重>0） | 绝不会出现错误的概率配置 | 运营无法分步操作（先加3个奖品再调权重），必须一次性配齐 |
| B 柔性提醒 | 保存时只校验单个奖品字段合法性（`win_weight`>0, `reward_tier`∈{high,mid,low}），分布问题用 **warning 返回但不阻断** | 运营可灵活操作，边加边调 | 可能存在短暂的"概率配置不完整"窗口期 |
| C 发布时校验 | 保存时不校验分布，仅在**活动状态从 draft→active** 或手动点「校验分布」按钮时做全量校验 | 草稿阶段完全自由，发布前强制检查 | 需要新增"活动发布前校验"流程 |

**行业做法对比**：

| 公司类型 | 代表 | 做法 | 校验时机 | 理由 |
|---------|------|------|---------|------|
| 游戏公司 | 米哈游（原神）、网易（阴阳师） | **C 发布时校验** | 策划在内部工具自由编辑，提交上线前跑自动化校验脚本，校验不通过不让发版 | 策划需要反复调参数，过程中概率不完整是常态，上线那一刻必须正确 |
| 电商大厂 | 美团（满减/抽奖）、阿里（双11） | **B 柔性提醒** | 每次编辑弹 warning toast，运营列表页显示"概率分布异常"标签，不阻断保存 | 促销活动频繁调整，阻断保存会严重影响运营效率；异常标签提醒运营自行修正 |
| SaaS 平台 | 有赞、微盟 | **B 柔性提醒 + C 发布时校验** | 编辑时 warning，活动上线前强制校验通过 | 兼顾灵活性和安全性，是 SaaS 行业最常见的模式 |
| 银行/金融 | 招行、工行 | **A 严格阻断** | 每次修改都走审批流程，概率配置必须严格正确才能提交 | 监管要求，任何概率变更需审计可追溯、审批后生效 |
| 小公司初创 | 餐饮 SaaS | 无校验或简单校验 | 没有系统性校验，靠人工检查 | 开发资源少，先上线再说 |
| 游戏虚拟物品交易 | Steam/Epic 活动抽奖 | **C 发布时校验** | 内部配置系统自由编辑，部署上线时 CI/CD 流水线自动校验概率合规 | 法规要求概率公示，必须在上线前保证数据正确 |

**你项目的实际情况**：

- 当前只有 1 个活动在运营（`tier_first` 模式），运营团队小
- `tier_first` 权重模式**天然不需要总和校验**——权重 700000 和 300000 意味着 70%:30%，不需要凑到某个特定总数
- `normalize` 百分比模式**确实需要总和 = 1.0 校验**，但是在运营逐个添加奖品的过程中，中间状态总和不等于 1.0 是正常的
- 项目未上线，没有银行级合规需求
- 已有 `admin_operation_logs` 审计表，变更可追溯

**两种算法模式的校验需求差异**：

| 校验维度 | tier_first（权重模式）| normalize（百分比模式）|
|---------|---------------------|---------------------|
| 总和校验 | **不需要**（权重自动归一化，总和无意义）| **需要**（`win_probability` 总和必须 = 1.0）|
| 单个值校验 | `win_weight` > 0，`reward_tier` ∈ {high,mid,low} | 0 < `win_probability` ≤ 1.0 |
| 档位校验 | 每个档位至少 1 个奖品 | 不适用（无档位概念）|
| 兜底校验 | 至少 1 个 `is_fallback=1` 的奖品 | 至少 1 个 `is_fallback=1` 的奖品 |
| 库存校验 | 有库存的奖品权重之和 > 0 | 有库存的奖品概率之和 > 0 |
| 校验时机 | 保存时单个字段校验 + warning | 保存时单个字段校验 + 激活/发布时总和校验 |

**🔴 拍板结论：B+C 混合（柔性提醒 + 激活时校验）**

理由：
1. 你的 `tier_first` 权重模式占当前所有活动的 100%，**权重天然不需要总和校验**，用 A 严格阻断是多余的
2. 你说"愿意一次性投入大量成本、从长期维护成本低的角度出发"——B+C 混合策略是 SaaS 行业（有赞/微盟）的标准做法，长期最稳
3. 项目未上线，不需要银行级严格审批
4. B+C 的实现成本不高（利用现有 `admin_operation_logs` 审计 + `grouped` API 的 `warnings` 数组）

**具体执行**：

- **保存奖品时（tier_first 模式）**：校验 `win_weight` > 0、`reward_tier` 合法，不校验总和。如果 `stock_quantity = 0 && win_weight > 0`，返回 warning 但不阻断
- **保存奖品时（normalize 模式）**：校验 `0 < win_probability ≤ 1.0`，不校验总和。如果总和 ≠ 1.0，返回 warning 但不阻断
- **激活活动时**（`status` 从 `draft`/`paused` 改为 `active`）：执行全量校验——normalize 模式总和必须 = 1.0（±0.001），tier_first 每档位至少 1 个奖品且至少 1 个兜底奖品。校验不通过则**阻断激活**
- **`batchAddPrizes()` 修复**：移除现有的硬编码 `win_probability` 总和校验，改为上述分模式校验

---

### 十、6 项拍板决定汇总

| # | 决定 | 🔴 拍板结论 | 执行轮次 |
|---|------|------------|---------|
| 1 | 分群动态管理 | **选 B — 完整实施**（表 + API + 条件构建器 UI + 测试面板） | 第三轮 |
| 2 | 删除策略 | **软删除（Sequelize paranoid）** | 第一轮（步骤 3） |
| 3 | 排序 UI | **拖拽（SortableJS CDN）** | 第二轮（步骤 7） |
| 4 | 分组查询 | **新增独立 API**（`/prize-pool/:code/grouped`） | 第一轮（步骤 2） |
| 5 | normalize 引擎 | **现在做，不推迟** | 第三轮（步骤 10） |
| 6 | 数据校验策略 | **B+C 混合：保存时柔性提醒 + 激活时强制校验** | 第一轮（步骤 3） |

**原则：14 个任务全部执行，不推迟任何需求。6 项决定全部确认。**

---

## 实施计划

### 第一轮：先能用（预估半天）

目标：让运营能选活动、加奖品、改库存、改权重。做完即可投入日常使用。

| # | 任务 | 改动量 | 状态 | 详细方案 |
|---|------|--------|------|---------|
| 1 | 后端加 `win_weight`/`reward_tier` 到白名单 + 前端加编辑入口 | 3 个文件，+25 行 | ⬜ 待开发 | [任务一](#问题说明) |
| 11 | 活动管理页新增「奖品管理」入口（选择指定活动进入专属奖品管理界面） | 前端 ~60 行，后端 ~20 行 | ⬜ 待开发 | [任务十一](#任务十一活动管理页新增奖品管理入口) |
| 12 | 指定活动新增与删除奖品（在活动奖品管理界面中增删奖品） | 前端 ~70 行，后端 ~60 行 | ⬜ 待开发 | [任务十二](#任务十二指定活动新增与删除奖品) |
| 14 | 活动奖品库存管理（行内编辑 + 快捷操作 + 批量调库存） | 前端 ~50 行，后端 ~25 行 | ⬜ 待开发 | [任务十四](#任务十四活动奖品库存管理) |

### 第二轮：好用（预估一天）

目标：概率可视化、排序、风险提示。运营体验从"能用"升级到"好用"。

| # | 任务 | 改动量 | 状态 | 详细方案 |
|---|------|--------|------|---------|
| 4 | 奖品列表显示档内实际占比（当前只显示原始权重数字，运营看不出实际概率） | 前端 ~20 行 | ⬜ 待开发 | [任务四](#任务四奖品列表显示档内实际占比) |
| 5 | 编辑活动弹窗增加奖品概览面板（一眼看到所有奖品的档位、权重、概率分布） | 前端 ~80 行 | ⬜ 待开发 | [任务五](#任务五编辑活动弹窗增加奖品概览面板) |
| 6 | 编辑奖品时显示同档位其他奖品（方便对比权重大小） | 前端 ~40 行 | ⬜ 待开发 | [任务六](#任务六编辑奖品时显示同档位其他奖品) |
| 7 | 库存=0 但权重>0 的风险提示（避免抽中没货的奖品） | 前后端各 ~10 行 | ⬜ 待开发 | [任务七](#任务七库存0-但权重0-的风险提示) |
| 13 | 活动奖品位置排序（拖拽或按钮调整奖品展示顺序 sort_order） | 前端 ~80 行，后端 ~30 行 | ⬜ 待开发 | [任务十三](#任务十三活动奖品位置排序) |

### 第三轮：完善（预估一天半）

目标：清理废弃代码、分群动态管理、审计日志、normalize 引擎。系统完善，不影响当前运营使用。

| # | 任务 | 改动量 | 状态 | 详细方案 |
|---|------|--------|------|---------|
| 2 | 清理废弃的 `fallback` 选奖模式（从枚举和代码中移除） | 约 5 个文件 | ⬜ 待开发 | [任务二](#任务二清理废弃的-fallback-选奖模式) |
| 3 | 用户分群规则动态管理（运营可视化搭建分群条件） | 8 个文件，新功能 | ⬜ 待开发 | [任务三](#任务三用户分群规则动态管理) |
| 8 | 概率变更审计日志（记录谁在什么时间改了什么权重） | 后端 ~30 行 | ⬜ 待开发 | [任务八](#任务八概率变更审计日志) |
| 9 | `normalize` 百分比引擎实现（当前数据库有枚举值但代码未实现） | 后端 ~100 行 | ⬜ 待开发 | [任务九](#任务九normalize-百分比引擎实现) |
| 10 | 创建活动时选择选奖方式（让运营可以选 tier_first 或 normalize） | 前后端各 ~30 行 | ⬜ 待开发 | [任务十](#任务十创建活动时选择选奖方式) |

---

## 背景：项目的抽奖概率算法体系

抽奖算法分为两大类：百分比算法和权重算法。`tier_first` 不是第三种算法，它只是权重算法加了分档位的功能，本质还是权重算法。

```
抽奖算法
  │
  ├── 百分比算法（normalize）
  │     运营填：30%、20%、50%（总和必须 = 100%）
  │     特点：直观，但改一个要动其他的
  │     使用字段：win_probability
  │
  └── 权重算法
        运营填：3、2、5（或 700000、200000、100000，总和随便）
        特点：灵活，改一个其他自动调整，系统自动算出百分比
        使用字段：win_weight
        │
        ├── 单层权重（所有奖品一个池子）
        │     不区分用户群，所有人概率一样
        │
        └── 分层权重 tier_first ← 当前使用的
              先选档位（high/mid/low），再在档位内选奖品
              支持新客/VIP/普通用户差异化概率
              额外使用字段：reward_tier（所属档位）
```

两大类算法使用完全不同的数据库字段，互不干扰：

| 字段 | 百分比算法（normalize） | 权重算法（单层权重 / tier_first） |
|------|----------------------|-------------------------------|
| `win_probability` | 算法使用 | 不使用 |
| `win_weight` | 不使用 | 算法使用 |
| `reward_tier` | 不需要（没有档位概念） | tier_first 使用 |

运营创建活动时先选抽奖算法：
- 选了百分比算法（normalize）→ 填百分比（`win_probability`），所有人概率一样
- 选了权重算法（tier_first）→ 填权重（`win_weight`）+ 档位（`reward_tier`），可按用户群差异化

---

## 任务一：后端加白名单 + 前端加编辑入口

当前活动使用 `tier_first` 选奖方式，算法实际使用 `win_weight`（选奖权重）和 `reward_tier`（所属档位）两个字段。但这两个字段：
- 后端 API 不允许更新（不在 `allowedFields` 白名单中）
- 前端 UI 没有编辑入口

管理员只能编辑 `win_probability`（百分比字段），但该字段在 `tier_first` 模式下算法不读取，改了没有任何效果。

---

## 需要修改的文件（共 3 个）

### 文件 1：后端 — `services/PrizePoolService.js`

位置：第 531-558 行，`allowedFields` 对象

当前代码：

```javascript
const allowedFields = {
  name: 'prize_name',
  prize_name: 'prize_name',
  type: 'prize_type',
  prize_type: 'prize_type',
  value: 'prize_value',
  prize_value: 'prize_value',
  prize_value_points: 'prize_value_points',
  quantity: 'stock_quantity',
  stock_quantity: 'stock_quantity',
  win_probability: 'win_probability',
  description: 'prize_description',
  prize_description: 'prize_description',
  image_resource_id: 'image_resource_id',
  angle: 'angle',
  color: 'color',
  cost_points: 'cost_points',
  sort_order: 'sort_order',
  max_daily_wins: 'max_daily_wins',
  status: 'status',
  rarity_code: 'rarity_code'
}
```

需要加入的字段：

```javascript
  win_weight: 'win_weight',         // 选奖权重（tier_first 模式下实际生效的概率控制字段）
  reward_tier: 'reward_tier'        // 所属档位（high/mid/low，决定奖品归属哪个档位）
```

---

### 文件 2：前端 JS — `admin/src/modules/lottery/composables/prizes.js`

#### 改动 1：prizeForm 初始值（第 36-53 行）

当前：

```javascript
prizeForm: {
  lottery_campaign_id: null,
  prize_name: '',
  prize_type: 'virtual',
  win_probability: 0,
  stock_quantity: 100,
  status: 'active',
  image_id: null,
  prize_description: '',
  rarity_code: 'common'
},
```

需要加入：

```javascript
  win_weight: 100000,               // 默认权重
  reward_tier: 'low',               // 默认档位
```

#### 改动 2：resetPrizeForm()（第 147-163 行附近）

需要在重置表单时也重置这两个字段：

```javascript
  win_weight: 100000,
  reward_tier: 'low',
```

#### 改动 3：editPrize()（第 169-188 行）

当前只读取 `win_probability`，需要同时读取 `win_weight` 和 `reward_tier`：

```javascript
  win_weight: prize.win_weight || 100000,
  reward_tier: prize.reward_tier || 'low',
```

#### 改动 4：submitPrizeForm() 编辑模式（第 256-273 行）

当前 updateData 中没有 win_weight 和 reward_tier，需要加入：

```javascript
const updateData = {
  prize_name: this.prizeForm.prize_name,
  prize_type: this.prizeForm.prize_type,
  win_probability: winProbability,
  stock_quantity: this.prizeForm.stock_quantity,
  status: this.prizeForm.status,
  image_id: this.prizeForm.image_id,
  prize_description: this.prizeForm.prize_description,
  rarity_code: this.prizeForm.rarity_code || 'common',
  win_weight: parseInt(this.prizeForm.win_weight) || 100000,     // 新增
  reward_tier: this.prizeForm.reward_tier || 'low'               // 新增
}
```

---

### 文件 3：前端 HTML — `admin/lottery-management.html`

位置：第 5559-5571 行，奖品编辑 Modal 中「中奖概率」和「库存数量」的 grid 区域

当前 UI：

```
┌─────────────────────┬─────────────────────┐
│ 中奖概率 (%)         │ 库存数量             │
│ [____0____]         │ [____100____]       │
│ ⚠️ 总和需=100%       │ 999999=无限          │
└─────────────────────┴─────────────────────┘
```

需要改为：

```
┌─────────────────────┬─────────────────────┐
│ 🎯 选奖权重          │ 📂 所属档位           │
│ [____100000____]    │ [high/mid/low ▾]    │
│ 数字越大越容易被抽中   │ 决定奖品归属哪个档次   │
├─────────────────────┼─────────────────────┤
│ 中奖概率 (%)  (旧)   │ 库存数量             │
│ [____0____]         │ [____100____]       │
│ ⚠️ tier_first下不生效 │ 999999=无限          │
└─────────────────────┴─────────────────────┘
```

具体 HTML 代码：在第 5559 行 `<div class="grid grid-cols-2 gap-4">` 之前插入新的一行：

```html
<div class="grid grid-cols-2 gap-4">
  <div>
    <label class="block text-sm font-medium themed-text-secondary mb-1">🎯 选奖权重</label>
    <input type="number" class="w-full px-3 py-2 border rounded"
           x-model.number="prizeForm.win_weight" min="1" step="1000">
    <p class="text-xs themed-text-muted mt-1">数字越大，在同档位内被抽中的概率越高</p>
  </div>
  <div>
    <label class="block text-sm font-medium themed-text-secondary mb-1">📂 所属档位</label>
    <select class="w-full px-3 py-2 border rounded" x-model="prizeForm.reward_tier">
      <option value="high">🏆 高档（high）</option>
      <option value="mid">🎁 中档（mid）</option>
      <option value="low">🎉 低档（low）</option>
    </select>
    <p class="text-xs themed-text-muted mt-1">决定奖品归属哪个档次的奖品池</p>
  </div>
</div>
```

---

## 修改量汇总

| 文件 | 改动 | 行数 |
|------|------|------|
| `services/PrizePoolService.js` | allowedFields 加 2 个字段 | +2 行 |
| `admin/src/modules/lottery/composables/prizes.js` | prizeForm、resetForm、editPrize、submitForm 各加 2 个字段 | +8 行 |
| `admin/lottery-management.html` | 奖品编辑 Modal 加一行输入框 | +15 行 |
| **总计** | | **+25 行** |

---

## 修改后的效果

修改前：

```
管理员编辑奖品 → 改 win_probability → 后端保存 → 算法不看这个字段 → 没效果
```

修改后：

```
管理员编辑奖品 → 改 win_weight 和 reward_tier → 后端保存 → 算法直接使用 → 立刻生效
```

---

## 验证方法

修改完成后用以下步骤验证：

1. 打开管理后台 → 抽奖运营 → 活动运营 → 奖品管理
2. 点击任意奖品的「编辑」按钮
3. 确认弹窗中出现「选奖权重」和「所属档位」两个新字段
4. 修改权重值（如从 700000 改为 350000），保存
5. 查数据库确认 `win_weight` 字段已更新：

```sql
SELECT lottery_prize_id, prize_name, win_weight, reward_tier
FROM lottery_prizes WHERE lottery_campaign_id = 1
ORDER BY reward_tier, win_weight DESC;
```

6. 在策略管理页的「模拟抽奖」功能中验证概率分布是否反映了修改后的权重

---

## 任务二：清理废弃的 `fallback` 选奖模式

### 为什么要删除

`fallback` 是 `pick_method` 枚举中的一个值，原始设想是"先抽 → 抽中了 → 发现没货 → 换成保底奖品"。这个设计有根本缺陷：

```
用户抽奖 → 抽中 iPhone → 系统发现没库存了 → 换成"谢谢参与"
                                                ↑ 用户体验极差：
                                                  "我明明看到抽中了好东西，怎么变了？"
```

这叫**事后降级**，用户心理落差大。当前 `tier_first` 用的是**事前过滤**，在抽之前就把没库存的奖品排除了，用户不会看到"中了又没了"的情况。

### `fallback` 的功能已被两个机制完整替代

| 原 `fallback` 想解决的问题 | 现在谁解决的 | 怎么解决的 |
|---------------------------|-------------|-----------|
| "抽奖结果不能为空，必须出东西" | `is_fallback` 字段（奖品属性） | 在 `LotteryPrize` 上标记 `is_fallback=1` 的奖品（如"谢谢参与"），当所有档位都没可用奖品时，`TierPickStage` 的降级路径 high→mid→low→**fallback** 保证一定有结果 |
| "用户运气太差，连续拿保底" | `pity` 保底系统（独立机制） | `PityCalculator` + `GuaranteeStage` 追踪 `consecutive_fail_count`，连续多次只拿到兜底奖品后强制给一个好奖品 |

两者是上下游关系：`is_fallback` 保证每次都出东西，`pity` 保证不会永远只出最差的。`fallback` 作为 `pick_method` 已经没有存在的意义。

### 需要修改的内容

#### 1. 数据库枚举值清理

`LotteryCampaign` 模型的 `pick_method` 字段，当前：

```javascript
type: DataTypes.ENUM('normalize', 'fallback', 'tier_first')
```

改为：

```javascript
type: DataTypes.ENUM('normalize', 'tier_first')
```

需要迁移脚本：先确认无活动使用 `fallback`，再删除枚举值。

#### 2. 关联字段清理

`LotteryCampaign` 模型中的 `fallback_lottery_prize_id` 字段（第 798 行）是专门给 `pick_method=fallback` 用的，与 `tier_fallback_lottery_prize_id`（给 tier_first 档位降级用的）功能重复，应标记废弃或删除。

#### 3. 涉及文件

| 文件 | 改动 |
|------|------|
| `models/LotteryCampaign.js` | 枚举移除 `fallback`，注释标记 `fallback_lottery_prize_id` 废弃 |
| `migrations/YYYYMMDD-remove-fallback-pick-method.js` | 新增迁移脚本 |
| 涉及 `fallback` 字符串的业务代码 | 移除相关分支（已确认无活动使用） |
| 注释和文档 | 更新说明 |

#### 验证方法

```sql
-- 确认无活动使用 fallback
SELECT COUNT(*) FROM lottery_campaigns WHERE pick_method = 'fallback';
-- 预期结果：0
```

---

## 任务三：用户分群规则动态管理

### 背景（为什么需要这个功能）

当前 `tier_first` 算法支持按用户分群（`segment_key`）使用不同的档位权重，但分群规则硬编码在 `config/segment_rules.js` 中，运营无法通过后台调整。改规则需要开发改代码、重新部署。

现状：

```
config/segment_rules.js（硬编码）
  ├── default：不分群，所有人一样
  ├── v1：注册 ≤7天 → new_user，否则 → regular_user
  ├── v2：积分 ≥10万 → vip_premium，≥1万 → vip_basic，否则 → regular_user
  ├── v3：组合策略（新用户 + VIP）
  └── v4：按活跃度（7天/30天）
```

问题：
- 运营想把"新用户"从 7 天改成 14 天 → 改不了，要找开发
- 运营想加一个"首单用户"分群 → 改不了，要改代码部署
- 活动编辑页没有选择分群版本的入口 → `segment_resolver_version` 字段虽然存在但无 UI

### 目标

运营在后台可以：
1. 查看所有分群策略版本及其规则
2. 创建新的分群策略版本
3. 编辑规则参数（如天数阈值、积分阈值）
4. 在活动中选择使用哪个分群策略版本

### 设计思路

不预定义固定模板，而是把用户表的可用字段暴露给运营，让运营自己用 **字段 + 比较方式 + 值** 搭建条件，就像搭积木一样：

```
运营在 UI 上操作：
┌──────────────────┬───────────┬──────────┐
│ 选字段            │ 选比较方式 │ 填值      │
│ [注册时间 ▾]      │ [≤ N天前 ▾]│ [7     ] │
└──────────────────┴───────────┴──────────┘

系统自动生成条件 JSON：
{ "field": "created_at", "operator": "days_within", "value": 7 }

运行时自动翻译为：
(Date.now() - user.created_at) / 86400000 <= 7
```

和之前"模板 + 参数"方案的区别：

| | 模板方案（之前） | 条件构建器方案（现在） |
|---|---|---|
| 加新条件类型 | 开发写代码加模板 | 运营自己选字段组装 |
| 灵活度 | 只能用预定义的模板 | 字段 × 运算符自由组合 |
| 安全性 | 高（代码控制） | 高（字段白名单 + 运算符白名单） |

### 需要新增的文件和修改

#### 新增 1：数据库表 — `segment_rule_configs`

存储运营可配置的分群策略：

```sql
CREATE TABLE segment_rule_configs (
  id              INT AUTO_INCREMENT PRIMARY KEY,
  version_key     VARCHAR(32) NOT NULL,           -- 版本标识，如 'custom_v1'
  version_name    VARCHAR(100) NOT NULL,          -- 版本名称，如 '春节活动分群'
  description     VARCHAR(500),                   -- 版本描述
  rules           JSON NOT NULL,                  -- 规则数组（见下方结构）
  is_system       TINYINT(1) DEFAULT 0,           -- 是否系统内置（内置不可删除）
  status          VARCHAR(20) DEFAULT 'active',   -- active / archived
  created_by      INT,                            -- 创建人
  created_at      DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at      DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  UNIQUE KEY uk_version_key (version_key)
);
```

`rules` 字段的 JSON 结构：

```json
[
  {
    "segment_key": "new_user",
    "label": "新用户",
    "conditions": [
      { "field": "created_at", "operator": "days_within", "value": 7 }
    ],
    "logic": "AND",
    "priority": 10
  },
  {
    "segment_key": "high_value_new",
    "label": "高价值新用户",
    "conditions": [
      { "field": "created_at", "operator": "days_within", "value": 14 },
      { "field": "history_total_points", "operator": "gte", "value": 5000 }
    ],
    "logic": "AND",
    "priority": 20
  },
  {
    "segment_key": "regular_user",
    "label": "普通用户",
    "conditions": [],
    "logic": "AND",
    "priority": 0
  }
]
```

`conditions` 为空数组表示兜底，匹配所有人。多个 condition 之间用 `logic`（AND/OR）连接。

#### 新增 2：字段与运算符白名单 — `config/segment_field_registry.js`

运营能选的字段和运算符完全由这个白名单控制，不在名单里的用户字段不会暴露给运营：

```javascript
const SEGMENT_FIELD_REGISTRY = {
  // 可选字段（从 User 模型中挑选，安全可暴露的字段）
  fields: {
    created_at: {
      label: '注册时间',
      type: 'date',
      operators: ['days_within', 'days_exceed']
    },
    last_active_at: {
      label: '最后活跃时间',
      type: 'date',
      operators: ['days_within', 'days_exceed']
    },
    history_total_points: {
      label: '历史总积分',
      type: 'number',
      operators: ['gte', 'lte', 'eq', 'between']
    },
    user_level: {
      label: '用户等级',
      type: 'enum',
      options: ['normal', 'vip', 'merchant'],
      operators: ['eq', 'neq', 'in']
    },
    consecutive_fail_count: {
      label: '连续未中奖次数',
      type: 'number',
      operators: ['gte', 'lte', 'eq']
    }
  },

  // 运算符定义（每种运算符的求值逻辑）
  operators: {
    days_within: {
      label: '距今 ≤ N 天',
      value_type: 'number',
      value_hint: '天数',
      evaluate: (fieldValue, value) => {
        if (!fieldValue) return false
        const daysDiff = (Date.now() - new Date(fieldValue)) / 86400000
        return daysDiff <= value
      }
    },
    days_exceed: {
      label: '距今 > N 天',
      value_type: 'number',
      value_hint: '天数',
      evaluate: (fieldValue, value) => {
        if (!fieldValue) return false
        const daysDiff = (Date.now() - new Date(fieldValue)) / 86400000
        return daysDiff > value
      }
    },
    gte: {
      label: '≥',
      value_type: 'number',
      evaluate: (fieldValue, value) => (fieldValue || 0) >= value
    },
    lte: {
      label: '≤',
      value_type: 'number',
      evaluate: (fieldValue, value) => (fieldValue || 0) <= value
    },
    eq: {
      label: '等于',
      value_type: 'auto',
      evaluate: (fieldValue, value) => fieldValue === value
    },
    neq: {
      label: '不等于',
      value_type: 'auto',
      evaluate: (fieldValue, value) => fieldValue !== value
    },
    in: {
      label: '属于',
      value_type: 'array',
      evaluate: (fieldValue, value) => value.includes(fieldValue)
    },
    between: {
      label: '在范围内',
      value_type: 'range',
      value_hint: '[最小值, 最大值]',
      evaluate: (fieldValue, value) => {
        const v = fieldValue || 0
        return v >= value[0] && v <= value[1]
      }
    }
  }
}
```

运营想加新条件时只需要在 UI 上操作：

```
1. 选字段：[历史总积分 ▾]        ← 从白名单的 fields 中选
2. 选运算符：[≥ ▾]              ← 根据字段 type 过滤可用运算符
3. 填值：[10000]                ← 按运算符的 value_type 显示对应输入框
```

如果未来要暴露新字段（比如"消费总金额"），只需在 `SEGMENT_FIELD_REGISTRY.fields` 里加一行配置，不需要改任何其他代码，运营那边立刻可选。

#### 修改 1：`config/segment_rules.js` — 改为优先读数据库，用通用求值器执行条件

```javascript
const { SEGMENT_FIELD_REGISTRY } = require('./segment_field_registry')

static async resolveSegment(version, user) {
  // 1. 尝试从数据库加载自定义规则
  const dbConfig = await SegmentRuleConfig.findOne({
    where: { version_key: version, status: 'active' }
  })

  if (dbConfig) {
    return SegmentResolver.evaluateConditions(dbConfig.rules, user)
  }

  // 2. 回退到内置硬编码规则（保持兼容）
  return SegmentResolver.evaluateBuiltinRules(version, user)
}

// 通用条件求值器 — 解析运营搭建的条件 JSON 并执行
static evaluateConditions(rules, user) {
  const sorted = [...rules].sort((a, b) => b.priority - a.priority)

  for (const rule of sorted) {
    // 空条件 = 兜底，匹配所有人
    if (!rule.conditions || rule.conditions.length === 0) {
      return rule.segment_key
    }

    const results = rule.conditions.map(cond => {
      const fieldValue = user?.[cond.field]
      const operator = SEGMENT_FIELD_REGISTRY.operators[cond.operator]
      if (!operator) return false
      return operator.evaluate(fieldValue, cond.value)
    })

    const matched = rule.logic === 'OR'
      ? results.some(r => r)
      : results.every(r => r)

    if (matched) return rule.segment_key
  }

  return 'default'
}
```

#### 修改 2：活动编辑页 — 加分群版本选择下拉框

在活动编辑 Modal 中增加：

```html
<div>
  <label class="block text-sm font-medium themed-text-secondary mb-1">👥 用户分群策略</label>
  <select class="w-full px-3 py-2 border rounded"
          x-model="campaignForm.segment_resolver_version">
    <option value="default">不分群（所有用户相同概率）</option>
    <!-- 从 API 动态加载可用版本 -->
    <template x-for="v in availableSegmentVersions" :key="v.version_key">
      <option :value="v.version_key" x-text="v.version_name"></option>
    </template>
  </select>
  <p class="text-xs themed-text-muted mt-1">不同用户群体可以有不同的档位概率配置</p>
</div>
```

#### 新增 3：后端 API — `routes/v4/console/segment-rules.js`

| 方法 | 路径 | 功能 |
|------|------|------|
| GET | `/api/v4/console/segment-rules` | 列出所有分群策略版本 |
| GET | `/api/v4/console/segment-rules/:version_key` | 获取某版本详情 |
| POST | `/api/v4/console/segment-rules` | 创建新版本 |
| PUT | `/api/v4/console/segment-rules/:version_key` | 编辑版本（修改参数） |
| DELETE | `/api/v4/console/segment-rules/:version_key` | 归档版本（is_system=1 的不可删） |
| GET | `/api/v4/console/segment-rules/condition-templates` | 获取可用的条件模板列表 |

#### 新增 4：管理后台 UI — 分群策略管理页（条件构建器）

运营看到的界面：

```
┌───────────────────────────────────────────────────────────────┐
│ 👥 用户分群策略管理                                             │
├───────────────────────────────────────────────────────────────┤
│                                                               │
│  📋 策略列表                                  [+ 创建新策略]    │
│  ┌────────────────────────────────────────────────────┐       │
│  │ 🔒 default — 不分群                 系统内置 | 查看  │       │
│  │ 🔒 v1 — 新老用户分层                系统内置 | 查看  │       │
│  │ ✏️ 春节活动分群 (custom_v1)         自定义  | 编辑   │       │
│  └────────────────────────────────────────────────────┘       │
│                                                               │
│  编辑「春节活动分群」:                                           │
│  ┌────────────────────────────────────────────────────┐       │
│  │ 规则 1 ── 分群: [high_value_new] 名称: [高价值新用户] │       │
│  │ 优先级: [20]    条件关系: [全部满足(AND) ▾]           │       │
│  │                                                    │       │
│  │  条件 ①  [注册时间    ▾] [距今 ≤ N天 ▾] [14    ]    │  [×]  │
│  │  条件 ②  [历史总积分  ▾] [≥           ▾] [5000  ]   │  [×]  │
│  │                                       [+ 添加条件]  │       │
│  │                                                    │       │
│  │  👁️ 预览: 注册时间 距今 ≤ 14天 且 历史总积分 ≥ 5000    │       │
│  │                                        [删除此规则]  │       │
│  ├────────────────────────────────────────────────────┤       │
│  │ 规则 2 ── 分群: [new_user] 名称: [新用户]            │       │
│  │ 优先级: [10]    条件关系: [全部满足(AND) ▾]           │       │
│  │                                                    │       │
│  │  条件 ①  [注册时间    ▾] [距今 ≤ N天 ▾] [7     ]    │  [×]  │
│  │                                       [+ 添加条件]  │       │
│  │                                                    │       │
│  │  👁️ 预览: 注册时间 距今 ≤ 7天                        │       │
│  ├────────────────────────────────────────────────────┤       │
│  │ 规则 3 ── 分群: [vip_user] 名称: [VIP用户]           │       │
│  │ 优先级: [5]     条件关系: [任一满足(OR) ▾]            │       │
│  │                                                    │       │
│  │  条件 ①  [用户等级    ▾] [等于        ▾] [vip  ▾]   │  [×]  │
│  │  条件 ②  [历史总积分  ▾] [≥           ▾] [10000 ]   │  [×]  │
│  │                                       [+ 添加条件]  │       │
│  │                                                    │       │
│  │  👁️ 预览: 用户等级 = vip 或 历史总积分 ≥ 10000       │       │
│  ├────────────────────────────────────────────────────┤       │
│  │ 规则 4（兜底）── 分群: [regular_user] 名称: [普通用户] │       │
│  │ 优先级: [0]     无条件，匹配所有未命中上述规则的用户    │       │
│  └────────────────────────────────────────────────────┘       │
│                                                               │
│               [+ 添加规则]    [保存策略]    [测试此策略]         │
│                                                               │
│  测试面板（输入模拟用户数据，实时看匹配结果）:                     │
│  ┌────────────────────────────────────────────────────┐       │
│  │ 注册时间: [2026-02-15] 积分: [8000] 等级: [normal ▾] │       │
│  │ 最后活跃: [2026-02-20] 连续未中奖: [3]               │       │
│  │                                                    │       │
│  │ 匹配结果: ✅ 命中规则 2「新用户」→ segment_key=new_user │       │
│  └────────────────────────────────────────────────────┘       │
└───────────────────────────────────────────────────────────────┘
```

UI 交互要点：
- 选「字段」时，下拉框只显示白名单中的字段，附带中文名
- 选「字段」后，「运算符」下拉框自动过滤为该字段支持的运算符
- 选「运算符」后，「值」输入框根据 `value_type` 变化（数字框 / 下拉框 / 范围输入）
- 「预览」行实时拼出自然语言描述，帮运营确认逻辑
- 规则必须包含一个优先级为 0 且无条件的兜底规则，否则保存时提示

### 数据迁移

将 `config/segment_rules.js` 中的 5 个内置版本写入 `segment_rule_configs` 表，标记 `is_system = 1`：

```javascript
// migrations/YYYYMMDD-seed-segment-rule-configs.js
const builtinVersions = [
  { version_key: 'default', version_name: '不分群', is_system: 1,
    rules: [{ segment_key: 'default', label: '所有用户',
              condition_type: 'always_match', params: {}, priority: 0 }] },
  { version_key: 'v1', version_name: '新老用户分层', is_system: 1,
    rules: [
      { segment_key: 'new_user', label: '新用户',
        condition_type: 'register_days_within', params: { days: 7 }, priority: 10 },
      { segment_key: 'regular_user', label: '普通用户',
        condition_type: 'always_match', params: {}, priority: 0 }
    ] },
  // ... v2、v3、v4 同理
]
```

### 修改量汇总

| 文件 | 类型 | 说明 |
|------|------|------|
| `migrations/YYYYMMDD-create-segment-rule-configs.js` | 新增 | 建表 + 内置版本种子数据 |
| `models/SegmentRuleConfig.js` | 新增 | Sequelize 模型 |
| `config/segment_field_registry.js` | 新增 | 字段 + 运算符白名单及求值函数 |
| `routes/v4/console/segment-rules.js` | 新增 | CRUD API（6 个接口） |
| `config/segment_rules.js` | 修改 | `resolveSegment` 改为读数据库 + 通用条件求值器 |
| `admin/lottery-management.html` | 修改 | 活动编辑加分群版本下拉框 |
| `admin/` 下新增页面 | 新增 | 分群策略管理页（含条件构建器 UI） |
| `admin/src/modules/lottery/composables/` 下新增 JS | 新增 | 前端分群管理逻辑 |

### 验证方法

1. 打开管理后台 → 分群策略管理页
2. 确认 5 个内置版本显示且标记为「系统内置」不可删除
3. 点击「创建新策略」，选择条件模板、填写参数，保存
4. 打开活动编辑页，确认「用户分群策略」下拉框能看到刚创建的版本
5. 选择新策略并保存活动
6. 用模拟抽奖验证：不同用户特征匹配到不同 `segment_key`，使用对应的档位权重

---

## P1 任务

### 任务四：奖品列表显示档内实际占比

当前奖品列表只显示原始权重数字（如 700000），运营看不出这个奖品在同档位内实际占多少概率。

改动：在前端奖品列表的权重列旁边显示计算后的百分比。

```
当前显示：                    改为：
┌──────────┬──────────┐      ┌──────────┬────────────────┐
│ 奖品名称  │ 权重      │      │ 奖品名称  │ 权重（档内占比）  │
│ iPhone   │ 700000   │      │ iPhone   │ 700000（70.0%） │
│ 耳机     │ 200000   │      │ 耳机     │ 200000（20.0%） │
│ 贴纸     │ 100000   │      │ 贴纸     │ 100000（10.0%） │
└──────────┴──────────┘      └──────────┴────────────────┘
```

计算公式：`某奖品权重 / 同档位所有奖品权重之和 × 100%`

涉及文件：`admin/lottery-management.html`（奖品列表渲染处），约 20 行。

### 任务五：编辑活动弹窗增加奖品概览面板

运营编辑活动时，看不到该活动下所有奖品的全局分布。需要在活动编辑弹窗中加一个概览面板，一眼看到：

```
┌─ 奖品概览 ───────────────────────────────────────┐
│                                                   │
│  🏆 高档 (high)  档位权重: 100000 (10%)            │
│  ├── iPhone    权重 700000  档内占比 70%           │
│  └── AirPods   权重 300000  档内占比 30%           │
│                                                   │
│  🎁 中档 (mid)   档位权重: 300000 (30%)            │
│  ├── 优惠券50元  权重 500000  档内占比 50%          │
│  └── 优惠券20元  权重 500000  档内占比 50%          │
│                                                   │
│  🎉 低档 (low)   档位权重: 600000 (60%)            │
│  ├── 积分 100   权重 800000  档内占比 80%           │
│  └── 谢谢参与   权重 200000  档内占比 20% [兜底]    │
│                                                   │
└───────────────────────────────────────────────────┘
```

涉及文件：`admin/lottery-management.html` + `prizes.js`，约 80 行。

---

## P2 任务

### 任务六：编辑奖品时显示同档位其他奖品

运营编辑单个奖品的权重时，不知道同档位其他奖品是多少，改完也不知道占比变成了多少。在奖品编辑 Modal 中加一个参照区域：

```
┌─ 编辑奖品：iPhone ──────────────────────┐
│                                         │
│  选奖权重: [700000    ]                  │
│  所属档位: [high ▾]                      │
│                                         │
│  📊 同档位 (high) 其他奖品：              │
│  ┌─────────────┬────────┬───────┐       │
│  │ 奖品         │ 权重    │ 占比   │       │
│  │ AirPods     │ 300000 │ 30.0% │       │
│  │ → iPhone    │ 700000 │ 70.0% │ ← 当前 │
│  └─────────────┴────────┴───────┘       │
└─────────────────────────────────────────┘
```

涉及文件：`admin/lottery-management.html` + `prizes.js`，约 40 行。

### 任务七：库存=0 但权重>0 的风险提示

奖品库存用完了但权重还大于 0，意味着算法会选中这个奖品但发不出去，触发降级逻辑。应该在以下位置给出提示：

- **后端**：保存奖品时，如果 `stock_quantity = 0` 且 `win_weight > 0`，在响应中返回 warning
- **前端**：奖品列表中对这类奖品显示黄色警告标记

涉及文件：`PrizePoolService.js`（后端 ~10 行）+ `lottery-management.html`（前端 ~10 行）。

---

## P3 任务

### 任务八：概率变更审计日志

记录每次权重修改的操作日志，方便事后追溯"谁在什么时间把 iPhone 的权重从 700000 改成了 100000"。

需要记录的字段：操作人、操作时间、奖品 ID、字段名、旧值、新值。

涉及文件：`PrizePoolService.js` 的更新方法中加日志写入，约 30 行。

### 任务九：`normalize` 百分比引擎实现

当前 `pick_method` 枚举有 `normalize` 值，含义是直接按 `win_probability` 百分比抽奖、不分档位，但引擎代码没有实现这个分支（选了 normalize 也走 tier_first 逻辑）。

需要在引擎中实现 normalize 分支：
- `TierPickStage` 检测到 `pick_method = normalize` 时跳过档位选择
- `PrizePickStage` 直接按 `win_probability` 做归一化随机选奖
- 所有 `win_probability` 之和必须 = 1.0，保存时校验

涉及文件：`TierPickStage.js`、`PrizePickStage.js`、`PrizePoolService.js`（校验），约 100 行。

### 任务十：创建活动时选择选奖方式

当前所有活动默认使用 `tier_first`，运营没有选择入口。任务九实现 normalize 后，需要让运营在创建/编辑活动时选择选奖方式：

```
┌─ 创建活动 ─────────────────────────────────┐
│                                             │
│  选奖方式: [先选档位 tier_first ▾]            │
│            ├── 先选档位 tier_first（推荐）     │
│            └── 百分比 normalize               │
│                                             │
│  选 tier_first → 显示档位权重配置 + 奖品权重   │
│  选 normalize  → 显示百分比配置（总和=100%）   │
└─────────────────────────────────────────────┘
```

涉及文件：活动编辑页 HTML + JS（前端各 ~30 行）+ 后端保存逻辑（~30 行）。

---

### 任务十一：活动管理页新增「奖品管理」入口

#### 背景

当前管理后台的奖品编辑散落在活动编辑弹窗内，运营无法针对某个活动集中管理其所有奖品。需要在新建活动或活动管理页面中，提供按活动维度进入奖品管理的明确入口。

#### 目标

- 活动列表中每个活动行新增「奖品管理」操作按钮，点击进入该活动的专属奖品管理面板
- 新建活动保存成功后，可直接跳转到该活动的奖品管理界面
- 奖品管理面板顶部显示当前活动基本信息（名称、状态、选奖方式、奖品总数）

#### UI 设计

活动列表页新增操作按钮：

```
┌─ 活动列表 ──────────────────────────────────────────────────┐
│                                                              │
│  ┌──────────────┬────────┬──────────┬──────────────────────┐ │
│  │ 活动名称      │ 状态    │ 选奖方式  │ 操作                  │ │
│  ├──────────────┼────────┼──────────┼──────────────────────┤ │
│  │ 春节大转盘    │ 🟢 进行中│ tier_first│ [编辑] [奖品管理] ... │ │
│  │ 元宵抽奖      │ ⚪ 草稿  │ tier_first│ [编辑] [奖品管理] ... │ │
│  └──────────────┴────────┴──────────┴──────────────────────┘ │
└──────────────────────────────────────────────────────────────┘
```

点击「奖品管理」后进入活动专属奖品管理面板：

```
┌─ 🎰 春节大转盘 — 奖品管理 ───────────────────────────────────┐
│  活动状态: 🟢 进行中  |  选奖方式: tier_first  |  奖品数: 6    │
│                                                              │
│  [+ 新增奖品]    [↕ 排序模式]    [📦 批量调库存]               │
│                                                              │
│  ┌──┬──────────┬──────┬──────┬──────┬──────┬──────────────┐ │
│  │# │ 奖品名称  │ 档位  │ 权重  │ 库存  │ 状态  │ 操作         │ │
│  ├──┼──────────┼──────┼──────┼──────┼──────┼──────────────┤ │
│  │1 │ iPhone   │ high │700000│  5   │ active│ [编辑][删除] ↕│ │
│  │2 │ AirPods  │ high │300000│ 20   │ active│ [编辑][删除] ↕│ │
│  │3 │ 优惠券50元│ mid  │500000│ 100  │ active│ [编辑][删除] ↕│ │
│  │4 │ 优惠券20元│ mid  │500000│ 200  │ active│ [编辑][删除] ↕│ │
│  │5 │ 积分100  │ low  │800000│999999│ active│ [编辑][删除] ↕│ │
│  │6 │ 谢谢参与  │ low  │200000│999999│ active│ [编辑][删除] ↕│ │
│  └──┴──────────┴──────┴──────┴──────┴──────┴──────────────┘ │
│                                                              │
│  [← 返回活动列表]                                              │
└──────────────────────────────────────────────────────────────┘
```

#### 涉及文件

| 文件 | 改动 |
|------|------|
| `admin/lottery-management.html` | 活动列表行增加「奖品管理」按钮 + 新增奖品管理面板 HTML 结构 |
| `admin/src/modules/lottery/composables/prizes.js` | 新增 `openPrizeManager(campaignId)` 方法，按 `lottery_campaign_id` 加载奖品列表 |
| `services/PrizePoolService.js` | 确保按 `lottery_campaign_id` 查询奖品列表的接口可用 |

#### 验证方法

1. 打开管理后台 → 抽奖运营 → 活动运营
2. 确认每个活动行出现「奖品管理」按钮
3. 点击按钮，确认进入该活动的奖品管理面板
4. 确认面板顶部正确显示活动名称、状态、选奖方式
5. 确认奖品列表只显示该活动的奖品（`lottery_campaign_id` 过滤正确）

---

### 任务十二：指定活动新增与删除奖品

#### 背景

运营需要为指定活动灵活添加新奖品或删除不需要的奖品。在任务十一的活动奖品管理面板基础上，实现增删操作。

#### 目标

- 在活动奖品管理面板点击「新增奖品」，弹出表单，`lottery_campaign_id` 自动关联当前活动（不可修改）
- 在奖品列表每行有「删除」按钮，二次确认后执行删除
- 删除时进行安全检查：活动进行中的奖品给出额外警告提示

#### 新增奖品流程

```
[+ 新增奖品] 按钮
    ↓
弹出奖品编辑 Modal（lottery_campaign_id 已锁定为当前活动，不可改）
    ↓
填写：奖品名称、类型、选奖权重、所属档位、库存数量、图片、描述等
    ↓
保存 → POST /api/v4/console/prize-pool/:code/add-prize
    ↓
奖品列表自动刷新，新奖品出现在列表末尾
```

新增奖品 Modal 示意：

```
┌─ 新增奖品（活动：春节大转盘）──────────────────┐
│                                               │
│  🔒 所属活动: 春节大转盘 (ID: 1)    [不可修改]  │
│                                               │
│  奖品名称: [________________]                  │
│  奖品类型: [virtual ▾]                         │
│                                               │
│  ┌─────────────────┬─────────────────┐        │
│  │ 🎯 选奖权重      │ 📂 所属档位       │        │
│  │ [____100000____] │ [low ▾]         │        │
│  └─────────────────┴─────────────────┘        │
│  ┌─────────────────┬─────────────────┐        │
│  │ 库存数量         │ 稀有度           │        │
│  │ [____100______] │ [common ▾]      │        │
│  └─────────────────┴─────────────────┘        │
│                                               │
│  奖品描述: [________________________________]  │
│                                               │
│               [取消]       [保存]              │
└───────────────────────────────────────────────┘
```

#### 删除奖品流程

```
点击奖品行的 [删除] 按钮
    ↓
弹出确认对话框：
  ┌────────────────────────────────────────┐
  │  ⚠️ 确认删除奖品「iPhone」？             │
  │                                        │
  │  该奖品属于活动「春节大转盘」(进行中)     │
  │  删除后该档位的概率分布将自动调整         │
  │                                        │
  │            [取消]    [确认删除]          │
  └────────────────────────────────────────┘
    ↓
确认 → DELETE /api/v4/console/prize-pool/prize/:prizeId
    ↓
奖品列表自动刷新
```

#### 后端安全检查逻辑

删除奖品时后端需要检查：

1. 该奖品是否标记了 `is_fallback = 1`（兜底奖品），如果是则禁止删除并返回提示
2. 活动状态如果为 `active`（进行中），在响应中附带 warning 提醒运营
3. 删除后如果该档位下无剩余奖品，返回 warning 提示档位为空

#### 涉及文件

| 文件 | 改动 |
|------|------|
| `admin/lottery-management.html` | 新增奖品按钮 + 新增奖品 Modal（campaign 锁定模式）+ 删除确认弹窗 |
| `admin/src/modules/lottery/composables/prizes.js` | `addPrizeToCampaign(campaignId, prizeData)` 和 `deletePrizeFromCampaign(campaignId, prizeId)` 方法 |
| `services/PrizePoolService.js` | `addPrizeToCampaign` 和 `deletePrize` 服务方法（含兜底奖品保护和安全检查） |
| `routes/v4/console/prize_pool.js` | 追加 POST `/:code/add-prize` 路由（复用已有路由文件） |

#### 验证方法

1. 进入某活动的奖品管理面板
2. 点击「新增奖品」，确认 `lottery_campaign_id` 已锁定且不可修改
3. 填写奖品信息并保存，确认列表中出现新奖品
4. 查数据库确认 `lottery_campaign_id` 正确关联：
   ```sql
   SELECT * FROM lottery_prizes WHERE lottery_campaign_id = 1 ORDER BY sort_order;
   ```
5. 点击某奖品的「删除」，确认弹出确认框
6. 确认删除后列表刷新、奖品消失
7. 尝试删除兜底奖品（`is_fallback=1`），确认被阻止并提示

---

### 任务十三：活动奖品位置排序

#### 背景

奖品在转盘或列表中的展示顺序由 `sort_order` 字段控制。运营需要调整奖品的展示位置，比如把大奖放在显眼位置。当前没有可视化的排序操作入口。

#### 目标

- 支持拖拽排序（首选）或上/下箭头按钮调整奖品顺序
- 排序变更后批量更新所有奖品的 `sort_order` 字段
- 保存后前端抽奖转盘的展示顺序同步变化

#### UI 设计

方案 A — 拖拽排序（推荐）：

```
┌─ 排序模式 ─────────────────────────────────┐
│  💡 拖拽奖品行可调整展示顺序                  │
│                                             │
│  ☰  1. iPhone        [high]  权重 700000   │ ← 拖拽手柄
│  ☰  2. AirPods       [high]  权重 300000   │
│  ☰  3. 优惠券50元     [mid]   权重 500000   │
│  ☰  4. 优惠券20元     [mid]   权重 500000   │
│  ☰  5. 积分100       [low]   权重 800000   │
│  ☰  6. 谢谢参与       [low]   权重 200000   │
│                                             │
│              [保存排序]    [取消]             │
└─────────────────────────────────────────────┘
```

方案 B — 上下箭头按钮（兼容方案）：

```
│  [▲] [▼]  1. iPhone        [high]  700000  │
│  [▲] [▼]  2. AirPods       [high]  300000  │
│  ...                                        │
```

#### 排序保存逻辑

用户拖拽或点击箭头完成排序后，点击「保存排序」，前端收集所有奖品的新顺序，一次性提交：

```
PUT /api/v4/console/prize-pool/:code/sort-order
Body:
{
  "prize_orders": [
    { "lottery_prize_id": 3, "sort_order": 1 },
    { "lottery_prize_id": 1, "sort_order": 2 },
    { "lottery_prize_id": 5, "sort_order": 3 },
    { "lottery_prize_id": 2, "sort_order": 4 },
    { "lottery_prize_id": 4, "sort_order": 5 },
    { "lottery_prize_id": 6, "sort_order": 6 }
  ]
}
```

后端在一个事务内批量更新 `sort_order`，保证原子性。

#### 涉及文件

| 文件 | 改动 |
|------|------|
| `admin/lottery-management.html` | 排序模式 UI（拖拽区域 + 拖拽手柄 + 保存/取消按钮） |
| `admin/src/modules/lottery/composables/prizes.js` | `enterSortMode()`、`saveSortOrder(campaignId)`、`cancelSort()` 方法 |
| `services/PrizePoolService.js` | `batchUpdateSortOrder(campaign_code, prizeOrders)` 事务批量更新方法 |
| `routes/v4/console/prize_pool.js` | 追加 PUT `/:code/sort-order` 路由 |

可选前端依赖：拖拽排序可引入 [SortableJS](https://sortablejs.github.io/Sortable/)（CDN `<script>` 引入即可，无需 npm）。

#### 验证方法

1. 进入某活动的奖品管理面板
2. 点击「排序模式」按钮，确认进入拖拽/箭头排序界面
3. 拖拽移动奖品位置，点击「保存排序」
4. 刷新页面确认顺序持久化
5. 查数据库验证 `sort_order` 字段已更新：
   ```sql
   SELECT lottery_prize_id, prize_name, sort_order
   FROM lottery_prizes WHERE lottery_campaign_id = 1
   ORDER BY sort_order;
   ```

---

### 任务十四：活动奖品库存管理

#### 背景

运营在活动进行中经常需要查看和调整奖品库存，如临时补货、清零库存、设为无限等。当前修改库存需要打开奖品编辑弹窗再修改，操作路径较长。需要更便捷的库存管理方式。

#### 目标

- 库存列支持「行内编辑」：点击库存数字直接修改，回车或失焦保存
- 提供快捷操作按钮：-1 / +1 / +10 / 设为无限(999999) / 清零
- 提供「批量调库存」弹窗：勾选多个奖品一次性调整
- 库存变更可与任务八的审计日志联动

#### UI 设计

行内编辑模式（每个库存单元格）：

```
┌──────────┬────────────────────────────────────────┐
│ 奖品名称  │ 库存操作                                │
├──────────┼────────────────────────────────────────┤
│ iPhone   │ [-1] [  5  ] [+1] [+10]  [∞]  [清零]  │
│ AirPods  │ [-1] [ 20  ] [+1] [+10]  [∞]  [清零]  │
│ 优惠券   │ [-1] [ 100 ] [+1] [+10]  [∞]  [清零]  │
└──────────┴────────────────────────────────────────┘

说明：
  [-1] [+1] [+10] = 快捷加减按钮
  [∞]  = 设为 999999（无限库存）
  [清零] = 设为 0
  中间数字框可直接输入
```

批量调库存弹窗：

```
┌─ 📦 批量调整库存 ──────────────────────────────┐
│                                                │
│  ☑ iPhone       当前: 5     调整为: [10     ]  │
│  ☑ AirPods      当前: 20    调整为: [50     ]  │
│  ☐ 优惠券50元   当前: 100   调整为: [       ]  │
│  ☐ 优惠券20元   当前: 200   调整为: [       ]  │
│  ☑ 积分100      当前: 999999 调整为: [999999]  │
│  ☐ 谢谢参与     当前: 999999 调整为: [       ]  │
│                                                │
│  💡 只有勾选的奖品会被修改                       │
│                                                │
│                [取消]       [确认调整]           │
└────────────────────────────────────────────────┘
```

#### 后端 API

单个奖品库存修改：

```
PUT /api/v4/console/prize-pool/prize/:prizeId/stock
Body: { "stock_quantity": 10 }
Response: { success: true, data: { old_stock: 5, new_stock: 10 } }
```

批量库存修改：

```
PUT /api/v4/console/prize-pool/:code/batch-stock
Body: {
  "updates": [
    { "lottery_prize_id": 1, "stock_quantity": 10 },
    { "lottery_prize_id": 2, "stock_quantity": 50 }
  ]
}
Response: { success: true, data: { updated_count: 2 } }
```

#### 库存变更安全逻辑

- 库存设为 0 且 `win_weight > 0` 时，返回 warning（与任务七联动）
- 批量更新在一个事务内执行，保证原子性
- 每次库存变更写入审计日志（与任务八联动）：记录操作人、奖品 ID、旧库存、新库存

#### 涉及文件

| 文件 | 改动 |
|------|------|
| `admin/lottery-management.html` | 库存行内编辑 UI（输入框 + 快捷按钮）+ 批量调库存弹窗 |
| `admin/src/modules/lottery/composables/prizes.js` | `updateStock(campaignId, prizeId, quantity)`、`batchUpdateStock(campaignId, updates)` 方法 |
| `services/PrizePoolService.js` | `updatePrizeStock` 单个更新 + `batchUpdatePrizeStock` 批量更新（含事务和审计日志） |
| `routes/v4/console/prize_pool.js` | 追加 PUT `/prize/:id/stock` + PUT `/:code/batch-stock` 路由 |

#### 验证方法

1. 进入某活动的奖品管理面板
2. 点击某奖品的库存数字，直接修改并回车，确认保存成功
3. 点击快捷按钮 `+1`、`-1`、`+10`，确认库存实时变化
4. 点击 `∞` 按钮，确认库存变为 999999
5. 点击「批量调库存」，勾选多个奖品并修改，确认一次性保存
6. 查数据库确认库存值正确：
   ```sql
   SELECT lottery_prize_id, prize_name, stock_quantity
   FROM lottery_prizes WHERE lottery_campaign_id = 1;
   ```
7. 将某奖品库存设为 0（权重 > 0），确认收到风险警告提示

---

## 任务十一：活动级奖品管理

### 背景（为什么需要这个功能）

当前管理后台的奖品管理存在以下痛点：

1. **缺少活动维度的管理入口**：没有明确的「选择某个活动 → 管理其奖品」操作流程，运营需要在全局奖品列表中手动筛选
2. **无法为指定活动增删奖品**：缺少在活动维度下直接新增或删除奖品的便捷操作
3. **无法调整奖品展示顺序**：奖品的 `sort_order` 字段无可视化调整入口，运营无法控制转盘/卡片翻转中奖品的展示位置
4. **库存修改不够便捷**：修改单个奖品库存需要打开完整编辑弹窗，批量调整库存无入口

运营期望的操作流：

```
活动列表/新建活动页
  → 点击某活动的「奖品管理」按钮
  → 进入该活动的奖品管理面板
  → 看到该活动所有奖品（按档位分组展示）
  → 可以：增加奖品、删除奖品、上下移动奖品位置、快捷修改库存
```

### 功能设计

#### 11.1 活动级奖品管理入口

在以下两个位置提供入口：

**位置 A — 活动列表页**：每个活动行的操作栏增加「奖品管理」按钮

```
┌────────────────────────────────────────────────────────────────┐
│  📋 活动列表                                                    │
├──────┬──────────────┬──────────┬────────┬──────────────────────┤
│ ID   │ 活动名称       │ 选奖方式  │ 奖品数  │ 操作                 │
├──────┼──────────────┼──────────┼────────┼──────────────────────┤
│ 1    │ 餐厅积分抽奖   │ tier_first│ 15     │ [编辑] [奖品管理] [...] │
│ 2    │ 新店开业抽奖   │ normalize │ 8      │ [编辑] [奖品管理] [...] │
└──────┴──────────────┴──────────┴────────┴──────────────────────┘
```

**位置 B — 新建/编辑活动弹窗**：在弹窗底部或 Tab 栏中增加「奖品管理」Tab

```
┌─ 编辑活动：餐厅积分抽奖 ──────────────────────────────────────┐
│                                                               │
│  [📋 基本信息] [⏰ 时间] [🎰 抽奖配置] [🎁 奖品管理] [🎮 展示]  │
│  ─────────────────────────────────────────────────────────────│
│                                                               │
│  （点击「奖品管理」Tab 展示下方 11.2 的奖品管理面板）              │
│                                                               │
└───────────────────────────────────────────────────────────────┘
```

点击「奖品管理」后，自动传入当前活动的 `lottery_campaign_id`，进入该活动专属的奖品管理面板。

#### 11.2 奖品管理面板（按档位分组展示）

进入后展示该活动的所有奖品，按 `reward_tier` 分组，每组内按 `sort_order` 排列：

```
┌─ 🎁 奖品管理 — 餐厅积分抽奖 (ID:1) ─────────────────────────────────────┐
│                                                                          │
│  [+ 新增奖品]                                         共 15 个奖品       │
│                                                                          │
│  🏆 高档 (high) — 4 个奖品，总权重 1,000,000                              │
│  ┌────┬────────────┬────────┬────────┬──────┬────────┬─────────────────┐ │
│  │ 序号│ 奖品名称     │ 权重    │ 档内占比│ 库存  │ 已发    │ 操作             │ │
│  ├────┼────────────┼────────┼────────┼──────┼────────┼─────────────────┤ │
│  │ 1  │ 500积分券   │ 700,000│ 70.0%  │ [0 ]│ 0      │ [↑][↓][✏️][🗑️] │ │
│  │ 2  │ 九八折券     │ 200,000│ 20.0%  │ [0 ]│ 0      │ [↑][↓][✏️][🗑️] │ │
│  │ 3  │ 2000积分券  │ 90,000 │ 9.0%   │[8642]│ 1,008  │ [↑][↓][✏️][🗑️] │ │
│  │ 4  │ 八八折      │ 10,000 │ 1.0%   │[9269]│ 401    │ [↑][↓][✏️][🗑️] │ │
│  └────┴────────────┴────────┴────────┴──────┴────────┴─────────────────┘ │
│                                                                          │
│  🎁 中档 (mid) — 4 个奖品，总权重 1,000,000                               │
│  ┌────┬────────────┬────────┬────────┬──────┬────────┬─────────────────┐ │
│  │ 5  │ 100积分     │ 400,000│ 40.0%  │[365] │ 107    │ [↑][↓][✏️][🗑️] │ │
│  │ 6  │ 甜品1份     │ 350,000│ 35.0%  │[589] │ 80     │ [↑][↓][✏️][🗑️] │ │
│  │ 7  │ 精品首饰     │ 150,000│ 15.0%  │[9947]│ 36     │ [↑][↓][✏️][🗑️] │ │
│  │ 8  │ 生腌拼盘     │ 100,000│ 10.0%  │[9969]│ 26     │ [↑][↓][✏️][🗑️] │ │
│  └────┴────────────┴────────┴────────┴──────┴────────┴─────────────────┘ │
│                                                                          │
│  🎉 低档 (low) — 7 个奖品，总权重 1,000,000                               │
│  ┌────┬────────────┬────────┬────────┬──────┬────────┬─────────────────┐ │
│  │ 9  │ 青菜1份     │ 240,000│ 24.0%  │[9532]│ 322    │ [↑][↓][✏️][🗑️] │ │
│  │ 10 │ 神秘彩蛋     │ 130,000│ 13.0%  │[9999]│ 199 🛡️│ [↑][↓][✏️][🗑️] │ │
│  │ ...│ ...         │ ...    │ ...    │ ...  │ ...    │ ...             │ │
│  └────┴────────────┴────────┴────────┴──────┴────────┴─────────────────┘ │
│                                                                          │
│  ⚠️ 提示：500积分券、九八折券 库存为 0 但权重 > 0，算法选中后将触发降级      │
│                                                                          │
└──────────────────────────────────────────────────────────────────────────┘
```

说明：
- 🛡️ 标记表示兜底奖品（`is_fallback = 1`）
- 库存列 `[数字]` 为可直接 inline 编辑的输入框
- ⚠️ 底部自动检测库存=0 但权重>0 的风险奖品并提示

#### 11.3 新增奖品

点击「+ 新增奖品」按钮，弹出奖品编辑弹窗，`lottery_campaign_id` 自动填入当前活动 ID，运营填写：

- 奖品名称、类型
- 选奖权重（`win_weight`）、所属档位（`reward_tier`）
- 库存数量（`stock_quantity`）
- 其他字段（图片、描述、稀有度等）

保存后奖品自动出现在对应档位分组中，`sort_order` 默认为该档位当前最大值 +1（排在末尾）。

新增后自动重新计算档内占比并刷新面板显示。

#### 11.4 删除奖品

每个奖品行的操作栏有 🗑️ 删除按钮，点击后：

1. 弹出确认对话框，提示内容：

```
确认删除奖品「500积分券」？

⚠️ 删除后：
• 该奖品从活动中移除，不再参与抽奖
• 高档 (high) 档位总权重将从 1,000,000 变为 300,000
• 其他高档奖品的档内占比将自动变化
• 已发放的奖品记录不受影响

[取消]  [确认删除]
```

2. 确认后调用后端 API 删除（软删除，`status` 改为 `deleted`）
3. 刷新面板，重新计算档内占比

**安全限制**：
- 兜底奖品（`is_fallback = 1`）不允许删除，按钮置灰并提示「兜底奖品不可删除」
- 某档位最后一个奖品不建议删除，弹出额外警告「删除后该档位将没有任何奖品，抽中该档位时将触发降级」

#### 11.5 移动奖品位置（排序管理）

每个奖品行的操作栏有 ↑ 和 ↓ 按钮，用于调整 `sort_order`：

- **↑ 上移**：与同档位上一个奖品交换 `sort_order`
- **↓ 下移**：与同档位下一个奖品交换 `sort_order`
- 第一个奖品的 ↑ 按钮置灰，最后一个奖品的 ↓ 按钮置灰
- 排序仅在同档位内进行，不跨档位移动

实现方式：交换两个奖品的 `sort_order` 值，调用后端批量更新接口。

```
操作前（high 档位）：          操作后（点击九八折券的 ↑）：
 1. 500积分券  sort=1           1. 九八折券   sort=1   ← 上移了
 2. 九八折券   sort=2           2. 500积分券  sort=2
 3. 2000积分券 sort=3           3. 2000积分券 sort=3
```

`sort_order` 影响奖品在转盘/卡片翻转中的展示位置，运营可通过排序控制用户看到的奖品顺序。

#### 11.6 库存快捷编辑

奖品列表中的库存列为 **inline 可编辑输入框**，运营可直接修改数字：

- 点击库存数字，变为输入框
- 修改后按 Enter 或失焦时自动保存
- 保存成功后显示短暂的绿色勾号 ✅
- 保存失败时恢复原值并显示红色提示

支持的库存操作：
- 直接输入具体数字（如 `500`）
- 输入 `999999` 表示无限库存
- 输入 `0` 表示库存清零（配合任务七的风险提示）

### 后端 API（遵循 `/api/v4/console/prize-pool` 路径规范）

| 方法 | 路径 | 功能 |
|------|------|------|
| GET | `/api/v4/console/prize-pool/:code/grouped` | 获取指定活动的奖品列表（按档位分组）— 新增 |
| POST | `/api/v4/console/prize-pool/:code/add-prize` | 为指定活动新增单个奖品 — 新增 |
| DELETE | `/api/v4/console/prize-pool/prize/:id` | 删除奖品（改为软删除）— 已有，改行为 |
| PUT | `/api/v4/console/prize-pool/prize/:id/stock` | 设置单个奖品绝对库存 — 新增 |
| PUT | `/api/v4/console/prize-pool/:code/sort-order` | 批量更新奖品排序 — 新增 |
| PUT | `/api/v4/console/prize-pool/:code/batch-stock` | 批量更新多个奖品库存 — 新增 |

> **路径纠偏**：不使用 `/campaigns/:id/prizes` 或 `/lottery/:campaignId/prizes`，统一使用 `prize-pool` 模块下的路径，保持模块内聚。活动标识使用 `campaign_code` 而非数字 ID。

**GET 响应格式**（按档位分组返回）：

```json
{
  "success": true,
  "data": {
    "campaign": { "id": 1, "name": "餐厅积分抽奖", "pick_method": "tier_first" },
    "prize_groups": [
      {
        "tier": "high",
        "tier_label": "高档",
        "prize_count": 4,
        "total_weight": 1000000,
        "prizes": [
          {
            "lottery_prize_id": 6,
            "prize_name": "500积分券",
            "win_weight": 700000,
            "tier_percentage": 70.0,
            "stock_quantity": 0,
            "total_won": 0,
            "is_fallback": false,
            "sort_order": 1,
            "status": "active"
          }
        ]
      }
    ],
    "warnings": [
      { "prize_id": 6, "type": "zero_stock_positive_weight", "message": "500积分券：库存为 0 但权重 700000 > 0" }
    ]
  }
}
```

**PUT sort-order 请求格式**：

```json
{
  "updates": [
    { "lottery_prize_id": 6, "sort_order": 2 },
    { "lottery_prize_id": 9, "sort_order": 1 }
  ]
}
```

### 涉及文件

| 文件 | 类型 | 说明 |
|------|------|------|
| `admin/lottery-management.html` | 修改 | 活动列表加「奖品管理」按钮 + 奖品管理面板 HTML |
| `admin/src/modules/lottery/composables/prizes.js` | 修改 | 新增活动级奖品加载、增删、排序、库存快捷编辑方法 |
| `routes/v4/console/prize_pool.js` | 修改 | 在现有路由文件中追加 6 个新路由（保持模块内聚） |
| `services/PrizePoolService.js` | 修改 | 新增按活动分组查询、软删除、批量排序、库存快捷更新方法 |

### 修改量汇总

| 模块 | 改动 | 行数 |
|------|------|------|
| 前端 HTML — 奖品管理面板 UI | 分组列表 + inline 编辑 + 排序按钮 + 新增/删除交互 | ~120 行 |
| 前端 JS — prizes.js | 活动级加载、CRUD、排序、库存方法 | ~80 行 |
| 后端路由 — API 端点 | 5 个活动级奖品管理接口 | ~40 行 |
| 后端服务 — PrizePoolService.js | 分组查询、软删除、批量排序、库存更新 | ~40 行 |
| **总计** | | **~280 行** |

### 与其他任务的关系

| 关联任务 | 关系 |
|---------|------|
| 任务一（加 win_weight/reward_tier 白名单） | **前置依赖**：任务一完成后，新增奖品时才能填写权重和档位 |
| 任务四（奖品列表显示档内占比） | **可合并**：奖品管理面板的列表自带档内占比，任务四在此面板中自然实现 |
| 任务五（奖品概览面板） | **互补**：任务五是只读概览，任务十一是完整的可编辑管理面板 |
| 任务七（库存=0 风险提示） | **可合并**：面板底部的 ⚠️ 风险提示区域即为任务七在此面板中的实现 |

### 验证方法

1. 打开管理后台 → 抽奖运营 → 活动运营
2. 确认每个活动行出现「奖品管理」按钮
3. 点击某活动的「奖品管理」，确认进入该活动的奖品管理面板
4. 确认奖品按 high/mid/low 分组显示，每组显示总权重和档内占比
5. **测试新增**：点击「+ 新增奖品」，填写信息保存，确认奖品出现在对应档位分组中
6. **测试删除**：点击某奖品的 🗑️ 删除，确认弹窗提示概率变化影响，确认删除后列表刷新且档内占比重算
7. **测试排序**：点击某奖品的 ↑ 或 ↓，确认与相邻奖品交换位置，数据库 `sort_order` 更新
8. **测试库存编辑**：点击库存数字直接修改，确认 Enter/失焦后保存成功
9. 验证数据库：

```sql
-- 确认排序正确
SELECT lottery_prize_id, prize_name, reward_tier, sort_order, stock_quantity
FROM lottery_prizes WHERE lottery_campaign_id = 1
ORDER BY reward_tier, sort_order;

-- 确认软删除
SELECT lottery_prize_id, prize_name, status
FROM lottery_prizes WHERE lottery_campaign_id = 1 AND status = 'deleted';
```

10. 在前端转盘/卡片翻转页面确认奖品展示顺序与 `sort_order` 一致

---

## 🛠️ 基于后端实际技术栈的执行方案（2026-02-22）

> 以下执行步骤严格遵循项目现有后端技术框架：ServiceManager + TransactionManager + ApiResponse + asyncHandler + adminAuthMiddleware。

### 第一轮执行步骤

#### 步骤 1：任务一 — 加白名单 + 修复查询遗漏（后端 ~25 行 + Web 前端 ~25 行）

**后端改动 1**：`services/PrizePoolService.js` 第 531-558 行 `allowedFields` 对象加 2 字段

```javascript
win_weight: 'win_weight',
reward_tier: 'reward_tier'
```

**后端改动 2（关键遗漏修复）**：`getAllPrizes()` 方法（第 398-421 行）的 `attributes` 数组加 3 字段 + 格式化输出（第 441-466 行）加 3 字段

```javascript
// attributes 数组中加入：
'win_weight',
'reward_tier',
'is_fallback',

// formattedPrizes map 中加入：
win_weight: prize.win_weight || 0,
reward_tier: prize.reward_tier || 'low',
is_fallback: prize.is_fallback || false,
```

**后端改动 3**：`getPrizesByCampaign()` 方法（第 277-299 行）同样加入这 3 个字段（attributes + formatting）

改完后，`GET /api/v4/console/prize-pool/list` 和 `GET /api/v4/console/prize-pool/:code` 都会返回 `win_weight`、`reward_tier`、`is_fallback`，Web 前端才能正确渲染。

`PUT /api/v4/console/prize-pool/prize/:id` 传入 `{ win_weight: 350000, reward_tier: 'high' }` 即可更新。审计日志会自动记录变更（`admin_operation_logs` 的 `changed_fields` 字段）。

**Web 前端改动**：`admin/src/modules/lottery/composables/prizes.js` + `admin/lottery-management.html`

- `prizeForm` 对象加 `win_weight: 100000` 和 `reward_tier: 'low'`
- `resetPrizeForm()` 加重置逻辑
- `editPrize()` 加读取逻辑
- `submitPrizeForm()` 编辑模式的 `updateData` 加这两个字段
- 编辑 Modal HTML 加权重输入框和档位下拉框

**验证**：打开管理后台编辑任意奖品，修改权重值，查数据库确认 `win_weight` 已更新。

#### 步骤 2：任务十一（活动级入口）— 后端 1 个新 API + Web 前端 ~120 行

**后端新增**：在 `routes/v4/console/prize_pool.js` 中追加路由

```
GET /api/v4/console/prize-pool/:code/grouped
```

**Service 层新增方法**：`PrizePoolService.getPrizesByCampaignGrouped(campaign_code)`

逻辑：
1. 通过 `campaign_code` 查到 `lottery_campaign_id`
2. 查询该活动所有奖品（`status = 'active'`）
3. 按 `reward_tier` 分组
4. 每组内按 `sort_order` 排序
5. 计算每组总权重和每个奖品的档内占比（`tier_percentage`）
6. 检测 `stock_quantity = 0 && win_weight > 0` 的风险奖品，放入 `warnings` 数组

**响应格式**（遵循 ApiResponse 标准）：

```javascript
res.apiSuccess({
  campaign: { lottery_campaign_id, campaign_name, campaign_code, pick_method, status },
  prize_groups: [
    {
      tier: 'high',
      tier_label: '高档',
      prize_count: 4,
      total_weight: 1000000,
      prizes: [
        {
          lottery_prize_id: 1,
          prize_name: '八八折',
          win_weight: 10000,
          tier_percentage: 1.0,  // 前端直接显示，不需要二次计算
          stock_quantity: 9269,
          total_win_count: 401,
          is_fallback: false,
          sort_order: 1,
          status: 'active',
          rarity_code: 'common',
          image_resource_id: null
        }
        // ...
      ]
    }
    // mid, low 同理
  ],
  warnings: [
    { lottery_prize_id: 6, type: 'zero_stock_positive_weight', message: '500积分券：库存为 0 但权重 700000 > 0' }
  ]
}, '活动奖品分组信息获取成功')
```

**Web 前端**：活动列表行加「奖品管理」按钮，点击调用此 API 并渲染分组面板。

#### 步骤 3：任务十二（增删奖品）— 修复 batchAddPrizes + 新增单个添加 API + Web 前端 ~70 行

**后端改动 1（修复 batchAddPrizes 缺陷）**：`services/PrizePoolService.js` 的 `batchAddPrizes()` 方法

- 第 134-164 行 `LotteryPrize.create()` 调用中加入 `win_weight`、`reward_tier`、`is_fallback` 三个字段：

```javascript
win_weight: parseInt(prizeData.win_weight) || 0,
reward_tier: prizeData.reward_tier || 'low',
is_fallback: prizeData.is_fallback ? 1 : 0,
```

- 第 101-109 行 `win_probability` 总和 = 1.0 校验改为按 `pick_method` 分支：

```javascript
if (campaign.pick_method === 'normalize') {
  // normalize 模式：校验 win_probability 总和 = 1.0
  const totalProbability = prizes.reduce((sum, p) => sum + (parseFloat(p.win_probability) || 0), 0)
  if (Math.abs(totalProbability - 1.0) > 0.001) {
    throw new Error(`奖品概率总和必须为1，当前为${totalProbability.toFixed(4)}`)
  }
}
// tier_first 模式：不校验 win_probability（使用 win_weight）
```

**后端改动 2**：`prize_pool.js` 追加单个奖品添加路由

```
POST /api/v4/console/prize-pool/:code/add-prize
```

逻辑：从 URL 的 `campaign_code` 解析出 `lottery_campaign_id` 和 `pick_method`，自动分配 `sort_order`，调用修复后的 `batchAddPrizes` 传入单奖品数组。

- 删除奖品：复用 `DELETE /api/v4/console/prize-pool/prize/:id`（已有）

**后端兜底保护**：删除时检查 `is_fallback = 1` 则返回 `res.apiError('兜底奖品不可删除', 'FALLBACK_PROTECTED')`。

**后端软删除改造**（拍板决定 2）：
- 迁移脚本：`ALTER TABLE lottery_prizes ADD COLUMN deleted_at DATETIME NULL`
- `LotteryPrize.js` 模型选项加 `paranoid: true`
- 现有 `deletePrize()` 中的 `prize.destroy()` 无需改（Sequelize paranoid 自动变为设置 `deleted_at`）
- 现有所有 `findAll()`/`findOne()` 无需改（Sequelize 自动加 `WHERE deleted_at IS NULL`）
- "有中奖记录则拒绝删除"的保护逻辑保留

**Web 前端**：新增奖品 Modal（`lottery_campaign_id` 锁定）+ 删除确认弹窗。

#### 步骤 4：任务十四（库存管理）— 后端 2 个新 API + Web 前端 ~50 行

**后端新增 API 1**：`PUT /api/v4/console/prize-pool/prize/:id/stock`

区别于现有 `add-stock`（增量），这个是**设置绝对值**。

```javascript
// Body: { stock_quantity: 10 }
// 返回: res.apiSuccess({ old_stock: 5, new_stock: 10 }, '库存更新成功')
```

**后端新增 API 2**：`PUT /api/v4/console/prize-pool/:code/batch-stock`

```javascript
// Body: { updates: [{ lottery_prize_id: 1, stock_quantity: 10 }, ...] }
// 在 TransactionManager.execute() 内批量更新
// 返回: res.apiSuccess({ updated_count: 2 }, '批量库存更新成功')
```

**Web 前端**：库存列改为 inline 输入框，失焦/回车调用单个更新 API；批量弹窗勾选后调用批量 API。

### 第二轮执行步骤

#### 步骤 5：任务四+五+六（概率可视化三件套）— 纯 Web 前端

**后端**：不需要改动。步骤 2 的分组 API 已返回 `tier_percentage` 和 `total_weight`。

**Web 前端实现**：
- 任务四：奖品列表权重列旁加 `(XX.X%)` 显示
- 任务五：活动编辑弹窗新 Tab 或面板，调用分组 API 渲染树形结构
- 任务六：奖品编辑 Modal 底部加同档位对比区域（从已加载的分组数据中过滤）

#### 步骤 6：任务七（风险提示）— 后端 ~10 行 + Web 前端 ~10 行

**后端**：在 `PrizePoolService.updatePrize()` 返回值中增加 `warnings` 数组。保存后检测：

```javascript
if (updatedPrize.stock_quantity === 0 && updatedPrize.win_weight > 0) {
  result.warnings = [{ type: 'zero_stock_positive_weight', message: '库存为 0 但权重 > 0，算法选中后将触发降级' }]
}
```

**Web 前端**：保存成功后检查 `response.data.warnings`，有则弹提示。

#### 步骤 7：任务十三（排序）— 后端 1 个新 API + Web 前端 ~80 行

**后端新增**：`PUT /api/v4/console/prize-pool/:code/sort-order`

```javascript
router.put(
  '/:code/sort-order',
  adminAuthMiddleware,
  asyncHandler(async (req, res) => {
    const campaign_code = req.params.code
    const { updates } = req.body  // [{ lottery_prize_id, sort_order }, ...]

    const result = await TransactionManager.execute(
      async transaction => {
        // 批量更新 sort_order，在事务内执行
        return await PrizePoolService.batchUpdateSortOrder(campaign_code, updates, {
          updated_by: req.user?.user_id,
          transaction
        })
      },
      { description: 'batchUpdateSortOrder' }
    )
    return res.apiSuccess(result, '排序更新成功')
  })
)
```

注意：`lottery_prizes` 表有 `idx_unique_campaign_sort_order(lottery_campaign_id, sort_order)` 唯一索引，批量更新需要先置临时值再设目标值，或一次 CASE WHEN UPDATE 避免中间态冲突。

**Web 前端**：CDN 引入 SortableJS，拖拽完成后收集新顺序调用 API。

### 第三轮执行步骤

#### 步骤 8：任务二（清理 fallback）— 后端迁移脚本

**迁移文件**：`migrations/YYYYMMDD-remove-fallback-pick-method.js`

```javascript
// up: ALTER TABLE lottery_campaigns MODIFY COLUMN pick_method ENUM('normalize','tier_first') NOT NULL DEFAULT 'tier_first'
// down: ALTER TABLE lottery_campaigns MODIFY COLUMN pick_method ENUM('normalize','fallback','tier_first') NOT NULL DEFAULT 'tier_first'
```

同时在 `LotteryCampaign.js` 模型中移除 `fallback` 枚举值。
`fallback_lottery_prize_id` 字段加注释标记废弃，后续版本删除。

#### 步骤 9：任务八（审计日志）— 后端验证现有覆盖

**验证方法**：加完白名单（步骤 1）后，编辑一个奖品的 `win_weight`，然后查询：

```sql
SELECT admin_operation_log_id, operation_type, target_type, target_id, changed_fields
FROM admin_operation_logs
WHERE target_type = 'lottery_prize' ORDER BY created_at DESC LIMIT 5;
```

如果 `changed_fields` 中包含 `win_weight` 的变更记录，则任务八**无需额外开发**。

#### 步骤 10：任务九+十（normalize 引擎 + 选奖方式选择）— 后端 ~130 行 + Web 前端 ~60 行

**🔴 拍板：现在做，不推迟。**

**后端改动 1 — normalize 引擎分支**：

涉及文件：`TierPickStage.js`、`PrizePickStage.js`

逻辑：
- `TierPickStage` 检测 `pick_method = 'normalize'` 时，跳过档位选择，直接把所有 `status='active'` 且 `stock_quantity > 0` 的奖品放入候选池
- `PrizePickStage` 在 normalize 模式下，按 `win_probability` 做归一化随机选奖：

```
奖品被选中概率 = 该奖品的 win_probability / 所有候选奖品 win_probability 之和
```

**后端改动 2 — 保存时概率校验**：

涉及文件：`PrizePoolService.js`

逻辑：当活动 `pick_method = 'normalize'` 时，`batchAddPrizes()` 和 `updatePrize()` 校验所有 active 奖品的 `win_probability` 之和是否 = 1.0（允许 ±0.001 浮点误差）。不等于则返回 warning（不阻断，只提示）。

**后端改动 3 — 活动创建/编辑支持 pick_method**：

现有 `LotteryCampaign` 模型已有 `pick_method` 字段，创建/编辑活动 API 已支持此字段，**后端不需要改**。

**Web 前端改动**：

活动编辑 Modal 中加选奖方式下拉框：

```
选奖方式: [先选档位 tier_first ▾]
          ├── 先选档位 tier_first（推荐）
          └── 百分比 normalize
```

联动逻辑：
- 选 `tier_first` → 显示档位权重配置（`reward_tier` + `win_weight`），隐藏百分比输入
- 选 `normalize` → 显示百分比输入（`win_probability`），隐藏档位/权重，底部显示概率总和

**验证**：创建一个 `pick_method = 'normalize'` 的测试活动，配置奖品百分比总和=100%，模拟抽奖验证分布。

#### 步骤 11：任务三（分群动态管理）— 完整实施 — 后端 ~200 行 + Web 前端 ~300 行

**🔴 拍板：选 B 完整实施，不推迟。**

**后端改动 1 — 新建 `segment_rule_configs` 表**：

迁移脚本 + Sequelize 模型（`models/SegmentRuleConfig.js`）。

```sql
CREATE TABLE segment_rule_configs (
  id              INT AUTO_INCREMENT PRIMARY KEY,
  version_key     VARCHAR(32) NOT NULL,
  version_name    VARCHAR(100) NOT NULL,
  description     VARCHAR(500),
  rules           JSON NOT NULL,
  is_system       TINYINT(1) DEFAULT 0,
  status          VARCHAR(20) DEFAULT 'active',
  created_by      INT,
  created_at      DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at      DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  UNIQUE KEY uk_version_key (version_key)
);
```

数据迁移：将 `config/segment_rules.js` 中的 5 个内置版本（default/v1/v2/v3/v4）写入表中，标记 `is_system = 1`。

**后端改动 2 — 新增路由文件 `routes/v4/console/segment-rules.js`**：

6 个 API，挂载于 `/api/v4/console/segment-rules`：

| 方法 | 路径 | 功能 | 备注 |
|------|------|------|------|
| GET | `/` | 列出所有分群策略版本 | 含内置 + 自定义 |
| GET | `/:version_key` | 获取某版本详情 | 含规则 JSON |
| POST | `/` | 创建新版本 | 自动 `is_system = 0` |
| PUT | `/:version_key` | 编辑版本规则 | `is_system = 1` 的不可改规则结构 |
| DELETE | `/:version_key` | 归档版本 | `is_system = 1` 的不可删 |
| GET | `/field-registry` | 获取可用字段+运算符白名单 | 从 `segment_field_registry.js` 返回 |

路由注册到 `routes/v4/console/index.js`。

**后端改动 3 — 新增 `config/segment_field_registry.js`**：

字段白名单 + 运算符白名单 + 每个运算符的 `evaluate()` 函数（文档中已有完整定义）。

**后端改动 4 — 修改 `config/segment_rules.js`**：

`resolveSegment()` 改为优先读数据库 `segment_rule_configs` 表，命中则用通用条件求值器执行；未命中则回退到内置硬编码规则。

**Web 前端改动 — 分群策略管理页**：

1. 策略列表页：显示所有版本，系统内置的标记🔒不可删
2. 条件构建器 UI：选字段 → 选运算符 → 填值，实时预览自然语言描述
3. 测试面板：输入模拟用户数据（注册时间、积分、等级等），实时显示匹配结果
4. 活动编辑 Modal 中加分群策略下拉选择器

**验证**：
1. 创建自定义分群策略，配置条件
2. 在测试面板中用模拟数据验证匹配
3. 在活动编辑中选择新策略
4. 模拟抽奖验证不同用户命中不同 segment_key

### 后端新增代码量汇总（全部 14 个任务，三轮合计）

| 改动类型 | 文件 | 行数 | 轮次 |
|---------|------|------|------|
| `allowedFields` 加 2 字段 + `getAllPrizes`/`getPrizesByCampaign` 加 3 字段（attributes + formatting） | `services/PrizePoolService.js` | +25 | 一 |
| 分组查询方法 | `services/PrizePoolService.js` | +40 | 一 |
| 批量排序方法 | `services/PrizePoolService.js` | +30 | 二 |
| 设置绝对库存方法 | `services/PrizePoolService.js` | +20 | 一 |
| 批量库存方法 | `services/PrizePoolService.js` | +25 | 一 |
| 风险提示检测 | `services/PrizePoolService.js` | +10 | 二 |
| 兜底保护检查 | `services/PrizePoolService.js` | +5 | 一 |
| 修复 `batchAddPrizes` 缺字段 + `win_probability` 校验分支 | `services/PrizePoolService.js` | +15 | 一 |
| 6 个新路由（分组/排序/库存×2/单个添加/字段注册） | `routes/v4/console/prize_pool.js` | +100 | 一/二 |
| 软删除迁移 | `migrations/YYYYMMDD-add-deleted-at-to-prizes.js` | +15 | 一 |
| 软删除模型配置 | `models/LotteryPrize.js` | +2 | 一 |
| 清理 fallback 迁移 | `migrations/YYYYMMDD-remove-fallback.js` | +20 | 三 |
| normalize 引擎分支 | `TierPickStage.js` + `PrizePickStage.js` | +80 | 三 |
| normalize 概率校验 | `services/PrizePoolService.js` | +20 | 三 |
| 分群表迁移 + 种子数据 | `migrations/YYYYMMDD-create-segment-rule-configs.js` | +60 | 三 |
| 分群模型 | `models/SegmentRuleConfig.js` | +40 | 三 |
| 字段运算符白名单 | `config/segment_field_registry.js` | +60 | 三 |
| 分群 CRUD 路由（6 个 API） | `routes/v4/console/segment-rules.js` | +120 | 三 |
| 改 SegmentResolver 读数据库 | `config/segment_rules.js` | +40 | 三 |
| 审计日志验证（可能为 0） | `services/PrizePoolService.js` | +0~10 | 三 |
| **三轮后端总计** | | **~660 行** |

### Web 前端新增代码量汇总（全部 14 个任务，三轮合计）

| 改动类型 | 文件 | 行数 | 轮次 |
|---------|------|------|------|
| prizeForm + 提交逻辑 | `composables/prizes.js` | +15 | 一 |
| 编辑 Modal 权重/档位 UI | `lottery-management.html` | +15 | 一 |
| 活动级管理面板 | `lottery-management.html` | +120 | 一 |
| 管理面板 JS 逻辑 | `composables/prizes.js` | +80 | 一 |
| 概率可视化（三件套） | `lottery-management.html` | +60 | 二 |
| 排序 UI（SortableJS） | `lottery-management.html` | +40 | 二 |
| 库存 inline 编辑 | `lottery-management.html` | +50 | 一 |
| 选奖方式选择 + 联动 | `lottery-management.html` | +30 | 三 |
| 选奖方式 JS 逻辑 | `composables/prizes.js` 或新文件 | +30 | 三 |
| 分群策略管理页 HTML | 新页面或 `lottery-management.html` 新面板 | +150 | 三 |
| 条件构建器 + 测试面板 JS | 新 composable 文件 | +100 | 三 |
| 活动编辑加分群策略选择器 | `lottery-management.html` | +20 | 三 |
| fallback 相关 UI 移除 | `lottery-management.html` | -10 | 三 |
| **三轮 Web 前端总计** | | **~700 行** |

### 三轮总工作量

| 轮次 | 后端 | Web 前端 | 合计 | 预估工期 |
|------|------|---------|------|---------|
| 第一轮（先能用） | ~260 行 | ~280 行 | ~540 行 | 1 天 |
| 第二轮（好用） | ~70 行 | ~150 行 | ~220 行 | 1 天 |
| 第三轮（完善） | ~370 行 | ~270 行 | ~640 行 | 2 天 |
| **合计** | **~700 行** | **~700 行** | **~1400 行** | **4 天** |

> 注：后端行数比之前版本增加 ~40 行，主要来自 `getAllPrizes()`/`getPrizesByCampaign()` 字段补全（+25 行）和 `batchAddPrizes()` 缺陷修复（+15 行），这两项是本次数据库实查发现的遗漏。
