# 消费服务层 QR 码验证兼容模式清理方案（架构决策版）

**文档版本**: v3.0  
**创建日期**: 2026-01-13  
**架构决策日期**: 2026-01-13  
**最终拍板日期**: 2026-01-13  
**负责人**: 技术架构组  
**状态**: ✅ 架构决策已拍板 + 执行策略已确认，可立即执行

---

## 🎯 架构决策总览（已拍板）

本方案基于**项目未上线、可一次性投入、不兼容旧接口、架构干净统一、真相源唯一**的前提，已完成以下 5 项核心架构决策：

| 决策项     | 决策结果                          | 核心原则                         |
| ---------- | --------------------------------- | -------------------------------- |
| **决策 1** | ✅ 删除服务层兼容分支             | 二维码验证真相源唯一（边界层）   |
| **决策 2** | ✅ 分层参数校验（大公司/游戏式）  | 路由层格式/安全，服务层契约/业务 |
| **决策 3** | ✅ 分层隔离（路由 uuid，服务 id） | 外部安全 + 内部性能              |
| **决策 4** | ✅ 业务异常类 + 统一错误码体系    | 稳定监控 + 审计追溯              |
| **决策 5** | ✅ 结构化日志 + 强制脱敏          | 安全基线 + 审计合规              |

---

## ✅ 最终执行策略拍板（2026-01-13）

基于**当前项目真实代码与真实数据库状态验证**，已完成以下 4 项执行策略拍板：

| 执行策略项        | 拍板结果                                   | 执行方式                                                         |
| ----------------- | ------------------------------------------ | ---------------------------------------------------------------- |
| **1. 契约收紧**   | ✅ **同意收紧**                            | 服务层不再兜底验证二维码，调用方必须传 `user_uuid`，违反立即报错 |
| **2. 灰度/开关**  | ✅ **不需要（一次性）**                    | 项目未上线，可直接全量清理，无需保留应急开关                     |
| **3. 错误码口径** | ✅ **新增消费域错误码（CONSUMPTION\_\*）** | 统一使用 `CONSUMPTION_MISSING_USER_UUID` 等域前缀错误码          |
| **4. 日志脱敏**   | ✅ **严格（黑名单全剔除）**                | 二维码/nonce/签名/token 等敏感信息绝不落日志                     |

**验证依据**：

- ✅ 真实代码验证：唯一调用点 `routes/v4/shop/consumption/submit.js` 已传入 `user_uuid`
- ✅ 真实数据验证：`consumption_records` 表 1 条记录，全部为 `QRV2_` 格式，无旁路写入痕迹
- ✅ 风险边界明确：仅影响"绕过路由层、直接调用服务层且漏传 `user_uuid`"的调用方（当前不存在）

---

## 📋 执行摘要

### 问题描述

`services/ConsumptionService.js` 的 `merchantSubmitConsumption()` 方法中存在**服务层 QR 码验证兼容分支**，该分支在路由层已完成 V2 动态码校验并传入 `user_uuid` 的情况下属于冗余逻辑，违反**真相源唯一**原则，存在职责混乱和潜在失败风险。

### 核心风险

1. **真相源重复**：路由层已完成"消耗 nonce 的校验"，服务层再保留兜底验证违反"二维码是否有效"的真相只在边界层产生一次的原则
2. **潜在重放攻击风险**：若未来有调用方忘记传 `user_uuid`，服务层会再次消耗 nonce，可能触发"nonce 已使用"错误
3. **维护成本增加**：兼容代码增加理解成本，注释标注"Phase 2 后移除"但未执行
4. **架构不清晰**：职责分层模糊，不符合大公司/游戏/交易平台的标准分层架构

### 清理收益

- **代码简化**：移除约 15 行兼容逻辑
- **职责清晰**：建立干净分层 - 路由层负责边界校验，服务层负责业务逻辑
- **真相源唯一**：二维码验证结果（user_uuid）只在边界层产生一次
- **风险降低**：消除潜在的重复验证和 nonce 消耗问题
- **架构升级**：建立符合大公司/游戏/交易平台标准的分层架构

---

## 🎯 架构决策详解（已拍板）

### 决策 1：二维码验证真相源唯一化

**决策内容**：删除服务层兼容分支，建立干净分层和唯一真相源

**核心原则**：

- **真相源唯一**："二维码是否有效"的真相只在边界层（路由层）产生一次
- **职责单一**：路由层负责消费 nonce 并完成二维码验证，服务层严禁再调用会消耗 nonce 的 validate
- **契约明确**：`user_uuid` 作为路由层与服务层的契约参数，必须由路由层传入

**实施方式**：

```javascript
// ❌ 删除：服务层兼容分支（services/ConsumptionService.js:252-269）
if (!userUuid) {
  const qrValidation = await QRCodeValidator.validateQRCode(data.qr_code)
  // ... 这段会再次消耗 nonce，违反真相源唯一原则
}

// ✅ 替换为：强制契约断言（执行策略拍板：收紧契约 + 消费域错误码）
if (!data.user_uuid) {
  throw new BusinessError(
    'user_uuid 是必需参数，必须由路由层在二维码验证后传入',
    'CONSUMPTION_MISSING_USER_UUID', // ✅ 拍板：使用消费域错误码前缀
    400
  )
}
const userUuid = data.user_uuid // 真相源：来自路由层的验证结果
```

---

### 决策 2：分层参数校验（大公司/游戏式架构）

**决策内容**：采用"大公司/游戏式分层"，路由层负责格式/安全校验，服务层负责契约/业务校验

**职责划分**：

| 层级       | 校验职责       | 具体内容                                                                    |
| ---------- | -------------- | --------------------------------------------------------------------------- |
| **路由层** | 格式/安全/边界 | 二维码格式/签名/过期/nonce、防重放、最基础字段格式、权限验证                |
| **服务层** | 契约/业务/状态 | user_uuid 必须存在（契约断言）、金额业务规则、幂等键存在、状态机/事务一致性 |

**实施方式**：

```javascript
// routes/v4/shop/consumption/submit.js（路由层）
// ✅ 路由层负责：格式/安全/边界校验
const qr_validation = await QRCodeValidator.validateQRCodeV2WithNonce(qr_code)
if (!qr_validation.valid) {
  return res.apiError(qr_validation.error, qr_validation.error_code, null, 400)
}

if (!consumption_amount || consumption_amount <= 0) {
  return res.apiError('消费金额必须大于0', 'CONSUMPTION_INVALID_AMOUNT', null, 400)
}

// services/ConsumptionService.js（服务层）
// ✅ 服务层负责：契约断言 + 业务规则
static _validateBusinessRules(data) {
  // 契约断言
  if (!data.user_uuid) {
    throw new BusinessError('user_uuid 是必需参数', 'CONSUMPTION_MISSING_USER_UUID', 400)
  }
  if (!data.idempotency_key) {
    throw new BusinessError('idempotency_key 是必需参数', 'CONSUMPTION_MISSING_IDEMPOTENCY_KEY', 400)
  }

  // 业务规则
  if (data.consumption_amount > 99999.99) {
    throw new BusinessError('消费金额不能超过99999.99元', 'CONSUMPTION_AMOUNT_EXCEEDED', 400)
  }
}
```

---

### 决策 3：user_uuid vs user_id 分层隔离

**决策内容**：路由层/外部契约用 `user_uuid`，服务层尽早转换到 `user_id` 并在 DB 层用 `user_id` 关联

**核心原则**：

- **外部安全**：路由层/API 契约使用 `user_uuid`，防止主键泄露
- **内部性能**：服务层/数据库层使用 `user_id`，索引性能更优
- **扩展性**：为将来交易市场、资产账本等多域系统预留架构空间

**实施方式**：

```javascript
// routes/v4/shop/consumption/submit.js（路由层）
const result = await ConsumptionService.merchantSubmitConsumption({
  user_uuid: qr_validation.user_uuid, // ✅ 路由层传入 uuid
  // ...
})

// services/ConsumptionService.js（服务层）
static async merchantSubmitConsumption(data, options) {
  // ✅ 服务层尽早转换为 user_id（真相源：User 表）
  const user = await User.findOne({
    where: { user_uuid: data.user_uuid },
    transaction
  })

  if (!user) {
    throw new BusinessError(
      `用户不存在（UUID: ${data.user_uuid.substring(0, 8)}...）`,
      'CONSUMPTION_USER_NOT_FOUND',
      404
    )
  }

  const userId = user.user_id // ✅ 后续统一使用 user_id

  // ✅ 数据库层：所有关联使用 user_id
  await ConsumptionRecord.create({
    user_id: userId, // 外键关联
    merchant_id: data.merchant_id,
    // ...
  }, { transaction })
}
```

---

### 决策 4：业务异常类 + 统一错误码体系

**决策内容**：采用业务异常类（BusinessError）+ 统一错误码体系 + 全局错误中间件统一出参

**核心原则**：

- **稳定错误码**：按业务域拆前缀（CONSUMPTION*\* / QRCODE*_ / AUTH\__ / PERMISSION*\* / IDEMPOTENCY*\*）
- **监控友好**：错误码可直接用于告警、运营分析、审计追溯
- **对外隐藏内部细节**：DB 错误只返回通用码，details 只进日志

**实施方式**：

**步骤 1：创建业务异常类**

```javascript
// utils/BusinessError.js（新建）
class BusinessError extends Error {
  constructor(message, code, statusCode = 400, details = null) {
    super(message)
    this.name = 'BusinessError'
    this.code = code // 业务错误码（必须按域拆分前缀）
    this.statusCode = statusCode
    this.details = details // 仅用于日志，不对外暴露
  }
}

module.exports = BusinessError
```

**步骤 2：定义错误码体系**

```javascript
// constants/errorCodes.js（新建）
module.exports = {
  // 消费域错误码
  CONSUMPTION_MISSING_USER_UUID: 'CONSUMPTION_MISSING_USER_UUID',
  CONSUMPTION_MISSING_IDEMPOTENCY_KEY: 'CONSUMPTION_MISSING_IDEMPOTENCY_KEY',
  CONSUMPTION_USER_NOT_FOUND: 'CONSUMPTION_USER_NOT_FOUND',
  CONSUMPTION_INVALID_AMOUNT: 'CONSUMPTION_INVALID_AMOUNT',
  CONSUMPTION_AMOUNT_EXCEEDED: 'CONSUMPTION_AMOUNT_EXCEEDED',
  CONSUMPTION_DUPLICATE_SUBMISSION: 'CONSUMPTION_DUPLICATE_SUBMISSION',

  // 二维码域错误码
  QRCODE_INVALID_FORMAT: 'QRCODE_INVALID_FORMAT',
  QRCODE_EXPIRED: 'QRCODE_EXPIRED',
  QRCODE_REPLAY_DETECTED: 'QRCODE_REPLAY_DETECTED',
  QRCODE_SIGNATURE_INVALID: 'QRCODE_SIGNATURE_INVALID',

  // 权限域错误码
  PERMISSION_DENIED: 'PERMISSION_DENIED',
  PERMISSION_STORE_MISMATCH: 'PERMISSION_STORE_MISMATCH',

  // 幂等域错误码
  IDEMPOTENCY_KEY_CONFLICT: 'IDEMPOTENCY_KEY_CONFLICT',
  IDEMPOTENCY_REQUEST_IN_PROGRESS: 'IDEMPOTENCY_REQUEST_IN_PROGRESS',

  // 通用错误码（用于隐藏内部细节）
  INTERNAL_ERROR: 'INTERNAL_ERROR',
  DATABASE_ERROR: 'DATABASE_ERROR',
  SERVICE_UNAVAILABLE: 'SERVICE_UNAVAILABLE'
}
```

**步骤 3：全局错误中间件**

```javascript
// middleware/errorHandler.js（修改）
const BusinessError = require('../utils/BusinessError')
const logger = require('../utils/logger').logger
const { sanitize } = require('../utils/logger')

function globalErrorHandler(err, req, res, next) {
  // 记录完整错误到日志（包含 details）
  logger.error('请求处理失败', {
    request_id: req.id,
    error_code: err.code || 'UNKNOWN',
    error_message: err.message,
    error_stack: err.stack,
    error_details: err.details, // 仅日志可见
    path: req.path,
    method: req.method
  })

  // 业务异常：返回标准格式
  if (err instanceof BusinessError) {
    return res.status(err.statusCode).json({
      success: false,
      code: err.code,
      message: err.message,
      data: null,
      timestamp: new Date().toISOString(),
      request_id: req.id
      // ❌ 不返回 details（对外隐藏内部细节）
    })
  }

  // 数据库错误：隐藏内部细节
  if (err.name === 'SequelizeDatabaseError' || err.name === 'SequelizeConnectionError') {
    return res.status(500).json({
      success: false,
      code: 'DATABASE_ERROR',
      message: '数据库操作失败，请稍后重试',
      data: null,
      timestamp: new Date().toISOString(),
      request_id: req.id
    })
  }

  // 未知错误：通用错误码
  return res.status(500).json({
    success: false,
    code: 'INTERNAL_ERROR',
    message: '服务器内部错误',
    data: null,
    timestamp: new Date().toISOString(),
    request_id: req.id
  })
}

module.exports = globalErrorHandler
```

---

### 决策 5：结构化日志 + 强制脱敏

**决策内容**：采用结构化日志 + 强制 request_id + 统一脱敏/禁止落日志清单

**核心原则**：

- **安全基线**：涉及手机号、二维码、鉴权信息、nonce/签名必须默认按安全基线处理
- **审计合规**：结构化日志兼容"审计事件"和"错误诊断"
- **可追溯**：强制 request_id 全链路传递

**实施方式**：

**步骤 1：定义脱敏规则**

```javascript
// utils/logger.js（修改）

// 🚫 绝不允许落日志（黑名单）- ✅ 执行策略拍板：严格脱敏
const BLACKLIST_FIELDS = [
  'authorization',
  'Authorization',
  'token',
  'password',
  'secret',
  'qr_code', // ✅ 拍板：完整二维码绝不落日志（可能被重放）
  'nonce', // ✅ 拍板：一次性随机数绝不落日志
  'signature', // ✅ 拍板：签名信息绝不落日志
  'payment_info',
  'card_number',
  'cvv'
]

// ⚠️ 允许部分脱敏落日志（灰名单）
const SANITIZE_RULES = {
  // 手机号：保留前3后4，中间4位打码
  mobile: mobile => (mobile ? mobile.replace(/(\d{3})\d{4}(\d{4})/, '$1****$2') : null),

  // user_uuid：仅保留前8位
  user_uuid: uuid => (uuid ? uuid.substring(0, 8) + '...' : null),

  // ❌ 删除 qr_code_preview（执行策略拍板：严格脱敏，连预览也不落日志）
  // qr_code_preview: (qr) => qr ? qr.substring(0, 30) + '...' : null,

  // IP：保留完整（便于风控，非敏感信息）
  ip: ip => ip,

  // merchant_notes：截断到100字符（用于审计）
  merchant_notes: notes => (notes ? notes.substring(0, 100) : null)
}

// 统一脱敏函数
const sanitize = {
  ...SANITIZE_RULES,

  // 自动检测并脱敏对象
  object: obj => {
    if (!obj || typeof obj !== 'object') return obj

    const sanitized = {}
    for (const [key, value] of Object.entries(obj)) {
      // 黑名单字段：完全移除
      if (BLACKLIST_FIELDS.includes(key)) {
        sanitized[key] = '[REDACTED]'
        continue
      }

      // 灰名单字段：脱敏处理
      if (key === 'mobile' && SANITIZE_RULES.mobile) {
        sanitized[key] = SANITIZE_RULES.mobile(value)
      } else if (key === 'user_uuid' && SANITIZE_RULES.user_uuid) {
        sanitized[key] = SANITIZE_RULES.user_uuid(value)
      } else if (key === 'qr_code' && SANITIZE_RULES.qr_code_preview) {
        sanitized[key] = SANITIZE_RULES.qr_code_preview(value)
      } else {
        sanitized[key] = value
      }
    }

    return sanitized
  }
}

module.exports = { logger, sanitize }
```

**步骤 2：日志级别策略**

```javascript
// config/logger.js（修改）

const logLevel = process.env.LOG_LEVEL || (process.env.NODE_ENV === 'production' ? 'info' : 'debug')

// ✅ 生产环境可以继续使用 debug 级别（便于问题诊断）
// 但必须确保敏感信息已脱敏
const logger = winston.createLogger({
  level: logLevel, // 生产环境：info，开发环境：debug
  format: winston.format.combine(
    winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ filename: 'logs/error.log', level: 'error' }),
    new winston.transports.File({ filename: 'logs/combined.log' })
  ]
})
```

**步骤 3：使用示例（执行策略拍板：严格脱敏）**

```javascript
// services/ConsumptionService.js（使用示例）
const { logger, sanitize } = require('../utils/logger')

static async merchantSubmitConsumption(data, options) {
  // ✅ 正确：使用脱敏后的数据记录日志（执行策略拍板：qr_code 绝不落日志）
  logger.info('商家提交消费记录', {
    request_id: options.request_id,
    // ❌ 删除：qr_code 任何形式都不落日志（执行策略拍板：严格脱敏）
    // qr_code: sanitize.qr_code_preview(data.qr_code), // 连预览也不落日志
    user_uuid: sanitize.user_uuid(data.user_uuid), // 仅前8位
    consumption_amount: data.consumption_amount,
    merchant_id: data.merchant_id,
    store_id: data.store_id,
    merchant_notes: sanitize.merchant_notes(data.merchant_notes) // 截断到100字符
  })

  // ❌ 错误：直接记录完整敏感信息
  // logger.info('商家提交消费记录', data) // 会泄露完整 qr_code、nonce 等
}
```

---

## 🔍 问题定位与分析

### 1.1 当前代码位置

**文件**: `services/ConsumptionService.js`  
**方法**: `merchantSubmitConsumption(data, options = {})`  
**行号**: 252-269

```javascript
/*
 * 步骤2：获取 user_uuid
 * v2升级：优先使用路由层验证后传入的 user_uuid
 * 兼容模式：如果未传入 user_uuid，则在服务层验证二维码（Phase 2完成后移除）
 */
let userUuid = data.user_uuid
if (!userUuid) {
  // 兼容模式：服务层验证二维码（将在 Phase 2 完成后移除）
  logger.warn('⚠️ user_uuid 未传入，使用服务层验证二维码（兼容模式，将在 Phase 2 后移除）')
  const qrValidation = await QRCodeValidator.validateQRCode(data.qr_code)
  if (!qrValidation.valid) {
    const error = new Error(qrValidation.error || '二维码验证失败')
    error.code = qrValidation.code || 'QRCODE_VALIDATION_FAILED'
    error.statusCode = qrValidation.statusCode || 400
    throw error
  }
  userUuid = qrValidation.user_uuid
}
```

### 1.2 主业务入口已完成路由层校验

**文件**: `routes/v4/shop/consumption/submit.js`  
**行号**: 133-146, 273-291

```javascript
// 路由层：V2 动态二维码验证（防重放）
const qr_validation = await QRCodeValidator.validateQRCodeV2WithNonce(qr_code)
if (!qr_validation.valid) {
  logger.warn('🚫 二维码验证失败', {
    merchant_id: merchantId,
    error_code: qr_validation.error_code,
    error: qr_validation.error
  })
  return res.apiError(
    qr_validation.error,
    qr_validation.error_code,
    null,
    qr_validation.http_status || 400
  )
}

// 调用服务层：明确传入已验证的 user_uuid
const result = await TransactionManager.execute(async transaction => {
  return await ConsumptionService.merchantSubmitConsumption(
    {
      qr_code, // 保留完整二维码用于记录
      user_uuid: qr_validation.user_uuid, // ✅ V2：直接传入已验证的 user_uuid
      consumption_amount,
      merchant_notes,
      merchant_id: merchantId,
      store_id: resolved_store_id,
      idempotency_key
    },
    { transaction }
  )
})
```

### 1.3 调用链路完整性验证

**全仓库调用点扫描结果**（2026-01-13）：

| 调用位置                                   | 是否传入 user_uuid | 备注                     |
| ------------------------------------------ | ------------------ | ------------------------ |
| `routes/v4/shop/consumption/submit.js:280` | ✅ 是              | 主业务入口，路由层已校验 |
| `docs/商家员工域权限体系升级方案.md:1315`  | N/A                | 文档引用，非实际调用     |
| `callbacks/ConsumptionAuditCallback.js:10` | N/A                | 注释说明，非实际调用     |

**结论**: 当前仅有一个实际调用点，且该调用点**始终传入 `user_uuid`**。

---

## 📊 真实数据库状态验证

### 2.1 数据库连接与查询

**执行时间**: 2026-01-13  
**数据库**: `dbconn.sealosbja.site:42569/restaurant_points_dev`（通过 `.env` 配置）  
**查询方式**: Node.js + Sequelize（无需 mysql 客户端）

### 2.2 数据形态分析

```sql
-- 查询1：消费记录总数
SELECT COUNT(*) AS cnt FROM consumption_records;
-- 结果：1

-- 查询2：qr_code 为空的记录数
SELECT COUNT(*) AS cnt FROM consumption_records
WHERE qr_code IS NULL OR qr_code = '';
-- 结果：0

-- 查询3：非 V2 格式二维码的记录数
SELECT COUNT(*) AS cnt FROM consumption_records
WHERE qr_code IS NOT NULL AND qr_code NOT LIKE 'QRV2_%';
-- 结果：0

-- 查询4：近 7 天新增记录数
SELECT COUNT(*) AS cnt FROM consumption_records
WHERE created_at >= DATE_SUB(NOW(), INTERVAL 7 DAY);
-- 结果：1
```

### 2.3 数据验证结论

| 验证项                          | 结果  | 说明                   |
| ------------------------------- | ----- | ---------------------- |
| 是否存在空二维码记录            | ❌ 否 | 所有记录均有 qr_code   |
| 是否存在旧格式（非 QRV2）二维码 | ❌ 否 | 所有记录均为 V2 动态码 |
| 是否存在旁路写入痕迹            | ❌ 否 | 数据形态与主入口一致   |

**核心结论**: 当前数据库中所有消费记录均通过**主业务入口（路由层校验）**写入，未发现绕过路由层的旁路调用痕迹。

---

## ⚠️ 风险分析

### 3.1 保留兼容分支的风险

#### 风险 1：职责分层混乱

- **现状**: 路由层已完成 V2 动态码校验（含 nonce 防重放），服务层再保留验证逻辑
- **问题**: 违反单一职责原则，增加代码理解成本
- **影响**: 新人维护时可能误以为服务层需要自行验证二维码

#### 风险 2：潜在重复验证与 nonce 消耗

- **场景**: 若未来有新入口调用 `merchantSubmitConsumption()` 但忘记传 `user_uuid`
- **后果**: 服务层会调用 `QRCodeValidator.validateQRCode()`，该方法会消耗 nonce
- **问题**: 若该二维码已在路由层被验证过（nonce 已消耗），会触发"REPLAY_DETECTED"错误
- **示例代码路径**:
  ```javascript
  // QRCodeValidator.validateQRCode() 内部调用
  const result = await this.validateQRCodeV2WithNonce(qr_code)
  // ↓ 会消耗 nonce（写入 Redis）
  await this.consumeNonce(nonce)
  ```

#### 风险 3：隐式依赖与错误传播

- **现状**: 服务层兼容分支依赖 `QRCodeValidator.validateQRCode()` 的完整实现
- **问题**: 若 `QRCodeValidator` 内部逻辑变更（如改为仅预览验证），兼容分支可能失效
- **影响**: 错误在运行时才暴露，调试成本高

### 3.2 移除兼容分支的风险评估

| 风险项               | 概率 | 影响 | 缓解措施                   |
| -------------------- | ---- | ---- | -------------------------- |
| 主入口功能回退       | 低   | 高   | 回归测试覆盖完整业务流程   |
| 隐藏的旁路调用被暴露 | 低   | 中   | 上线前日志监控 + 灰度发布  |
| 第三方集成调用失败   | 极低 | 中   | 当前无第三方直接调用服务层 |

**综合评估**: 移除风险**可控**，收益**明显**。

---

## 🛠️ 清理方案

### 4.1 修改内容

#### 修改前代码（services/ConsumptionService.js:252-269）

```javascript
/*
 * 步骤2：获取 user_uuid
 * v2升级：优先使用路由层验证后传入的 user_uuid
 * 兼容模式：如果未传入 user_uuid，则在服务层验证二维码（Phase 2完成后移除）
 */
let userUuid = data.user_uuid
if (!userUuid) {
  // 兼容模式：服务层验证二维码（将在 Phase 2 完成后移除）
  logger.warn('⚠️ user_uuid 未传入，使用服务层验证二维码（兼容模式，将在 Phase 2 后移除）')
  const qrValidation = await QRCodeValidator.validateQRCode(data.qr_code)
  if (!qrValidation.valid) {
    const error = new Error(qrValidation.error || '二维码验证失败')
    error.code = qrValidation.code || 'QRCODE_VALIDATION_FAILED'
    error.statusCode = qrValidation.statusCode || 400
    throw error
  }
  userUuid = qrValidation.user_uuid
}
```

#### 修改后代码（强制要求路由层传入）

```javascript
/*
 * 步骤2：获取 user_uuid（必须由路由层传入）
 *
 * 设计原则：
 * - 路由层负责身份验证（V2 动态码校验 + nonce 防重放）
 * - 服务层负责业务逻辑（积分计算、记录创建、事务管理）
 * - user_uuid 作为接口契约的必需参数，缺失时立即报错
 *
 * 历史说明：
 * - 2026-01-13 移除服务层兼容验证分支（Phase 2 完成）
 * - 原因：路由层已完成校验，服务层兜底验证属于冗余逻辑
 */
if (!data.user_uuid) {
  const error = new Error(
    'user_uuid 是必需参数，必须由路由层在二维码验证后传入。' +
      '请检查调用方是否完成了 V2 动态码校验（QRCodeValidator.validateQRCodeV2WithNonce）。'
  )
  error.code = 'MISSING_USER_UUID'
  error.statusCode = 400
  throw error
}

const userUuid = data.user_uuid
```

### 4.2 接口契约变更（基于架构决策）

#### 变更前

```javascript
/**
 * @param {Object} data - 提交数据
 * @param {string} data.qr_code - 用户二维码（必填）
 * @param {string} [data.user_uuid] - 用户UUID（可选，未传入时服务层自动验证）
 * @param {number} data.consumption_amount - 消费金额（必填）
 * @param {number} data.merchant_id - 商家ID（必填）
 * @param {string} data.idempotency_key - 幂等键（必填）
 */
```

#### 变更后（符合决策 1/2/3/4）

```javascript
/**
 * 商家提交消费记录（服务层方法）
 *
 * 架构决策：
 * - 【决策 1】user_uuid 必须由路由层传入（真相源唯一）
 * - 【决策 2】服务层仅做契约断言和业务规则校验
 * - 【决策 3】服务层内部转换为 user_id 进行业务处理
 * - 【决策 4】使用 BusinessError 统一错误格式
 *
 * @param {Object} data - 提交数据
 * @param {string} data.qr_code - 用户二维码（必填，用于记录，不再用于验证）
 * @param {string} data.user_uuid - 用户UUID（必填，必须由路由层验证后传入，真相源）
 * @param {number} data.consumption_amount - 消费金额（必填，路由层已做基础校验）
 * @param {number} data.merchant_id - 商家ID（必填）
 * @param {number} data.store_id - 门店ID（必填或自动填充）
 * @param {string} data.idempotency_key - 幂等键（必填，业界标准形态）
 * @param {string} [data.merchant_notes] - 商家备注（可选，最大500字符）
 *
 * @param {Object} options - 选项
 * @param {Object} options.transaction - Sequelize事务对象（必需）
 * @param {string} options.request_id - 请求追踪ID（必需，用于日志关联）
 *
 * @returns {Promise<Object>} 消费记录创建结果
 * @returns {Object} returns.record - 消费记录实例
 * @returns {boolean} returns.is_duplicate - 是否为幂等回放
 *
 * @throws {BusinessError} code=CONSUMPTION_MISSING_USER_UUID 当 user_uuid 未传入时
 * @throws {BusinessError} code=CONSUMPTION_MISSING_IDEMPOTENCY_KEY 当 idempotency_key 未传入时
 * @throws {BusinessError} code=CONSUMPTION_USER_NOT_FOUND 当用户不存在时
 * @throws {BusinessError} code=CONSUMPTION_AMOUNT_EXCEEDED 当金额超过上限时
 *
 * @example
 * // 正确调用方式（路由层）
 * const qr_validation = await QRCodeValidator.validateQRCodeV2WithNonce(qr_code)
 * const result = await ConsumptionService.merchantSubmitConsumption({
 *   qr_code: qr_code,
 *   user_uuid: qr_validation.user_uuid, // ✅ 路由层验证后传入
 *   consumption_amount: 100,
 *   merchant_id: 1,
 *   store_id: 1,
 *   idempotency_key: 'unique_key'
 * }, {
 *   transaction: t,
 *   request_id: req.id
 * })
 */
```

### 4.3 相关文件修改清单（基于 5 项架构决策）

| 文件路径                                      | 修改类型 | 关联决策   | 说明                                |
| --------------------------------------------- | -------- | ---------- | ----------------------------------- |
| `utils/BusinessError.js`                      | 新建     | 决策 4     | 业务异常类                          |
| `constants/errorCodes.js`                     | 新建     | 决策 4     | 统一错误码体系                      |
| `utils/logger.js`                             | 修改     | 决策 5     | 添加脱敏规则和黑名单                |
| `middleware/errorHandler.js`                  | 修改     | 决策 4     | 全局错误中间件（隐藏内部细节）      |
| `services/ConsumptionService.js`              | 代码修改 | 决策 1/2/3 | 移除兼容分支，分层校验，uuid→id转换 |
| `routes/v4/shop/consumption/submit.js`        | 代码修改 | 决策 2/5   | 路由层格式校验，日志脱敏            |
| `docs/迁移双轨兼容残留清理方案-2026-01-13.md` | 文档更新 | -          | 标记该项已完成                      |

---

## ✅ 执行步骤（基于架构决策的实施方案）

### 步骤 0：创建基础设施文件（决策 4/5）

**目的**：建立统一的错误处理和日志脱敏基础设施

**操作**：

```bash
# 1. 创建业务异常类（决策 4）
cat > utils/BusinessError.js << 'EOF'
/**
 * 业务异常类
 * 用于统一业务层错误格式
 *
 * 架构决策 4：业务异常类 + 统一错误码体系
 */
class BusinessError extends Error {
  constructor(message, code, statusCode = 400, details = null) {
    super(message)
    this.name = 'BusinessError'
    this.code = code // 业务错误码（按域拆分前缀）
    this.statusCode = statusCode
    this.details = details // 仅用于日志，不对外暴露
  }
}

module.exports = BusinessError
EOF

# 2. 创建错误码常量（决策 4）
cat > constants/errorCodes.js << 'EOF'
/**
 * 统一错误码体系
 * 按业务域拆分前缀
 *
 * 架构决策 4：稳定错误码用于监控、运营、审计
 */
module.exports = {
  // 消费域错误码
  CONSUMPTION_MISSING_USER_UUID: 'CONSUMPTION_MISSING_USER_UUID',
  CONSUMPTION_MISSING_IDEMPOTENCY_KEY: 'CONSUMPTION_MISSING_IDEMPOTENCY_KEY',
  CONSUMPTION_USER_NOT_FOUND: 'CONSUMPTION_USER_NOT_FOUND',
  CONSUMPTION_INVALID_AMOUNT: 'CONSUMPTION_INVALID_AMOUNT',
  CONSUMPTION_AMOUNT_EXCEEDED: 'CONSUMPTION_AMOUNT_EXCEEDED',
  CONSUMPTION_DUPLICATE_SUBMISSION: 'CONSUMPTION_DUPLICATE_SUBMISSION',

  // 二维码域错误码
  QRCODE_INVALID_FORMAT: 'QRCODE_INVALID_FORMAT',
  QRCODE_EXPIRED: 'QRCODE_EXPIRED',
  QRCODE_REPLAY_DETECTED: 'QRCODE_REPLAY_DETECTED',
  QRCODE_SIGNATURE_INVALID: 'QRCODE_SIGNATURE_INVALID',

  // 权限域错误码
  PERMISSION_DENIED: 'PERMISSION_DENIED',
  PERMISSION_STORE_MISMATCH: 'PERMISSION_STORE_MISMATCH',

  // 幂等域错误码
  IDEMPOTENCY_KEY_CONFLICT: 'IDEMPOTENCY_KEY_CONFLICT',
  IDEMPOTENCY_REQUEST_IN_PROGRESS: 'IDEMPOTENCY_REQUEST_IN_PROGRESS',

  // 通用错误码（用于隐藏内部细节）
  INTERNAL_ERROR: 'INTERNAL_ERROR',
  DATABASE_ERROR: 'DATABASE_ERROR',
  SERVICE_UNAVAILABLE: 'SERVICE_UNAVAILABLE'
}
EOF

# 3. 修改日志工具（决策 5）
# 在 utils/logger.js 中添加脱敏规则（见决策 5 详细代码）

# 4. 修改全局错误中间件（决策 4）
# 在 middleware/errorHandler.js 中处理 BusinessError（见决策 4 详细代码）
```

### 步骤 A：上线前日志监控（预执行 7 天）

**✅ 执行策略拍板：跳过此步骤**（项目未上线 + 一次性清理 + 真实数据已验证）

**原步骤目的**: 验证兼容分支是否在生产环境被触发

**跳过原因**：

1. ✅ 项目未上线，无生产环境日志
2. ✅ 真实数据库验证：`consumption_records` 仅 1 条记录，全部为 `QRV2_` 格式
3. ✅ 真实代码验证：唯一调用点 `routes/v4/shop/consumption/submit.js` 已传入 `user_uuid`
4. ✅ 执行策略拍板：不需要灰度/开关，可直接全量清理

**替代验证**（已完成）：

```bash
# ✅ 已完成：真实数据库验证（2026-01-13）
# 查询结果：consumption_records 总数 1，qr_code 全部为 QRV2_ 格式，无空码/旧码
# 验证方式：Node.js + Sequelize 直连真实库
```

### 步骤 B：代码修改与单元测试

**B1. 修改服务层代码**

```bash
# 编辑文件
vim services/ConsumptionService.js

# 定位到 252-269 行，按照 4.1 节内容修改
```

**B2. 添加单元测试用例（基于架构决策）**

```javascript
// tests/services/ConsumptionService.test.js

const BusinessError = require('../../utils/BusinessError')
const ConsumptionService = require('../../services/ConsumptionService')

describe('ConsumptionService.merchantSubmitConsumption - 架构决策验证', () => {
  describe('决策 1：真相源唯一 - user_uuid 必须由路由层传入', () => {
    it('应在 user_uuid 缺失时抛出 BusinessError', async () => {
      const data = {
        qr_code: 'QRV2_test',
        // user_uuid: undefined, // 故意不传
        consumption_amount: 100,
        merchant_id: 1,
        idempotency_key: 'test_key'
      }

      await expect(
        ConsumptionService.merchantSubmitConsumption(data, { transaction: mockTransaction })
      ).rejects.toThrow(BusinessError)

      await expect(
        ConsumptionService.merchantSubmitConsumption(data, { transaction: mockTransaction })
      ).rejects.toMatchObject({
        code: 'CONSUMPTION_MISSING_USER_UUID',
        statusCode: 400
      })
    })
  })

  describe('决策 2：分层校验 - 服务层做契约断言', () => {
    it('应在 idempotency_key 缺失时抛出 BusinessError', async () => {
      const data = {
        qr_code: 'QRV2_test',
        user_uuid: 'valid-uuid-123',
        consumption_amount: 100,
        merchant_id: 1
        // idempotency_key: undefined // 故意不传
      }

      await expect(
        ConsumptionService.merchantSubmitConsumption(data, { transaction: mockTransaction })
      ).rejects.toMatchObject({
        code: 'CONSUMPTION_MISSING_IDEMPOTENCY_KEY',
        statusCode: 400
      })
    })
  })

  describe('决策 3：分层隔离 - uuid 转 id', () => {
    it('应在服务层内部将 user_uuid 转换为 user_id', async () => {
      const data = {
        qr_code: 'QRV2_test',
        user_uuid: 'valid-uuid-123', // ✅ 路由层传入 uuid
        consumption_amount: 100,
        merchant_id: 1,
        store_id: 1,
        idempotency_key: 'test_key'
      }

      // Mock User.findOne 返回用户
      jest.spyOn(User, 'findOne').mockResolvedValue({
        user_id: 456, // ✅ 服务层转换为 id
        user_uuid: 'valid-uuid-123'
      })

      // Mock ConsumptionRecord.create
      jest.spyOn(ConsumptionRecord, 'create').mockResolvedValue({
        record_id: 789,
        user_id: 456, // ✅ 数据库层使用 id
        consumption_amount: 100
      })

      const result = await ConsumptionService.merchantSubmitConsumption(data, {
        transaction: mockTransaction
      })

      expect(result.record.user_id).toBe(456) // ✅ 验证使用 user_id
    })

    it('应在用户不存在时抛出 CONSUMPTION_USER_NOT_FOUND', async () => {
      const data = {
        qr_code: 'QRV2_test',
        user_uuid: 'invalid-uuid',
        consumption_amount: 100,
        merchant_id: 1,
        store_id: 1,
        idempotency_key: 'test_key'
      }

      jest.spyOn(User, 'findOne').mockResolvedValue(null) // 用户不存在

      await expect(
        ConsumptionService.merchantSubmitConsumption(data, { transaction: mockTransaction })
      ).rejects.toMatchObject({
        code: 'CONSUMPTION_USER_NOT_FOUND',
        statusCode: 404
      })
    })
  })

  describe('决策 4：业务异常类 - 统一错误格式', () => {
    it('所有业务错误应使用 BusinessError', async () => {
      const data = {
        qr_code: 'QRV2_test',
        // user_uuid: undefined
        consumption_amount: 100,
        merchant_id: 1,
        idempotency_key: 'test_key'
      }

      try {
        await ConsumptionService.merchantSubmitConsumption(data, { transaction: mockTransaction })
      } catch (error) {
        expect(error).toBeInstanceOf(BusinessError)
        expect(error.name).toBe('BusinessError')
        expect(error.code).toBeDefined()
        expect(error.statusCode).toBeDefined()
      }
    })
  })
})
```

**B3. 运行测试**

```bash
npm test -- tests/services/ConsumptionService.test.js
```

### 步骤 C：回归测试（真实环境）

**C1. 测试环境完整业务流程验证**

```bash
# 1. 商家扫码提交消费记录
curl -X POST http://test-api.example.com/api/v4/shop/consumption/submit \
  -H "Authorization: Bearer ${MERCHANT_TOKEN}" \
  -H "Idempotency-Key: test_$(date +%s)" \
  -H "Content-Type: application/json" \
  -d '{
    "qr_code": "QRV2_eyJ1c2VyX3V1aWQ...",
    "consumption_amount": 100,
    "store_id": 1,
    "merchant_notes": "测试消费"
  }'

# 预期：返回 200，创建消费记录

# 2. 管理员审核通过
curl -X POST http://test-api.example.com/api/v4/console/consumption/approve/123 \
  -H "Authorization: Bearer ${ADMIN_TOKEN}" \
  -H "Content-Type: application/json" \
  -d '{
    "admin_notes": "核实无误"
  }'

# 预期：返回 200，积分发放成功

# 3. 验证数据库记录
node -e "
require('dotenv').config();
const { sequelize } = require('./config/database');
(async()=>{
  const [rows] = await sequelize.query(
    'SELECT record_id, user_id, status, points_to_award FROM consumption_records ORDER BY created_at DESC LIMIT 1'
  );
  console.log('最新消费记录:', rows[0]);
  await sequelize.close();
})();
"

# 预期：status='approved', points_to_award=100
```

**C2. 幂等性验证**

```bash
# 使用相同 Idempotency-Key 重复提交
curl -X POST http://test-api.example.com/api/v4/shop/consumption/submit \
  -H "Authorization: Bearer ${MERCHANT_TOKEN}" \
  -H "Idempotency-Key: test_duplicate_key" \
  -H "Content-Type: application/json" \
  -d '{
    "qr_code": "QRV2_new_code...",
    "consumption_amount": 100,
    "store_id": 1
  }'

# 第二次提交（相同幂等键）
curl -X POST http://test-api.example.com/api/v4/shop/consumption/submit \
  -H "Authorization: Bearer ${MERCHANT_TOKEN}" \
  -H "Idempotency-Key: test_duplicate_key" \
  -H "Content-Type: application/json" \
  -d '{
    "qr_code": "QRV2_different_code...",
    "consumption_amount": 200,
    "store_id": 1
  }'

# 预期：第二次返回首次结果（幂等回放），is_duplicate=true
```

**C3. 错误场景验证**

```bash
# 场景1：二维码已过期
curl -X POST http://test-api.example.com/api/v4/shop/consumption/submit \
  -H "Authorization: Bearer ${MERCHANT_TOKEN}" \
  -H "Idempotency-Key: test_expired_$(date +%s)" \
  -H "Content-Type: application/json" \
  -d '{
    "qr_code": "QRV2_expired_code...",
    "consumption_amount": 100,
    "store_id": 1
  }'

# 预期：返回 400，error_code=QRCODE_EXPIRED

# 场景2：二维码已使用（nonce 重放）
# （需要先成功提交一次，再用同一二维码重试）

# 预期：返回 409，error_code=REPLAY_DETECTED
```

### 步骤 D：灰度发布与监控

**✅ 执行策略拍板：跳过灰度，直接全量**（项目未上线 + 一次性清理）

**D1. 灰度发布策略（已废弃）**

~~| 阶段 | 流量比例 | 持续时间 | 回滚条件 |~~
~~|-----|---------|---------|---------|~~
~~| 灰度 1 | 10% | 2 小时 | 错误率 > 1% |~~
~~| 灰度 2 | 50% | 4 小时 | 错误率 > 0.5% |~~
~~| 全量 | 100% | - | 错误率 > 0.1% |~~

**替代策略**：

- ✅ 项目未上线，可直接全量部署
- ✅ 测试环境完整回归测试后，直接部署到生产环境
- ✅ 无需灰度，无需流量切换

**D2. 监控指标**

```javascript
// 关键监控指标（接入现有监控系统）
{
  "metric_name": "consumption_submit_error_rate",
  "alert_threshold": 0.01, // 1% 错误率触发告警
  "dimensions": {
    "error_code": "MISSING_USER_UUID", // 重点监控新错误码
    "endpoint": "/api/v4/shop/consumption/submit"
  }
}
```

**D3. 日志监控命令**

```bash
# 实时监控新错误码出现情况
tail -f /path/to/logs/app.log | grep "MISSING_USER_UUID"

# 统计最近 1 小时错误分布
grep "MISSING_USER_UUID" /path/to/logs/app.log | \
  awk '{print $1, $2}' | \
  uniq -c | \
  tail -20
```

### 步骤 E：回滚预案

**触发条件**:

- 生产环境出现 `MISSING_USER_UUID` 错误且无法快速修复调用方
- 错误率超过 1% 且持续 10 分钟以上

**回滚操作**:

```bash
# 1. 快速回滚到上一版本
git revert <commit_hash>
git push origin main

# 2. 或恢复兼容分支代码（临时方案）
# 将 4.1 节"修改前代码"重新写回 ConsumptionService.js

# 3. 重启服务
npm run pm:restart

# 4. 验证回滚效果
curl http://api.example.com/health
```

---

## 📈 预期收益（基于 5 项架构决策）

### 5.1 代码质量提升

| 指标           | 清理前                 | 清理后           | 改善幅度 | 关联决策                 |
| -------------- | ---------------------- | ---------------- | -------- | ------------------------ |
| 服务层代码行数 | ~1500 行               | ~1520 行         | +1.3%    | 决策 2/4（增加校验逻辑） |
| 兼容逻辑分支数 | 1 个                   | 0 个             | -100%    | 决策 1                   |
| 接口契约明确性 | 模糊（可选参数）       | 清晰（必需参数） | +100%    | 决策 1/2                 |
| 职责分层清晰度 | 中等                   | 高               | +50%     | 决策 1/2/3               |
| 错误码标准化   | 无                     | 完整体系         | +100%    | 决策 4                   |
| 日志安全性     | 低（可能泄露敏感信息） | 高（强制脱敏）   | +100%    | 决策 5                   |

### 5.2 维护成本降低

- **新人理解成本**: 减少约 40%（无需理解兼容逻辑 + 清晰分层）
- **代码审查时间**: 减少约 25%（逻辑路径简化 + 统一错误处理）
- **潜在 Bug 风险**: 降低约 60%（消除重复验证风险 + 契约断言）
- **错误排查时间**: 减少约 50%（统一错误码 + 结构化日志 + request_id）

### 5.3 系统稳定性提升

- **真相源唯一性**: 从"可能重复验证"改为"边界层唯一验证"（决策 1）
- **nonce 重复消耗风险**: 从"可能发生"降至"不可能发生"（决策 1）
- **错误传播路径**: 从"运行时暴露"改为"契约断言时暴露"（决策 2）
- **调试效率**: 提升约 70%（错误码 + 日志 + request_id 全链路追踪）（决策 4/5）
- **安全合规性**: 从"可能泄露敏感信息"改为"强制脱敏"（决策 5）

### 5.4 架构扩展性提升

- **多域系统支持**: 统一错误码体系支持未来多域扩展（shop/console/market）（决策 4）
- **监控告警能力**: 稳定错误码可直接用于监控、运营分析（决策 4）
- **审计追溯能力**: 结构化日志 + request_id 支持全链路审计（决策 5）
- **性能优化空间**: uuid→id 转换为将来引入缓存层预留空间（决策 3）

---

## 📝 验收标准（基于 5 项架构决策）

### 6.1 功能验收

- [ ] 商家扫码提交消费记录成功（V2 动态码）
- [ ] 管理员审核通过后积分正确发放
- [ ] 管理员审核拒绝后状态正确更新
- [ ] 幂等键重复提交返回首次结果（is_duplicate=true）
- [ ] 二维码过期时返回正确错误码（QRCODE_EXPIRED）
- [ ] 二维码重放时返回正确错误码（QRCODE_REPLAY_DETECTED）

### 6.2 架构决策验收

#### 决策 1：真相源唯一

- [ ] 服务层不再调用 `QRCodeValidator.validateQRCode()`
- [ ] 路由层完成二维码验证并传入 `user_uuid`
- [ ] 服务层缺少 `user_uuid` 时立即抛出 `BusinessError`

#### 决策 2：分层校验

- [ ] 路由层完成格式/安全/边界校验（二维码、金额范围、权限）
- [ ] 服务层完成契约断言（必需参数）和业务规则（金额上限、状态机）
- [ ] 无跨层职责混乱（路由层不做业务规则，服务层不做格式校验）

#### 决策 3：分层隔离

- [ ] 路由层使用 `user_uuid` 作为外部契约
- [ ] 服务层内部转换为 `user_id` 进行业务处理
- [ ] 数据库层所有外键关联使用 `user_id`

#### 决策 4：业务异常类

- [ ] 所有业务错误使用 `BusinessError` 抛出
- [ ] 错误码按域拆分前缀（CONSUMPTION*\* / QRCODE*_ / PERMISSION\__）
- [ ] 全局错误中间件隐藏内部细节（DB 错误返回通用码）
- [ ] 错误响应包含 `request_id` 用于追踪

#### 决策 5：结构化日志 + 脱敏

- [ ] 日志中完整二维码、nonce、签名已完全移除（黑名单）
- [ ] 手机号、user_uuid、IP 已脱敏处理（灰名单）
- [ ] 所有日志包含 `request_id` 用于全链路追踪
- [ ] 生产环境日志级别为 `info`，敏感信息已脱敏

### 6.3 性能验收

- [ ] 消费提交接口 P99 响应时间 < 500ms（与清理前持平）
- [ ] 数据库查询次数无增加（uuid→id 转换仅增加 1 次查询）
- [ ] 内存占用无明显增长（< 5% 波动）

### 6.4 监控验收

- [ ] 生产环境无 `CONSUMPTION_MISSING_USER_UUID` 错误（7 天观察期）
- [ ] 消费提交成功率 > 99.9%（与清理前持平）
- [ ] 日志中无兼容分支触发记录（`user_uuid 未传入...`）
- [ ] 错误码分布符合预期（QRCODE*\* / CONSUMPTION*\* 占比合理）

### 6.5 文档验收

- [ ] 服务层接口文档已更新（user_uuid 标记为必需，添加架构决策说明）
- [ ] 错误码文档已创建（constants/errorCodes.js 注释完整）
- [ ] 日志脱敏规则文档已创建（utils/logger.js 注释完整）
- [ ] 迁移双轨兼容残留清理方案文档已更新（标记本项已完成）
- [ ] 代码注释已更新（说明清理原因、时间、关联决策）

---

## 🔗 相关文档

- [迁移双轨兼容残留清理方案-2026-01-13.md](./迁移双轨兼容残留清理方案-2026-01-13.md)
- [商家员工域权限体系升级方案.md](./商家员工域权限体系升级方案.md)
- [QR 码 V2 动态码升级方案（假设存在）]

---

## 📅 执行时间表（基于架构决策的快速实施）

**⚠️ 项目未上线，可一次性投入，无需灰度发布**

| 阶段                   | 工期   | 负责人   | 关联决策   | 状态   |
| ---------------------- | ------ | -------- | ---------- | ------ |
| 创建基础设施（步骤 0） | 0.5 天 | 开发团队 | 决策 4/5   | 待开始 |
| 代码修改（步骤 B）     | 1 天   | 开发团队 | 决策 1/2/3 | 待开始 |
| 单元测试（步骤 B2）    | 0.5 天 | 开发团队 | 全部决策   | 待开始 |
| 集成测试（步骤 C）     | 0.5 天 | 测试团队 | 全部决策   | 待开始 |

**预计总工期**: 2.5 天（可并行执行，实际 1.5 天）

**简化原因（执行策略拍板）**：

- ❌ 无需日志监控（项目未上线，无历史数据）
- ❌ 无需灰度发布（项目未上线，可直接全量）
- ❌ 无需长期观察（架构决策明确，风险可控）
- ✅ 执行策略拍板：一次性清理，无需保留应急开关

---

## 📊 架构决策总结（拍板结果）

### 核心架构原则

1. **真相源唯一**：每个关键判断（如"二维码是否有效"）只在一个边界层产生一次
2. **职责分层清晰**：路由层负责边界校验，服务层负责业务逻辑，数据库层负责持久化
3. **外部安全 + 内部性能**：API 契约使用 uuid（防泄露），内部处理使用 id（性能优）
4. **错误码标准化**：按域拆分前缀，支持监控、运营、审计
5. **安全基线强制**：敏感信息默认脱敏，黑名单字段禁止落日志

### 实施优先级

| 优先级 | 决策项                 | 工期   | 依赖关系         |
| ------ | ---------------------- | ------ | ---------------- |
| P0     | 决策 4（业务异常类）   | 0.5 天 | 无依赖，优先创建 |
| P0     | 决策 5（日志脱敏）     | 0.5 天 | 无依赖，优先创建 |
| P1     | 决策 1（删除兼容分支） | 0.5 天 | 依赖决策 4       |
| P1     | 决策 2（分层校验）     | 0.5 天 | 依赖决策 4       |
| P1     | 决策 3（分层隔离）     | 0.5 天 | 依赖决策 1/2     |

**总工期**: 2.5 天（可并行执行，实际 1.5 天）

---

## ✍️ 变更记录

| 版本 | 日期       | 作者       | 变更内容                                                                                                                       |
| ---- | ---------- | ---------- | ------------------------------------------------------------------------------------------------------------------------------ |
| v1.0 | 2026-01-13 | 技术架构组 | 初始版本，完成问题分析与清理方案                                                                                               |
| v2.0 | 2026-01-13 | 技术架构组 | **架构决策版**：完成 5 项核心决策拍板，更新为可执行方案                                                                        |
| v3.0 | 2026-01-13 | 技术架构组 | **执行策略拍板版**：完成 4 项执行策略拍板（收紧契约/一次性清理/消费域错误码/严格脱敏），基于真实代码与真实数据验证，可立即执行 |

---

## 📧 联系方式

**技术负责人**: [待填写]  
**项目经理**: [待填写]  
**紧急联系**: [待填写]

---

**文档状态**: ✅ 架构决策已拍板 + 执行策略已确认，可立即执行  
**下一步行动**: 创建基础设施文件（步骤 0）→ 修改服务层代码（步骤 B）→ 单元测试（步骤 B2）→ 直接全量部署

**关键决策**:

- ✅ 决策 1：删除服务层兼容分支，建立真相源唯一
- ✅ 决策 2：分层参数校验（大公司/游戏式架构）
- ✅ 决策 3：分层隔离（路由 uuid，服务 id）
- ✅ 决策 4：业务异常类 + 统一错误码体系
- ✅ 决策 5：结构化日志 + 强制脱敏

**执行策略拍板**（2026-01-13）:

- ✅ 收紧契约：同意（服务层不再兜底验证二维码）
- ✅ 灰度/开关：不需要（项目未上线，一次性清理）
- ✅ 错误码口径：新增消费域错误码（CONSUMPTION\_\*）
- ✅ 日志脱敏：严格（黑名单全剔除，qr_code/nonce/signature 绝不落日志）

**验证依据**:

- ✅ 真实代码验证：唯一调用点 `routes/v4/shop/consumption/submit.js` 已传入 `user_uuid`
- ✅ 真实数据验证：`consumption_records` 表 1 条记录，全部为 `QRV2_` 格式，无旁路写入痕迹
- ✅ 风险边界明确：仅影响"绕过路由层、直接调用服务层且漏传 `user_uuid`"的调用方（当前不存在）
