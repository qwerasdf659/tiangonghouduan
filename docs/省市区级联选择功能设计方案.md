# 省市区级联选择功能设计方案

**项目**: 餐厅积分抽奖系统 V4.0  
**模块**: 门店管理 - 行政区划级联选择  
**创建日期**: 2026-01-12  
**状态**: 待实施  
**拍板日期**: 2026-01-12

---

## 📋 目录

- [1. 业务背景](#1-业务背景)
- [2. 方案设计](#2-方案设计)
- [3. 数据库设计](#3-数据库设计)
- [4. 后端API设计](#4-后端api设计)
- [5. 数据来源与导入](#5-数据来源与导入)
- [6. 实施计划](#6-实施计划)

---

## 1. 业务背景

### 1.1 现状问题

当前门店（`stores` 表）的区域信息存储方式存在以下问题：

```javascript
// 当前字段设计
{
  region: "海淀区",           // ❌ 自由文本，容易出现脏数据
  store_address: "待填写地址"  // ❌ 完全手填，格式不统一
}

// 实际可能出现的脏数据
region: "海淀区"
region: "海淀"
region: "北京海淀"
region: "北京市海淀区"
region: "Beijing Haidian"
```

**问题**：

1. **数据不一致**：同一区域有多种写法，无法准确统计和筛选
2. **无法索引**：自由文本难以建立有效索引
3. **无法级联**：无法按"省→市→区"层级筛选和统计
4. **容易出错**：手工输入容易拼写错误或格式不统一

### 1.2 业务需求

1. **平台管理员**在创建/编辑门店时，通过**级联下拉框**选择"省→市→区"
2. **区域经理/业务员**按区域筛选门店时，可以按省/市/区三级筛选
3. **数据统计**时，可以按省/市/区维度聚合门店数量、消费记录等
4. **数据质量**：确保区域信息标准化、可索引、可统计

---

## 2. 方案设计

### 2.1 方案选型与决策依据

**最终选型**：**标准字典 + code 存储 + 业务表冗余 name**

**选型对比**：

| 方案          | 适用场景                 | 优势                         | 劣势                           | 本项目是否采用 |
| ------------- | ------------------------ | ---------------------------- | ------------------------------ | -------------- |
| 自由文本      | 小型项目、快速原型       | 开发快、无依赖               | 脏数据、无法统计、难维护       | ❌ 不采用      |
| 第三方API     | 外部集成、临时需求       | 无需维护数据                 | 依赖配额、成本、网络、合规风险 | ❌ 不采用      |
| 标准字典+code | 中大型项目、需要统计分析 | 标准化、可索引、可统计、可控 | 需要维护字典表                 | ✅ **采用**    |

**决策依据**（结合本项目实际情况）：

1. **业务需求明确**：需要按省/市/区筛选门店、统计消费数据、分配区域经理
2. **数据质量优先**：当前 `region` 字段已出现脏数据，必须标准化
3. **技术栈匹配**：Sequelize + MySQL + Node.js 完全支持字典表方案
4. **无历史包袱**：**不兼容旧数据，直接删除旧 `region` 字段**，无需过渡方案
5. **可控性要求**：数据存储在本地数据库，不依赖第三方API配额/网络
6. **扩展性需求**：未来可能需要街道级、地图展示、区域权限隔离

**关键决策（已拍板）**：

| 决策项                 | 决策结果                                   | 说明                                                                            |
| ---------------------- | ------------------------------------------ | ------------------------------------------------------------------------------- |
| **字典数据来源**       | `modood/Administrative-divisions-of-China` | 唯一数据源，GitHub 开源数据集                                                   |
| **数据范围层级**       | level=1/2/3/4（省/市/区县/街道）           | **包含街道/乡镇级别**，支持更细粒度选择                                         |
| **字典更新策略**       | **上线后默认不更新**                       | 仅在行政区划重大调整时手工更新，避免频繁变更                                    |
| **冗余 name 更新规则** | **门店改地址/区域时刷新为最新字典名**      | 修改门店区域时，重新从字典表查询最新 `*_name` 并更新                            |
| **旧门店数据处理**     | **直接清空/删除，不导出**                  | 迁移时直接删除旧数据，不保留任何备份                                            |
| **门店重建数据来源**   | **JSON body 批量导入（已拍板）**           | 提供"门店列表 + 省市区街道 code + 地址"JSON，后端批量导入                       |
| **街道字段是否必填**   | **street_code/street_name 必填**           | 门店必须精确到街道，否则不允许创建/导入                                         |
| **字典表字段保留**     | **保留扩展字段**                           | 保留 `pinyin/short_name/longitude/latitude/status/sort_order`（数据源缺就置空） |
| **批量导入重复处理**   | **重复 store_code 直接报错**               | 严格禁止重复，要求业务方先去重                                                  |

### 2.1.1 关键决策拍板记录（2026-01-12）

以下 8 项决策已于 2026-01-12 正式拍板，作为后续开发/验收/文档更新的权威依据：

| #   | 决策项                   | 拍板结论                                                        | 说明                                                                                                    |
| --- | ------------------------ | --------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------- |
| 1   | **行政区划 code 标准**   | **采用 GB/T 2260 六位体系（6/6/6/9）**                          | 省=6位、市=6位、区=6位、街道=9位；需重导数据以对齐此标准                                                |
| 2   | **省级是否包含港澳台**   | **补进并允许选择（共 34 个省级单位）**                          | 字典更完整，支持未来跨境门店/业务数据                                                                   |
| 3   | **street_code 是否必填** | **必填（stores 表 NOT NULL）**                                  | 数据质量最高；区域权限、风控、门店员工审计粒度更精准；删除文档中所有"可选"描述                          |
| 4   | **API 契约形态**         | **以当前实现为准（路径参数 `/children/:parent_code`）**         | 文档示例更新为路径参数；`GET /regions/:code` 暂不实现（非必须）                                         |
| 5   | **批量导入门店方式**     | **JSON body 导入（非 CSV/multipart）**                          | 接口为 `POST /stores/batch-import`，body 为 `{ stores: [...] }`；如需 CSV 可后续规划前端转换层          |
| 6   | **搜索能力**             | **仅支持名称搜索，降级拼音搜索**                                | 当前数据 pinyin 覆盖率极低（市/区/街道几乎全 NULL）；后续可作为优化项补齐                               |
| 7   | **迁移破坏性范围**       | **认可为允许代价（清空 `stores` + `merchant_operation_logs`）** | 旧门店数据与关联审计日志直接删除不导出；新数据通过批量导入重建                                          |
| 8   | **权限范围**             | **实现数据权限（按组织/区域/门店隔离）**                        | admin 完全访问；区域经理/业务员按 province/city/district/store 范围过滤；需配合 RBAC + 数据范围模型实现 |

**核心设计原则**：

- ✅ **code 为主键**：`province_code`/`city_code`/`district_code`/`street_code` 作为关联字段
- ✅ **冗余 name**：`province_name`/`city_name`/`district_name`/`street_name` 冗余存储
- ✅ **name 更新策略**：门店**修改区域时**重新从字典表查询最新 `*_name` 并更新（非严格快照）
- ✅ **字典表独立**：`administrative_regions` 表作为标准字典，**上线后默认不更新**
- ✅ **强制约束**：所有区划字段（含 `street_code`/`street_name`）全部 `NOT NULL`，**门店必须精确到街道**
- ✅ **字典表字段**：保留 `pinyin/short_name/longitude/latitude/status/sort_order`（数据源缺就置空）
- ❌ **不兼容旧数据**：直接 `DROP COLUMN region`，旧数据**直接删除不导出**
- ❌ **批量导入重复**：同 `store_code` **直接报错**，严格禁止重复，要求业务方先去重

### 2.2 核心思路

**存储方式**：使用**行政区划代码（region_code）**而非文本

```javascript
// ✅ 本项目采用方案：code + name 冗余存储（支持到街道级，已拍板：街道必填）
{
  // 主键字段（用于关联查询、统计分析，全部必填）
  province_code: "110000",      // 北京市（主键，建立索引，必填）
  city_code: "110100",          // 北京市（主键，建立索引，必填）
  district_code: "110108",      // 海淀区（主键，建立索引，必填）
  street_code: "110108001",     // 万寿路街道（主键，建立索引，必填）

  // 冗余字段（便于展示，修改区域时刷新为最新字典名，全部必填）
  province_name: "北京市",      // 冗余存储，创建/修改时从字典表查询写入（必填）
  city_name: "北京市",          // 冗余存储，创建/修改时从字典表查询写入（必填）
  district_name: "海淀区",      // 冗余存储，创建/修改时从字典表查询写入（必填）
  street_name: "万寿路街道",    // 冗余存储，创建/修改时从字典表查询写入（必填）

  // 详细地址
  store_address: "复兴路10号"   // 门牌号+楼栋号
}
```

**优势**：

- ✅ **标准化**：使用国家标准 GB/T 2260 行政区划代码
- ✅ **可索引**：`district_code`/`street_code` 可建立高效索引，支持快速筛选
- ✅ **可统计**：按 code 前缀聚合（`110000` = 北京全市，`110108` = 海淀区，`110108001` = 万寿路街道）
- ✅ **细粒度支持**：支持到街道/乡镇级别（level=4），满足精细化管理需求
- ✅ **name 自动同步**：门店修改区域时，自动从字典表查询最新 `*_name` 并更新
- ✅ **无历史包袱**：直接删除旧 `region` 字段，旧数据直接清空不导出

**为什么冗余 name 字段？**

```javascript
// 场景1：日常展示（无需 JOIN 字典表）
stores: {
  store_id: 1,
  district_code: "110108",
  district_name: "海淀区",  // ✅ 直接展示，无需关联查询
  street_code: "110108001",
  street_name: "万寿路街道"
}

// 场景2：门店修改区域时，自动刷新最新名称
// 假设字典表更新了"朝阳区" → "朝阳新区"
// 用户修改门店区域时：
await StoreService.updateStore(storeId, {
  district_code: "110105",  // 用户选择新区域
  // ✅ 后端自动从字典表查询最新名称并更新
  district_name: "朝阳新区"  // 自动填充最新名称
})

// 场景3：字典表默认不更新，name 保持稳定
// 上线后字典表默认不更新，除非行政区划重大调整
// 因此 *_name 字段在大部分情况下保持稳定
```

### 2.3 技术架构

```
┌─────────────────────────────────────────────────────────────┐
│                        前端（Web管理后台）                      │
│  ┌──────────────────────────────────────────────────────┐   │
│  │  省份下拉框 → 选择"广东省" → 触发加载市列表            │   │
│  │  市级下拉框 → 选择"广州市" → 触发加载区县列表          │   │
│  │  区县下拉框 → 选择"天河区" → 最终提交 code             │   │
│  └──────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────┘
                              ↓ HTTP API
┌─────────────────────────────────────────────────────────────┐
│                        后端（Node.js）                         │
│  ┌──────────────────────────────────────────────────────┐   │
│  │  GET /api/v4/console/regions/provinces               │   │
│  │  GET /api/v4/console/regions/children/:parent_code   │   │
│  │  POST /api/v4/console/stores（校验 code 有效性）      │   │
│  └──────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────┘
                              ↓ 查询
┌─────────────────────────────────────────────────────────────┐
│                    数据库（MySQL）                             │
│  ┌──────────────────────────────────────────────────────┐   │
│  │  administrative_regions 表（行政区划字典）            │   │
│  │  - region_code (主键): "110108"                      │   │
│  │  - parent_code: "110100"                             │   │
│  │  - region_name: "海淀区"                             │   │
│  │  - level: 3 (1=省, 2=市, 3=区县)                     │   │
│  └──────────────────────────────────────────────────────┘   │
│  ┌──────────────────────────────────────────────────────┐   │
│  │  stores 表（门店信息）                                 │   │
│  │  - province_code: "110000"                           │   │
│  │  - city_code: "110100"                               │   │
│  │  - district_code: "110108"                           │   │
│  │  - store_address: "中关村大街1号"                     │   │
│  └──────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────┘
```

---

## 3. 数据库设计

### 3.1 新增表：`administrative_regions`（行政区划字典表）

```sql
CREATE TABLE `administrative_regions` (
  `region_code` VARCHAR(12) NOT NULL COMMENT '行政区划代码（GB/T 2260标准，如110108）',
  `parent_code` VARCHAR(12) DEFAULT NULL COMMENT '父级区划代码（省的parent_code为NULL）',
  `region_name` VARCHAR(100) NOT NULL COMMENT '区划名称（如"海淀区"）',
  `level` TINYINT NOT NULL COMMENT '层级（1=省级, 2=市级, 3=区县级, 4=街道/乡镇）',
  `short_name` VARCHAR(50) DEFAULT NULL COMMENT '简称（如"京"）',
  `pinyin` VARCHAR(100) DEFAULT NULL COMMENT '拼音（如"haidian"，用于搜索）',
  `longitude` DECIMAL(10, 7) DEFAULT NULL COMMENT '经度（可选，用于地图展示）',
  `latitude` DECIMAL(10, 7) DEFAULT NULL COMMENT '纬度（可选）',
  `status` ENUM('active', 'merged', 'abolished') DEFAULT 'active' COMMENT '状态（active=有效, merged=已合并, abolished=已撤销）',
  `sort_order` INT DEFAULT 0 COMMENT '排序权重（用于前端展示排序）',
  `created_at` DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `updated_at` DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',

  PRIMARY KEY (`region_code`),
  KEY `idx_parent_code` (`parent_code`),
  KEY `idx_level_status` (`level`, `status`),
  KEY `idx_region_name` (`region_name`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='行政区划字典表（省市区县数据）';
```

**字段说明**：

- `region_code`：**主键**，国标 6 位代码（省市区）或 9 位（街道），如 `110108`（海淀区）、`110108001`（万寿路街道）
- `parent_code`：父级代码，用于级联查询（省的 `parent_code` 为 `NULL`）
- `level`：层级标识（**1=省, 2=市, 3=区县, 4=街道/乡镇**）
- `status`：支持行政区划调整（合并/撤销）

**数据范围**（已拍板）：

- **level=1**：省/直辖市/自治区/特别行政区（**34 个，含港澳台**）
- **level=2**：市级（约 333 条）
- **level=3**：区县级（约 2851 条）
- **level=4**：街道/乡镇（约 41636 条）
- **总计**：约 44854 条

> ⚠️ **已拍板**：省级包含港澳台（共 34 个），字典更完整，支持未来跨境门店/业务数据

**数据示例**：

```sql
-- 省级（level=1）
('110000', NULL, '北京市', 1, '京', 'beijing', NULL, NULL, 'active', 1)
('440000', NULL, '广东省', 1, '粤', 'guangdong', NULL, NULL, 'active', 19)

-- 市级（level=2）
('110100', '110000', '北京市', 2, NULL, 'beijing', NULL, NULL, 'active', 1)
('440100', '440000', '广州市', 2, NULL, 'guangzhou', NULL, NULL, 'active', 1)
('440300', '440000', '深圳市', 2, NULL, 'shenzhen', NULL, NULL, 'active', 2)

-- 区县级（level=3）
('110108', '110100', '海淀区', 3, NULL, 'haidian', 116.298056, 39.959912, 'active', 8)
('440106', '440100', '天河区', 3, NULL, 'tianhe', 113.361328, 23.124943, 'active', 6)

-- 街道级（level=4，已拍板：必需导入）
('110108001', '110108', '万寿路街道', 4, NULL, 'wanshoulu', 116.298056, 39.959912, 'active', 1)
('110108002', '110108', '永定路街道', 4, NULL, 'yongdinglu', 116.298056, 39.959912, 'active', 2)
('440106001', '440106', '沙河街道', 4, NULL, 'shahe', 113.361328, 23.124943, 'active', 1)
```

### 3.2 修改表：`stores`（门店表）

**迁移策略**：**不兼容旧数据，直接删除 `region` 字段**（已拍板）

**数据处理**（已拍板）：

1. ❌ **旧数据直接删除，不导出**：执行迁移时直接清空现有门店数据，不保留任何备份
2. ✅ **所有字段强制必填**：`province_code/name`、`city_code/name`、`district_code/name`、**`street_code/name`** 全部设为 `NOT NULL`
3. ✅ **街道字段必填**：门店必须精确到街道，否则不允许创建/导入
4. ✅ **索引优化**：为 `province_code`、`city_code`、`district_code`、`street_code` 建立索引
5. ✅ **批量导入准备**：迁移后通过 **JSON body** 批量导入新门店数据（已拍板）
6. ✅ **批量导入重复处理**：同 `store_code` 直接报错，严格禁止重复，要求业务方先去重

**迁移SQL**：

```sql
-- 步骤0：清空关联表数据（已拍板：认可为允许代价）
-- ⚠️ 会清空 merchant_operation_logs 表（审计日志直接删除不导出）
SET FOREIGN_KEY_CHECKS = 0;
TRUNCATE TABLE `merchant_operation_logs`;
SET FOREIGN_KEY_CHECKS = 1;

-- 步骤1：清空旧门店数据（已拍板：直接删除不导出）
TRUNCATE TABLE `stores`;

-- 步骤2：删除旧字段（不兼容旧数据）
ALTER TABLE `stores`
DROP COLUMN `region`;

-- 步骤3：新增标准化字段（已拍板：全部必填，含街道级）
ALTER TABLE `stores`
ADD COLUMN `province_code` VARCHAR(12) NOT NULL COMMENT '省级行政区划代码（必填，用于关联查询）',
ADD COLUMN `province_name` VARCHAR(100) NOT NULL COMMENT '省级名称（冗余字段，必填，修改区域时刷新）',
ADD COLUMN `city_code` VARCHAR(12) NOT NULL COMMENT '市级行政区划代码（必填，用于关联查询）',
ADD COLUMN `city_name` VARCHAR(100) NOT NULL COMMENT '市级名称（冗余字段，必填，修改区域时刷新）',
ADD COLUMN `district_code` VARCHAR(12) NOT NULL COMMENT '区县级行政区划代码（必填，用于关联查询）',
ADD COLUMN `district_name` VARCHAR(100) NOT NULL COMMENT '区县级名称（冗余字段，必填，修改区域时刷新）',
ADD COLUMN `street_code` VARCHAR(12) NOT NULL COMMENT '街道级行政区划代码（必填，门店必须精确到街道）',
ADD COLUMN `street_name` VARCHAR(100) NOT NULL COMMENT '街道级名称（冗余字段，必填，修改区域时刷新）';

-- 步骤4：建立索引（提升查询性能）
ALTER TABLE `stores`
ADD KEY `idx_province_code` (`province_code`),
ADD KEY `idx_city_code` (`city_code`),
ADD KEY `idx_district_code` (`district_code`),
ADD KEY `idx_street_code` (`street_code`);
```

**⚠️ 重要提示**（已拍板）：

- 执行迁移后，`stores` 和 `merchant_operation_logs` 数据将**永久删除且不可恢复**
- **不保留任何备份**，旧数据直接清空（已拍板：认可为允许代价）
- 迁移后通过 **JSON body 批量导入**新门店数据（需提供"门店列表 + 省市区街道 code + 地址"）
- 建议在测试环境先验证迁移流程
- 需**重导行政区划数据**以对齐 GB/T 2260 六位标准（当前库为 2/4/6/9 位）

**最终 stores 表结构（关键字段）**：

```javascript
{
  store_id: 1,
  store_name: "测试餐厅总店",
  store_code: "ST20260112001",

  // ✅ 标准化行政区划（已拍板：全部必填含街道，code + name 冗余存储）
  province_code: "110000",      // 主键字段，用于关联查询、统计分析（必填）
  province_name: "北京市",      // 冗余字段，创建/修改时从字典表查询写入（必填）
  city_code: "110100",          // 主键字段，用于关联查询、统计分析（必填）
  city_name: "北京市",          // 冗余字段，创建/修改时从字典表查询写入（必填）
  district_code: "110108",      // 主键字段，用于关联查询、统计分析（必填）
  district_name: "海淀区",      // 冗余字段，创建/修改时从字典表查询写入（必填）
  street_code: "110108001",     // 主键字段，用于关联查询、统计分析（必填，门店必须精确到街道）
  street_name: "万寿路街道",    // 冗余字段，创建/修改时从字典表查询写入（必填）

  // 详细地址（门牌号+楼栋号）
  store_address: "复兴路10号",

  // 联系信息
  contact_name: "张三",
  contact_mobile: "13800138000",

  // 其他字段...
  created_at: "2026-01-12T10:00:00.000+08:00",
  updated_at: "2026-01-12T10:00:00.000+08:00"
}
```

**字段设计说明**（已拍板）：

| 字段类型     | 字段名          | 用途                     | 更新策略                    | 是否受字典变更影响                          |
| ------------ | --------------- | ------------------------ | --------------------------- | ------------------------------------------- |
| **code字段** | `province_code` | 关联查询、统计分析、索引 | 仅在修改门店区域时更新      | ❌ 不受影响（code稳定）                     |
| **name字段** | `province_name` | 展示、冗余存储           | 创建/修改时从字典表查询写入 | ✅ **修改区域时刷新为最新字典名**           |
| **code字段** | `city_code`     | 关联查询、统计分析、索引 | 仅在修改门店区域时更新      | ❌ 不受影响（code稳定）                     |
| **name字段** | `city_name`     | 展示、冗余存储           | 创建/修改时从字典表查询写入 | ✅ **修改区域时刷新为最新字典名**           |
| **code字段** | `district_code` | 关联查询、统计分析、索引 | 仅在修改门店区域时更新      | ❌ 不受影响（code稳定）                     |
| **name字段** | `district_name` | 展示、冗余存储           | 创建/修改时从字典表查询写入 | ✅ **修改区域时刷新为最新字典名**           |
| **code字段** | `street_code`   | 关联查询、统计分析、索引 | 仅在修改门店区域时更新      | ❌ 不受影响（code稳定），**必填**           |
| **name字段** | `street_name`   | 展示、冗余存储           | 创建/修改时从字典表查询写入 | ✅ **修改区域时刷新为最新字典名**，**必填** |

**更新策略说明**：

- **字典表默认不更新**：上线后字典表默认不更新，仅在行政区划重大调整时手工更新
- **name 字段自动同步**：门店修改区域时（修改 `*_code`），后端自动从字典表查询最新 `*_name` 并更新
- **非严格快照**：`*_name` 字段会随门店区域修改而更新，不是严格的历史快照

---

## 4. 后端API设计

### 4.1 API清单

| 接口路径                                        | 方法 | 权限  | 说明                                   |
| ----------------------------------------------- | ---- | ----- | -------------------------------------- |
| `/api/v4/console/regions/provinces`             | GET  | admin | 获取省级列表                           |
| `/api/v4/console/regions/children/:parent_code` | GET  | admin | 获取子级区划（市/区县/街道），路径参数 |
| `/api/v4/console/regions/search`                | GET  | admin | 按名称搜索区划（仅名称，不支持拼音）   |
| `/api/v4/console/regions/path/:region_code`     | GET  | admin | 获取区划完整路径                       |
| `/api/v4/console/regions/stats`                 | GET  | admin | 获取区划统计信息                       |
| `/api/v4/console/regions/validate`              | POST | admin | 校验区划代码有效性                     |
| `/api/v4/console/stores`                        | POST | admin | 创建门店（校验 code + 自动填充 name）  |
| `/api/v4/console/stores/:id`                    | PUT  | admin | 更新门店（校验 code + 自动填充 name）  |
| `/api/v4/console/stores/batch-import`           | POST | admin | 批量导入门店（**JSON body，已拍板**）  |

### 4.2 API详细设计

#### 4.2.1 获取省级列表

**请求**：

```http
GET /api/v4/console/regions/provinces
Authorization: Bearer {token}
```

**响应**：

```json
{
  "success": true,
  "code": "SUCCESS",
  "message": "获取省级列表成功",
  "data": {
    "provinces": [
      {
        "region_code": "110000",
        "region_name": "北京市",
        "short_name": "京",
        "pinyin": "beijing"
      },
      {
        "region_code": "440000",
        "region_name": "广东省",
        "short_name": "粤",
        "pinyin": "guangdong"
      }
      // ... 其他省份
    ],
    "total": 34 // 含港澳台（已拍板）
  },
  "timestamp": "2026-01-12T10:00:00.000+08:00",
  "version": "v4.0"
}
```

#### 4.2.2 获取子级区划

**请求**：

```http
GET /api/v4/console/regions/children/440000
Authorization: Bearer {token}
```

**路径参数**：

- `:parent_code`（必填）：父级区划代码
  - 传省代码 → 返回市列表
  - 传市代码 → 返回区县列表
  - 传区县代码 → 返回街道列表（level=4）

> ⚠️ **注意**：此接口使用**路径参数**（`/children/:parent_code`），非查询参数

**响应**：

```json
{
  "success": true,
  "code": "SUCCESS",
  "message": "获取子级区划成功",
  "data": {
    "parent": {
      "region_code": "440000",
      "region_name": "广东省",
      "level": 1
    },
    "children": [
      {
        "region_code": "440100",
        "region_name": "广州市",
        "level": 2,
        "pinyin": "guangzhou"
      },
      {
        "region_code": "440300",
        "region_name": "深圳市",
        "level": 2,
        "pinyin": "shenzhen"
      }
      // ... 其他市
    ],
    "total": 21
  },
  "timestamp": "2026-01-12T10:00:00.000+08:00",
  "version": "v4.0"
}
```

#### 4.2.3 按名称搜索区划

**请求**：

```http
GET /api/v4/console/regions/search?keyword=海淀&level=3
Authorization: Bearer {token}
```

**参数**：

- `keyword`（必填）：搜索关键词（**仅支持名称搜索，不支持拼音**）
- `level`（可选）：限制层级（1=省, 2=市, 3=区县, 4=街道）

> ⚠️ **已拍板**：拼音搜索已降级，当前数据 pinyin 覆盖率极低，后续可作为优化项补齐

**响应**：

```json
{
  "success": true,
  "code": "SUCCESS",
  "message": "搜索成功",
  "data": {
    "results": [
      {
        "region_code": "110108",
        "region_name": "海淀区",
        "level": 3,
        "full_path": "北京市 > 北京市 > 海淀区",
        "parent_code": "110100"
      }
    ],
    "total": 1
  },
  "timestamp": "2026-01-12T10:00:00.000+08:00",
  "version": "v4.0"
}
```

#### 4.2.4 创建/更新门店（带区划校验）

**请求**：

```http
POST /api/v4/console/stores
Authorization: Bearer {token}
Content-Type: application/json

{
  "store_name": "测试门店",
  "store_code": "ST20260112002",
  "province_code": "440000",
  "city_code": "440100",
  "district_code": "440106",
  "street_code": "440106001",  // ⚠️ 必填，街道代码（已拍板）
  "store_address": "天河路123号",
  "contact_name": "李四",
  "contact_mobile": "13900139000"
}
```

**后端校验逻辑**（已拍板）：

1. 校验 `province_code` 是否存在且 `level=1`
2. 校验 `city_code` 是否存在且 `parent_code=province_code`
3. 校验 `district_code` 是否存在且 `parent_code=city_code`
4. 校验 `street_code`（如果提供）是否存在且 `parent_code=district_code`
5. **自动填充 `*_name` 字段**（从 `administrative_regions` 表查询最新名称并写入）
6. **不再生成 `region` 字段**（已删除，不兼容旧数据）

**响应**（成功）：

```json
{
  "success": true,
  "code": "SUCCESS",
  "message": "门店创建成功",
  "data": {
    "store_id": 3,
    "store_name": "测试门店",
    "province_code": "440000",
    "province_name": "广东省", // ✅ 后端自动填充（从字典表查询最新名称）
    "city_code": "440100",
    "city_name": "广州市", // ✅ 后端自动填充（从字典表查询最新名称）
    "district_code": "440106",
    "district_name": "天河区", // ✅ 后端自动填充（从字典表查询最新名称）
    "street_code": "440106001",
    "street_name": "沙河街道", // ✅ 后端自动填充（从字典表查询最新名称）
    "store_address": "天河路123号",
    "created_at": "2026-01-12T10:00:00.000+08:00",
    "updated_at": "2026-01-12T10:00:00.000+08:00"
    // ... 其他字段
  },
  "timestamp": "2026-01-12T10:00:00.000+08:00",
  "version": "v4.0"
}
```

**响应**（失败 - 区划代码不匹配）：

```json
{
  "success": false,
  "code": "INVALID_REGION_CODE",
  "message": "区划代码层级不匹配",
  "data": {
    "errors": [
      "city_code (440100) 的 parent_code 应为 440000，实际为 440000（匹配）",
      "district_code (440106) 的 parent_code 应为 440100，实际为 440100（匹配）"
    ]
  },
  "httpStatus": 400
}
```

#### 4.2.5 批量导入门店（JSON body）

**请求**（已拍板：迁移后通过此接口导入新门店数据）：

```http
POST /api/v4/console/stores/batch-import
Authorization: Bearer {token}
Content-Type: application/json
```

> ⚠️ **已拍板**：采用 **JSON body** 导入方式（非 CSV/multipart）。如需 CSV 可后续规划前端转换层。

**⚠️ 重要约束**（已拍板）：

- `street_code` 字段**必填**，门店必须精确到街道，否则导入失败
- `store_code` 重复时**直接报错**，严格禁止重复，要求业务方先去重
- 单次批量导入最多支持 **100 条**记录

**JSON body 格式**（已拍板：street_code 必填，store_code 重复报错）：

```json
{
  "stores": [
    {
      "store_name": "测试餐厅总店",
      "store_code": "ST20260112001",
      "province_code": "110000",
      "city_code": "110100",
      "district_code": "110108",
      "street_code": "110108001", // 必填，门店必须精确到街道
      "store_address": "复兴路10号",
      "contact_name": "张三",
      "contact_mobile": "13800138000"
    },
    {
      "store_name": "测试餐厅分店",
      "store_code": "ST20260112002",
      "province_code": "440000",
      "city_code": "440100",
      "district_code": "440106",
      "street_code": "440106001", // 必填，门店必须精确到街道
      "store_address": "天河路123号",
      "contact_name": "李四",
      "contact_mobile": "13900139000"
    }
  ]
}
```

**后端处理逻辑**（已拍板）：

1. 解析 JSON body 中的 `stores` 数组
2. 逐行校验区划代码（调用 `RegionService.validateStoreCodes()`）
3. **强制校验 `street_code` 必填**，缺失则报错
4. **强制校验 `store_code` 唯一性**，重复则直接报错（不允许导入）
5. 自动填充 `*_name` 字段（从字典表查询最新名称）
6. **每条记录独立事务**插入数据库
7. 返回导入结果（成功数量、失败数量、错误详情）

**响应**（成功）：

```json
{
  "success": true,
  "code": "SUCCESS",
  "message": "批量导入完成",
  "data": {
    "total": 100,
    "success": 98,
    "failed": 2,
    "errors": [
      {
        "row": 15,
        "store_code": "ST20260112015",
        "error": "district_code (999999) 不存在"
      },
      {
        "row": 32,
        "store_code": "ST20260112032",
        "error": "street_code (110108999) 的 parent_code 不匹配"
      },
      {
        "row": 45,
        "store_code": "ST20260112045",
        "error": "street_code 缺失，门店必须精确到街道"
      },
      {
        "row": 58,
        "store_code": "ST20260112001",
        "error": "store_code 重复，已存在相同编码的门店"
      }
    ]
  },
  "timestamp": "2026-01-12T10:00:00.000+08:00",
  "version": "v4.0"
}
```

---

## 5. 前端实现要求（交给前端开发人员）

**核心要求**（已拍板）：

1. 使用级联下拉框组件（省→市→区→街道**四级联动**）
2. 调用后端提供的区划查询API（见第4节）
3. 表单提交时**必须**包含：`province_code`、`city_code`、`district_code`、**`street_code`（必填）**
4. 前端不需要关心 `*_name` 字段，由后端自动填充（从字典表查询最新名称）
5. 搜索功能**仅支持名称搜索**，不支持拼音（已拍板降级）

**API接口**：

- 获取省级列表：`GET /api/v4/console/regions/provinces`
- 获取子级区划：`GET /api/v4/console/regions/children/:parent_code`（**路径参数**，支持到街道级）
- 搜索区划：`GET /api/v4/console/regions/search?keyword={keyword}&level={level}`（仅名称搜索）

**提交数据格式**：

```json
{
  "store_name": "测试门店",
  "province_code": "440000",
  "city_code": "440100",
  "district_code": "440106",
  "street_code": "440106001", // ⚠️ 必填（已拍板）
  "store_address": "天河路123号"
}
```

---

## 6. 数据来源与导入

### 6.1 数据来源（已拍板）

**使用开源数据集**：

- **GitHub 仓库**：[modood/Administrative-divisions-of-China](https://github.com/modood/Administrative-divisions-of-China)（**唯一数据源**）
- **数据格式**：JSON
- **Code 标准**：**GB/T 2260 六位体系（6/6/6/9）**（已拍板）
  - 省级：6位（如 `110000` = 北京市）
  - 市级：6位（如 `110100` = 北京市）
  - 区县级：6位（如 `110108` = 海淀区）
  - 街道级：9位（如 `110108001` = 万寿路街道）
- **数据量**：
  - level=1（省级）：**34 个（含港澳台，已拍板）**
  - level=2（市级）：约 333 个
  - level=3（区县级）：约 2851 个
  - level=4（街道级）：约 41636 个
  - **总计**：约 44854 条

> ⚠️ **重要**：当前数据库实际数据为 2/4/6/9 位体系，需**重导数据**以对齐 GB/T 2260 六位标准（已拍板）

### 6.2 数据导入脚本（Node.js）

**步骤1：下载数据**（已拍板：包含街道级数据）

```bash
# 下载开源数据集（包含 level=1/2/3/4）
curl -o data/regions.json https://raw.githubusercontent.com/modood/Administrative-divisions-of-China/master/dist/data.json

# 数据说明：
# - 包含省/市/区县/街道四级数据
# - 总计约 44854 条记录
# - 数据来源：modood/Administrative-divisions-of-China（唯一数据源）
```

**步骤2：编写导入脚本**

```javascript
// scripts/database/import_regions.js
/**
 * 行政区划数据导入脚本
 *
 * 数据来源：https://github.com/modood/Administrative-divisions-of-China
 * 执行方式：node scripts/database/import_regions.js
 */

require('dotenv').config()
const fs = require('fs')
const path = require('path')
const { sequelize, AdministrativeRegion } = require('../../models')
const logger = require('../../utils/logger').logger

async function importRegions() {
  try {
    logger.info('开始导入行政区划数据...')

    // 1. 读取 JSON 数据文件
    const dataPath = path.join(__dirname, '../../data/regions.json')
    const rawData = fs.readFileSync(dataPath, 'utf8')
    const regionsData = JSON.parse(rawData)

    logger.info(`读取到 ${regionsData.length} 条区划数据`)

    // 2. 开启事务
    const transaction = await sequelize.transaction()

    try {
      // 3. 清空旧数据（可选）
      await AdministrativeRegion.destroy({ where: {}, transaction })
      logger.info('已清空旧数据')

      // 4. 批量插入
      let insertCount = 0
      const batchSize = 500

      for (let i = 0; i < regionsData.length; i += batchSize) {
        const batch = regionsData.slice(i, i + batchSize)
        await AdministrativeRegion.bulkCreate(batch, { transaction })
        insertCount += batch.length
        logger.info(`已导入 ${insertCount}/${regionsData.length} 条`)
      }

      // 5. 提交事务
      await transaction.commit()
      logger.info(`✅ 行政区划数据导入成功，共 ${insertCount} 条`)

      // 6. 验证数据
      const counts = await AdministrativeRegion.count({
        group: ['level']
      })
      logger.info('数据统计:', counts)
    } catch (error) {
      await transaction.rollback()
      throw error
    }
  } catch (error) {
    logger.error('❌ 导入失败:', error)
    process.exit(1)
  } finally {
    await sequelize.close()
  }
}

if (require.main === module) {
  importRegions()
}

module.exports = { importRegions }
```

**步骤3：执行导入**

```bash
# 执行导入脚本
node scripts/database/import_regions.js

# 预期输出（已拍板：包含街道级数据）
# 开始导入行政区划数据...
# 读取到 44854 条区划数据
# 已清空旧数据
# 已导入 500/44854 条
# 已导入 1000/44854 条
# ...
# ✅ 行政区划数据导入成功，共 44854 条
# 数据统计: [
#   { level: 1, count: 34 },     // 省级
#   { level: 2, count: 333 },    // 市级
#   { level: 3, count: 2851 },   // 区县级
#   { level: 4, count: 41636 }   // 街道级
# ]
```

---

## 7. 实施计划

### 7.1 后端开发任务

> ⚠️ **注意**：当前数据库已有数据（2/4/6/9 位），需执行**数据重导**以对齐 GB/T 2260 六位标准（6/6/6/9）

| 任务ID      | 任务描述                                             | 工作量 | 依赖           | 备注                                                          |
| ----------- | ---------------------------------------------------- | ------ | -------------- | ------------------------------------------------------------- |
| **后端-0**  | **重导行政区划数据（对齐 6/6/6/9 标准）**            | 2h     | -              | **已拍板：采用 GB/T 2260 六位体系，需重新下载/转换/导入数据** |
| **后端-1**  | 创建 `administrative_regions` 表迁移                 | 0.5h   | 后端-0         | 字典表结构定义（支持 level=1/2/3/4）                          |
| **后端-2**  | 创建 `AdministrativeRegion` 模型                     | 0.5h   | 后端-1         | Sequelize 模型定义                                            |
| **后端-3**  | 修改 `stores` 表迁移（删除 `region`，新增 8 个字段） | 0.5h   | -              | **不兼容旧数据，直接清空**                                    |
| **后端-4**  | 修改 `Store` 模型（新增 8 个字段）                   | 0.5h   | 后端-3         | code + name 冗余存储（含街道级）                              |
| **后端-5**  | 编写数据导入脚本（下载+转换+导入）                   | 1h     | 后端-2         | 从 GitHub 开源数据集导入（唯一数据源）                        |
| **后端-6**  | 执行数据导入（44854 条区划数据）                     | 1h     | 后端-5         | 包含街道级数据，验证数据完整性                                |
| **后端-7**  | 实现区划查询 API（6个接口，路径参数）                | 2h     | 后端-2         | provinces/children/:parent_code/search/path/stats/validate    |
| **后端-8**  | 创建 `RegionService`（区划业务逻辑 + 自动填充 name） | 1h     | 后端-2         | **核心逻辑：code → name 查询（最新字典名）**                  |
| **后端-9**  | 修改 `StoreService`（增加区划校验 + 自动填充）       | 1h     | 后端-4,8       | 创建/修改时自动填充 `*_name`（刷新为最新字典名）              |
| **后端-10** | 更新门店 CRUD 路由（集成区划校验）                   | 0.5h   | 后端-9         | `/api/v4/console/stores`                                      |
| **后端-11** | 实现批量导入接口（**JSON body，已拍板**）            | 1.5h   | 后端-9         | `/api/v4/console/stores/batch-import`                         |
| **后端-12** | 编写单元测试（API + Service + 边界情况）             | 1h     | 后端-7,9,10,11 | 测试区划校验、自动填充、批量导入逻辑                          |

**后端总工作量**：11h（约 1.5 个工作日）

**关键技术点**（已拍板）：

1. **code + name 冗余存储**：创建/修改门店时，后端自动从字典表查询最新 `*_name` 并写入
2. **name 自动同步**：门店修改区域时，`*_name` 字段刷新为最新字典名（非严格快照）
3. **不兼容旧数据**：迁移时直接清空 `stores` + `merchant_operation_logs`，不导出备份
4. **批量导入**：迁移后通过 **JSON body** 批量导入新门店数据（非 CSV）
5. **街道级必填**：支持到 level=4（街道/乡镇），**`street_code`/`street_name` 必填**
6. **字典默认不更新**：上线后字典表默认不更新，仅在行政区划重大调整时手工更新
7. **数据权限**：支持按组织/区域/门店隔离（区域经理/业务员按范围过滤）

### 7.2 实施步骤

#### 阶段1：数据库准备（不兼容旧数据，已拍板）

1. **⚠️ 清空 `merchant_operation_logs` 表**（审计日志随门店一起删除，已拍板认可）
2. **⚠️ 清空 `stores` 表**（`TRUNCATE TABLE stores`，不导出备份）
3. 创建 `administrative_regions` 表（字典表，支持 level=1/2/3/4）
4. **删除 `stores.region` 字段**（不兼容旧数据）
5. 新增 `stores` 表 8 个字段（`province_code/name`、`city_code/name`、`district_code/name`、`street_code/name`）
6. **重导行政区划数据**（对齐 GB/T 2260 六位标准 6/6/6/9，约 44854 条，含港澳台 34 省级）

#### 阶段2：后端开发（code + name 冗余存储，已拍板）

1. 创建 `AdministrativeRegion` 模型
2. 创建 `RegionService`（**核心：code → name 自动填充逻辑，查询最新字典名**）
3. 实现区划查询 API（路径参数 `/children/:parent_code`，支持街道级，**仅名称搜索**）
4. 修改 `StoreService`（增加区划校验 + **自动填充 `*_name` 字段，修改区域时刷新为最新字典名**）
5. 更新门店 CRUD 路由（集成区划校验，**street_code 必填**）
6. 实现批量导入接口（**JSON body**，用于迁移后导入新门店数据）
7. 编写单元测试（测试区划校验、自动填充、批量导入逻辑）

#### 阶段3：数据迁移（已拍板）

1. 准备门店数据文件（**JSON 格式，已拍板**）
   - 字段：`store_name`、`store_code`、`province_code`、`city_code`、`district_code`、**`street_code`（必填）**、`store_address`、`contact_name`、`contact_mobile`
   - Code 标准：GB/T 2260 六位体系（6/6/6/9）
   - 数据来源：由业务方提供（旧数据已删除）
2. 调用批量导入接口（`POST /api/v4/console/stores/batch-import`），body 为 `{ stores: [...] }`
3. 验证导入结果（成功数量、失败数量、错误详情）

#### 阶段4：前端开发（交给前端开发人员）

1. 封装区划查询 API
2. 开发级联选择组件（省→市→区→街道四级联动）
3. 集成到门店管理页面
4. 提交数据格式：仅需提交 `*_code` 字段，`*_name` 由后端自动填充（查询最新字典名）

### 7.3 风险与应对

| 风险                     | 影响                         | 应对措施（已拍板）                                                 |
| ------------------------ | ---------------------------- | ------------------------------------------------------------------ |
| **旧数据丢失**           | 现有门店数据永久删除         | **已拍板：直接清空不导出，迁移后通过 JSON 批量导入新数据**         |
| **审计日志丢失**         | merchant_operation_logs 清空 | **已拍板：认可为允许代价，审计日志随门店一起清空不保留**           |
| 数据源更新不及时         | 新增区划无法选择             | **已拍板：上线后默认不更新字典表**，仅在行政区划重大调整时手工更新 |
| 直辖市层级特殊           | 前端逻辑复杂                 | 后端统一处理（市级 code=省级 code）                                |
| 性能问题（44854 条区划） | 前端加载慢                   | 按需加载（四级联动）+ 前端缓存 + 后端索引优化                      |
| 字典表改名影响历史数据   | 门店区域名称不一致           | **已拍板：门店修改区域时刷新为最新字典名**（非严格快照）           |
| 批量导入数据质量         | 区划代码错误导致导入失败     | 后端逐行校验 + 返回详细错误信息 + 支持部分成功                     |

### 7.4 后续优化方向

1. ~~**街道/乡镇级别**~~：已实现（level=4，已拍板）
2. **地图展示**：利用经纬度字段，在地图上标注门店
3. **数据分析**：按区域维度统计门店数量、消费金额等
4. **区域权限隔离（已拍板）**：基于 `province_code`/`city_code`/`district_code`/`store_id` 实现**数据权限**
   - admin 完全访问
   - 区域经理按 province/city/district 范围过滤
   - 业务员按 store 范围过滤
   - 需配合 RBAC + 数据范围模型实现
5. **字典表更新机制**：建立行政区划变更监控和更新流程（默认不更新，重大调整时手工更新）
6. **拼音搜索补齐**：当前拼音覆盖率极低，后续可引入拼音生成策略重算/重导（已降级为优化项）

---

## 8. 附录

### 8.1 国标行政区划代码规则

**GB/T 2260-2007 标准**：

- **省级**：2位数字 + 0000（如 `110000` = 北京市）
- **市级**：前2位为省代码 + 2位市代码 + 00（如 `110100` = 北京市）
- **区县级**：前4位为市代码 + 2位区县代码（如 `110108` = 海淀区）
- **街道级**（可选）：前6位为区县代码 + 3位街道代码（如 `110108001` = 万寿路街道）

**特殊情况**：

- **直辖市**：省级和市级代码相同（如北京 `110000` = `110100`）
- **省直辖县级市**：市级代码为 `XX9000`（如海南省直辖县级市）

### 8.2 数据示例（完整）

```json
{
  "provinces": [
    {
      "region_code": "110000",
      "parent_code": null,
      "region_name": "北京市",
      "level": 1,
      "short_name": "京",
      "pinyin": "beijing",
      "status": "active"
    },
    {
      "region_code": "440000",
      "parent_code": null,
      "region_name": "广东省",
      "level": 1,
      "short_name": "粤",
      "pinyin": "guangdong",
      "status": "active"
    }
  ],
  "cities": [
    {
      "region_code": "110100",
      "parent_code": "110000",
      "region_name": "北京市",
      "level": 2,
      "pinyin": "beijing",
      "status": "active"
    },
    {
      "region_code": "440100",
      "parent_code": "440000",
      "region_name": "广州市",
      "level": 2,
      "pinyin": "guangzhou",
      "status": "active"
    },
    {
      "region_code": "440300",
      "parent_code": "440000",
      "region_name": "深圳市",
      "level": 2,
      "pinyin": "shenzhen",
      "status": "active"
    }
  ],
  "districts": [
    {
      "region_code": "110108",
      "parent_code": "110100",
      "region_name": "海淀区",
      "level": 3,
      "pinyin": "haidian",
      "longitude": 116.298056,
      "latitude": 39.959912,
      "status": "active"
    },
    {
      "region_code": "440106",
      "parent_code": "440100",
      "region_name": "天河区",
      "level": 3,
      "pinyin": "tianhe",
      "longitude": 113.361328,
      "latitude": 23.124943,
      "status": "active"
    }
  ]
}
```

### 8.3 参考资源

- **国家标准**：[GB/T 2260-2007 中华人民共和国行政区划代码](http://www.mca.gov.cn/article/sj/xzqh/)
- **开源数据集**：[modood/Administrative-divisions-of-China](https://github.com/modood/Administrative-divisions-of-China)
- **高德地图API**：[行政区域查询](https://lbs.amap.com/api/webservice/guide/api/district)
- **Element Plus 级联选择器**：[Cascader 组件](https://element-plus.org/zh-CN/component/cascader.html)

---

## 9. 总结

本方案通过引入**标准化行政区划代码 + 冗余 name 存储**，解决了门店区域信息的数据质量问题，并为后续的区域统计、地图展示等功能奠定了基础。

**核心优势**：

1. ✅ **数据标准化**：使用国标 GB/T 2260 六位代码体系（6/6/6/9），避免脏数据
2. ✅ **细粒度支持**：支持到街道/乡镇级别（level=4），满足精细化管理需求
3. ✅ **name 自动同步**：门店修改区域时，自动从字典表查询最新 `*_name` 并更新
4. ✅ **统计分析强**：按省/市/区/街道维度聚合数据（使用 `*_code` 字段索引）
5. ✅ **维护成本低**：使用开源数据集（唯一数据源），上线后默认不更新，避免频繁变更
6. ✅ **无历史包袱**：不兼容旧数据，直接清空不导出，避免过渡方案复杂性
7. ✅ **批量导入支持**：迁移后通过 **JSON body** 批量导入新门店数据

**关键决策汇总**（2026-01-12 拍板）：

| 决策项          | 结论                                                            |
| --------------- | --------------------------------------------------------------- |
| **Code 标准**   | GB/T 2260 六位体系（6/6/6/9）：省=6位、市=6位、区=6位、街道=9位 |
| **省级范围**    | 含港澳台，共 34 个省级单位                                      |
| **street_code** | 必填（stores 表 NOT NULL）                                      |
| **API 契约**    | 以当前实现为准（路径参数 `/children/:parent_code`）             |
| **批量导入**    | JSON body（非 CSV/multipart）                                   |
| **搜索能力**    | 仅名称搜索（拼音降级为后续优化项）                              |
| **迁移破坏性**  | 认可清空 `stores` + `merchant_operation_logs`                   |
| **权限范围**    | 实现数据权限（按组织/区域/门店隔离），配合 RBAC + 数据范围模型  |

**方案选型决策**（已拍板）：

- **存储方式**：code（主键，索引） + name（冗余，修改区域时刷新）
- **数据来源**：本地数据库字典表（不依赖第三方API），`modood/Administrative-divisions-of-China`（唯一数据源）
- **数据范围**：level=1/2/3/4（省/市/区县/街道），总计约 44854 条，省级含港澳台
- **兼容性**：不兼容旧数据，直接清空 `stores` + `merchant_operation_logs`（已拍板认可）
- **更新策略**：上线后默认不更新字典表，仅在行政区划重大调整时手工更新
- **name 更新规则**：门店修改区域时，重新从字典表查询最新 `*_name` 并更新（非严格快照）
- **扩展性**：支持未来地图展示、数据权限隔离（区域经理/业务员按范围过滤）

**实施建议**：

- **优先级**：P1（数据质量问题严重，需尽快标准化）
- **后端工作量**：约 2 个工作日（含数据重导对齐 6/6/6/9 标准）
- **风险**：中等（需重导数据 + JSON 批量导入新门店数据，但技术方案成熟）
- **前置条件**：
  1. 重导行政区划数据，对齐 GB/T 2260 六位标准
  2. 准备"门店列表 + 省市区街道 code + 地址"JSON 文件，用于迁移后批量导入

---

**文档版本**: v1.1  
**最后更新**: 2026-01-12  
**拍板日期**: 2026-01-12  
**维护人**: 后端开发团队

### 变更记录

| 版本 | 日期       | 变更内容                                                                                   |
| ---- | ---------- | ------------------------------------------------------------------------------------------ |
| v1.0 | 2026-01-12 | 初始版本                                                                                   |
| v1.1 | 2026-01-12 | 新增 8 项关键决策拍板记录；更新 API 契约为路径参数；更新批量导入为 JSON body；降级拼音搜索 |
