# SESSION_INVALIDATED 认证异常 — 后端排查结果

## 问题概述

| 项目 | 内容 |
|------|------|
| **发现时间** | 2026-02-18 01:02:13 |
| **影响范围** | 所有需要认证的REST API请求（新/旧会话均无法发送消息） |
| **问题现象** | 后端返回 `401 SESSION_INVALIDATED`，但用户JWT Token有效且无其他设备登录 |
| **前端版本** | v5.2.0（TypeScript + MobX + Socket.IO） |
| **触发场景** | 点击客服会话 → 加载聊天历史 → 401被拒 |

---

## 后端排查结论

### 1. 表名纠正

前端文档提到 `user_sessions` 表 — **该表不存在**。

后端实际使用的是 `authentication_sessions` 表，主键为 `authentication_session_id`，关键字段：

| 字段 | 类型 | 说明 |
|------|------|------|
| `authentication_session_id` | bigint (PK) | 认证会话主键 |
| `session_token` | varchar(255) UNIQUE | JWT中嵌入的会话令牌 |
| `user_type` | enum('user','admin') | 用户类型 |
| `user_id` | int | 用户ID |
| `is_active` | tinyint(1) | 是否活跃（默认1） |
| `expires_at` | datetime | 过期时间 |
| `last_activity` | datetime | 最后活动时间 |

### 2. SESSION_INVALIDATED 触发机制（实际代码）

位于 `middleware/auth.js` 第475-493行：

```
authenticateToken 中间件流程:
  1. jwt.verify(token, JWT_SECRET) → 解码得到 decoded
  2. 若 decoded.session_token 存在:
     → 调用 AuthenticationSession.findValidByToken(session_token)
     → 查询条件: session_token 匹配 AND is_active = true AND expires_at > NOW()
     → 若查询结果为 null → 返回 401 SESSION_INVALIDATED
  3. 查询 users 表确认用户存在且 status='active'
  4. 获取用户角色信息，构建 req.user
```

### 3. 会话失效的根本原因：单设备登录策略

位于 `routes/v4/auth/login.js` 第199-207行和 `models/AuthenticationSession.js` 第250-271行：

每次登录（密码登录或微信登录）时，后端调用 `AuthenticationSession.deactivateUserSessions(userType, user_id, null)`，将该用户所有已有会话的 `is_active` 设为 `false`，然后创建新会话。

**数据库实际数据（user_id=31）：**

| 统计项 | 值 |
|--------|------|
| 总会话记录 | 63条 |
| 当前活跃 | 1条（authentication_session_id=7038） |
| 已失效 | 62条 |

最近会话时间线：
- 7034（01:44:02创建 → 01:44:13失效）
- 7035（01:44:11创建 → 01:44:13失效）
- 7036（01:44:13创建 → 01:44:13失效）
- 7037（01:44:13创建 → 01:45:08失效）
- 7038（01:45:08创建 → **当前活跃**）

短时间内连续创建5个会话，说明有重复登录行为触发了连锁失效。

### 4. REST API 与 Socket.IO 认证差异（实际代码）

| 认证环节 | REST API (`middleware/auth.js`) | Socket.IO (`services/ChatWebSocketService.js`) |
|----------|--------------------------------|------------------------------------------------|
| JWT验证 | `jwt.verify()` | `jwt.verify()` |
| 会话有效性 | `AuthenticationSession.findValidByToken()` | **无** |
| 结果 | 会话失效 → 401 | 只要JWT未过期 → 连接成功 |

这解释了文档中提到的矛盾现象：同一个Token，REST API返回401但Socket.IO连接成功。

### 5. 后端方案

**方案A（推荐）：前端避免重复登录**

前端小程序启动时的 `checkAuthStatus()` 流程不应触发新的登录请求。应先验证本地Token有效性（JWT未过期 + 调用 `GET /api/v4/auth/verify` 确认），仅在确认无效时才发起登录。

**方案B：后端优化错误提示**

当前所有会话失效都返回同一条消息"可能是其他设备登录导致"，后端可细分为：
- `SESSION_EXPIRED`：`expires_at` 已过期 → "会话已过期，请重新登录"
- `SESSION_REPLACED`：`is_active` 被新登录覆盖 → "您的账号已在其他位置登录"
- `SESSION_DEACTIVATED`：管理员手动失效 → "会话已被管理员终止"

**方案C：Socket.IO补齐会话检查**

在 `ChatWebSocketService.js` 握手中间件增加 `AuthenticationSession.findValidByToken()` 检查，与REST API保持一致。

### 6. 前端需修改的内容

- 删除文档中所有对 `user_sessions` 表的引用，正确表名为 `authentication_sessions`
- 排查小程序冷启动/热启动时是否有多余的登录请求（这是导致会话被连锁失效的主因）
- session_id=1873 在数据库中不存在（该ID是 `customer_service_sessions` 范围，非认证会话），前端需确认实际使用的session标识

---

# 我的挂单页面数据不一致 — 后端排查结果

## 问题概述

| 项目 | 内容 |
|------|------|
| **发现时间** | 2026-02-19 |
| **影响范围** | 我的挂单页面状态统计数字显示为0 |
| **问题现象** | 全部挂单显示260条，但各状态计数均显示0 |

---

## 后端排查结论

### 1. 确认：status_counts 字段确实未返回

`GET /api/v4/market/my-listings` 路由（`routes/v4/market/listings.js` 第322-364行）调用 `MarketListingQueryService.getUserListings()`，当前返回结构：

```json
{
  "success": true,
  "data": {
    "listings": [...],
    "pagination": {
      "total": 265,
      "page": 1,
      "limit": 20,
      "total_pages": 14
    }
  }
}
```

`MarketListingQueryService.getUserListings()`（`services/market-listing/QueryService.js` 第84-118行）仅返回 `{ listings, total, page, page_size }`，不包含 `status_counts`。

### 2. 数据库真实数据（user_id=31）

```sql
SELECT status, COUNT(*) as cnt FROM market_listings WHERE seller_user_id = 31 GROUP BY status;
```

| status | 数量 |
|--------|------|
| on_sale | 3 |
| locked | 9 |
| sold | 16 |
| withdrawn | 237 |
| 总计 | 265 |

全库数据分布：

| status | 数量 |
|--------|------|
| on_sale | 25 |
| locked | 9 |
| sold | 17 |
| withdrawn | 237 |
| 总计 | 288 |

### 3. market_listings 表实际字段

| 字段 | 类型 | 说明 |
|------|------|------|
| `market_listing_id` | bigint (PK) | 挂牌主键 |
| `listing_kind` | enum('item_instance','fungible_asset') | 挂牌类型 |
| `seller_user_id` | int | 卖家用户ID |
| `offer_item_instance_id` | bigint | 物品实例ID（物品挂牌时） |
| `offer_item_template_id` | bigint | 物品模板ID |
| `offer_item_category_code` | varchar(50) | 物品类目代码 |
| `offer_item_rarity` | varchar(50) | 稀有度 |
| `offer_item_display_name` | varchar(200) | 物品显示名 |
| `offer_asset_group_code` | varchar(50) | 资产分组代码 |
| `offer_asset_display_name` | varchar(100) | 资产显示名 |
| `offer_asset_code` | varchar(50) | 资产代码 |
| `offer_amount` | bigint | 出售数量 |
| `price_asset_code` | varchar(50) | 定价币种（默认DIAMOND） |
| `price_amount` | bigint | 定价金额 |
| `status` | enum('on_sale','locked','sold','withdrawn','admin_withdrawn') | 状态 |
| `created_at` | datetime | 创建时间 |
| `updated_at` | datetime | 更新时间 |

### 4. 后端方案：在 getUserListings 中追加 status_counts 聚合

在 `services/market-listing/QueryService.js` 的 `getUserListings` 方法中，追加一条聚合查询：

```sql
SELECT status, COUNT(*) AS cnt
FROM market_listings
WHERE seller_user_id = :seller_user_id
GROUP BY status
```

返回结构改为：

```json
{
  "listings": [...],
  "pagination": { "total": 265, "page": 1, "limit": 20, "total_pages": 14 },
  "status_counts": {
    "on_sale": 3,
    "locked": 9,
    "sold": 16,
    "withdrawn": 237,
    "admin_withdrawn": 0
  }
}
```

`status_counts` 统计该用户全部挂单（不受 `status` 查询参数筛选影响），缺失的状态键返回 `0`。

### 5. 前端适配方案（使用后端字段名，不做映射）

前端直接使用后端 `market_listings` 表的原始字段名，不做额外映射：

**每条挂单记录的字段（后端实际返回）：**

| 后端字段 | 类型 | 前端直接使用 |
|----------|------|-------------|
| `market_listing_id` | number | 用作列表key和详情跳转 |
| `listing_kind` | string | 区分物品挂牌/资产挂牌 |
| `offer_item_display_name` | string/null | 物品名称（物品挂牌时有值） |
| `offer_asset_display_name` | string/null | 资产名称（资产挂牌时有值） |
| `offer_asset_code` | string/null | 资产代码 |
| `offer_amount` | number/null | 出售数量 |
| `offer_item_rarity` | string/null | 稀有度 |
| `price_asset_code` | string | 定价币种 |
| `price_amount` | number | 定价金额 |
| `status` | string | 状态枚举值 |
| `status_display` | string | 状态中文名（后端已通过 attachDisplayNames 附加） |
| `status_color` | string | 状态颜色标识（后端已附加） |
| `created_at` | string | 创建时间 |

前端状态标签页映射关系：

| 标签页 | 对应 status_counts 的 key |
|--------|--------------------------|
| 全部 | `pagination.total` |
| 在售中 | `status_counts.on_sale` |
| 已锁定 | `status_counts.locked` |
| 已成交 | `status_counts.sold` |
| 已撤回 | `status_counts.withdrawn + status_counts.admin_withdrawn` |

---

# 客服聊天会话ID为空 — 后端排查结果

## 一、问题现象

用户在微信小程序中无法发送客服消息，新会话和旧会话均受影响。`sessionId` 始终为 `undefined`。

---

## 二、后端排查结论：路由层属性名不匹配（非 DataSanitizer 问题）

### 根本原因

`routes/v4/system/chat.js` 第111行：

```javascript
return res.apiSuccess({
    session_id: session.session_id,   // ← BUG: session 对象没有 session_id 属性
    status: session.status,
    source: session.source,
    created_at: session.created_at
})
```

但 `CustomerServiceSessionService.getOrCreateSession()` 返回的对象结构是：

```javascript
{
    customer_service_session_id: 1882,  // ← 实际属性名
    status: 'waiting',
    source: 'mobile',
    created_at: '2026-02-19T08:56:52.000+08:00',
    is_new: false
}
```

`session.session_id` 为 `undefined`，导致 API 响应中 `session_id: undefined`。

**这是一个简单的属性名不匹配 bug，不是 DataSanitizer 未调用的问题。**

### 后端修复方案

将 `routes/v4/system/chat.js` 第111行改为：

```javascript
session_id: session.customer_service_session_id
```

修复后 `POST /api/v4/system/chat/sessions` 的响应：

```json
{
  "success": true,
  "data": {
    "session_id": 1882,
    "status": "waiting",
    "source": "mobile",
    "created_at": "2026-02-19T08:56:52.000+08:00"
  }
}
```

---

## 三、客服聊天所有 API 的实际响应字段（后端权威）

以下是后端代码中每个聊天 API 实际返回的字段，前端应直接使用这些字段名。

### 3.1 POST /api/v4/system/chat/sessions （创建/获取会话）

路由：`routes/v4/system/chat.js` 第71-122行

修复后响应：

```json
{
  "success": true,
  "data": {
    "session_id": 1882,
    "status": "waiting",
    "source": "mobile",
    "created_at": "2026-02-19T08:56:52.000+08:00"
  }
}
```

前端读取 `data.session_id` 即可。

### 3.2 GET /api/v4/system/chat/sessions （会话列表）

路由：`routes/v4/system/chat.js` 第136-174行
Service：`CustomerServiceSessionService.getSessionList()` 第123-273行

响应（每条会话的字段）：

| 字段 | 类型 | 说明 |
|------|------|------|
| `customer_service_session_id` | number | 会话主键 |
| `user` | object | `{ user_id, nickname, mobile }` |
| `admin` | object/null | `{ user_id, nickname }` |
| `status` | string | 会话状态 |
| `status_display` | string | 状态中文名（attachDisplayNames附加） |
| `priority` | number | 优先级 |
| `last_message_at` | string/null | 最后消息时间（ISO 8601+08:00） |
| `created_at` | string | 创建时间 |
| `updated_at` | string | 更新时间 |
| `last_message` | object/null | 最后一条消息 `{ chat_message_id, content, sender_type, created_at }` |
| `unread_count` | number | 未读消息数 |

前端使用 `customer_service_session_id` 作为会话标识（不是 `id`）。

### 3.3 GET /api/v4/system/chat/sessions/:id/messages （消息历史）

路由：`routes/v4/system/chat.js` 第192-229行
Service：`CustomerServiceSessionService.getSessionMessages()` 第294-443行

响应（每条消息的字段）：

**基础字段模式（include_all_fields=false 时）：**

| 字段 | 类型 | 说明 |
|------|------|------|
| `chat_message_id` | number | 消息主键 |
| `customer_service_session_id` | number | 所属会话ID |
| `sender` | object | `{ user_id, nickname }`（系统消息时为 `{ user_id: sender_id, nickname: '已删除用户' }`） |
| `sender_type` | string | 'user' / 'admin' |
| `message_source` | string | 'user_client' / 'admin_client' / 'system' |
| `content` | string | 消息内容 |
| `message_type` | string | 'text' / 'image' / 'system' |
| `status` | string | 'sending' / 'sent' / 'delivered' / 'read' |
| `created_at` | string | ISO 8601+08:00 |

**完整字段模式（include_all_fields=true 时，当前路由使用此模式）：**

额外包含：`reply_to_id`、`temp_message_id`、`metadata`、`updated_at`

前端使用 `chat_message_id` 作为消息标识（不是 `id`）。

### 3.4 POST /api/v4/system/chat/sessions/:id/messages （发送消息）

路由：`routes/v4/system/chat.js` 第247-363行

响应：

| 字段 | 类型 | 说明 |
|------|------|------|
| `chat_message_id` | number | 新消息主键 |
| `customer_service_session_id` | number | 所属会话ID |
| `content` | string | 消息内容 |
| `message_type` | string | 消息类型 |
| `sent_at` | string | 发送时间（即 created_at） |

### 3.5 Socket.IO 事件字段（后端实际发送）

| 事件名 | 字段 | 说明 |
|--------|------|------|
| `connection_established` | `user_id, is_admin, socket_id, server_time` | 连接成功 |
| `message_sent` | `chat_message_id, customer_service_session_id, sender_id, sender_type, content, message_type, created_at, sender_name, timestamp` | 消息发送确认 |
| `new_message` | 同 message_sent | 广播给管理员的新消息 |

所有事件使用 `chat_message_id` 和 `customer_service_session_id`，不使用 `id`。

---

## 四、前端需修改的内容（直接使用后端字段名）

### 4.1 会话标识

```
错误: const sessionId = session.id ?? session.customer_service_session_id
正确: const sessionId = session.customer_service_session_id
```

注意：`POST /api/v4/system/chat/sessions` 返回的字段名是 `session_id`（路由层已做重命名），
`GET /api/v4/system/chat/sessions` 返回的字段名是 `customer_service_session_id`（Service层原始输出）。

后端将统一这两个接口的字段名，统一使用 `customer_service_session_id`。在此之前，前端兼容读取：

```
创建会话: data.session_id (即 customer_service_session_id)
会话列表: item.customer_service_session_id
消息列表: item.chat_message_id
```

### 4.2 消息标识

```
错误: const messageId = msg.id ?? msg.chat_message_id
正确: const messageId = msg.chat_message_id
```

### 4.3 Socket.IO 事件

```
错误: event.id
正确: event.chat_message_id 和 event.customer_service_session_id
```

### 4.4 关于 DataSanitizer

`DataSanitizer.sanitizeChatSessions()` 方法存在且映射正确（`customer_service_session_id → id`），但当前聊天路由**未调用** DataSanitizer，而是在路由层和Service层直接构造返回字段。

后端决策：聊天路由不启用 DataSanitizer，保持当前的显式字段选择模式。前端直接使用后端原始字段名（`customer_service_session_id`、`chat_message_id`），不依赖 DataSanitizer 的 `id` 映射。

---

## 五、wx:key 重复警告排查

数据库排查结果：

- `customer_service_sessions` 表无重复主键记录
- `chat_messages` 表无重复主键记录

`wx:key` 重复警告可能原因：前端列表渲染时使用了非唯一字段作为 key（如 `session.id` 为 undefined 时多条记录 key 相同），修复会话标识后此问题应自动消失。

---

## 六、数据库实际数据参考

### customer_service_sessions（user_id=31）

| customer_service_session_id | status | source | last_message_at | 消息数 |
|----|----|----|----|----|
| 1882 | waiting | system_notification | 2026-02-19T02:00:00 | 29条 |

用户仅有1个会话。

### customer_service_sessions 表结构

| 字段 | 类型 | 说明 |
|------|------|------|
| `customer_service_session_id` | bigint (PK) | 会话主键 |
| `user_id` | int | 咨询用户ID |
| `admin_id` | int/null | 接入客服ID |
| `status` | enum('waiting','assigned','active','closed') | 会话状态 |
| `source` | varchar(32) | 来源（mobile/system_notification） |
| `priority` | int | 优先级 |
| `is_active_session` | tinyint(1) | 是否活跃会话 |
| `last_message_at` | datetime | 最后消息时间 |
| `first_response_at` | datetime/null | 首次响应时间 |
| `closed_at` | datetime/null | 关闭时间 |
| `close_reason` | varchar(500)/null | 关闭原因 |
| `satisfaction_score` | int/null | 满意度评分 |

### chat_messages 表结构

| 字段 | 类型 | 说明 |
|------|------|------|
| `chat_message_id` | bigint (PK) | 消息主键 |
| `customer_service_session_id` | bigint (FK) | 所属会话ID |
| `sender_id` | int/null | 发送者用户ID（系统消息为null） |
| `sender_type` | enum('user','admin') | 发送者类型 |
| `message_source` | enum('user_client','admin_client','system') | 消息来源 |
| `content` | text | 消息内容 |
| `message_type` | enum('text','image','system') | 消息类型 |
| `status` | enum('sending','sent','delivered','read') | 消息状态 |
| `reply_to_id` | bigint/null | 回复的消息ID |
| `temp_message_id` | varchar(64)/null | 临时消息ID |
| `metadata` | json/null | 扩展数据 |

---

---

# 三个问题的责任归属分析

## 总览

| 问题 | 后端数据库项目 | 微信小程序前端 | Web管理后台前端 |
|------|--------------|--------------|---------------|
| SESSION_INVALIDATED | 有责任 | 有责任（主因） | 有责任 |
| 挂单status_counts缺失 | 有责任（主因） | 需适配 | 不涉及 |
| 聊天sessionId为空 | 有责任（主因） | 需适配 | 不涉及 |

---

## 问题1：SESSION_INVALIDATED

### 后端数据库项目的问题

1. **REST API 和 Socket.IO 认证逻辑不一致**
   - `middleware/auth.js` 做了 JWT + `authentication_sessions` 表双重校验
   - `ChatWebSocketService.js` 握手中间件只做 JWT 校验，不检查 `authentication_sessions`
   - 同一个 Token 在 REST API 返回 401 但 Socket.IO 连接成功，这是后端设计缺陷

2. **错误提示不精确**
   - 所有会话失效场景统一返回"可能是其他设备登录导致"
   - 实际上 `is_active=false` 可能是：过期清理、管理员操作、同一设备重复登录
   - 后端应区分 `SESSION_EXPIRED`、`SESSION_REPLACED`、`SESSION_DEACTIVATED`

### 微信小程序前端的问题（主因）

数据库证据：user_id=31 在 01:40:50 到 01:45:08 之间创建了 **10个认证会话**（id 7029-7038），每次新登录都会使前一个会话失效。

小程序前端可能在以下场景触发多余登录：
- 冷启动时 `checkAuthStatus()` 判定Token"无效"后自动发起登录
- 热启动/切后台回来时重复调用登录
- Token刷新逻辑（`POST /api/v4/auth/refresh`）内部创建了新认证会话

**前端需排查**：启动时的认证流程是否有多余的登录请求。正确流程应该是：先验证本地Token（JWT未过期 + 调用 `GET /api/v4/auth/verify`），仅在确认失效时才登录。

### Web管理后台前端的问题

数据库证据：10个会话中，前9个（7029-7037）的 `login_ip` 都是 `127.0.0.1` 或 `::ffff:127.0.0.1`，最后一个（7038）来自外网IP `116.4.39.203`。

- `127.0.0.1` 是 Web管理后台从服务器本地发起的登录
- `116.4.39.203` 是微信小程序或外部浏览器的登录
- 短时间内 Web管理后台连续创建了多个会话（01:40-01:44），说明Web端也存在重复登录问题
- Web端最后一次登录（7037）被小程序的外网登录（7038）覆盖失效

**Web管理后台需排查**：是否存在页面刷新或心跳机制导致重复调用登录接口。

---

## 问题2：我的挂单 status_counts 缺失

### 后端数据库项目的问题（主因）

`MarketListingQueryService.getUserListings()` 方法缺少 `status_counts` 聚合查询，需要后端补充：

```sql
SELECT status, COUNT(*) AS cnt FROM market_listings WHERE seller_user_id = ? GROUP BY status
```

并在返回结果中追加 `status_counts` 字段。这是后端功能缺失。

### 微信小程序前端的问题

- 前端页面 `pages/trade/my-listings` 需要适配后端字段名
- 直接使用 `market_listing_id`（不是 `id`）
- 直接使用 `offer_asset_display_name`、`offer_item_display_name` 等后端原始字段
- 后端已通过 `attachDisplayNames()` 附加了 `status_display` 和 `status_color`，前端直接读取即可

### Web管理后台前端

不涉及。Web管理后台的市场管理走独立路由 `GET /api/v4/console/marketplace/...`，与小程序的 `GET /api/v4/market/my-listings` 是不同的接口。

---

## 问题3：客服聊天 sessionId 为空

### 后端数据库项目的问题（主因）

`routes/v4/system/chat.js` 第111行存在属性名不匹配 bug：

```
代码写的: session.session_id        → undefined
应该写的: session.customer_service_session_id → 1882
```

Service 层 `getOrCreateSession()` 返回的对象使用 `customer_service_session_id` 作为属性名，但路由层读取了不存在的 `session_id` 属性。修复一行代码即可。

### 微信小程序前端的问题

- 前端当前写了 `session.id ?? session.customer_service_session_id` 的兼容逻辑，应改为直接使用后端字段名
- 会话标识：使用 `customer_service_session_id`（不是 `id`）
- 消息标识：使用 `chat_message_id`（不是 `id`）
- Socket.IO事件：使用 `event.chat_message_id` 和 `event.customer_service_session_id`
- `wx:key` 重复警告是因为 `session.id` 为 undefined 导致多条记录的 key 相同，修复后自动消失

### Web管理后台前端

不涉及。Web管理后台的客服功能走独立的管理路由：
- `GET /api/v4/console/customer-service/sessions` — 会话列表
- `GET /api/v4/console/customer-service/sessions/:id/messages` — 消息历史
- `POST /api/v4/console/customer-service/sessions/:id/send` — 发送消息

这些是 `routes/v4/console/customer-service/` 下的独立路由文件，不受小程序端 `routes/v4/system/chat.js` 的 bug 影响。

---

## 各项目待办汇总

### 后端数据库项目（3项）

| 序号 | 问题 | 修改位置 | 优先级 |
|------|------|---------|--------|
| B1 | 聊天路由属性名不匹配 | `routes/v4/system/chat.js` 第111行 | P0 — 一行修复 |
| B2 | 挂单缺少status_counts | `services/market-listing/QueryService.js` getUserListings方法 | P1 — 追加聚合查询 |
| B3 | REST/Socket.IO认证不一致 | `services/ChatWebSocketService.js` 握手中间件 | P2 — 补齐session检查 |

可选优化：
- 细分 SESSION_INVALIDATED 错误码（SESSION_EXPIRED / SESSION_REPLACED / SESSION_DEACTIVATED）

### 微信小程序前端（3项）

| 序号 | 问题 | 修改位置 | 优先级 |
|------|------|---------|--------|
| M1 | 排查重复登录问题 | 启动流程 checkAuthStatus() | P0 — 这是SESSION_INVALIDATED的主因 |
| M2 | 聊天字段名适配 | chat.ts, chat-message-handlers.ts | P1 — 直接用 customer_service_session_id |
| M3 | 挂单字段名适配 | my-listings.ts | P1 — 直接用后端原始字段名 |

### Web管理后台前端（1项）

| 序号 | 问题 | 修改位置 | 优先级 |
|------|------|---------|--------|
| W1 | 排查重复登录问题 | 登录/Token刷新逻辑 | P1 — 127.0.0.1连续创建多个会话 |

---

**排查时间**: 2026-02-19
**排查方式**: Node.js 直连生产数据库查询 + 后端源码逐行核对
**后端技术栈**: Node.js + Express + Sequelize + MySQL + Socket.IO
**数据库**: restaurant_points_dev（MySQL，timezone: +08:00）
