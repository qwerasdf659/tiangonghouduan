# 兑换市场资产结算与手续费落地方案（对齐当前代码：实用主义、全部需求可落地）

> 目标：在**不推翻现有路由拆分 + Service 模式**前提下，把以下“全部需求”落到当前仓库技术路线（Node.js + MySQL + Sequelize）中，并给出**可执行的最小改造步骤 + 可验收口径**。
>
> - **交易市场**：结算从积分迁移到 **DIAMOND 资产账本**；购买收手续费（`monetize` 入平台账户）；**强幂等（客户端必传）**
> - **兑换市场**：支付口径迁移到 **材料资产余额扣减**（不做兼容、不允许自动辅助转换）；订单新增支付对账字段
> - **材料系统**：落地材料余额/流水/转换规则；提供“**碎红水晶 → DIAMOND（1:20）**”显式分解（不在兑换流程隐式触发）
>
> 你已拍板（本方案写死）：
> 1) **资产底座统一**：DIAMOND 与材料复用同一套账户/流水底座  
> 2) **兑换订单新增支付字段**：必须可对账（扣了哪种材料、扣了多少）  
> 3) **市场上架入参不做兼容**：直接切到 DIAMOND 定价入参（拒绝 selling_points）

---

## 一、现状对齐（严格以当前仓库代码/表结构为准）

### 1.0 当前系统里“可复用的真实基础”

- **兑换市场已落幂等规范**（且路由层文档化得很清楚）：
  - `routes/v4/unified-engine/exchange_market.js`：Body `business_id` 或 Header `Idempotency-Key` 二选一，缺失 400；同幂等键参数不一致 409；重复返回 `is_duplicate=true`
  - `models/ExchangeMarketRecord.js`：`business_id` 已存在，且有唯一索引 `idx_business_id_unique`
- **手续费规则与计算器已存在**：
  - `config/fee_rules.js`：分档（`max_value` 300/600/∞，费率 3%/5%/10%）、`min_fee=1`、`fee_strategy='monetize'`、`enabled=true`
  - `services/FeeCalculator.js`：手续费档位按 `UserInventory.value` 选，手续费金额按成交价计算并向上取整

### 1.1 交易市场现状（inventory-market / InventoryService）
- **定价字段仍是积分**：
  - `models/UserInventory.js`：市场定价字段为 `selling_points`（积分口径），无 `selling_asset_code/selling_amount`
  - `routes/v4/unified-engine/inventory-market.js`：上架接口仍收 `selling_points`
- **购买接口幂等做法不符合“强幂等”要求**：
  - 路由层仍会拼一个 `purchase_${buyer}_${product}_${Date.now()}` 作为 `business_id`（客户端缺失时也能下单 → **天然不可重试幂等**）
  - `InventoryService.purchaseMarketProduct()` 虽有“幂等检查”但并非按 `business_id`：它查询 `TradeRecord` 只看 `trade_type + item_id + buyer_id + status`，无法满足“同幂等键重试返回同一结果/参数冲突 409”的明确语义
- **运行时必炸的不一致（必须先修）**：
  - `InventoryService.purchaseMarketProduct` 调用 `PointsService.deductPoints`，但 `services/PointsService.js`真实方法是 `consumePoints()` / `addPoints()`
  - `InventoryService.purchaseMarketProduct` 创建 `TradeRecord.trade_type='market_purchase'`，但 `models/TradeRecord.js` 的 ENUM **不包含该值**（会触发 DB/ORM 层写入错误）

### 1.2 兑换市场现状（exchange_market）
- **支付方式已被强制简化为 virtual**（当前代码真实行为）：
  - `models/ExchangeItem.js`：`price_type` 枚举仅 `virtual`，价格字段为 `virtual_value_price`（实际扣减）+ `points_price`（仅展示）
  - `services/ExchangeMarketService.js`：支付通过 `_getUserTotalVirtualValue/_deductVirtualValue` 从 `user_inventory.value` 扣减（虚拟奖品价值），并强制 `points_paid=0`
  - `public/admin/exchange-market-items.html` / `public/admin/exchange-market-orders.html`：管理后台 UI 也固定在“虚拟价值支付”

> 结论：兑换市场目前不是“材料资产扣减”，而是“背包虚拟价值扣减”。本期需要**直接改掉**，且按你要求“不做兼容”。

### 1.3 手续费现状
- `FeeCalculator/fee_rules` 目前主要围绕 `inventory_transfer` / `point_transfer`；**交易市场购买路径（`trade_type=market_purchase`）尚未接入手续费开关与平台入账**。

---

## 二、目标口径（上线后必须满足的业务/对账语义）

### 2.1 交易市场（DIAMOND 结算 + 手续费）
- **结算资产**：只允许 `asset_code = DIAMOND`
- **售价字段**：只读 `user_inventory.selling_asset_code / user_inventory.selling_amount`
- **手续费开关**：
  - 全局：`fee_rules.enabled`
  - 交易类型：`fee_rules.trade_type_fees.market_purchase.enabled`（新增）
- **手续费去向**：沿用现有 `fee_rules.fee_strategy='monetize'`
  - 平台收款账户：环境变量 `PLATFORM_USER_ID`（必须配置且用户存在）
- **三笔资产流水（强幂等）**：同一 `business_id` 三笔都必须可幂等（DB 唯一约束兜底），`business_type` 拆 3 个：
  - `market_purchase_buyer_debit`
  - `market_purchase_seller_credit`
  - `market_purchase_platform_fee_credit`
- **TradeRecord 对账字段（最小够用）**：
  - `trade_type='market_purchase'`
  - `asset_code`（固定 DIAMOND）
  - `gross_amount`（买家支付）
  - `fee_amount`（平台抽成）
  - `net_amount`（卖家实收）
  - `business_id`（幂等键）
- **幂等语义**：
  - 客户端必须提供 `business_id` 或 `Idempotency-Key`（二选一），缺失直接 400
  - 同一幂等键重试：**返回同一成交结果（HTTP 200）**，并返回 `is_duplicate=true`
  - 同一幂等键但参数不一致：HTTP 409（对齐兑换市场现有做法）

### 2.2 兑换市场（材料资产扣减，不做兼容）
- **支付口径**：兑换支付只扣 **材料资产余额**（按商品配置扣减）
- **不做兼容**：运行时不再使用/不再校验：
  - `exchange_items.virtual_value_price`
  - `user_inventory.value / virtual_value_points`
  - `UserPointsAccount.available_points`
- **不允许自动辅助**：材料不足直接失败提示，不在兑换流程里隐式执行任何转换
- **订单支付对账字段（新增字段）**：订单必须能直接对账“扣了哪种材料资产、扣了多少”

---

## 三、数据模型与迁移（按“资产底座统一”收敛，避免过度设计）

### 3.0 为什么需要新资产底座（基于当前代码真实现状）

当前系统只有：
- `user_points_accounts + points_transactions`：承载“积分体系”
- `user_inventory.value`：承载“兑换市场虚拟价值扣减”（并非账本、不可对账、也不适合作为 DIAMOND/material 余额）

因此要实现“DIAMOND + 材料统一账本”，**必须**引入一套最小的“余额表 + 流水表”（参考积分系统的做法，但不复用 points 表）。

### 3.1 统一资产底座（DIAMOND + 材料都用同一套）

新增两张表（统一承载所有资产余额与流水）：
- `user_asset_accounts`
  - `user_id`
  - `asset_code`（包含 `DIAMOND` 以及各类材料 asset code）
  - `available_amount`（BIGINT/DECIMAL 均可；建议 BIGINT，避免浮点）
  - UNIQUE(`user_id`,`asset_code`)
- `asset_transactions`
  - `user_id`
  - `asset_code`
  - `delta_amount`（正负表示增减）
  - `business_id`
  - `business_type`
  - `meta`（JSON，可记录 rule 快照、order_no 等）
  - UNIQUE(`business_id`,`business_type`)

> 说明：材料与 DIAMOND **不分两套表**，只用 `asset_code` 区分，避免两套账本带来的对账与维护成本。

### 3.2 交易市场字段与 TradeRecord 对账字段
- `user_inventory` 新增：
  - `selling_asset_code`（仅允许 DIAMOND）
  - `selling_amount`（售价，单位 DIAMOND）
  - 数据迁移（可重复跑）：`selling_points → selling_amount = ceil(selling_points / 20)`，并回填 `selling_asset_code='DIAMOND'`
- `trade_records`：
  - `trade_type` ENUM 增加 `market_purchase`
  - 新增字段：`asset_code/gross_amount/fee_amount/net_amount/business_id`
  - 建议增加索引：`UNIQUE(business_id)`（只对 trade_type=market_purchase 的新数据强制；历史数据允许 NULL）

### 3.3 兑换市场商品与订单支付字段
- `exchange_items` 新增字段（不做兼容后运行时只认这些字段；后台必须可配置）：
  - `cost_asset_code`
  - `cost_amount`
- `exchange_market_records` 新增字段：
  - `pay_asset_code`
  - `pay_amount`（`cost_amount * quantity` 的总扣减额）
  - `business_id`（当前表已存在且有唯一索引；本期开始强制“新订单必填”）

---

## 四、接口契约（不做兼容的具体含义：直接写死）

### 4.1 市场上架接口（不兼容旧入参）
- **上架入参必须改为**：`selling_amount`（DIAMOND，整数）
- **禁止继续接收**：`selling_points`（收到即 400）
- **上架时强制写入**：`selling_asset_code='DIAMOND'`

### 4.2 市场购买接口幂等键（对齐 exchange_market）
- Body: `business_id` 或 Header: `Idempotency-Key` 二选一
- 缺失返回 400
- 禁止后端兜底生成

### 4.3 兑换接口（材料支付）
- 下单时按 `exchange_items.cost_asset_code/cost_amount` 扣减统一资产余额
- 幂等键沿用现有 `routes/v4/unified-engine/exchange_market.js` 的规范（冲突保护 409、重复返回 `is_duplicate=true`）

---

## 五、执行步骤（按模块拆解，可直接照此落地；不做过度设计）

### 5.0 交付原则（写给“真的要落地”的实现者）

- **优先复用现有习惯**：沿用 `routes/v4/unified-engine/*` + `services/*Service.js` + Sequelize Model/Migration 的组织方式
- **先修“运行时必炸”**再做资产迁移：否则会出现“迁移做完但线上购买直接报错”的尴尬
- **幂等先行**：所有资产变动必须能用 DB 唯一约束兜底（类似 `exchange_market_records.business_id` 的策略）

### 5.1 P0：先消除“运行时必炸”的不一致
- **修复 TradeRecord 枚举**：`models/TradeRecord.js` + DB 迁移，把 `trade_type` 加入 `market_purchase`
- **修复 PointsService 方法名不一致**：
  - 当前 `services/PointsService.js` 实际方法是 `consumePoints()` / `addPoints()`
  - 当前 `services/InventoryService.js` 市场购买调用了 `deductPoints()`（不存在）→ 必须先改到 `consumePoints()`（否则在你切 DIAMOND 前，现网就会炸）

### 5.2 P1：落地统一资产底座（账户 + 流水 + 幂等）
- 新建 `user_asset_accounts` / `asset_transactions`（见 3.1）
- 幂等粒度：`UNIQUE(business_id, business_type)`（对齐兑换市场“DB 唯一约束兜底”的思路）
- 需要一个最小的 `AssetService`（或同名模块）能力清单（不引入复杂域模型）：
  - `getOrCreateAccount(user_id, asset_code, tx)`
  - `changeBalance(user_id, asset_code, delta, {business_id, business_type, meta}, tx)`：内部写 `asset_transactions` 并更新余额
  - `assertSufficient(user_id, asset_code, amount, tx)`：不足直接报错（兑换市场/交易市场都用）

> 备注：这里不引入“资产类型表/版本化规则表/复杂冻结字段”，先把“余额 + 流水 + 幂等”做完整即可满足本期所有需求。

### 5.3 P2：交易市场迁移到 DIAMOND 结算 + 手续费 monetize
- **表结构**：
  - `user_inventory` 新增 `selling_asset_code/selling_amount`（并保留旧字段一段时间用于回滚观测，但业务逻辑不再读）
  - `trade_records` 新增对账字段（见 3.2）
- **数据迁移**（可重复跑，确保幂等）：
  - `selling_amount = ceil(selling_points / 20)`
  - `selling_asset_code='DIAMOND'`
- **上架接口改造（不兼容）**：
  - `routes/v4/unified-engine/inventory-market.js` 的 `POST /market/list`：仅接收 `selling_amount`，直接 400 拒绝 `selling_points`
  - `InventoryService.listProductToMarket()`：写入 `selling_asset_code/selling_amount`，并且市场列表/详情返回也改为 DIAMOND 口径（避免前端继续展示 selling_points）
- **购买接口改造（强幂等 + 手续费 + 资产流水）**：
  - 幂等键：对齐 `exchange_market`（Body `business_id` 或 Header `Idempotency-Key`）
  - 幂等语义：同键重试返回同结果（`is_duplicate=true`），同键参数不一致 409
  - 手续费计算：
    - 开关：`fee_rules.enabled` + `fee_rules.trade_type_fees.market_purchase.enabled`
    - 费率档位：**沿用当前真实分档**（按 `UserInventory.value` 选档：<300 / <600 / ≥600）
    - 手续费金额：按 DIAMOND 成交价 `selling_amount` 计算并向上取整（与 `FeeCalculator` 一致）
  - 三笔流水（同一 `business_id`，三条 `business_type`）：
    - 买家：`-gross_amount`（DIAMOND）
    - 卖家：`+net_amount`（DIAMOND）
    - 平台：`+fee_amount`（DIAMOND，`PLATFORM_USER_ID`）
  - `TradeRecord`：写入 `asset_code/gross_amount/fee_amount/net_amount/business_id`（用于对账）

> 关键点：你要的“monetize 入平台账户”并不需要复杂计费系统，**只需要把手续费那条资产流水记到平台用户**即可。

### 5.4 P3：材料系统（按“统一资产底座”实现）
- **本期最小集**（不做过度设计）：
  - 资产 code 直接用字符串（建议：`DIAMOND`、`red_shard` 等），先不引入“资产类型表”
  - 转换规则先用配置常量/配置文件（可后续再做 DB 化与版本化）
- **必须提供的显式转换能力**：
  - `red_shard -> DIAMOND`，比例 1:20
  - 转换操作必须强幂等：客户端必传 `business_id` 或 `Idempotency-Key`
  - 流水最小要求：同一 `business_id` 下写两条 `asset_transactions`：
    - `material_convert_debit`：`red_shard` 扣减
    - `material_convert_credit`：`DIAMOND` 入账

> 注意：你要求“兑换流程不允许自动辅助转换”，因此这里的转换只提供“显式 API”，兑换服务只做余额不足就失败。

### 5.5 P4：兑换市场支付迁移为材料资产扣减（不做兼容）
- **DB/模型**：
  - `exchange_items`：新增 `cost_asset_code/cost_amount`
  - `exchange_market_records`：新增 `pay_asset_code/pay_amount`
  - `exchange_market_records.business_id`：本期开始“新订单必填”（历史数据可为空）
- **服务改造（不做兼容）**：
  - `services/ExchangeMarketService.js`：
    - 删除/停用 `_getUserTotalVirtualValue/_deductVirtualValue` 在兑换流程中的使用
    - 兑换时只读取 `exchange_items.cost_asset_code/cost_amount`
    - 扣减资产：调用统一资产底座（见 5.2）
    - 订单写入 `pay_asset_code/pay_amount`（`cost_amount * quantity`）
- **后台页面改造（不做兼容）**：
  - `public/admin/exchange-market-items.html`：
    - 表单字段从 `virtual_value_price/points_price` 改为 `cost_asset_code/cost_amount`
    - “price_type 固定 virtual”相关 UI 逻辑可直接移除或改为“材料支付”
  - `public/admin/exchange-market-orders.html`：
    - 支付信息展示从 `virtual_value_paid` 改为 `pay_asset_code/pay_amount`

---

## 六、验收用例矩阵（必须全部通过）

### 6.1 市场购买（开启手续费）
- 开启 `fee_rules.enabled=true` 且 `trade_type_fees.market_purchase.enabled=true`
- 买家扣 gross（DIAMOND，来自 `user_inventory.selling_amount`）
- 卖家入 net（DIAMOND）
- 平台入 fee（DIAMOND，`PLATFORM_USER_ID`）
- TradeRecord：`gross=fee+net`，`asset_code='DIAMOND'`，`business_id` 可对账
- `asset_transactions`：同一 `business_id` 下存在 3 条对应 `business_type`

### 6.2 市场购买（关闭手续费）
- fee=0，卖家入账=售价，平台不入账

### 6.3 市场购买幂等
- 缺幂等键 400
- 同幂等键重复请求：不重复扣款/入账，返回同一成交结果，`is_duplicate=true`
- 同幂等键但参数不同：409（对齐兑换市场现有行为）

### 6.4 兑换市场（材料支付）
- 材料足够：扣减统一资产余额成功，订单写入 `pay_asset_code/pay_amount`
- 材料不足：直接失败，不自动转换
- 幂等：重复请求不重复扣减，返回同一订单

### 6.5 材料 → DIAMOND 显式分解
- `red_shard` 足够：同一 `business_id` 两条流水（材料扣减 + DIAMOND 入账）
- 不足：直接失败
- 幂等：重复请求返回同一结果，不重复扣减/入账

---

## 七、资产 code / 单位 / 金额精度约定（必须写死，避免后续对账争议）

### 7.1 资产 code（实用主义：直接用字符串，不引入资产类型表）

- **DIAMOND**：交易市场唯一结算币种，也是手续费币种
- **材料资产**：兑换市场与材料转换使用材料资产 code（示例）
  - `red_shard`（碎红水晶）

> 说明：资产 code 是“账本维度”，必须稳定；新材料只需要新增 code，不需要改表结构。

### 7.2 金额单位与精度（建议统一整数）

- **建议统一为整数**（`BIGINT` 或 `INT` 视业务上限）：所有资产余额/流水都用整数，避免 `DECIMAL` 的尾差和序列化问题。
- **DIAMOND**：单位为 “1 DIAMOND”
- **材料**：单位为 “1 个材料单位”（例如 1 个 `red_shard`）

---

## 八、配置与开关（与当前代码对齐的最小改造要求）

### 8.1 `fee_rules` 必须补齐 `market_purchase` 开关

当前 `config/fee_rules.js` 的 `trade_type_fees` 只有 `inventory_transfer/point_transfer`，没有 `market_purchase`。

- **必须新增**：`fee_rules.trade_type_fees.market_purchase.enabled`
- **验收口径**：当该开关为 false 时，`fee_amount=0`，平台账户不入账；为 true 时按费率计算并入账平台账户。

### 8.2 `PLATFORM_USER_ID`（平台收款账户）必须新增并强校验

当前仓库代码中尚未出现 `PLATFORM_USER_ID`（需要新增读取与校验）。

- **新增环境变量**：`PLATFORM_USER_ID`
- **强校验口径**（满足任一条件即失败，避免“手续费算了但找不到收款方”）：
  - `fee_rules.enabled=true` 且 `fee_rules.fee_strategy='monetize'` 且 `trade_type_fees.market_purchase.enabled=true`
  - 同时下单路径触发 market_purchase
- **校验内容**：
  - `PLATFORM_USER_ID` 必须存在、是合法整数
  - `users` 表中必须存在该用户

---

## 九、数据库迁移 / 回填 / 发布顺序（按“最少风险、可回滚”）

> 目标：任何一个发布步骤失败，都能回退到“旧逻辑仍可用”，且不会造成资金/资产错误对账。

### 9.1 迁移顺序（建议分 2 次上线）

#### 第一次上线（先把“表与字段”准备好，不切流量）

- **P1**：新增 `user_asset_accounts`、`asset_transactions`
- **P2-结构**：给 `user_inventory` 增加 `selling_asset_code/selling_amount`
- **P2-结构**：给 `trade_records` 增加对账字段（`asset_code/gross_amount/fee_amount/net_amount/business_id`）并补齐 `trade_type='market_purchase'` 枚举
- **P4-结构**：给 `exchange_items` 增加 `cost_asset_code/cost_amount`；给 `exchange_market_records` 增加 `pay_asset_code/pay_amount`

#### 第二次上线（切业务逻辑 + 强制不兼容）

- **交易市场**：
  - 上架接口拒绝 `selling_points`，只收 `selling_amount`
  - 购买接口拒绝缺幂等键（对齐 exchange_market 的路由层风格）
  - 结算切到 DIAMOND 账本 + 手续费（可先让 `trade_type_fees.market_purchase.enabled=false` 灰度）
- **兑换市场**：
  - 兑换支付改为材料资产扣减，完全不再读 `virtual_value_price` / `user_inventory.value`
  - 管理后台字段同步切换

### 9.2 回填策略（必须可重复执行）

#### 市场定价回填（selling_points → selling_amount）

- **目标**：把存量在售商品全部补齐 DIAMOND 售价，便于“切读 selling_amount”后不影响展示/购买。
- **回填口径**：
  - `selling_asset_code='DIAMOND'`
  - `selling_amount = ceil(selling_points / 20)`
  - 仅回填 `market_status='on_sale' AND selling_amount IS NULL`（避免覆盖已人工修正的数据）

---

## 十、接口请求/响应示例与错误码（写清楚给前端/联调用）

> 说明：示例的字段命名遵循你当前项目的风格：`business_id` 优先，Header `Idempotency-Key` 作为等价替代。

### 10.1 交易市场上架（不兼容）

- **接口**：`POST /api/v4/inventory/market/list`
- **请求 Body（示例）**：

```json
{
  "inventory_id": 123,
  "selling_amount": 50,
  "condition": "good"
}
```

- **错误码**：
  - `400 BAD_REQUEST`：缺少 `selling_amount` 或继续传了 `selling_points`

### 10.2 交易市场购买（强幂等）

- **接口**：`POST /api/v4/inventory/market/products/:id/purchase`
- **幂等键（二选一）**：
  - Header：`Idempotency-Key: mp_20251215_xxx`
  - Body：`{"business_id":"mp_20251215_xxx"}`
- **错误码（对齐兑换市场做法）**：
  - `400`：两者都没传
  - `409 IDEMPOTENCY_KEY_CONFLICT`：同一幂等键但请求参数不一致（例如 product_id 不同）

### 10.3 兑换市场下单（材料支付，不做兼容）

- **接口**：`POST /api/v4/exchange_market/exchange`
- **请求 Body（示例）**：

```json
{
  "item_id": 1001,
  "quantity": 2,
  "business_id": "em_20251215_xxx"
}
```

- **订单对账字段（必须返回/存储）**：
  - `pay_asset_code`
  - `pay_amount`

### 10.4 材料→DIAMOND 显式分解（新增能力）

> 这是本期新增能力。路由命名建议继续放在 `routes/v4/unified-engine/` 下，避免另起体系。

- **接口（建议）**：`POST /api/v4/assets/convert`
- **请求 Body（示例）**：

```json
{
  "from_asset_code": "red_shard",
  "from_amount": 20,
  "to_asset_code": "DIAMOND",
  "business_id": "mc_20251215_xxx"
}
```

- **规则写死**：仅允许 `red_shard -> DIAMOND`，比例 `1:20`（本期范围）

---

## 十一、对账 SQL（验收时直接跑）

> 注意：以下 SQL 是验收/排查用，不依赖任何“历史报告”。字段名以本方案新增字段为准。

### 11.1 校验 market_purchase：gross = fee + net

```sql
SELECT
  trade_id,
  business_id,
  asset_code,
  gross_amount,
  fee_amount,
  net_amount,
  (fee_amount + net_amount) AS fee_plus_net
FROM trade_records
WHERE trade_type = 'market_purchase'
  AND business_id IS NOT NULL
  AND gross_amount <> (fee_amount + net_amount)
LIMIT 50;
```

### 11.2 校验 asset_transactions：同一 business_id 必须 3 笔（市场购买）

```sql
SELECT
  business_id,
  COUNT(*) AS tx_count
FROM asset_transactions
WHERE business_type IN (
  'market_purchase_buyer_debit',
  'market_purchase_seller_credit',
  'market_purchase_platform_fee_credit'
)
GROUP BY business_id
HAVING tx_count <> 3
LIMIT 50;
```

### 11.3 校验兑换订单：pay 字段完整

```sql
SELECT
  record_id,
  order_no,
  business_id,
  pay_asset_code,
  pay_amount
FROM exchange_market_records
WHERE business_id IS NOT NULL
  AND (pay_asset_code IS NULL OR pay_amount IS NULL)
LIMIT 50;
```

---

## 十二、管理后台改造映射（避免“接口已改但后台不能配/不能看”）

### 12.1 商品管理页 `public/admin/exchange-market-items.html`

当前页面字段围绕：
- `virtual_value_price`（实际扣减）
- `points_price`（仅展示）
- `price_type` 固定为 `virtual`

本期必须改为：
- `cost_asset_code`（材料 code，如 `red_shard`）
- `cost_amount`（单件成本）

### 12.2 订单管理页 `public/admin/exchange-market-orders.html`

当前页面展示围绕：
- `payment_type` / `virtual_value_paid` / `points_paid`

本期必须改为展示：
- `pay_asset_code` / `pay_amount`

---

## 十三、上线前检查清单（实用主义：10分钟内能完成）

- **配置检查**：
  - `fee_rules.trade_type_fees.market_purchase.enabled` 已配置
  - 如启用 monetize：`PLATFORM_USER_ID` 已配置且 users 表存在该用户
- **幂等检查**：
  - 交易市场购买接口：缺幂等键必 400；同键重复返回 `is_duplicate=true`
  - 兑换市场下单接口：沿用现有幂等语义（400/409/duplicate）
- **对账字段检查**：
  - `trade_records` 新增字段不为空（market_purchase 新单）
  - `exchange_market_records.pay_*` 不为空（新单）
- **资金安全检查**：
  - 任意扣减路径必须先做余额充足校验，不允许出现负余额

