# 业务测试逻辑与诊断指南

## 📋 文档性质

> **这是一份测试体系完善文档**
> 
> 本文档的核心目标是：
> 1. **定义测试标准** - 明确各类测试的验证目标、通过标准、超时设置
> 2. **规划测试开发** - 列出待创建的测试文件清单（TDD：先创建测试，倒逼实现）
> 3. **指导测试执行** - 提供测试命令、数据准备、结果验证方法
> 4. **记录测试方法论** - 沉淀测试思路、诊断技巧、最佳实践

---

## 📝 更新日志

> **最后更新：2026-01-28**
>
> **本次更新内容**：
> - ✅ 新增 **附录 G 测试开发计划（TDD）**：待创建测试文件清单，先创建测试（会失败）倒逼实现
> - ✅ 新增 **测试数据管理 - 大规模测试积分准备**：10000 次抽奖需 100 万积分，提供自动充值方案
> - ✅ 创建 `tests/helpers/test-points-setup.js`：测试前积分充值工具
> - ✅ 更新 **6.6 概率验证测试**：添加自动化测试实现和测试前积分准备说明
> - ✅ 更新 **灰度发布状态**：已有 `FeatureFlag` 模型支持
>
> **历史更新**：
> - Pipeline 验证改为引用 `tests/integration/pipeline_full_flow.test.js` 集成测试
> - 并发测试部分标注待创建 `tests/integration/concurrent_lottery.test.js`
> - 新增 6.4-6.8 章节：用户异常行为、运营配置、概率验证、风控规则、熔断降级测试
> - 新增附录 F 推荐架构方案

---

## ⚙️ 测试体系规则

> ⛔ **禁止实施的功能（除非明确授权）**：
> - ~~**灰度发布** - 不实施~~ → 已有 `FeatureFlag` 模型，支持 Feature Flag 控制
> - **A/B 测试** - 不实施  
> - **混沌工程** - 不实施

---

> 🔴 **强制规定：测试体系必须对齐实际代码**
> - **禁止引用**：历史报告、其它报告、外部文档
> - **必须对齐**：当前实际代码状态、数据库真实数据
> - **必须了解**：项目的实际业务逻辑、商业模式、技术框架技术路线
> - **验证方法**：所有测试脚本必须能在当前代码库上直接运行

---

> 🧪 **测试开发策略（TDD）**：
> - **先创建测试**：测试用例先行，会失败（因为功能未实现或未完善）
> - **倒逼实现**：根据测试失败原因，推动功能实现
> - **全部自动化**：所有测试脚本放在 `tests/` 目录下，通过 Jest 自动执行

---

## 📑 目录

| 章节 | 内容 | 说明 |
|------|------|------|
| [一、测试流程概述](#一测试流程概述) | 六阶段测试流程 | 技术栈、核心模块、**模块覆盖分析** |
| [二、阶段 1：基础设施验证](#二阶段-1基础设施验证) | PM2/Redis/MySQL | 环境检查 |
| [三、阶段 2：代码质量检查](#三阶段-2代码质量检查) | ESLint + Prettier | 代码规范 |
| [四、阶段 3：自动化测试套件](#四阶段-3自动化测试套件) | Jest + SuperTest | 测试框架、目录结构、代码模式 |
| [五、阶段 4：核心业务 API 测试](#五阶段-4核心业务-api-测试) | 6 大业务模块 | API 手工测试 |
| [六、阶段 5：数据库数据验证](#六阶段-5数据库数据验证nodejs-脚本) | Node.js 脚本 | 真实数据验证 |
| [七、阶段 6：性能与并发测试](#七阶段-6性能与并发测试) | 响应时间/并发 | 性能基准 |
| [八、问题诊断流程](#八问题诊断流程) | 日志分析/根因分析 | 故障排查 |
| [九、常见问题诊断案例](#九常见问题诊断案例) | 5 个典型案例 | 实战经验 |
| [十、测试完整性验证清单](#十测试完整性验证清单) | 提交前检查 | Checklist |
| [十一、核心测试原则](#十一核心测试原则) | 6 大原则 | 方法论 |
| [十二、常用命令速查](#十二常用命令速查) | 常用命令 | 快速参考 |
| [附录](#附录) | 账号/模型图/脚本/架构方案/TDD计划 | 参考资料 |

### 模块覆盖分析子目录

| 分类 | 链接 | 模块数 |
|------|------|--------|
| 已覆盖模块 | [✅ 已覆盖模块（6 个）](#-已覆盖模块6-个) | 6 |
| P0 优先级 | [🔴 核心业务（4 个）](#-p0-优先级核心业务) | 4 |
| P1 优先级 | [🟡 运营功能（4 个）](#-p1-优先级运营功能) | 4 |
| P2 优先级 | [🟢 辅助功能（6 个）](#-p2-优先级辅助功能) | 6 |
| 覆盖率统计 | [📈 覆盖率统计](#-覆盖率统计) | 30% |

### 阶段 3 测试框架子目录

| 内容 | 链接 | 说明 |
|------|------|------|
| 测试框架技术栈 | [测试框架技术栈](#测试框架技术栈) | Jest + SuperTest |
| 测试目录结构 | [测试目录结构（完整）](#测试目录结构完整) | `tests/` 完整结构 |
| Jest 配置 | [Jest 配置说明](#jest-配置说明jestconfigjs) | 超时、覆盖率、并发 |
| 测试数据管理 | [测试数据管理机制](#测试数据管理机制) | 单一真相源 |
| 测试代码模式 | [测试代码模式示例](#测试代码模式示例) | 4 种测试模式 |

### 阶段 4 子目录

| 模块 | 链接 |
|------|------|
| 4.1 认证模块 | [认证模块测试](#41-认证模块测试) |
| 4.2 抽奖模块 | [抽奖模块测试（含 Pipeline 分阶段验证）](#42-抽奖模块测试含-pipeline-分阶段验证) |
| 4.3 交易市场 | [交易市场模块测试](#43-交易市场模块测试) |
| 4.4 资产系统 | [资产系统模块测试](#44-资产系统模块测试) |
| 4.5 背包模块 | [背包模块测试](#45-背包模块测试) |
| 4.6 消费记录 | [消费记录模块测试](#46-消费记录模块测试) |

### 阶段 5 子目录

| 验证项 | 链接 |
|--------|------|
| 5.0 脚本一览 | [项目现有验证脚本一览](#50-项目现有验证脚本一览) |
| 5.1 抽奖对账 | [抽奖一致性对账](#51-抽奖一致性对账现有脚本) |
| 5.2 消费对账 | [消费一致性对账](#52-消费一致性对账现有脚本) |
| 5.3 兑换对账 | [兑换一致性对账](#53-兑换一致性对账现有脚本) |
| 5.4 数据库检查 | [数据库连接与完整性检查](#54-数据库连接与完整性检查现有脚本) |
| 5.5 综合验证 | [综合验证检查](#55-综合验证检查现有脚本) |

### 阶段 6 子目录

| 内容 | 链接 | 说明 |
|------|------|------|
| 6.1 响应时间 | [响应时间基准测试](#61-响应时间基准测试) | API 响应时间 < 500ms |
| 6.2 并发测试 | [并发竞态测试](#62-并发竞态测试) | 多用户/多设备并发 |
| 6.3 幂等性 | [幂等性验证](#63-幂等性验证) | Idempotency-Key |
| 6.4 用户异常行为 | [用户异常行为测试](#64-用户异常行为测试防无脑用法) | **防"无脑用法"** |
| 6.5 运营配置 | [运营配置动态调整测试](#65-运营配置动态调整测试) | 配置热加载、开关切换 |
| 6.6 概率验证 | [概率验证测试](#66-概率验证测试数值平衡) | 概率分布、保底机制 |
| 6.7 风控规则 | [风控规则测试](#67-风控规则测试) | 限流、黑名单、异常检测 |
| 6.8 熔断降级 | [熔断降级测试](#68-熔断降级测试) | Redis/DB 不可用时优雅降级 |

---

## 一、测试流程概述

测试流程遵循"**由外到内、由浅入深**"的原则，分为以下六个阶段：

```
┌─────────────────────────────────────────────────────────────────┐
│  阶段1: 基础设施验证（PM2/Redis/MySQL）                           │
│  ↓                                                               │
│  阶段2: 代码质量检查（ESLint + Prettier）                          │
│  ↓                                                               │
│  阶段3: 自动化测试套件（Jest + SuperTest）                         │
│  ↓                                                               │
│  阶段4: 核心业务 API 测试（按模块分类）                            │
│  ↓                                                               │
│  阶段5: 数据库数据验证（Node.js 脚本连接真实数据库）                │
│  ↓                                                               │
│  阶段6: 性能与并发测试                                            │
└─────────────────────────────────────────────────────────────────┘
```

### 项目技术栈

| 组件 | 技术选型 | 说明 |
|------|----------|------|
| 运行时 | Node.js 20+ | Express 框架 |
| 数据库 | MySQL | Sequelize ORM |
| 缓存 | Redis | ioredis 客户端 |
| 认证 | JWT | RBAC 权限控制 |
| 实时通信 | Socket.io | WebSocket |
| 时区 | 北京时间 | 全链路 UTC+8 |

### 核心业务模块

| 模块 | 涉及模型 | API 路径 |
|------|----------|----------|
| 认证系统 | User, Role, UserRole, AuthenticationSession | `/api/v4/auth/*` |
| 抽奖系统 | LotteryCampaign, LotteryPrize, LotteryDraw, LotteryDrawDecision | `/api/v4/lottery/*` |
| 资产系统 | Account, AccountAssetBalance, AssetTransaction | `/api/v4/assets/*` |
| 交易市场 | MarketListing, TradeOrder, ItemInstance | `/api/v4/market/*` |
| 背包系统 | ItemInstance, ItemInstanceEvent, RedemptionOrder | `/api/v4/backpack/*` |
| 消费记录 | ConsumptionRecord, ContentReviewRecord | `/api/v4/merchant-points/*` |

### 📊 模块覆盖分析

#### ✅ 已覆盖模块（6 个）

| 模块 | 涉及模型 | 覆盖程度 | 说明 |
|------|----------|----------|------|
| 认证系统 | User, AuthenticationSession | ⭐⭐⭐ 基础 | 登录/注册/Token 验证 |
| 抽奖系统 | LotteryCampaign, LotteryPrize, LotteryDraw | ⭐⭐⭐⭐ 详细 | Pipeline 分阶段、事务验证 |
| 交易市场 | MarketListing, TradeOrder | ⭐⭐⭐ 基础 | 挂牌/购买/撤回流程 |
| 资产系统 | Account, AccountAssetBalance, AssetTransaction | ⭐⭐⭐ 基础 | 余额/冻结/流水 |
| 背包系统 | ItemInstance, RedemptionOrder | ⭐⭐⭐ 基础 | 物品/核销码 |
| 消费记录 | ConsumptionRecord, ContentReviewRecord | ⭐⭐ 简要 | 审核/积分发放 |

#### ❌ 未覆盖模块（需完善）

##### 🔴 P0 优先级（核心业务）

| 模块 | 涉及模型 | 说明 | 测试重点 |
|------|----------|------|----------|
| **用户权限系统** | Role, UserRole, UserHierarchy | 角色分配、层级关系验证 | RBAC 权限校验、角色继承 |
| **客服聊天系统** | CustomerServiceSession, ChatMessage | WebSocket 消息、会话状态 | 实时消息、会话管理 |
| **兑换商城系统** | ExchangeItem, ExchangeRecord | B2C 兑换流程 | 库存扣减、兑换记录 |
| **材料转换系统** | MaterialAssetType, MaterialConversionRule | 多币种转换、套利检测 | 转换规则、汇率验证 |

##### 🟡 P1 优先级（运营功能）

| 模块 | 涉及模型 | 说明 | 测试重点 |
|------|----------|------|----------|
| **抽奖高级功能** | LotteryTierRule, LotteryUserExperienceState, LotteryUserGlobalState | Pity保底、运气债务机制 | 保底触发、状态累计 |
| **抽奖监控指标** | LotteryHourlyMetrics, LotteryDailyMetrics | 空奖率、档位分布统计 | 统计准确性、异常告警 |
| **抽奖管理干预** | LotteryManagementSetting, PresetInventoryDebt, PresetBudgetDebt | 预设发放、欠账管理 | 干预生效、欠账清算 |
| **门店管理系统** | Store, StoreStaff, AdministrativeRegion | 门店员工、区域管理 | 组织架构、权限继承 |

##### 🟢 P2 优先级（辅助功能）

| 模块 | 涉及模型 | 说明 | 测试重点 |
|------|----------|------|----------|
| **系统配置** | SystemSettings, SystemDictionary, FeatureFlag | 配置管理、功能开关 | 配置生效、灰度发布 |
| **审计日志** | AdminOperationLog, MerchantOperationLog | 操作追溯、合规审计 | 日志完整性、不可篡改 |
| **风控系统** | UserRiskProfile, RiskAlert | 交易风控、告警管理 | 风险识别、告警触发 |
| **高级会员** | UserPremiumStatus | 高级空间解锁 | 订阅状态、权益验证 |
| **反馈公告** | Feedback, SystemAnnouncement, PopupBanner | 用户反馈、弹窗管理 | 展示逻辑、状态管理 |
| **物品模板** | ItemTemplate, CategoryDef, RarityDef | 物品定义、分类字典 | 模板继承、字典一致性 |

#### 📈 覆盖率统计

```
已覆盖: 6 模块 ████████░░░░░░░░░░ 30%
待完善: 14 模块 ░░░░░░░░░░░░░░░░░░ 70%

按优先级:
- P0 (核心): 4 模块 - 用户权限/客服聊天/兑换商城/材料转换
- P1 (运营): 4 模块 - 抽奖高级/监控指标/管理干预/门店管理  
- P2 (辅助): 6 模块 - 系统配置/审计日志/风控/会员/反馈/物品模板
```

---

## 二、阶段 1：基础设施验证

### 目的

确保测试环境可用，避免在环境问题上浪费时间。

### 检查项目

| 检查项 | 命令 | 期望结果 |
|--------|------|----------|
| PM2 进程状态 | `pm2 status` | `online` 状态 |
| Redis 连接 | `redis-cli ping` | `PONG` |
| 健康检查端点 | `curl http://localhost:3000/health` | `SYSTEM_HEALTHY` |
| 数据库连接 | 健康检查返回 `database: connected` | 已连接 |

### 命令示例

```bash
# 检查 PM2 状态
pm2 status

# 检查 Redis
redis-cli ping

# 健康检查
curl -s http://localhost:3000/health | head -50

# 统一启动服务
npm run pm:start:pm2
```

### Node.js 数据库连接验证

由于项目没有安装 MySQL 客户端，使用项目现有脚本验证：

```bash
# 方式 1：使用现有验证脚本
node scripts/validation/check_db_connections.js

# 方式 2：使用数据库工具包
npm run test:database

# 方式 3：使用预启动检查
npm run validate:full
```

**现有验证脚本说明**：

| 脚本 | 命令 | 用途 |
|------|------|------|
| `check_db_connections.js` | `npm run monitor:db` | 数据库连接池监控 |
| `database_toolkit.js` | `npm run test:database` | 数据库完整性检查 |
| `pre_start_check.js` | `npm run validate:prestart` | 启动前预检查 |

### 原理说明

如果基础设施有问题，后续所有测试都没有意义。先排除环境因素，再进行业务测试。

---

## 三、阶段 2：代码质量检查

### 目的

确保代码符合团队规范，减少运行时错误。

### 执行内容

| 工具 | 作用 | 命令 |
|------|------|------|
| ESLint | 语法检查、未使用变量、风格问题 | `npm run lint` |
| Prettier | 代码格式一致性 | `npm run format:check` |

### 处理策略

- **后端代码问题**：立即修复
- **前端代码问题**：排除在检查范围外（通过 `.eslintignore` 配置）

### 命令示例

```bash
# 运行 ESLint 检查
npm run lint

# 自动修复
npm run lint:fix

# Prettier 格式化
npm run format
```

---

## 四、阶段 3：自动化测试套件

### 目的

验证已有的单元测试和集成测试是否通过。

### 测试框架技术栈

| 组件 | 技术选型 | 用途 |
|------|----------|------|
| 测试框架 | **Jest** | 单元/集成测试运行器 |
| HTTP 测试 | **SuperTest** | API 端点测试 |
| 数据库 | MySQL（真实数据库） | 测试使用真实数据库 `restaurant_points_dev` |
| 断言库 | Jest 内置 expect | 断言验证 |
| 配置管理 | dotenv | 环境变量从 `.env` 加载 |

### 测试目录结构（完整）

```
tests/                              # 测试根目录
├── api/                            # API 层测试
│   ├── core/                       # 核心 API 测试
│   ├── helpers/                    # API 测试辅助
│   └── TestCoordinator.js          # 测试协调器
│
├── api-contracts/                  # API 契约测试
│
├── business/                       # 业务逻辑测试
│   └── lottery/
│       ├── sort_order.test.js      # 排序逻辑测试
│       └── preset.test.js          # 预设功能测试
│
├── config/                         # 测试配置
│
├── core/                           # 核心功能测试
│   ├── audit_target_type_normalization.test.js  # 审计类型规范化
│   ├── c2c_asset_blacklist.test.js              # C2C 资产黑名单
│   ├── test_data_initialization.test.js         # 测试数据初始化
│   └── transaction_manager_error_classification.test.js  # 事务错误分类
│
├── critical/                       # 关键路径测试
│
├── helpers/                        # 🔧 测试辅助工具（重要）
│   ├── auth-helper.js              # 认证辅助
│   ├── ModelAssociationManager.js  # 模型关联管理
│   ├── test-data.js                # 📌 统一测试数据中心
│   ├── test-quality-reporter.js    # 测试质量报告
│   ├── test-setup.js               # 📌 测试环境配置
│   └── UnifiedTestManager.js       # 📌 统一服务管理
│
├── integration/                    # ⭐ 集成测试（主要）
│   ├── activity_conditions.test.js          # 活动条件
│   ├── audit_log.test.js                    # 审计日志
│   ├── backpack-redemption.test.js          # 背包核销
│   ├── campaign_preset_budget_policy.test.js # 活动预算策略
│   ├── concurrent_chat_session.test.js      # 并发聊天会话
│   ├── fee_calculation.test.js              # 手续费计算
│   ├── fungible-asset-listing.test.js       # 同质化资产挂牌
│   ├── multi_currency_fee.test.js           # 多币种手续费
│   ├── pipeline_full_flow.test.js           # 📌 Pipeline 完整流程
│   └── redemption-fixes-validation.test.js  # 核销修复验证
│
├── middleware/                     # 中间件测试
│   └── market_risk_control_middleware.test.js  # 市场风控中间件
│
├── services/                       # 服务层测试
│   └── fee_calculator.test.js      # 手续费计算器
│
├── shared/                         # 共享测试资源
│
├── specialized/                    # 专项测试
│
├── unit/                           # 单元测试
│   └── compute/                    # 计算逻辑单元测试
│
├── p1-validation.test.js           # P1 优先级验证（完整版）
└── p1-validation-simple.test.js    # P1 优先级验证（简化版）
```

### Jest 配置说明（jest.config.js）

| 配置项 | 值 | 说明 |
|--------|-----|------|
| testEnvironment | `node` | Node.js 测试环境 |
| testMatch | `**/tests/**/*.test.js` | 测试文件匹配 |
| testTimeout | `30000` | 超时时间 30 秒 |
| maxConcurrency | `5` | 最大并发 5 |
| setupFilesAfterEnv | `jest.setup.js`, `test-setup.js` | 初始化文件 |
| coverageThreshold | branches: 60%, lines: 70% | 覆盖率阈值 |
| forceExit | `true` | 测试完成后强制退出 |
| detectOpenHandles | `true` | 检测未关闭句柄 |

### 测试数据管理机制

#### 单一真相源原则

```javascript
// jest.setup.js - 全局初始化
global.beforeAll(async () => {
  // 1. 初始化 ServiceManager
  await initializeTestServiceManager()
  
  // 2. 从真实数据库加载测试数据
  const testData = await initRealTestData('13612227930')
  
  // 3. 存储到 global 供所有测试使用
  global.testData = {
    testUser: { user_id, mobile },
    testCampaign: { campaign_id, campaign_code }
  }
})
```

#### 测试数据获取方式

```javascript
// tests/helpers/test-data.js
const TEST_DATA = {
  users: {
    get testUser() {
      return {
        user_id: global.testData?.testUser?.user_id,  // 动态获取
        mobile: '13612227930'
      }
    }
  }
}
```

#### 大规模测试积分准备（10000 次抽奖）

> 🎰 **业务背景**：概率验证测试需要 10000 次抽奖样本，需提前为测试用户充值足够积分。

**抽奖消耗资产分析**（基于实际代码 `SettleStage.js`）：

| 资产类型 | 用途 | 消耗来源 | 单次消耗 |
|----------|------|----------|----------|
| `POINTS` | 抽奖费用 | `system_settings.lottery_cost_points` | 100 积分/次 |
| `BUDGET_POINTS` | 用户预算（可选） | 仅 `budget_mode='user'` 活动 | 按奖品价值 |

**10000 次抽奖所需积分**：

```
最大消耗 = 10000 × 100 = 1,000,000 POINTS
连抽折扣后（10连九折） ≈ 900,000 POINTS
建议充值量 = 1,500,000 POINTS（预留余量）
```

**测试前积分充值脚本**（`tests/helpers/test-points-setup.js`）：

```javascript
/**
 * 为测试用户充值足够积分
 * 使用场景：概率验证测试（10000 次）、并发测试、边界测试
 * 
 * @file tests/helpers/test-points-setup.js
 */
const { sequelize } = require('../../config/database')
const AssetService = require('../../services/AssetService')
const { getRealTestUserId } = require('./test-setup')
const { v4: uuidv4 } = require('uuid')

/**
 * 确保测试用户有足够积分
 * @param {number} requiredPoints - 需要的积分数量（默认 1,500,000）
 * @returns {Promise<{user_id: number, before: number, after: number, added: number}>}
 */
async function ensureTestUserHasPoints(requiredPoints = 1500000) {
  const user_id = await getRealTestUserId()
  if (!user_id) throw new Error('测试用户未初始化')

  const transaction = await sequelize.transaction()
  
  try {
    // 1. 查询当前余额
    const currentBalance = await AssetService.getBalance(user_id, 'POINTS', { transaction })
    
    // 2. 计算需要充值的金额
    const shortage = requiredPoints - (currentBalance || 0)
    
    if (shortage <= 0) {
      await transaction.commit()
      console.log(`✅ 测试用户积分充足: ${currentBalance} >= ${requiredPoints}`)
      return { user_id, before: currentBalance, after: currentBalance, added: 0 }
    }

    // 3. 充值积分
    await AssetService.changeBalance({
      user_id,
      asset_code: 'POINTS',
      delta_amount: shortage,
      business_type: 'test_topup',
      idempotency_key: `test_topup_${user_id}_${uuidv4()}`,
      meta: { reason: '测试积分充值', test_name: 'probability_verification' }
    }, { transaction })

    await transaction.commit()
    
    const newBalance = currentBalance + shortage
    console.log(`✅ 测试用户积分充值完成: ${currentBalance} + ${shortage} = ${newBalance}`)
    
    return { user_id, before: currentBalance, after: newBalance, added: shortage }
  } catch (error) {
    await transaction.rollback()
    throw error
  }
}

module.exports = { ensureTestUserHasPoints }
```

**在测试中使用**：

```javascript
// tests/specialized/probability_verification.test.js
const { ensureTestUserHasPoints } = require('../helpers/test-points-setup')

describe('概率验证测试', () => {
  beforeAll(async () => {
    // 确保有 150 万积分用于 10000 次抽奖
    await ensureTestUserHasPoints(1500000)
  }, 60000) // 60 秒超时

  test('10000 次抽奖概率分布验证', async () => {
    // ... 测试逻辑
  })
})
```

### 测试代码模式示例

#### 模式 1：集成测试（API + 数据库）

```javascript
// tests/integration/pipeline_full_flow.test.js
const request = require('supertest')
const app = require('../../app')
const { TEST_DATA } = require('../helpers/test-data')

describe('🎯 Pipeline 架构完整业务流程测试', () => {
  let authToken, testUserId

  beforeAll(async () => {
    // 登录获取 token
    const response = await request(app)
      .post('/api/v4/auth/login')
      .send({ mobile: TEST_DATA.users.testUser.mobile, verification_code: '123456' })
    
    authToken = response.body.data.access_token
    testUserId = response.body.data.user.user_id
  })

  test('单抽功能验证', async () => {
    const response = await request(app)
      .post('/api/v4/lottery/draw')
      .set('Authorization', `Bearer ${authToken}`)
      .send({ campaign_code: 'DEFAULT', draw_count: 1 })
    
    expect(response.status).toBe(200)
    expect(response.body.success).toBe(true)
  })
})
```

#### 模式 2：服务层单元测试

```javascript
// tests/services/fee_calculator.test.js
const FeeCalculator = require('../../services/FeeCalculator')

describe('手续费计算测试', () => {
  test('低价值商品费率 5%', () => {
    const feeInfo = FeeCalculator.calculateItemFee(200, 180)
    expect(feeInfo.fee).toBe(9)       // 180 * 0.05
    expect(feeInfo.rate).toBe(0.05)
    expect(feeInfo.net_amount).toBe(171)
  })
})
```

#### 模式 3：数据库验证测试

```javascript
// tests/p1-validation-simple.test.js
const { sequelize } = require('../models')

describe('数据库字段验证', () => {
  test('user_id 字段应该不存在（已迁移到 account_id）', async () => {
    const [columns] = await sequelize.query(`
      SELECT COLUMN_NAME FROM information_schema.COLUMNS
      WHERE TABLE_SCHEMA = DATABASE()
        AND TABLE_NAME = 'asset_transactions'
        AND COLUMN_NAME = 'user_id'
    `)
    expect(columns).toHaveLength(0)  // 字段已删除
  })
})
```

#### 模式 4：通过 ServiceManager 获取服务

```javascript
// P1-9 J2-RepoWide 规范
describe('服务层测试', () => {
  test('TradeOrderService.createOrder 应该存在', () => {
    // 通过 global.getTestService 获取服务（snake_case key）
    const TradeOrderService = global.getTestService('trade_order')
    expect(TradeOrderService).toBeDefined()
    expect(typeof TradeOrderService.createOrder).toBe('function')
  })
})
```

### 执行测试命令

```bash
# 运行全部测试
npm test

# 运行特定目录
npm test -- tests/integration/

# 运行单个文件
npm test -- tests/integration/pipeline_full_flow.test.js

# 运行特定测试（匹配描述）
npm test -- -t "单抽功能验证"

# 生成覆盖率报告
npm test -- --coverage

# 监视模式（开发时使用）
npm test -- --watch
```

### 关注指标

| 指标 | 说明 | 期望 |
|------|------|------|
| 通过数量 | passed tests | 尽可能高 |
| 失败数量 | failed tests | **0** |
| 跳过数量 | skipped tests | 合理范围内 |
| 覆盖率 | branches/lines/functions | ≥ 70% |

---

## 五、阶段 4：核心业务 API 测试

这是最主要的测试环节，因为自动化测试可能覆盖不到所有真实场景。

### 测试 API 选择标准

1. **高频使用的核心功能**（如：登录、抽奖）
2. **涉及数据库写操作的接口**（如：下单、资产变更）
3. **涉及事务处理的复杂业务**（如：多连抽）

---

### 4.1 认证模块测试

#### 步骤 1：获取认证 Token

```bash
# 使用验证码登录
curl -s -X POST http://localhost:3000/api/v4/auth/login-code \
  -H "Content-Type: application/json" \
  -d '{"mobile": "13612227930", "code": "123456"}'
```

提取返回的 `access_token` 并保存：

```bash
export TOKEN="eyJhbGciOiJIUzI1NiIs..."
```

#### 步骤 2：验证 Token 有效性

```bash
# 获取用户信息
curl -s http://localhost:3000/api/v4/user/profile \
  -H "Authorization: Bearer $TOKEN"
```

#### 数据库验证（Node.js 脚本）

```javascript
// 验证认证会话记录
const { AuthenticationSession, User } = require('../../models')

async function verifyAuthSession(userId) {
  const session = await AuthenticationSession.findOne({
    where: { user_id: userId, status: 'active' }
  })
  
  if (session) {
    console.log('✅ 认证会话存在:', {
      session_id: session.user_session_id,
      expires_at: session.expires_at
    })
  } else {
    console.log('❌ 未找到活跃的认证会话')
  }
}
```

---

### 4.2 抽奖模块测试（含 Pipeline 分阶段验证）

#### 4.2.1 基础抽奖测试

```bash
# 单抽测试
curl -s -X POST http://localhost:3000/api/v4/lottery/draw \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer $TOKEN" \
  -H "Idempotency-Key: lottery_draw_$(date +%s)_test" \
  -d '{"campaign_code": "BASIC_LOTTERY"}'
```

```bash
# 多连抽测试
curl -s -X POST http://localhost:3000/api/v4/lottery/draw \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer $TOKEN" \
  -H "Idempotency-Key: lottery_draw_$(date +%s)_multi" \
  -d '{"campaign_code": "BASIC_LOTTERY", "draw_count": 3}'
```

#### 4.2.2 Pipeline Stage 分阶段验证

抽奖系统使用 Pipeline 架构，包含以下 Stage：

| Stage | 功能 | 验证方法 |
|-------|------|----------|
| `EligibilityStage` | 用户资格校验 | 查询 `users` 表的 `status`、`available_points` |
| `LoadCampaignStage` | 活动配置加载 | 查询 `lottery_campaigns` 表的有效期和状态 |
| `PricingStage` | 定价计算 | 查询 `lottery_campaign_pricing_config` 表 |
| `BudgetContextStage` | 预算上下文 | 验证预算模式配置 |
| `BuildPrizePoolStage` | 奖品池构建 | 查询 `lottery_prizes` 库存 > 0 的奖品 |
| `TierPickStage` | 档位选择 | 查询 `lottery_tier_rules` 权重配置 |
| `PrizePickStage` | 奖品选择 | 验证选奖逻辑 |
| `GuaranteeStage` | 保底机制 | 验证 Pity 触发条件 |
| `SettleStage` | 结算写入 | 验证三表（asset_transactions + lottery_draws + item_instances）一致性 |
| `DecisionSnapshotStage` | 决策快照 | 验证 `lottery_draw_decisions` 记录完整性 |

**Pipeline 验证方式（使用现有集成测试）**：

```bash
# 运行 Pipeline 完整流程集成测试
npm test -- tests/integration/pipeline_full_flow.test.js

# 运行单个测试用例
npm test -- tests/integration/pipeline_full_flow.test.js -t "单抽功能验证"
```

**集成测试位置**：`tests/integration/pipeline_full_flow.test.js`

该测试已覆盖：
- 用户资格校验（EligibilityStage）
- 活动配置加载（LoadCampaignStage）
- 单抽/多连抽完整流程
- 事务原子性验证
- 三表一致性验证（asset_transactions + lottery_draws + item_instances）

#### 4.2.3 SettleStage 三表一致性验证

抽奖结算涉及三张表的原子写入，使用**现有对账脚本**进行验证：

```bash
# 执行抽奖一致性对账
node scripts/reconciliation/check_lottery_consistency.js
```

**验证内容**：
- 按 `lottery_session_id` 聚合检查
- 验证：`SUM(lottery_draws.cost_points)` = `|asset_transaction.delta_amount|`
- 检测孤立的资产流水记录
- 检测缺失 `lottery_session_id` 的抽奖记录

#### 4.2.4 事务原子性验证

使用**现有诊断脚本**验证事务原子性：

```bash
# 抽奖账本验证
node scripts/diagnostic/verify_lottery_ledger.js

# 抽奖交易检查
node scripts/diagnostic/check_lottery_txns.js
```

**验证内容**：
- 孤立资产流水检测（有流水无对应抽奖记录）
- 不完整抽奖记录检测（缺失 `asset_transaction_id`）
- 决策快照完整性检测

---

### 4.3 交易市场模块测试

#### 4.3.1 挂牌流程测试

```bash
# 创建挂牌
curl -s -X POST http://localhost:3000/api/v4/market/listings \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer $TOKEN" \
  -d '{
    "item_instance_id": 123,
    "price": 100,
    "asset_code": "DIAMOND"
  }'

# 撤回挂牌
curl -s -X DELETE http://localhost:3000/api/v4/market/listings/456 \
  -H "Authorization: Bearer $TOKEN"

# 购买挂牌
curl -s -X POST http://localhost:3000/api/v4/market/listings/456/buy \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer $TOKEN" \
  -H "Idempotency-Key: market_buy_$(date +%s)_test"
```

#### 4.3.2 交易市场数据验证

```javascript
// scripts/test/verify_market_consistency.js
require('dotenv').config()
const { 
  MarketListing, 
  TradeOrder, 
  ItemInstance,
  AccountAssetBalance,
  sequelize 
} = require('../../models')

async function verifyMarketConsistency() {
  console.log('🔍 验证交易市场数据一致性...\n')
  
  // 1. 验证挂牌状态与物品状态同步
  console.log('📋 [挂牌-物品状态同步验证]')
  const [mismatchedListings] = await sequelize.query(`
    SELECT ml.listing_id, ml.status as listing_status, 
           ii.item_instance_id, ii.status as item_status
    FROM market_listings ml
    JOIN item_instances ii ON ml.item_instance_id = ii.item_instance_id
    WHERE (ml.status = 'on_sale' AND ii.status != 'locked')
       OR (ml.status = 'sold' AND ii.status = 'locked')
  `)
  
  if (mismatchedListings.length > 0) {
    console.log('   ⚠️ 发现状态不一致的挂牌:')
    mismatchedListings.forEach(m => {
      console.log(`   - listing_id: ${m.listing_id}, listing_status: ${m.listing_status}, item_status: ${m.item_status}`)
    })
  } else {
    console.log('   ✅ 挂牌状态与物品状态一致')
  }
  
  // 2. 验证交易订单金额一致性
  console.log('\n📋 [订单金额一致性验证]')
  const [invalidOrders] = await sequelize.query(`
    SELECT order_id, gross_amount, fee_amount, net_amount
    FROM trade_orders
    WHERE gross_amount != fee_amount + net_amount
  `)
  
  if (invalidOrders.length > 0) {
    console.log('   ⚠️ 发现金额不一致的订单:')
    invalidOrders.forEach(o => {
      console.log(`   - order_id: ${o.order_id}, gross: ${o.gross_amount}, fee: ${o.fee_amount}, net: ${o.net_amount}`)
    })
  } else {
    console.log('   ✅ 所有订单金额一致 (gross = fee + net)')
  }
  
  // 3. 验证交易订单与挂牌关联
  console.log('\n📋 [订单-挂牌关联验证]')
  const [orphanOrders] = await sequelize.query(`
    SELECT to_.order_id, to_.listing_id
    FROM trade_orders to_
    LEFT JOIN market_listings ml ON to_.listing_id = ml.listing_id
    WHERE ml.listing_id IS NULL
  `)
  
  if (orphanOrders.length > 0) {
    console.log('   ⚠️ 发现孤立的订单记录:')
  } else {
    console.log('   ✅ 所有订单都有对应的挂牌记录')
  }
  
  console.log('\n📊 交易市场验证完成')
}

verifyMarketConsistency()
  .then(() => process.exit(0))
  .catch(err => {
    console.error(err)
    process.exit(1)
  })
```

---

### 4.4 资产系统模块测试

#### 4.4.1 资产查询测试

```bash
# 查询用户资产余额
curl -s http://localhost:3000/api/v4/assets/balance \
  -H "Authorization: Bearer $TOKEN"

# 查询资产流水
curl -s http://localhost:3000/api/v4/assets/transactions?limit=10 \
  -H "Authorization: Bearer $TOKEN"
```

#### 4.4.2 资产系统数据验证

```javascript
// scripts/test/verify_asset_consistency.js
require('dotenv').config()
const { 
  Account,
  AccountAssetBalance, 
  AssetTransaction,
  sequelize 
} = require('../../models')
const { Op } = require('sequelize')

async function verifyAssetConsistency() {
  console.log('🔍 验证资产系统数据一致性...\n')
  
  // 1. 验证账户余额连续性（通过流水计算）
  console.log('📋 [余额连续性验证]')
  const accounts = await Account.findAll({
    where: { account_type: 'user' },
    limit: 10
  })
  
  for (const account of accounts) {
    const balances = await AccountAssetBalance.findAll({
      where: { account_id: account.account_id }
    })
    
    for (const balance of balances) {
      // 计算流水累计
      const [result] = await sequelize.query(`
        SELECT COALESCE(SUM(delta_amount), 0) as calculated_balance
        FROM asset_transactions
        WHERE account_id = :accountId AND asset_code = :assetCode
      `, {
        replacements: { 
          accountId: account.account_id, 
          assetCode: balance.asset_code 
        },
        type: sequelize.QueryTypes.SELECT
      })
      
      const calculatedBalance = parseFloat(result.calculated_balance)
      const recordedBalance = parseFloat(balance.available_amount) + parseFloat(balance.frozen_amount)
      
      if (Math.abs(calculatedBalance - recordedBalance) > 0.01) {
        console.log(`   ⚠️ 账户 ${account.account_id} 的 ${balance.asset_code} 余额不一致:`)
        console.log(`      流水累计: ${calculatedBalance}, 记录余额: ${recordedBalance}`)
      }
    }
  }
  console.log('   ✅ 抽样账户余额验证完成')
  
  // 2. 验证冻结金额合理性
  console.log('\n📋 [冻结金额验证]')
  const [negativeFrozen] = await sequelize.query(`
    SELECT account_id, asset_code, frozen_amount
    FROM account_asset_balances
    WHERE frozen_amount < 0
  `)
  
  if (negativeFrozen.length > 0) {
    console.log('   ⚠️ 发现负数冻结金额:')
    negativeFrozen.forEach(f => {
      console.log(`   - account_id: ${f.account_id}, asset_code: ${f.asset_code}, frozen: ${f.frozen_amount}`)
    })
  } else {
    console.log('   ✅ 无负数冻结金额')
  }
  
  // 3. 验证资产流水关联完整性
  console.log('\n📋 [流水-账户关联验证]')
  const [orphanTransactions] = await sequelize.query(`
    SELECT at.transaction_id, at.account_id
    FROM asset_transactions at
    LEFT JOIN accounts a ON at.account_id = a.account_id
    WHERE a.account_id IS NULL
  `)
  
  if (orphanTransactions.length > 0) {
    console.log('   ⚠️ 发现孤立的流水记录:')
  } else {
    console.log('   ✅ 所有流水都有对应的账户')
  }
  
  console.log('\n📊 资产系统验证完成')
}

verifyAssetConsistency()
  .then(() => process.exit(0))
  .catch(err => {
    console.error(err)
    process.exit(1)
  })
```

---

### 4.5 背包模块测试

#### 4.5.1 背包操作测试

```bash
# 查询背包物品
curl -s http://localhost:3000/api/v4/backpack/items \
  -H "Authorization: Bearer $TOKEN"

# 生成核销码
curl -s -X POST http://localhost:3000/api/v4/backpack/items/123/redemption-code \
  -H "Authorization: Bearer $TOKEN"

# 使用核销码
curl -s -X POST http://localhost:3000/api/v4/backpack/redeem \
  -H "Content-Type: application/json" \
  -d '{"code": "ABCD1234EFGH"}'
```

#### 4.5.2 背包数据验证

```javascript
// scripts/test/verify_backpack_consistency.js
require('dotenv').config()
const { 
  ItemInstance, 
  ItemInstanceEvent,
  RedemptionOrder,
  sequelize 
} = require('../../models')

async function verifyBackpackConsistency() {
  console.log('🔍 验证背包系统数据一致性...\n')
  
  // 1. 验证物品状态机流转合法性
  console.log('📋 [物品状态机验证]')
  const [invalidTransitions] = await sequelize.query(`
    SELECT ii.item_instance_id, ii.status,
           (SELECT GROUP_CONCAT(event_type ORDER BY created_at) 
            FROM item_instance_events 
            WHERE item_instance_id = ii.item_instance_id) as event_chain
    FROM item_instances ii
    WHERE ii.status = 'available' 
      AND EXISTS (
        SELECT 1 FROM item_instance_events iie
        WHERE iie.item_instance_id = ii.item_instance_id
          AND iie.event_type = 'use'
      )
  `)
  
  if (invalidTransitions.length > 0) {
    console.log('   ⚠️ 发现状态机流转异常的物品:')
    invalidTransitions.forEach(t => {
      console.log(`   - item_instance_id: ${t.item_instance_id}, status: ${t.status}`)
    })
  } else {
    console.log('   ✅ 物品状态机流转合法')
  }
  
  // 2. 验证核销码状态
  console.log('\n📋 [核销码状态验证]')
  const [expiredPending] = await sequelize.query(`
    SELECT order_id, status, expires_at
    FROM redemption_orders
    WHERE status = 'pending'
      AND expires_at < NOW()
  `)
  
  if (expiredPending.length > 0) {
    console.log(`   ⚠️ 发现 ${expiredPending.length} 个过期未处理的核销码`)
  } else {
    console.log('   ✅ 无过期未处理的核销码')
  }
  
  // 3. 验证物品所有权
  console.log('\n📋 [物品所有权验证]')
  const [orphanItems] = await sequelize.query(`
    SELECT ii.item_instance_id, ii.owner_user_id
    FROM item_instances ii
    LEFT JOIN users u ON ii.owner_user_id = u.user_id
    WHERE u.user_id IS NULL
      AND ii.status NOT IN ('destroyed', 'expired')
  `)
  
  if (orphanItems.length > 0) {
    console.log('   ⚠️ 发现无效所有者的物品:')
  } else {
    console.log('   ✅ 所有物品所有权有效')
  }
  
  console.log('\n📊 背包系统验证完成')
}

verifyBackpackConsistency()
  .then(() => process.exit(0))
  .catch(err => {
    console.error(err)
    process.exit(1)
  })
```

---

### 4.6 消费记录模块测试

#### 4.6.1 消费记录测试

```bash
# 提交消费记录（商家端）
curl -s -X POST http://localhost:3000/api/v4/merchant-points/consumption \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer $MERCHANT_TOKEN" \
  -d '{
    "user_mobile": "13612227930",
    "amount": 100,
    "store_id": 1
  }'

# 查询消费记录
curl -s http://localhost:3000/api/v4/merchant-points/records \
  -H "Authorization: Bearer $TOKEN"
```

#### 4.6.2 消费记录数据验证

```javascript
// scripts/test/verify_consumption_consistency.js
require('dotenv').config()
const { 
  ConsumptionRecord, 
  ContentReviewRecord,
  AssetTransaction,
  sequelize 
} = require('../../models')

async function verifyConsumptionConsistency() {
  console.log('🔍 验证消费记录数据一致性...\n')
  
  // 1. 验证审核记录与消费记录关联
  console.log('📋 [审核-消费记录关联验证]')
  const [orphanReviews] = await sequelize.query(`
    SELECT crr.audit_id, crr.target_type, crr.target_id
    FROM content_review_records crr
    LEFT JOIN consumption_records cr ON crr.target_id = cr.record_id
    WHERE crr.target_type = 'consumption'
      AND cr.record_id IS NULL
  `)
  
  if (orphanReviews.length > 0) {
    console.log('   ⚠️ 发现孤立的审核记录')
  } else {
    console.log('   ✅ 审核记录与消费记录关联正确')
  }
  
  // 2. 验证积分发放一致性
  console.log('\n📋 [积分发放一致性验证]')
  const [approvedWithoutPoints] = await sequelize.query(`
    SELECT cr.record_id, cr.status, cr.expected_points
    FROM consumption_records cr
    WHERE cr.status = 'approved'
      AND NOT EXISTS (
        SELECT 1 FROM asset_transactions at
        WHERE at.business_type = 'consumption_reward'
          AND at.business_id = CAST(cr.record_id AS CHAR)
      )
  `)
  
  if (approvedWithoutPoints.length > 0) {
    console.log(`   ⚠️ 发现 ${approvedWithoutPoints.length} 条已审核但未发放积分的记录`)
  } else {
    console.log('   ✅ 所有已审核记录的积分已发放')
  }
  
  console.log('\n📊 消费记录验证完成')
}

verifyConsumptionConsistency()
  .then(() => process.exit(0))
  .catch(err => {
    console.error(err)
    process.exit(1)
  })
```

---

## 六、阶段 5：数据库数据验证（Node.js 脚本）

> ⚠️ **重要说明**：本节使用项目**实际存在**的验证脚本，脚本位于以下目录：
> - `scripts/reconciliation/` - 对账脚本
> - `scripts/validation/` - 验证脚本
> - `scripts/diagnostic/` - 诊断脚本

### 5.0 项目现有验证脚本一览

```bash
# 一键执行所有对账检查
node scripts/reconciliation/run_all_checks.js

# 单独执行各类检查
node scripts/reconciliation/check_lottery_consistency.js    # 抽奖一致性
node scripts/reconciliation/check_consumption_consistency.js # 消费一致性
node scripts/reconciliation/check_exchange_consistency.js   # 兑换一致性

# 验证类脚本
node scripts/validation/check_db_connections.js             # 数据库连接
node scripts/validation/verify_idempotency_canonical.js     # 幂等性验证
node scripts/validation/route_validator.js                  # 路由验证

# 诊断类脚本
node scripts/diagnostic/verify_lottery_ledger.js            # 抽奖账本验证
node scripts/diagnostic/check_lottery_txns.js               # 抽奖交易检查
```

### 5.1 抽奖一致性对账（现有脚本）

**脚本位置**：`scripts/reconciliation/check_lottery_consistency.js`

**执行命令**：
```bash
node scripts/reconciliation/check_lottery_consistency.js
```

**验证内容**：
- 按 `lottery_session_id` 聚合检查
- 验证：多条 `lottery_draws` 的 `cost_points` 总和 = 对应 `asset_transaction` 的 `|delta_amount|`
- 发现差异立即告警

---

### 5.2 消费一致性对账（现有脚本）

**脚本位置**：`scripts/reconciliation/check_consumption_consistency.js`

**执行命令**：
```bash
node scripts/reconciliation/check_consumption_consistency.js
```

---

### 5.3 兑换一致性对账（现有脚本）

**脚本位置**：`scripts/reconciliation/check_exchange_consistency.js`

**执行命令**：
```bash
node scripts/reconciliation/check_exchange_consistency.js
```

**验证内容**：
- 兑换记录与资产流水一致性
- 兑换扣款金额匹配验证

---

### 5.4 数据库连接与完整性检查（现有脚本）

**脚本位置**：`scripts/validation/check_db_connections.js`

**执行命令**：
```bash
# 数据库连接检查
node scripts/validation/check_db_connections.js

# 数据库完整性检查
npm run test:database
```

**验证内容**：
- 数据库连接池状态
- 表结构完整性
- 外键约束有效性

---

### 5.5 综合验证检查（现有脚本）

**脚本位置**：`scripts/validation/comprehensive_checker.js`

**执行命令**：
```bash
# 综合检查
node scripts/validation/comprehensive_checker.js

# 预启动完整验证
npm run validate:full
```

**验证内容**：
- Sequelize 初始化状态
- 模型关联完整性
- 路由注册正确性
- 服务管理器状态

---

## 七、阶段 6：性能与并发测试

### 6.1 响应时间基准测试

| 测试项 | 指标 | 方法 |
|--------|------|------|
| 抽奖 API 响应时间 | < 500ms | Node.js 脚本计时 |
| 数据库查询时间 | < 50ms | Sequelize benchmark |
| 健康检查响应 | < 100ms | curl 计时 |

```bash
# 测试 API 响应时间
time curl -s -X POST http://localhost:3000/api/v4/lottery/draw \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer $TOKEN" \
  -H "Idempotency-Key: perf_test_$(date +%s)" \
  -d '{"campaign_code": "BASIC_LOTTERY"}'
```

### 6.2 并发竞态测试

**现有参考测试**：`tests/integration/concurrent_chat_session.test.js`

**待创建测试**：`tests/integration/concurrent_lottery.test.js`

```bash
# 运行现有并发测试（聊天会话）
npm test -- tests/integration/concurrent_chat_session.test.js

# 运行抽奖并发测试（待创建）
npm test -- tests/integration/concurrent_lottery.test.js
```

**抽奖并发测试应覆盖**：
- 同一用户多个并发抽奖请求（幂等性验证）
- 多用户同时抽奖（库存竞态验证）
- 高并发下事务隔离性验证
- 积分扣减原子性验证

**测试模式参考**（基于 `concurrent_chat_session.test.js`）：

| 测试场景 | 验证点 |
|----------|--------|
| 同用户并发 | 幂等性、防重复扣款 |
| 多用户并发 | 库存一致性、无超卖 |
| 事务隔离 | 无脏读、无幻读 |

### 6.3 幂等性验证

```bash
# 使用相同的 Idempotency-Key 发送两次请求
IDEM_KEY="test_idempotency_$(date +%s)"

# 第一次请求
curl -s -X POST http://localhost:3000/api/v4/lottery/draw \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer $TOKEN" \
  -H "Idempotency-Key: $IDEM_KEY" \
  -d '{"campaign_code": "BASIC_LOTTERY"}'

# 第二次请求（应返回相同结果）
curl -s -X POST http://localhost:3000/api/v4/lottery/draw \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer $TOKEN" \
  -H "Idempotency-Key: $IDEM_KEY" \
  -d '{"campaign_code": "BASIC_LOTTERY"}'
```

### 6.4 用户异常行为测试（防"无脑用法"）

> ⚠️ **重要**：用户不会按照预期流程操作，测试必须覆盖各种"无脑"场景。

#### 6.4.1 快速重复点击测试

**场景**：用户快速连续点击抽奖按钮 10 次

```bash
# 模拟快速重复点击（100ms 间隔发送 10 个请求）
for i in {1..10}; do
  curl -s -X POST http://localhost:3000/api/v4/lottery/draw \
    -H "Content-Type: application/json" \
    -H "Authorization: Bearer $TOKEN" \
    -H "Idempotency-Key: rapid_click_$(date +%s%N)_$i" \
    -d '{"campaign_code": "BASIC_LOTTERY"}' &
  sleep 0.1
done
wait
```

**预期结果**：
- 仅扣除一次积分（幂等控制）或每次扣款都有独立记录
- 无重复扣款、无负余额
- 响应时间不因并发明显增加

#### 6.4.2 边界条件测试

| 测试场景 | 测试方法 | 预期结果 |
|----------|----------|----------|
| **余额不足抽奖** | 设置用户余额 < 单抽价格后抽奖 | 返回 `INSUFFICIENT_BALANCE`，不扣款 |
| **库存耗尽购买** | 将奖品库存设为 0 后抽奖 | 跳过该奖品或返回无奖品可抽 |
| **活动过期参与** | 将活动 `end_date` 设为过去时间 | 返回 `CAMPAIGN_EXPIRED` |
| **活动未开始参与** | 将活动 `start_date` 设为未来时间 | 返回 `CAMPAIGN_NOT_STARTED` |
| **超出每日限制** | 连续抽奖直到超出每日次数限制 | 返回 `DAILY_LIMIT_EXCEEDED` |
| **订单过期支付** | 等待挂牌订单过期后尝试购买 | 返回 `LISTING_EXPIRED` |

```bash
# 余额不足测试
# 先清空用户积分（通过管理接口或直接数据库操作）
curl -s -X POST http://localhost:3000/api/v4/lottery/draw \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer $TOKEN" \
  -H "Idempotency-Key: insufficient_balance_test_$(date +%s)" \
  -d '{"campaign_code": "BASIC_LOTTERY"}'
# 预期返回: {"success": false, "code": "INSUFFICIENT_BALANCE", ...}
```

#### 6.4.3 异常输入测试

| 输入类型 | 测试值 | 预期结果 |
|----------|--------|----------|
| **空值** | `campaign_code: ""` | 参数校验失败 |
| **null** | `campaign_code: null` | 参数校验失败 |
| **超长字符串** | `campaign_code: "A" * 1000` | 参数校验失败 |
| **特殊字符** | `campaign_code: "<script>alert(1)</script>"` | 参数校验失败/XSS 过滤 |
| **SQL 注入** | `campaign_code: "'; DROP TABLE users;--"` | 参数校验失败/SQL 注入过滤 |
| **负数** | `draw_count: -1` | 参数校验失败 |
| **超大数** | `draw_count: 999999` | 参数校验失败或限制为最大值 |
| **非法类型** | `draw_count: "abc"` | 参数校验失败 |

```bash
# 空值测试
curl -s -X POST http://localhost:3000/api/v4/lottery/draw \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer $TOKEN" \
  -H "Idempotency-Key: empty_input_test_$(date +%s)" \
  -d '{"campaign_code": ""}'
# 预期返回: {"success": false, "code": "INVALID_PARAMS", ...}

# 超大数测试
curl -s -X POST http://localhost:3000/api/v4/lottery/draw \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer $TOKEN" \
  -H "Idempotency-Key: large_count_test_$(date +%s)" \
  -d '{"campaign_code": "BASIC_LOTTERY", "draw_count": 999999}'
# 预期返回: 限制为最大连抽次数或返回参数错误
```

#### 6.4.4 Token 和权限异常测试

| 测试场景 | 测试方法 | 预期结果 |
|----------|----------|----------|
| **无 Token** | 不带 Authorization 头 | 返回 `401 UNAUTHORIZED` |
| **无效 Token** | `Authorization: Bearer invalid_token` | 返回 `401 UNAUTHORIZED` |
| **过期 Token** | 使用超过有效期的 Token | 返回 `401 TOKEN_EXPIRED` |
| **权限不足** | 普通用户访问管理员接口 | 返回 `403 FORBIDDEN` |
| **被禁用账号** | 账号状态为 `banned` 时操作 | 返回 `403 ACCOUNT_DISABLED` |

```bash
# 无 Token 测试
curl -s -X POST http://localhost:3000/api/v4/lottery/draw \
  -H "Content-Type: application/json" \
  -H "Idempotency-Key: no_token_test_$(date +%s)" \
  -d '{"campaign_code": "BASIC_LOTTERY"}'
# 预期返回: {"success": false, "code": "UNAUTHORIZED", ...}

# 无效 Token 测试
curl -s -X POST http://localhost:3000/api/v4/lottery/draw \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer invalid_fake_token_12345" \
  -H "Idempotency-Key: invalid_token_test_$(date +%s)" \
  -d '{"campaign_code": "BASIC_LOTTERY"}'
# 预期返回: {"success": false, "code": "UNAUTHORIZED", ...}
```

#### 6.4.5 多设备/多标签页并发测试

**场景**：同一用户在多个设备/浏览器标签页同时操作

```bash
# 模拟同一用户在 5 个设备同时抽奖
for i in {1..5}; do
  curl -s -X POST http://localhost:3000/api/v4/lottery/draw \
    -H "Content-Type: application/json" \
    -H "Authorization: Bearer $TOKEN" \
    -H "Idempotency-Key: multi_device_$(date +%s)_device_$i" \
    -d '{"campaign_code": "BASIC_LOTTERY"}' &
done
wait

# 验证：查询用户积分流水，确保每次操作都有正确记录
curl -s http://localhost:3000/api/v4/assets/transactions?limit=10 \
  -H "Authorization: Bearer $TOKEN"
```

**验证点**：
- 每个设备的请求都应独立处理（如果 Idempotency-Key 不同）
- 不应出现数据竞态（负余额、超卖）
- 积分扣减总额应等于 `单抽价格 × 成功抽奖次数`

#### 6.4.6 网络中断/超时恢复测试

**场景**：请求发送后网络中断，用户刷新页面重试

```bash
# 第一次请求（模拟网络超时，用户不知道是否成功）
IDEM_KEY="network_timeout_$(date +%s)"
curl -s -X POST http://localhost:3000/api/v4/lottery/draw \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer $TOKEN" \
  -H "Idempotency-Key: $IDEM_KEY" \
  -d '{"campaign_code": "BASIC_LOTTERY"}'

# 用户刷新页面后重试（相同 Idempotency-Key）
curl -s -X POST http://localhost:3000/api/v4/lottery/draw \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer $TOKEN" \
  -H "Idempotency-Key: $IDEM_KEY" \
  -d '{"campaign_code": "BASIC_LOTTERY"}'
# 预期：返回与第一次相同的结果，不重复扣款
```

#### 6.4.7 乱序操作测试

**场景**：用户跳过流程直接访问后续接口

| 测试场景 | 测试方法 | 预期结果 |
|----------|----------|----------|
| **未登录直接抽奖** | 不经登录直接调用抽奖接口 | 返回 `401` |
| **未挂牌直接购买** | 直接调用购买接口，传入不存在的 `listing_id` | 返回 `404` 或 `LISTING_NOT_FOUND` |
| **未中奖查看奖品** | 查看不属于自己的物品 | 返回 `403` 或 `NOT_OWNER` |
| **重复核销** | 同一核销码多次核销 | 返回 `ALREADY_REDEEMED` |

#### 6.4.8 用户异常行为测试清单

**集成测试覆盖**（待创建：`tests/integration/user_abuse_scenarios.test.js`）：

```javascript
// 测试用例清单
describe('用户异常行为测试', () => {
  describe('快速重复点击', () => {
    it('10 次快速点击只扣一次款（相同 Idempotency-Key）')
    it('10 次快速点击扣 10 次款（不同 Idempotency-Key）')
  })
  
  describe('边界条件', () => {
    it('余额不足时返回错误，不扣款')
    it('库存耗尽时返回错误或跳过该奖品')
    it('活动过期时返回错误')
    it('超出每日限制时返回错误')
  })
  
  describe('异常输入', () => {
    it('空值参数被正确拒绝')
    it('超长字符串被正确拒绝')
    it('SQL 注入被正确过滤')
    it('负数/超大数被正确拒绝')
  })
  
  describe('权限异常', () => {
    it('无 Token 返回 401')
    it('无效 Token 返回 401')
    it('权限不足返回 403')
  })
  
  describe('并发竞态', () => {
    it('多设备同时操作无数据竞态')
    it('网络超时重试返回相同结果')
  })
})
```

### 6.5 运营配置动态调整测试

> 🎯 **业务背景**：抽奖/交易类系统需要运营频繁调整配置（概率、库存、限制等），必须支持**热加载**，无需重启服务。

#### 6.5.1 配置热加载测试

| 测试场景 | 测试方法 | 预期结果 | 验证SQL |
|----------|----------|----------|---------|
| **修改抽奖概率** | 后台修改 `lottery_tier_rules.weight` | 60s 内生效，无需重启 | 查询 `lottery_tier_rules` 配置变更时间 |
| **修改活动状态** | 后台将活动设为 `disabled` | 立即返回"活动已关闭" | 查询 `lottery_campaigns.is_active` |
| **修改奖品库存** | 后台调整 `lottery_prizes.available_stock` | 新库存立即生效 | 查询 `lottery_prizes` 库存 |
| **修改每日限制** | 后台调整 `lottery_campaigns.daily_draw_limit` | 新限制立即生效 | 查询活动配置 |
| **修改定价配置** | 后台调整 `lottery_campaign_pricing_config` | 新价格立即生效 | 查询定价配置 |

```bash
# 测试配置热加载流程

# 1. 记录当前配置
curl -s http://localhost:3000/api/v4/lottery/campaigns/BASIC_LOTTERY \
  -H "Authorization: Bearer $TOKEN" | jq '.data.daily_draw_limit'

# 2. 通过管理后台或 API 修改配置
# （假设有管理接口）
curl -s -X PATCH http://localhost:3000/api/v4/admin/campaigns/BASIC_LOTTERY \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer $ADMIN_TOKEN" \
  -d '{"daily_draw_limit": 5}'

# 3. 等待配置刷新（最多 60s）
sleep 60

# 4. 验证新配置是否生效
curl -s http://localhost:3000/api/v4/lottery/campaigns/BASIC_LOTTERY \
  -H "Authorization: Bearer $TOKEN" | jq '.data.daily_draw_limit'
# 预期：返回 5
```

#### 6.5.2 功能开关切换测试

| 开关 | 关闭后行为 | 恢复后行为 | 配置位置 |
|------|------------|------------|----------|
| **抽奖总开关** | 返回"功能维护中" | 正常抽奖 | `system_configs.lottery_enabled` |
| **交易市场开关** | 禁止挂牌/购买 | 正常交易 | `system_configs.market_enabled` |
| **新用户注册开关** | 返回"暂停注册" | 正常注册 | `system_configs.registration_enabled` |
| **紧急熔断开关** | 所有写操作返回"系统维护" | 恢复正常 | `system_configs.emergency_stop` |

```bash
# 开关切换测试流程

# 1. 关闭抽奖开关（通过管理接口或直接数据库）
# 方式 A：管理 API
curl -s -X POST http://localhost:3000/api/v4/admin/system/config \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer $ADMIN_TOKEN" \
  -d '{"key": "lottery_enabled", "value": false}'

# 方式 B：直接数据库（测试环境）
# UPDATE system_configs SET config_value = 'false' WHERE config_key = 'lottery_enabled';

# 2. 验证开关生效
curl -s -X POST http://localhost:3000/api/v4/lottery/draw \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer $TOKEN" \
  -H "Idempotency-Key: switch_test_$(date +%s)" \
  -d '{"campaign_code": "BASIC_LOTTERY"}'
# 预期返回: {"success": false, "code": "FEATURE_DISABLED", "message": "功能维护中"}

# 3. 恢复开关
curl -s -X POST http://localhost:3000/api/v4/admin/system/config \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer $ADMIN_TOKEN" \
  -d '{"key": "lottery_enabled", "value": true}'

# 4. 验证恢复后正常
curl -s -X POST http://localhost:3000/api/v4/lottery/draw \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer $TOKEN" \
  -H "Idempotency-Key: switch_test_recover_$(date +%s)" \
  -d '{"campaign_code": "BASIC_LOTTERY"}'
# 预期返回: {"success": true, ...}
```

#### 6.5.3 配置变更审计验证

```bash
# 验证配置变更是否被正确记录到审计日志
node -e "
const { AdminOperationLog, sequelize } = require('./models');

(async () => {
  const logs = await AdminOperationLog.findAll({
    where: {
      operation_type: 'config_change',
      target_type: 'system_config'
    },
    order: [['created_at', 'DESC']],
    limit: 10
  });
  
  console.log('📋 最近 10 条配置变更记录:');
  logs.forEach(log => {
    console.log(\`- \${log.created_at}: \${log.operation_detail}\`);
  });
  
  process.exit(0);
})();
"
```

### 6.6 概率验证测试（数值平衡）

> 🎰 **业务背景**：抽奖系统的核心是概率公平性，需要验证实际概率与配置概率一致。

#### 6.6.0 测试前准备（自动充值积分）

> ⚠️ **重要**：10000 次抽奖需要约 **1,000,000 POINTS**，测试前必须确保测试用户 `13612227930` 有足够积分。

**积分消耗计算**（基于 `system_settings.lottery_cost_points = 100`）：

| 样本量 | 单抽消耗 | 总消耗（无折扣） | 总消耗（10连九折） |
|--------|----------|------------------|-------------------|
| 1,000 | 100 | 100,000 | 90,000 |
| 5,000 | 100 | 500,000 | 450,000 |
| 10,000 | 100 | 1,000,000 | 900,000 |

**自动化测试文件位置**：`tests/specialized/probability_verification.test.js`

**测试执行流程**：
```bash
# 1. 运行概率验证测试（自动充值 + 10000 次抽奖）
npm test -- tests/specialized/probability_verification.test.js --runInBand

# 2. 测试会自动：
#    - beforeAll: 调用 ensureTestUserHasPoints(1500000) 充值积分
#    - 执行 10000 次抽奖 API 调用
#    - 统计各档位实际概率
#    - 验证概率误差在 ±5% 范围内
```

#### 6.6.1 概率分布验证

**验证目标**：
- 模拟大量抽奖，验证各档位实际概率在配置概率的 **±5%** 误差范围内
- 验证保底机制（Pity）正确触发
- 验证概率配置变更后立即生效

**自动化测试实现**（`tests/specialized/probability_verification.test.js`）：

```javascript
/**
 * 概率分布验证测试
 * @file tests/specialized/probability_verification.test.js
 * 
 * 执行: npm test -- tests/specialized/probability_verification.test.js --runInBand
 * 预计时间: 5-15 分钟（取决于数据库性能）
 */
const request = require('supertest')
const app = require('../../app')
const { ensureTestUserHasPoints } = require('../helpers/test-points-setup')
const { TEST_DATA } = require('../helpers/test-data')
const { LotteryTierRule, LotteryDraw, sequelize } = require('../../models')

const SAMPLE_SIZE = 10000
const TOLERANCE = 0.05 // ±5% 误差容忍度

describe('概率分布验证测试', () => {
  let authToken
  let campaignId
  const tierResults = {}

  beforeAll(async () => {
    // 1. 充值足够积分
    await ensureTestUserHasPoints(1500000)
    
    // 2. 登录获取 token
    const loginRes = await request(app)
      .post('/api/v4/auth/login')
      .send({ mobile: TEST_DATA.users.testUser.mobile, verification_code: '123456' })
    authToken = loginRes.body.data.access_token
    campaignId = TEST_DATA.lottery.testCampaign.campaign_id
  }, 120000) // 2 分钟超时

  test(`执行 ${SAMPLE_SIZE} 次抽奖并统计`, async () => {
    // 10连抽，执行 1000 次 = 10000 次抽奖
    for (let batch = 0; batch < SAMPLE_SIZE / 10; batch++) {
      const res = await request(app)
        .post('/api/v4/lottery/draw')
        .set('Authorization', `Bearer ${authToken}`)
        .send({ campaign_id: campaignId, draw_count: 10 })
      
      if (res.body.success && res.body.data.rewards) {
        res.body.data.rewards.forEach(reward => {
          const tier = reward.tier_name || 'unknown'
          tierResults[tier] = (tierResults[tier] || 0) + 1
        })
      }
    }
    
    expect(Object.values(tierResults).reduce((a, b) => a + b, 0)).toBe(SAMPLE_SIZE)
  }, 900000) // 15 分钟超时

  test('验证概率分布在 ±5% 误差范围内', async () => {
    // 获取配置概率
    const tierRules = await LotteryTierRule.findAll({
      where: { campaign_id: campaignId, is_active: true }
    })
    const totalWeight = tierRules.reduce((sum, r) => sum + r.weight, 0)
    
    // 验证每个档位
    tierRules.forEach(rule => {
      const configuredProb = rule.weight / totalWeight
      const actualCount = tierResults[rule.tier_name] || 0
      const actualProb = actualCount / SAMPLE_SIZE
      const deviation = Math.abs(actualProb - configuredProb) / configuredProb
      
      console.log(`${rule.tier_name}: 配置=${(configuredProb*100).toFixed(2)}%, 实际=${(actualProb*100).toFixed(2)}%, 偏差=${(deviation*100).toFixed(2)}%`)
      
      expect(deviation).toBeLessThan(TOLERANCE)
    })
  })
})
```

**手动验证脚本**（查询历史数据）：

```javascript
// scripts/test/verify_probability_distribution.js
require('dotenv').config();
const { LotteryDraw, LotteryTierRule, sequelize } = require('../../models');

async function verifyProbabilityDistribution(campaignId, sampleSize = 10000) {
  console.log(`🎰 概率分布验证 (样本量: ${sampleSize})\n`);
  
  // 1. 获取配置的概率
  const tierRules = await LotteryTierRule.findAll({
    where: { campaign_id: campaignId, is_active: true },
    order: [['tier_level', 'ASC']]
  });
  
  console.log('📋 配置概率:');
  const totalWeight = tierRules.reduce((sum, r) => sum + r.weight, 0);
  const configuredProbabilities = {};
  tierRules.forEach(rule => {
    const probability = (rule.weight / totalWeight * 100).toFixed(2);
    configuredProbabilities[rule.tier_name] = parseFloat(probability);
    console.log(`   ${rule.tier_name}: ${probability}%`);
  });
  
  // 2. 统计实际抽奖结果分布
  const [results] = await sequelize.query(`
    SELECT 
      tier_name,
      COUNT(*) as count,
      ROUND(COUNT(*) * 100.0 / :sampleSize, 2) as actual_percentage
    FROM lottery_draws
    WHERE campaign_id = :campaignId
    ORDER BY tier_name
    LIMIT :sampleSize
  `, {
    replacements: { campaignId, sampleSize },
    type: sequelize.QueryTypes.SELECT
  });
  
  console.log('\n📊 实际分布:');
  let hasDeviation = false;
  results.forEach(result => {
    const configured = configuredProbabilities[result.tier_name] || 0;
    const actual = parseFloat(result.actual_percentage);
    const deviation = Math.abs(actual - configured);
    const status = deviation <= 5 ? '✅' : '⚠️';
    
    if (deviation > 5) hasDeviation = true;
    
    console.log(`   ${status} ${result.tier_name}: ${actual}% (配置: ${configured}%, 偏差: ${deviation.toFixed(2)}%)`);
  });
  
  if (hasDeviation) {
    console.log('\n⚠️ 存在概率偏差超过 5% 的档位，请检查抽奖算法');
  } else {
    console.log('\n✅ 所有档位概率在合理范围内');
  }
}

// 执行验证
verifyProbabilityDistribution(1, 10000)
  .then(() => process.exit(0))
  .catch(err => {
    console.error(err);
    process.exit(1);
  });
```

#### 6.6.2 保底机制验证

```javascript
// scripts/test/verify_pity_mechanism.js
require('dotenv').config();
const { LotteryDraw, LotteryUserExperienceState, sequelize } = require('../../models');

async function verifyPityMechanism(userId, campaignId) {
  console.log('🎯 保底机制验证\n');
  
  // 1. 查询用户当前保底状态
  const state = await LotteryUserExperienceState.findOne({
    where: { user_id: userId, campaign_id: campaignId }
  });
  
  if (state) {
    console.log('📊 当前保底状态:');
    console.log(`   累计抽奖次数: ${state.total_draws}`);
    console.log(`   距离小保底: ${state.pity_counter_small}`);
    console.log(`   距离大保底: ${state.pity_counter_big}`);
    console.log(`   运气债务: ${state.luck_debt || 0}`);
  }
  
  // 2. 验证保底触发记录
  const [pityDraws] = await sequelize.query(`
    SELECT 
      draw_id,
      tier_name,
      is_pity_triggered,
      pity_type,
      created_at
    FROM lottery_draws
    WHERE user_id = :userId
      AND campaign_id = :campaignId
      AND is_pity_triggered = true
    ORDER BY created_at DESC
    LIMIT 10
  `, {
    replacements: { userId, campaignId },
    type: sequelize.QueryTypes.SELECT
  });
  
  console.log('\n📋 最近保底触发记录:');
  if (pityDraws.length === 0) {
    console.log('   暂无保底触发记录');
  } else {
    pityDraws.forEach(draw => {
      console.log(`   - ${draw.created_at}: ${draw.tier_name} (${draw.pity_type})`);
    });
  }
  
  // 3. 验证保底间隔是否符合配置
  console.log('\n🔍 保底间隔验证:');
  const [intervals] = await sequelize.query(`
    SELECT 
      pity_type,
      AVG(draws_since_last_pity) as avg_interval,
      MIN(draws_since_last_pity) as min_interval,
      MAX(draws_since_last_pity) as max_interval
    FROM (
      SELECT 
        draw_id,
        pity_type,
        (SELECT COUNT(*) 
         FROM lottery_draws ld2 
         WHERE ld2.user_id = ld.user_id 
           AND ld2.campaign_id = ld.campaign_id
           AND ld2.created_at < ld.created_at
           AND ld2.created_at > COALESCE(
             (SELECT MAX(created_at) FROM lottery_draws ld3 
              WHERE ld3.user_id = ld.user_id 
                AND ld3.campaign_id = ld.campaign_id
                AND ld3.is_pity_triggered = true
                AND ld3.created_at < ld.created_at),
             '1970-01-01'
           )
        ) as draws_since_last_pity
      FROM lottery_draws ld
      WHERE user_id = :userId
        AND campaign_id = :campaignId
        AND is_pity_triggered = true
    ) t
    GROUP BY pity_type
  `, {
    replacements: { userId, campaignId },
    type: sequelize.QueryTypes.SELECT
  });
  
  intervals.forEach(interval => {
    console.log(`   ${interval.pity_type}: 平均间隔 ${interval.avg_interval} 次 (最小: ${interval.min_interval}, 最大: ${interval.max_interval})`);
  });
}

// 执行
const testUserId = process.argv[2] || 1;
const campaignId = process.argv[3] || 1;
verifyPityMechanism(testUserId, campaignId)
  .then(() => process.exit(0))
  .catch(err => {
    console.error(err);
    process.exit(1);
  });
```

#### 6.6.3 经济系统平衡监控

| 监控指标 | 计算方式 | 告警阈值 | 说明 |
|----------|----------|----------|------|
| **积分产出速率** | 每小时新增积分总量 | > 基线 150% | 可能存在刷积分漏洞 |
| **积分消耗比例** | 消耗积分 / 产出积分 | < 30% | 积分堆积，经济系统失衡 |
| **高价值奖品产出率** | SSR 级奖品 / 总抽奖次数 | > 配置概率 120% | 概率可能被篡改 |
| **用户积分中位数** | 所有用户积分中位数 | 周环比 > 50% | 通货膨胀预警 |

```javascript
// scripts/monitor/economic_balance_check.js
require('dotenv').config();
const { AssetTransaction, AccountAssetBalance, LotteryDraw, sequelize } = require('../../models');

async function checkEconomicBalance() {
  console.log('💰 经济系统平衡检查\n');
  
  // 1. 积分产出速率（最近 1 小时）
  const [production] = await sequelize.query(`
    SELECT 
      COALESCE(SUM(CASE WHEN delta_amount > 0 THEN delta_amount ELSE 0 END), 0) as total_production,
      COALESCE(SUM(CASE WHEN delta_amount < 0 THEN ABS(delta_amount) ELSE 0 END), 0) as total_consumption
    FROM asset_transactions
    WHERE asset_code = 'POINTS'
      AND created_at >= DATE_SUB(NOW(), INTERVAL 1 HOUR)
  `, { type: sequelize.QueryTypes.SELECT });
  
  console.log('📊 最近 1 小时积分流动:');
  console.log(`   产出: +${production[0]?.total_production || 0}`);
  console.log(`   消耗: -${production[0]?.total_consumption || 0}`);
  
  const consumptionRatio = production[0]?.total_production > 0 
    ? (production[0]?.total_consumption / production[0]?.total_production * 100).toFixed(2)
    : 0;
  console.log(`   消耗比例: ${consumptionRatio}%`);
  
  if (parseFloat(consumptionRatio) < 30) {
    console.log('   ⚠️ 消耗比例过低，积分可能堆积');
  }
  
  // 2. 用户积分分布
  const [distribution] = await sequelize.query(`
    SELECT 
      COUNT(*) as user_count,
      AVG(available_amount) as avg_balance,
      PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY available_amount) as median_balance,
      MAX(available_amount) as max_balance
    FROM account_asset_balances
    WHERE asset_code = 'POINTS'
  `, { type: sequelize.QueryTypes.SELECT });
  
  console.log('\n📊 用户积分分布:');
  console.log(`   用户数: ${distribution[0]?.user_count || 0}`);
  console.log(`   平均余额: ${distribution[0]?.avg_balance?.toFixed(2) || 0}`);
  console.log(`   中位数余额: ${distribution[0]?.median_balance?.toFixed(2) || 0}`);
  console.log(`   最大余额: ${distribution[0]?.max_balance || 0}`);
  
  // 3. 高价值奖品产出率
  const [ssrRate] = await sequelize.query(`
    SELECT 
      COUNT(CASE WHEN tier_name IN ('SSR', 'UR', 'LEGENDARY') THEN 1 END) as ssr_count,
      COUNT(*) as total_draws,
      ROUND(COUNT(CASE WHEN tier_name IN ('SSR', 'UR', 'LEGENDARY') THEN 1 END) * 100.0 / COUNT(*), 4) as ssr_rate
    FROM lottery_draws
    WHERE created_at >= DATE_SUB(NOW(), INTERVAL 24 HOUR)
  `, { type: sequelize.QueryTypes.SELECT });
  
  console.log('\n📊 最近 24 小时高价值奖品产出:');
  console.log(`   总抽奖次数: ${ssrRate[0]?.total_draws || 0}`);
  console.log(`   SSR+ 产出: ${ssrRate[0]?.ssr_count || 0} (${ssrRate[0]?.ssr_rate || 0}%)`);
  
  console.log('\n✅ 经济系统平衡检查完成');
}

checkEconomicBalance()
  .then(() => process.exit(0))
  .catch(err => {
    console.error(err);
    process.exit(1);
  });
```

### 6.7 风控规则测试

> 🛡️ **业务背景**：交易类系统需要风控机制防止刷单、羊毛党、异常交易等行为。

#### 6.7.1 限流规则测试

| 限流规则 | 测试方法 | 预期结果 |
|----------|----------|----------|
| **用户每分钟抽奖限制** | 1 分钟内连续抽奖超过限制 | 返回 `RATE_LIMIT_EXCEEDED` |
| **IP 每分钟请求限制** | 同 IP 高频请求 | 返回 `TOO_MANY_REQUESTS` |
| **单用户每日抽奖限制** | 超过每日限制后抽奖 | 返回 `DAILY_LIMIT_EXCEEDED` |
| **单用户每日交易限制** | 超过每日交易金额限制 | 返回 `DAILY_TRADE_LIMIT_EXCEEDED` |

```bash
# 测试用户每分钟抽奖限制（假设限制为 10 次/分钟）
for i in {1..15}; do
  echo "请求 $i:"
  curl -s -X POST http://localhost:3000/api/v4/lottery/draw \
    -H "Content-Type: application/json" \
    -H "Authorization: Bearer $TOKEN" \
    -H "Idempotency-Key: rate_limit_test_$(date +%s%N)_$i" \
    -d '{"campaign_code": "BASIC_LOTTERY"}' | jq '.code'
done
# 预期：前 10 次返回 SUCCESS，后 5 次返回 RATE_LIMIT_EXCEEDED
```

#### 6.7.2 黑名单测试

| 黑名单类型 | 触发条件 | 限制行为 |
|------------|----------|----------|
| **用户黑名单** | 异常行为被封禁 | 禁止抽奖、交易 |
| **设备黑名单** | 设备指纹异常 | 禁止登录、注册 |
| **IP 黑名单** | IP 被标记为恶意 | 禁止所有操作 |
| **资产黑名单** | 特定物品被标记 | 禁止交易该物品 |

```bash
# 测试用户黑名单
# 1. 将测试用户加入黑名单
curl -s -X POST http://localhost:3000/api/v4/admin/risk/blacklist \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer $ADMIN_TOKEN" \
  -d '{"user_id": 12345, "reason": "测试", "expires_at": "2026-12-31"}'

# 2. 尝试抽奖
curl -s -X POST http://localhost:3000/api/v4/lottery/draw \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer $BLACKLISTED_USER_TOKEN" \
  -H "Idempotency-Key: blacklist_test_$(date +%s)" \
  -d '{"campaign_code": "BASIC_LOTTERY"}'
# 预期返回: {"success": false, "code": "USER_BLACKLISTED", ...}

# 3. 移除黑名单
curl -s -X DELETE http://localhost:3000/api/v4/admin/risk/blacklist/12345 \
  -H "Authorization: Bearer $ADMIN_TOKEN"
```

#### 6.7.3 异常检测测试

| 异常模式 | 检测方法 | 处理方式 |
|----------|----------|----------|
| **短时间大量抽奖** | 统计用户 1 小时内抽奖次数 | 触发人工审核 |
| **异常中奖率** | 用户中奖率远高于平均值 | 触发概率审计 |
| **快速倒卖** | 获得物品后立即挂牌 | 延迟挂牌/标记 |
| **关联账号交易** | 检测设备指纹相同的账号间交易 | 阻止交易 |

```javascript
// scripts/test/verify_anomaly_detection.js
require('dotenv').config();
const { LotteryDraw, TradeOrder, UserRiskProfile, sequelize } = require('../../models');

async function verifyAnomalyDetection(userId) {
  console.log('🔍 异常检测验证\n');
  
  // 1. 检查用户风险画像
  const riskProfile = await UserRiskProfile.findOne({
    where: { user_id: userId }
  });
  
  if (riskProfile) {
    console.log('📊 用户风险画像:');
    console.log(`   风险等级: ${riskProfile.risk_level}`);
    console.log(`   风险分数: ${riskProfile.risk_score}`);
    console.log(`   异常标记: ${riskProfile.anomaly_flags?.join(', ') || '无'}`);
  }
  
  // 2. 检查最近 1 小时抽奖频率
  const [drawFrequency] = await sequelize.query(`
    SELECT COUNT(*) as draw_count
    FROM lottery_draws
    WHERE user_id = :userId
      AND created_at >= DATE_SUB(NOW(), INTERVAL 1 HOUR)
  `, {
    replacements: { userId },
    type: sequelize.QueryTypes.SELECT
  });
  
  console.log(`\n📊 最近 1 小时抽奖次数: ${drawFrequency[0]?.draw_count || 0}`);
  if (drawFrequency[0]?.draw_count > 100) {
    console.log('   ⚠️ 抽奖频率异常，应触发审核');
  }
  
  // 3. 检查中奖率
  const [winRate] = await sequelize.query(`
    SELECT 
      COUNT(CASE WHEN tier_name IN ('SR', 'SSR', 'UR') THEN 1 END) as high_tier_count,
      COUNT(*) as total_draws,
      ROUND(COUNT(CASE WHEN tier_name IN ('SR', 'SSR', 'UR') THEN 1 END) * 100.0 / COUNT(*), 2) as win_rate
    FROM lottery_draws
    WHERE user_id = :userId
  `, {
    replacements: { userId },
    type: sequelize.QueryTypes.SELECT
  });
  
  console.log(`📊 用户中奖率: ${winRate[0]?.win_rate || 0}% (高级奖品: ${winRate[0]?.high_tier_count || 0}/${winRate[0]?.total_draws || 0})`);
  
  // 4. 检查快速倒卖行为
  const [quickResale] = await sequelize.query(`
    SELECT 
      ii.item_instance_id,
      ii.created_at as acquired_at,
      ml.created_at as listed_at,
      TIMESTAMPDIFF(MINUTE, ii.created_at, ml.created_at) as minutes_to_list
    FROM item_instances ii
    JOIN market_listings ml ON ii.item_instance_id = ml.item_instance_id
    WHERE ii.owner_user_id = :userId
      AND TIMESTAMPDIFF(MINUTE, ii.created_at, ml.created_at) < 5
    LIMIT 10
  `, {
    replacements: { userId },
    type: sequelize.QueryTypes.SELECT
  });
  
  console.log(`\n📊 快速倒卖检测 (5 分钟内挂牌): ${quickResale.length} 条`);
  if (quickResale.length > 0) {
    console.log('   ⚠️ 存在快速倒卖行为');
    quickResale.forEach(item => {
      console.log(`   - item_instance_id: ${item.item_instance_id}, 间隔: ${item.minutes_to_list} 分钟`);
    });
  }
  
  console.log('\n✅ 异常检测验证完成');
}

const testUserId = process.argv[2] || 1;
verifyAnomalyDetection(testUserId)
  .then(() => process.exit(0))
  .catch(err => {
    console.error(err);
    process.exit(1);
  });
```

#### 6.7.4 风控规则测试清单

**待创建集成测试**：`tests/integration/risk_control.test.js`

```javascript
// 测试用例清单
describe('风控规则测试', () => {
  describe('限流规则', () => {
    it('用户每分钟抽奖超过限制返回 RATE_LIMIT_EXCEEDED')
    it('IP 每分钟请求超过限制返回 TOO_MANY_REQUESTS')
    it('每日抽奖超过限制返回 DAILY_LIMIT_EXCEEDED')
  })
  
  describe('黑名单规则', () => {
    it('黑名单用户抽奖返回 USER_BLACKLISTED')
    it('黑名单用户交易返回 USER_BLACKLISTED')
    it('黑名单资产禁止交易')
  })
  
  describe('异常检测', () => {
    it('短时间大量抽奖触发风险标记')
    it('异常中奖率触发审计')
    it('快速倒卖触发延迟挂牌')
  })
})
```

### 6.8 熔断降级测试

> 🛡️ **核心原则**：Redis/DB 挂了时，**不要直接返回 500**，应该优雅降级。

#### 6.8.1 降级场景与预期行为

| 故障场景 | 降级行为 | 返回内容 | 禁止行为 |
|----------|----------|----------|----------|
| **Redis 不可用** | 跳过缓存，直接查数据库 | 正常响应（可能稍慢） | ❌ 返回 500 |
| **Redis 不可用（写操作）** | 允许操作，异步补偿缓存 | 正常响应 | ❌ 阻断业务 |
| **数据库只读** | 允许读操作，拒绝写操作 | 读正常，写返回 `SERVICE_DEGRADED` | ❌ 返回 500 |
| **数据库完全不可用** | 返回缓存数据（如有） | 缓存数据 + 降级标记 | ❌ 返回 500 |
| **第三方服务超时** | 使用默认值/缓存值 | 降级响应 + 告警 | ❌ 无限等待 |

#### 6.8.2 Redis 降级测试

```bash
# 测试 Redis 不可用时的降级行为

# 1. 停止 Redis（模拟故障）
redis-cli shutdown

# 2. 测试读操作（应该降级到数据库查询）
curl -s http://localhost:3000/api/v4/lottery/campaigns/BASIC_LOTTERY \
  -H "Authorization: Bearer $TOKEN"
# 预期：返回正常数据，可能稍慢，不应返回 500

# 3. 测试写操作（应该允许，异步补偿）
curl -s -X POST http://localhost:3000/api/v4/lottery/draw \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer $TOKEN" \
  -H "Idempotency-Key: redis_down_test_$(date +%s)" \
  -d '{"campaign_code": "BASIC_LOTTERY"}'
# 预期：返回正常结果，日志记录缓存写入失败

# 4. 恢复 Redis
redis-server --daemonize yes

# 5. 验证缓存补偿（如果有实现）
redis-cli GET "lottery:campaign:BASIC_LOTTERY"
```

#### 6.8.3 数据库降级测试

```bash
# 测试数据库不可用时的降级行为

# 1. 模拟数据库只读（测试环境）
# SET GLOBAL read_only = ON;

# 2. 测试读操作
curl -s http://localhost:3000/api/v4/user/profile \
  -H "Authorization: Bearer $TOKEN"
# 预期：正常返回用户信息

# 3. 测试写操作
curl -s -X POST http://localhost:3000/api/v4/lottery/draw \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer $TOKEN" \
  -H "Idempotency-Key: db_readonly_test_$(date +%s)" \
  -d '{"campaign_code": "BASIC_LOTTERY"}'
# 预期：返回 {"success": false, "code": "SERVICE_DEGRADED", "message": "服务暂时不可用，请稍后重试"}
# 禁止：返回 500 Internal Server Error
```

#### 6.8.4 降级响应格式规范

```javascript
// 降级响应标准格式（不是 500 错误）
{
  "success": false,
  "code": "SERVICE_DEGRADED",
  "message": "服务暂时不可用，请稍后重试",
  "data": null,
  "degraded": true,           // 标记为降级响应
  "degraded_reason": "redis_unavailable",  // 降级原因
  "retry_after": 30           // 建议重试时间（秒）
}

// HTTP 状态码使用 503 Service Unavailable，不是 500
// 503 表示临时不可用，客户端应该稍后重试
```

#### 6.8.5 降级处理代码示例

```javascript
// middleware/circuitBreaker.js（建议实现）
class CircuitBreaker {
  constructor(options = {}) {
    this.failureThreshold = options.failureThreshold || 5;
    this.resetTimeout = options.resetTimeout || 30000;
    this.failures = 0;
    this.lastFailure = null;
    this.state = 'CLOSED'; // CLOSED, OPEN, HALF_OPEN
  }

  async execute(operation, fallback) {
    if (this.state === 'OPEN') {
      if (Date.now() - this.lastFailure > this.resetTimeout) {
        this.state = 'HALF_OPEN';
      } else {
        return fallback ? await fallback() : this.degradedResponse();
      }
    }

    try {
      const result = await operation();
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();
      if (fallback) {
        return await fallback();
      }
      return this.degradedResponse(error.message);
    }
  }

  onSuccess() {
    this.failures = 0;
    this.state = 'CLOSED';
  }

  onFailure() {
    this.failures++;
    this.lastFailure = Date.now();
    if (this.failures >= this.failureThreshold) {
      this.state = 'OPEN';
    }
  }

  degradedResponse(reason = 'service_unavailable') {
    return {
      success: false,
      code: 'SERVICE_DEGRADED',
      message: '服务暂时不可用，请稍后重试',
      data: null,
      degraded: true,
      degraded_reason: reason,
      retry_after: Math.ceil(this.resetTimeout / 1000)
    };
  }
}

module.exports = CircuitBreaker;
```

#### 6.8.6 熔断降级测试清单

**待创建集成测试**：`tests/integration/circuit_breaker.test.js`

```javascript
// 测试用例清单
describe('熔断降级测试', () => {
  describe('Redis 降级', () => {
    it('Redis 不可用时读操作降级到数据库')
    it('Redis 不可用时写操作正常，异步补偿')
    it('Redis 恢复后自动恢复缓存')
  })
  
  describe('数据库降级', () => {
    it('数据库只读时写操作返回 SERVICE_DEGRADED')
    it('数据库不可用时返回缓存数据（如有）')
    it('数据库恢复后自动恢复正常')
  })
  
  describe('响应格式', () => {
    it('降级响应使用 503 状态码，不是 500')
    it('降级响应包含 retry_after 字段')
    it('降级响应包含 degraded_reason 字段')
  })
})
```

---

## 八、问题诊断流程

当 API 返回错误时，按以下流程进行诊断。

### 8.1 查看错误日志

```bash
# 查看 PM2 日志
pm2 logs --lines 50 --nostream

# 查看特定错误
pm2 logs --lines 50 --nostream 2>&1 | grep -E "error|Error" | tail -30
```

### 8.2 定位错误位置

从日志中找到关键信息：

| 信息类型 | 说明 | 示例 |
|----------|------|------|
| 出错的 Stage/Service | 哪个模块报错 | `[Stage:SettleStage] 结算阶段失败` |
| 具体错误消息 | 错误描述 | `notNull Violation: LotteryDraw.asset_transaction_id cannot be null` |
| 堆栈追踪 | 代码调用链 | `at SettleStage.execute (SettleStage.js:378:12)` |

### 8.3 根因分析流程

```
错误消息
    ↓
找到报错的模型/方法
    ↓
追溯数据来源
    ↓
定位问题根因
    ↓
修复代码
    ↓
验证修复
```

**示例：`asset_transaction_id cannot be null`**

1. 找到报错的模型：`LotteryDraw`
2. 找到创建该记录的代码：`SettleStage._createDrawRecord`
3. 追溯数据来源：`AssetService.changeBalance` 的返回值
4. 确认问题：返回值没有被捕获和传递
5. 修复：捕获返回值并传递给 `_createDrawRecord`

### 8.4 修复验证

修复后必须重新测试：

```bash
# 1. 检查代码语法
npm run lint

# 2. 重启服务
npm run pm:restart

# 3. 重新调用相同的 API
curl -s -X POST http://localhost:3000/api/v4/lottery/draw \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer $TOKEN" \
  -H "Idempotency-Key: lottery_draw_$(date +%s)_verify" \
  -d '{"campaign_code": "BASIC_LOTTERY"}'

# 4. 运行完整测试套件（确保没有破坏其他功能）
npm test
```

---

## 九、常见问题诊断案例

### 案例 1：方法不存在

**错误信息**：
```
BudgetProviderFactory.create is not a function
```

**诊断思路**：
1. 方法不存在 → 检查导入方式
2. 发现 `require` 导入的是模块对象而非类本身

**根因**：
```javascript
// 错误写法
const BudgetProviderFactory = require('../budget/BudgetProviderFactory')
// 导入的是 { BudgetProviderFactory, NoBudgetProvider, factory }

// 正确写法
const { BudgetProviderFactory } = require('../budget/BudgetProviderFactory')
```

---

### 案例 2：NOT NULL 约束失败

**错误信息**：
```
notNull Violation: LotteryDraw.asset_transaction_id cannot be null
```

**诊断思路**：
1. 必填字段为空 → 追溯字段来源
2. 发现 `AssetService.changeBalance` 返回值未被使用

**根因**：
```javascript
// 错误写法：未捕获返回值
await AssetService.changeBalance({ ... })

// 正确写法：捕获并使用返回值
const result = await AssetService.changeBalance({ ... })
const asset_transaction_id = result.transaction_record.transaction_id
```

---

### 案例 3：对象属性访问失败

**错误信息**：
```
Cannot read properties of undefined (reading 'unified')
```

**诊断思路**：
1. 对象访问失败 → 搜索代码中 `.unified` 的使用
2. 发现初始化和使用时字段名不一致

**根因**：
```javascript
// 初始化时
this.metrics = {
  pipelines_used: {}  // 使用 pipelines_used
}

// 更新时
this.metrics.strategies_used[strategyUsed] = ...  // 使用 strategies_used（错误）
```

---

### 案例 4：参数未传递

**错误信息**：
```
notNull Violation: LotteryDrawDecision.idempotency_key cannot be null
```

**诊断思路**：
1. 必填字段为空 → 追溯方法调用链
2. 发现调用方未传递该参数

**根因**：
```javascript
// 调用时未传递 idempotency_key
await this._createDecisionRecord({
  draw_id,
  user_id,
  campaign_id,
  decision_snapshot,
  transaction
})

// 正确写法
await this._createDecisionRecord({
  draw_id,
  user_id,
  campaign_id,
  idempotency_key,  // 添加缺失的参数
  decision_snapshot,
  transaction
})
```

---

### 案例 5：外键约束失败

**错误信息**：
```
Cannot add or update a child row: a foreign key constraint fails
```

**诊断思路**：
1. 外键约束失败 → 检查引用的父记录是否存在
2. 使用 Node.js 脚本验证外键引用完整性

**验证脚本**：
```javascript
// 检查外键引用
const [result] = await sequelize.query(`
  SELECT * FROM lottery_draws 
  WHERE user_id NOT IN (SELECT user_id FROM users)
`)
```

---

## 十、测试完整性验证清单

在提交代码前，确保完成以下验证：

### 基础验证
- [ ] **健康检查通过**：`curl http://localhost:3000/health` 返回 `SYSTEM_HEALTHY`
- [ ] **ESLint 检查通过**：`npm run lint` 无错误
- [ ] **自动化测试通过**：`npm test` 无失败

### API 测试
- [ ] **认证模块**：
  - [ ] 登录 API
  - [ ] 用户信息 API
- [ ] **抽奖模块**：
  - [ ] 单抽 API
  - [ ] 多连抽 API
  - [ ] Pipeline 分阶段验证
- [ ] **交易市场模块**：
  - [ ] 挂牌 API
  - [ ] 购买 API
- [ ] **资产模块**：
  - [ ] 余额查询 API
  - [ ] 流水查询 API

### 数据库验证
- [ ] **数据一致性对账**：运行 `node scripts/reconciliation/run_all_checks.js`
- [ ] **数据库连接检查**：运行 `node scripts/validation/check_db_connections.js`
- [ ] **综合验证检查**：运行 `npm run validate:full`
- [ ] **数据一致性**：
  - [ ] 积分余额正确变更
  - [ ] 抽奖记录正确写入
  - [ ] 事务回滚正常工作

### 性能验证
- [ ] **响应时间**：核心 API < 500ms
- [ ] **并发测试**：无竞态问题
- [ ] **幂等性**：重复请求返回一致结果

### 用户异常行为验证（防"无脑用法"）
- [ ] **快速重复点击**：
  - [ ] 相同 Idempotency-Key 不重复扣款
  - [ ] 不同 Idempotency-Key 正常扣款
- [ ] **边界条件**：
  - [ ] 余额不足返回错误，不扣款
  - [ ] 活动过期/未开始返回错误
  - [ ] 超出每日限制返回错误
- [ ] **异常输入**：
  - [ ] 空值/null 被拒绝
  - [ ] 超长/特殊字符被过滤
  - [ ] 负数/超大数被拒绝
- [ ] **权限异常**：
  - [ ] 无 Token 返回 401
  - [ ] 无效 Token 返回 401
  - [ ] 权限不足返回 403

### 运营配置验证（动态调整）
- [ ] **配置热加载**：
  - [ ] 修改概率配置 60s 内生效
  - [ ] 修改库存配置立即生效
  - [ ] 修改每日限制立即生效
- [ ] **功能开关**：
  - [ ] 关闭抽奖开关返回"功能维护中"
  - [ ] 关闭交易开关禁止挂牌/购买
  - [ ] 紧急熔断开关生效
- [ ] **配置审计**：
  - [ ] 配置变更记录到审计日志

### 概率与经济系统验证
- [ ] **概率分布**：
  - [ ] 各档位实际概率在配置 ±5% 范围内
  - [ ] 保底机制正确触发
- [ ] **经济平衡**：
  - [ ] 积分产出/消耗比例合理（>30%）
  - [ ] 无异常通货膨胀

### 风控规则验证
- [ ] **限流规则**：
  - [ ] 用户每分钟超限返回 RATE_LIMIT_EXCEEDED
  - [ ] IP 每分钟超限返回 TOO_MANY_REQUESTS
- [ ] **黑名单规则**：
  - [ ] 黑名单用户被正确阻止
- [ ] **异常检测**：
  - [ ] 高频抽奖被标记风险
  - [ ] 快速倒卖被检测

### 熔断降级验证
- [ ] **Redis 降级**：
  - [ ] Redis 不可用时读操作降级到数据库（**不返回 500**）
  - [ ] Redis 不可用时写操作正常执行
- [ ] **数据库降级**：
  - [ ] 数据库只读时写操作返回 SERVICE_DEGRADED（**不返回 500**）
  - [ ] 使用 503 状态码，不是 500
- [ ] **响应格式**：
  - [ ] 降级响应包含 `degraded: true` 标记
  - [ ] 降级响应包含 `retry_after` 字段

---

## 十一、核心测试原则

| 原则 | 说明 |
|------|------|
| 🔴 **对齐实际代码** | **禁止引用历史报告/外部文档**，必须与当前代码状态和数据库真实数据对齐 |
| **先环境后业务** | 确保基础设施正常再测业务 |
| **先自动后手工** | 自动化测试快速发现明显问题，手工测试验证真实场景 |
| **先表后里** | 从 API 响应开始，逐层深入到服务、模型、数据库 |
| **修复即验证** | 每次修复后立即重新测试，不积累问题 |
| **关注数据流** | 大多数问题出在数据传递链路上（参数未传递、返回值未捕获） |
| **Node.js 验证** | 使用 Node.js 脚本直接连接数据库验证数据，而非依赖 MySQL 客户端 |

### 🔴 对齐实际代码的具体要求

| 要求 | 说明 | 验证方法 |
|------|------|----------|
| **禁止引用历史报告** | 不依赖过时的分析报告或文档 | 所有引用必须指向当前代码文件 |
| **禁止引用外部文档** | 不依赖与本项目无关的文档 | 测试脚本必须能直接运行 |
| **对齐数据库真实数据** | 测试数据来自真实数据库，不是虚构 | 使用 `.env` 连接真实数据库 |
| **对齐实际业务逻辑** | 了解项目的商业模式和业务流程 | 测试覆盖实际业务场景 |
| **对齐技术框架** | 了解项目的技术栈和架构 | 测试脚本使用项目现有依赖 |

```bash
# 验证测试脚本是否能在当前代码库运行
node scripts/reconciliation/run_all_checks.js          # 必须能直接运行
node scripts/validation/check_db_connections.js        # 必须连接真实数据库
npm test -- tests/integration/pipeline_full_flow.test.js  # 必须通过
```

---

## 十二、常用命令速查

```bash
# === 服务管理 ===
npm run pm:start:pm2      # 启动服务
npm run pm:restart        # 重启服务
pm2 status                # 查看状态
pm2 logs --lines 50       # 查看日志

# === 代码质量 ===
npm run lint              # ESLint 检查
npm run lint:fix          # ESLint 自动修复
npm run format            # Prettier 格式化

# === 测试 ===
npm test                  # 运行所有测试
npm test -- --testPathPattern="lottery"  # 运行特定测试

# === 数据库 ===
npm run migration:create  # 创建迁移
npm run migration:up      # 执行迁移
npm run migration:down    # 回滚迁移

# === 数据验证脚本（实际存在） ===
# 对账脚本
node scripts/reconciliation/run_all_checks.js              # 一键执行所有对账
node scripts/reconciliation/check_lottery_consistency.js   # 抽奖一致性
node scripts/reconciliation/check_consumption_consistency.js # 消费一致性
node scripts/reconciliation/check_exchange_consistency.js  # 兑换一致性

# 验证脚本
node scripts/validation/check_db_connections.js            # 数据库连接
node scripts/validation/verify_idempotency_canonical.js    # 幂等性验证
node scripts/validation/pre_start_check.js                 # 预启动检查

# 诊断脚本
node scripts/diagnostic/verify_lottery_ledger.js           # 抽奖账本验证
node scripts/diagnostic/check_lottery_txns.js              # 抽奖交易检查

# === API 测试 ===
# 健康检查
curl -s http://localhost:3000/health

# 登录
curl -s -X POST http://localhost:3000/api/v4/auth/login-code \
  -H "Content-Type: application/json" \
  -d '{"mobile": "13612227930", "code": "123456"}'

# 抽奖
curl -s -X POST http://localhost:3000/api/v4/lottery/draw \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer $TOKEN" \
  -H "Idempotency-Key: lottery_draw_$(date +%s)_test" \
  -d '{"campaign_code": "BASIC_LOTTERY"}'

# 资产查询
curl -s http://localhost:3000/api/v4/assets/balance \
  -H "Authorization: Bearer $TOKEN"

# 背包查询
curl -s http://localhost:3000/api/v4/backpack/items \
  -H "Authorization: Bearer $TOKEN"
```

---

## 附录

### A. 测试账号信息

| 用途 | 手机号 | 验证码 | 角色 |
|------|--------|--------|------|
| 测试账号 | 13612227930 | 123456 | 用户 + 管理员 |

> ⚠️ **注意**：以上测试账号仅用于开发和测试环境，生产环境请使用真实验证码。

### B. 数据库模型关系图

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│      User       │───▶│     Account     │───▶│AccountAssetBalance│
│   (user_id)     │    │  (account_id)   │    │  (balance_id)   │
└─────────────────┘    └─────────────────┘    └─────────────────┘
        │                      │
        │                      ▼
        │              ┌─────────────────┐
        │              │AssetTransaction │
        │              │(transaction_id) │
        │              └─────────────────┘
        │
        ▼
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│  LotteryDraw    │───▶│LotteryDrawDecision│   │   LotteryPrize  │
│   (draw_id)     │    │  (decision_id)  │    │   (prize_id)    │
└─────────────────┘    └─────────────────┘    └─────────────────┘
        │                                              │
        │                                              │
        ▼                                              ▼
┌─────────────────┐                          ┌─────────────────┐
│  ItemInstance   │                          │ LotteryCampaign │
│(item_instance_id)│                         │  (campaign_id)  │
└─────────────────┘                          └─────────────────┘
        │
        ▼
┌─────────────────┐    ┌─────────────────┐
│ MarketListing   │───▶│   TradeOrder    │
│  (listing_id)   │    │   (order_id)    │
└─────────────────┘    └─────────────────┘
```

### C. Pipeline Stage 执行顺序

```
1. EligibilityStage      → 用户资格校验
2. LoadCampaignStage     → 加载活动配置
3. LoadDecisionSourceStage → 决策来源判断
4. PricingStage          → 定价计算
5. BudgetContextStage    → 预算上下文
6. BuildPrizePoolStage   → 构建奖品池
7. TierPickStage         → 档位选择
8. PrizePickStage        → 奖品选择
9. GuaranteeStage        → 保底机制
10. SettleStage          → 结算写入
11. DecisionSnapshotStage → 决策快照
```

### D. 项目实际脚本目录结构

```
scripts/
├── reconciliation/                  # 🔍 对账脚本（实际存在）
│   ├── run_all_checks.js           # 一键执行所有对账
│   ├── check_lottery_consistency.js # 抽奖一致性对账
│   ├── check_consumption_consistency.js # 消费一致性
│   └── check_exchange_consistency.js # 兑换一致性
│
├── validation/                      # ✅ 验证脚本（实际存在）
│   ├── check_db_connections.js     # 数据库连接检查
│   ├── verify_idempotency_canonical.js # 幂等性验证
│   ├── route_validator.js          # 路由验证
│   ├── pre_start_check.js          # 预启动检查
│   ├── verify_all_keys_migrated.js # 迁移完整性
│   ├── check_sequelize_initialization.js # ORM 初始化
│   ├── comprehensive_checker.js    # 综合检查
│   └── verify_service_manager_usage.js # 服务管理器验证
│
├── diagnostic/                      # 🔬 诊断脚本（实际存在）
│   ├── verify_lottery_ledger.js    # 抽奖账本验证
│   ├── check_lottery_txns.js       # 抽奖交易检查
│   ├── verify_doc_claims.js        # 文档声明验证
│   └── diagnose_503_error.sh       # 503 错误诊断
│
├── database/                        # 💾 数据库工具
│   └── database_toolkit.js         # 数据库工具包
│
├── toolkit/                         # 🛠️ 工具包
│   ├── timezone_toolkit.js         # 时区工具
│   └── generate_api_docs.js        # API 文档生成
│
└── system/                          # ⚙️ 系统脚本
    └── process_manager.sh          # 进程管理器
```

### E. 常用 npm 命令速查

```bash
# 测试相关
npm test                            # 运行所有测试
npm run test:database               # 数据库检查
npm run test:contracts              # API 契约测试

# 验证相关
npm run validate:prestart           # 预启动验证
npm run validate:full               # 完整验证

# 进程管理
npm run pm:status                   # 进程状态
npm run pm:start:pm2                # PM2 启动
npm run pm:restart                  # 重启
npm run pm:health                   # 健康检查

# 系统检查
npm run system:check                # 系统检查
npm run check:config                # 配置检查
```

### F. 推荐架构方案（游戏公司 + 交易平台风控混合版）

> 🎯 **适用场景**：本项目是抽奖系统（类似游戏抽卡）+ 虚拟物品交易（类似游戏道具交易），
> 未上线可以一次性投入，需要运营动态调整。

#### F.1 架构总览

```
┌──────────────────────────────────────────────────────────────┐
│                    推荐架构方案                               │
├──────────────────────────────────────────────────────────────┤
│                                                              │
│  ┌─────────────────────────────────────────────────────┐    │
│  │  运营管理后台（Admin）                               │    │
│  │  ├── 活动配置（时间、状态、开关）                    │    │
│  │  ├── 抽奖配置（概率、档位、保底）← 动态调整         │    │
│  │  ├── 奖品配置（库存、权重）← 动态调整               │    │
│  │  ├── 风控配置（限制、黑名单）← 动态调整             │    │
│  │  └── 开关配置（功能开关、紧急熔断）                  │    │
│  └─────────────────────────────────────────────────────┘    │
│                           ↓                                  │
│  ┌─────────────────────────────────────────────────────┐    │
│  │  数据库配置表 + Redis 缓存热加载                     │    │
│  │  ├── lottery_campaigns（活动配置）← 已有            │    │
│  │  ├── lottery_tier_rules（档位规则）← 已有           │    │
│  │  ├── lottery_prizes（奖品配置）← 已有               │    │
│  │  ├── system_configs（系统开关）← 需补充             │    │
│  │  └── risk_control_rules（风控规则）← 需补充         │    │
│  └─────────────────────────────────────────────────────┘    │
│                           ↓                                  │
│  ┌─────────────────────────────────────────────────────┐    │
│  │  业务服务（热加载配置）                              │    │
│  │  ├── 配置变更监听（数据库轮询/Redis订阅）           │    │
│  │  ├── 配置缓存刷新（TTL 或 事件驱动）                │    │
│  │  └── 配置生效验证（日志记录、监控打点）             │    │
│  └─────────────────────────────────────────────────────┘    │
│                                                              │
└──────────────────────────────────────────────────────────────┘
```

#### F.2 已有配置表（无需新建）

| 配置表 | 用途 | 热加载方式 |
|--------|------|------------|
| `lottery_campaigns` | 活动配置 | 每次请求查询 / Redis 缓存 |
| `lottery_tier_rules` | 档位概率规则 | Pipeline Stage 加载 |
| `lottery_prizes` | 奖品配置 | Pipeline Stage 加载 |
| `lottery_campaign_pricing_config` | 定价配置 | Pipeline Stage 加载 |
| `lottery_management_settings` | 管理干预配置 | Pipeline Stage 加载 |

#### F.3 需补充的配置表

| 配置表 | 用途 | 建议字段 |
|--------|------|----------|
| `system_configs` | 系统开关 | `config_key`, `config_value`, `description`, `updated_at` |
| `risk_control_rules` | 风控规则 | `rule_type`, `rule_config`, `is_active`, `priority` |
| `user_risk_profiles` | 用户风险画像 | `user_id`, `risk_level`, `risk_score`, `anomaly_flags` |
| `feature_flags` | 功能开关 | `feature_key`, `is_enabled`, `rollout_percentage` |

#### F.4 配置热加载实现建议

```javascript
// services/ConfigHotLoader.js（建议实现）
class ConfigHotLoader {
  constructor() {
    this.cache = new Map();
    this.ttl = 60000; // 60秒 TTL
  }
  
  async getConfig(key) {
    const cached = this.cache.get(key);
    if (cached && Date.now() - cached.timestamp < this.ttl) {
      return cached.value;
    }
    
    // 从数据库加载
    const config = await SystemConfig.findOne({ where: { config_key: key } });
    this.cache.set(key, { value: config?.config_value, timestamp: Date.now() });
    return config?.config_value;
  }
  
  async isFeatureEnabled(featureKey) {
    const value = await this.getConfig(featureKey);
    return value === 'true' || value === true;
  }
  
  // 强制刷新缓存（用于配置变更后立即生效）
  invalidate(key) {
    this.cache.delete(key);
  }
  
  invalidateAll() {
    this.cache.clear();
  }
}

module.exports = new ConfigHotLoader();
```

#### F.5 风控规则建议配置

```json
// risk_control_rules 表数据示例
[
  {
    "rule_type": "rate_limit",
    "rule_config": {
      "user_per_minute": 10,
      "ip_per_minute": 100,
      "user_daily_lottery": 100,
      "user_daily_trade_amount": 10000
    },
    "is_active": true,
    "priority": 1
  },
  {
    "rule_type": "anomaly_detection",
    "rule_config": {
      "high_frequency_threshold": 100,
      "quick_resale_minutes": 5,
      "abnormal_win_rate_threshold": 0.3
    },
    "is_active": true,
    "priority": 2
  }
]
```

#### F.6 测试要点总结

| 测试类型 | 验证内容 | 相关章节 |
|----------|----------|----------|
| **配置热加载** | 修改配置后 60s 内生效 | 6.5.1 |
| **功能开关** | 开关切换立即生效 | 6.5.2 |
| **概率验证** | 实际概率 ±5% 误差范围 | 6.6.1 |
| **保底机制** | 保底正确触发 | 6.6.2 |
| **经济平衡** | 产出/消耗比例合理 | 6.6.3 |
| **限流规则** | 超限返回正确错误码 | 6.7.1 |
| **黑名单** | 黑名单用户被正确阻止 | 6.7.2 |
| **异常检测** | 异常行为被正确标记 | 6.7.3 |

---

### 附录 G：测试开发计划（TDD）

> 🧪 **TDD 策略**：先创建测试（会失败），倒逼功能实现。所有测试全部自动化。

#### G.1 待创建测试文件清单

按优先级排序，P0 优先创建：

| 优先级 | 测试文件 | 目录 | 覆盖场景 | 状态 |
|--------|----------|------|----------|------|
| **P0** | `probability_verification.test.js` | `tests/specialized/` | 10000 次抽奖概率分布验证 | 🔴 待创建 |
| **P0** | `concurrent_lottery.test.js` | `tests/integration/` | 多用户/多设备并发抽奖 | 🔴 待创建 |
| **P0** | `pity_mechanism.test.js` | `tests/specialized/` | 保底机制触发验证 | 🔴 待创建 |
| **P1** | `user_abuse_scenarios.test.js` | `tests/integration/` | 用户异常行为（快速点击、边界值） | 🔴 待创建 |
| **P1** | `config_hot_reload.test.js` | `tests/integration/` | 配置热加载、开关切换 | 🔴 待创建 |
| **P1** | `risk_control.test.js` | `tests/integration/` | 限流规则、黑名单、异常检测 | 🔴 待创建 |
| **P2** | `circuit_breaker.test.js` | `tests/integration/` | 熔断降级（Redis/DB 不可用） | 🔴 待创建 |
| **P2** | `economic_balance.test.js` | `tests/specialized/` | 积分产出/消耗比例监控 | 🔴 待创建 |

#### G.2 测试辅助文件清单

| 文件 | 目录 | 用途 | 状态 |
|------|------|------|------|
| `test-points-setup.js` | `tests/helpers/` | 测试前积分充值（支持大规模测试） | 🔴 待创建 |
| `test-concurrent-utils.js` | `tests/helpers/` | 并发测试工具函数 | 🔴 待创建 |
| `test-mock-redis.js` | `tests/helpers/` | Redis 模拟（熔断测试用） | 🔴 待创建 |

#### G.3 测试创建模板

**P0 测试模板**（`tests/specialized/probability_verification.test.js`）：

```javascript
/**
 * 概率验证测试
 * 
 * TDD 状态: 🔴 先创建测试 → 运行失败 → 倒逼实现
 * 
 * @file tests/specialized/probability_verification.test.js
 */
const request = require('supertest')
const app = require('../../app')
const { ensureTestUserHasPoints } = require('../helpers/test-points-setup')
const { TEST_DATA } = require('../helpers/test-data')

const SAMPLE_SIZE = 10000
const TOLERANCE = 0.05 // ±5%

describe('【P0】概率分布验证测试', () => {
  let authToken
  
  beforeAll(async () => {
    // 充值 150 万积分（10000 次抽奖）
    await ensureTestUserHasPoints(1500000)
    
    // 登录获取 token
    const res = await request(app)
      .post('/api/v4/auth/login')
      .send({ mobile: TEST_DATA.users.testUser.mobile, verification_code: '123456' })
    authToken = res.body.data.access_token
  }, 120000)

  test(`执行 ${SAMPLE_SIZE} 次抽奖`, async () => {
    // TODO: 实现批量抽奖逻辑
    expect(true).toBe(false) // 先失败，倒逼实现
  }, 900000)

  test('各档位概率误差在 ±5% 范围内', async () => {
    // TODO: 实现概率验证逻辑
    expect(true).toBe(false) // 先失败，倒逼实现
  })
})
```

**P1 测试模板**（`tests/integration/concurrent_lottery.test.js`）：

```javascript
/**
 * 并发抽奖测试
 * 
 * TDD 状态: 🔴 先创建测试 → 运行失败 → 倒逼实现
 * 
 * @file tests/integration/concurrent_lottery.test.js
 */
const request = require('supertest')
const app = require('../../app')
const { ensureTestUserHasPoints } = require('../helpers/test-points-setup')
const { TEST_DATA } = require('../helpers/test-data')

describe('【P0】并发抽奖测试', () => {
  const CONCURRENT_USERS = 10
  const DRAWS_PER_USER = 5
  
  beforeAll(async () => {
    // 为每个测试用户充值积分
    await ensureTestUserHasPoints(100000)
  }, 60000)

  test('10 用户同时抽奖不出现库存超卖', async () => {
    // TODO: 实现并发抽奖逻辑
    expect(true).toBe(false) // 先失败，倒逼实现
  }, 60000)

  test('同一用户多设备同时抽奖幂等性验证', async () => {
    // TODO: 实现幂等性验证逻辑
    expect(true).toBe(false) // 先失败，倒逼实现
  })

  test('并发情况下积分扣减一致性', async () => {
    // TODO: 实现一致性验证逻辑
    expect(true).toBe(false) // 先失败，倒逼实现
  })
})
```

#### G.4 测试执行顺序

```bash
# 1. 先创建所有测试文件（会失败）
npm test -- tests/specialized/probability_verification.test.js  # 🔴 失败
npm test -- tests/integration/concurrent_lottery.test.js        # 🔴 失败
npm test -- tests/specialized/pity_mechanism.test.js            # 🔴 失败

# 2. 创建辅助文件
# tests/helpers/test-points-setup.js
# tests/helpers/test-concurrent-utils.js

# 3. 逐个实现测试逻辑
# 每实现一个，对应测试变绿 ✅

# 4. 全部通过后运行完整测试套件
npm test -- --coverage
```

#### G.5 测试验收标准

| 测试类型 | 验收条件 | 超时设置 |
|----------|----------|----------|
| 概率验证 | 10000 次抽奖全部完成，各档位误差 < 5% | 15 分钟 |
| 并发抽奖 | 10 用户并发无库存超卖、无数据不一致 | 1 分钟 |
| 保底机制 | 保底次数内必触发、触发后计数器重置 | 30 秒 |
| 配置热加载 | 配置修改后 60 秒内生效 | 2 分钟 |
| 限流规则 | 超限请求返回 429、未超限正常处理 | 30 秒 |
| 熔断降级 | Redis 断开后服务降级不崩溃 | 1 分钟 |

---

> 📝 **文档维护说明**：本文档应随业务逻辑变更同步更新，确保测试方法与实际代码保持一致。
