# 三项核心需求实施方案

> 创建时间：2026-02-23
> **数据来源：Node.js (mysql2) 连接 Sealos 真实数据库实时验证（dbconn.sealosbja.site:42569）**
> **代码来源：`/home/devbox/project` 后端源码 + `admin/` Web管理后台源码实际审计**
> 状态：后端+Web管理后台+资产守恒全部实施完成并验证通过，等待微信小程序前端对接
> 最后更新：2026-02-24（扫码核销功能从独立页面合并到兑换核销管理的"扫码核销"Tab中；删除 `redemption-scan.html`；侧边栏"扫码核销"菜单项已移除）

---

## 零、后端项目技术框架概要（权威基线）

后续所有需求的接口路径、数据库查询、响应格式、字段设计，均以此技术框架为准。前端（Web管理后台 / 微信小程序）适配后端，不做反向兼容。

| 维度 | 实际状态 |
|---|---|
| 运行时 | Node.js 20+ / Express 4.18 |
| ORM | Sequelize 6.35（MySQL方言，mysql2驱动） |
| 数据库 | Sealos MySQL（98张表，`restaurant_points_dev`） |
| API版本 | 全局 `/api/v4/*`（扁平化 RESTful 资源导向） |
| 认证 | JWT Bearer Token（`middleware/auth.js` 的 `authenticateToken`） |
| 权限 | RBAC（`roles` + `user_roles` 表，role_level 数值分级） |
| 事务 | `TransactionManager.execute()` 统一管理，Service层 `assertAndGetTransaction` 强制校验 |
| 服务容器 | `ServiceManager` 单例（路由通过 `req.app.locals.services.getService('key')` 获取） |
| 响应格式 | `ApiResponse` 中间件统一：`{ success, code, message, data, timestamp, version, request_id }` |
| 物品体系 | 三表模型：`items`（缓存层）+ `item_ledger`（真相层，双录记账）+ `item_holds`（锁定层） |
| 资产体系 | `accounts`（统一账户）+ `account_asset_balances`（余额）+ `asset_transactions`（双录流水） |
| 模型数量 | 96 个 Sequelize 模型（`models/*.js`） |
| 迁移数量 | 392 个已执行迁移（`SequelizeMeta` 表） |
| 时区 | 全链路北京时间 `Asia/Shanghai`（`process.env.TZ`） |
| 日志 | Winston 结构化日志（`utils/logger.js`） |
| 幂等 | `idempotency_key` 唯一约束（asset_transactions / item_ledger） |
| 缓存 | Redis（ioredis） |

**Web管理后台技术栈（`admin/` 目录）：**

| 维度 | 实际状态 |
|---|---|
| 构建 | Vite 6.4 |
| 框架 | Alpine.js 3.15（响应式数据绑定） |
| 样式 | Tailwind CSS 3.4 |
| 图表 | ECharts 6.0 |
| WebSocket | socket.io-client 4.8 |
| API调用 | `admin/src/api/base.js` 统一 `request()` 封装，前缀 `API_PREFIX = '/api/v4'` |
| 页面模式 | 多页应用（每个 `.html` 文件对应一个管理功能页） |
| 现有页面 | 44个HTML页面（含 `redemption-management.html` 核销管理页（含"订单管理"+"扫码核销"双Tab）、`store-management.html` 门店管理页、`dict-management.html` 字典管理页，均已存在） |
| 已有核销API封装 | `admin/src/api/redemption.js`（LIST/STATISTICS/EXPORT/BATCH_REDEEM/BATCH_CANCEL/BATCH_EXPIRE/SCAN/FULFILL 八个端点已封装） |

**系统账户体系（accounts 表实际数据）：**

| account_id | system_code | 用途 |
|---|---|---|
| 1 | SYSTEM_PLATFORM_FEE | 平台手续费收入 |
| 2 | SYSTEM_MINT | 系统发放来源 |
| 3 | SYSTEM_BURN | 系统销毁去向 |
| 4 | SYSTEM_ESCROW | 争议托管（预留） |
| 12 | SYSTEM_RESERVE | 系统储备（对账修正对手方） |
| 15 | SYSTEM_CAMPAIGN_POOL | 活动奖池 |

---

## 一、需求总览与优先级

| 优先级 | 需求 | 当前问题 | 目标 |
|---|---|---|---|
| P0 | 核销流程走通 | 1158 个过期 vs 5 个核销，流程基本未被使用 | 完整跑通"生成兑换码→到店核销"链路 |
| P0 | 资产守恒残差修复 | DIAMOND 差 -42,094；POINTS 差 -48,403；red_shard 差 +43,595 | 全部 SUM=0，对账脚本零告警 |
| P1 | 多商家架构 | 系统无 merchant 维度，无法区分奖品来自哪个商家 | 新增 merchants 表 + 关键表加 merchant_id |

---

## 二、核销流程诊断与修复（P0）

### 2.1 当前状态（2026-02-23 数据库实时验证）

**redemption_orders 表统计（2026-02-23 二次实时查询）：**

| 状态 | 数量 | 占比 |
|---|---|---|
| expired | 1,162 | 86.8% |
| pending | 171 | 12.8% |
| fulfilled | 5 | 0.4% |
| cancelled | 1 | 0.1% |

**171 笔 pending 订单：** 最早创建于 2026-01-26，最晚过期于 2026-03-25，当前全部仍在有效期内。

**5 笔成功核销详情（数据库存储 UTC，以下为北京时间 +8h）：**

| 订单 | 物品 | 创建时间 | 核销时间 | 间隔 |
|---|---|---|---|---|
| 56fdcc0b | item_id=17931 | 01-22 06:54 | 01-22 07:04 | 10 分钟 |
| 8b7ae804 | item_id=17934 | 01-22 06:54 | 01-22 07:04 | 10 分钟 |
| 419c38a7 | item_id=18690 | 01-22 10:28 | 01-25 14:03 | 3 天 |
| e6c52465 | item_id=28773 | 02-19 12:28 | 02-20 20:40 | 1 天 |
| d82faa98 | item_id=28738 | 02-20 19:50 | 02-20 20:40 | 49 分钟 |

5 笔核销全部集中在两个时间点（01-22 和 02-20），大概率是开发调试而非真实用户使用。

### 2.2 问题根因分析（按三端归因）

核销流程涉及三方角色和两个端：

```
用户（小程序）              商家店员（核销端）
    │                          │
    ├── 1. 背包选物品           │
    ├── 2. 点"生成兑换码"       │
    │   → POST /api/v4/backpack/items/:item_id/redeem
    │   → 返回 { code: 'XXXX-YYYY-ZZZZ', qr: {...} }
    ├── 3. 展示兑换码/QR码给店员 │
    │                          ├── 4. 扫QR码 或 输入文本码
    │                          │   → POST /api/v4/shop/redemption/scan（主流程：QR码）
    │                          │   → POST /api/v4/shop/redemption/fulfill（备用：文本码）
    │                          ├── 5. 核销成功
    │                          │
    └── 6. 物品状态变为 used    │
```

#### 后端（本项目）已具备的能力（代码审计确认）

| 环节 | 文件 / 路由 | 状态 | 说明 |
|---|---|---|---|
| 创建订单 | `RedemptionService.createOrder` | ✅ 已实现 | 生成 12 位 Base32 码，SHA-256 哈希存储，30天有效期 |
| 核销订单（文本码） | `RedemptionService.fulfillOrder` | ✅ 已实现 | 验证码 → 查订单 → 更新状态 → 调 `ItemService.consumeItem` 双录 |
| 核销订单（QR码） | `POST /api/v4/shop/redemption/scan` | ✅ 已实现 | RQRV1 签名验证 → 解码 → 调用 fulfillOrder |
| 用户生成核销码 | `POST /api/v4/backpack/items/:item_id/redeem` | ✅ 已实现 | 返回文本码 + QR码数据 |
| QR码刷新 | `POST /api/v4/backpack/items/:item_id/redeem/refresh-qr` | ✅ 已实现 | 5分钟过期后刷新 |
| 过期清理 | `RedemptionService.expireOrders` | ✅ 已实现 | 定时批量过期 |
| 物品消耗 | `ItemService.consumeItem` | ✅ 已实现 | 三表模型双录记账（用户 -1 / SYSTEM_BURN +1） |
| 物品锁定 | `item_holds` 表 | ✅ 已实现 | hold_type='redemption'，防止核销期间物品被交易 |
| 幂等控制 | `code_hash` 唯一约束 | ✅ 已实现 | 同一码不会重复核销 |
| 事务保证 | `TransactionManager.execute` | ✅ 已实现 | 强制事务边界 |
| 核销权限 | `requireMerchantDomainAccess` | ✅ 已实现 | `/shop/*` 域整体受商家角色准入保护 |
| 管理后台核销管理 | `admin/redemption-management.html` | ✅ 已存在 | Tab1:订单列表+批量核销/取消/过期操作 Tab2:扫码核销（文本码+QR码） |

#### 结论：后端能力 100% 就绪，核销未跑通的原因不在后端

**⚠️ 微信小程序前端问题（0% 就绪）：**

| 缺失 | 说明 |
|---|---|
| 小程序未上线 | 用户没有任何入口触达后端 API |
| 背包页面无"生成兑换码"按钮 | 后端 `POST /api/v4/backpack/items/:item_id/redeem` 无前端调用方 |
| 无兑换码展示页 | 核销码 + QR码 + 倒计时无展示载体 |
| 无物品详情页核销码入口 | 已生成核销码的物品无法查看 |

**⚠️ Web管理后台前端问题（80% 就绪）：**

| 现状 | 说明 |
|---|---|
| `redemption-management.html` 已存在（含双Tab） | Tab1:管理员视角的核销订单管理（列表/批量操作）已完成；Tab2:商家店员扫码核销（文本码+QR码）已完成 |
| ~~缺少商家店员扫码核销页面~~ | ✅ 已合并到 `redemption-management.html` 的"扫码核销"Tab中（2026-02-24） |
| `admin/src/api/redemption.js` 已存在 | 后端核销 API 封装已完成（含 SCAN/FULFILL 端点） |

### 2.3 需要建设的内容

#### 2.3.1 微信小程序端（用户侧）— 需小程序团队实现

| 页面 | 功能 | 调用的后端接口（已存在） | 响应字段（后端实际返回） |
|---|---|---|---|
| 背包物品详情页 | 增加"生成兑换码"按钮（仅 `status=available` 且 `item_type` 为 `voucher`/`product` 时显示） | `POST /api/v4/backpack/items/:item_id/redeem` | `{ data: { order: { redemption_order_id, status, expires_at }, code: 'XXXX-YYYY-ZZZZ', qr: { qr_content, expires_at } } }` |
| 兑换码展示页 | 展示 XXXX-YYYY-ZZZZ 格式文本码 + QR码（用 `qr.qr_content` 生成二维码图片）+ 过期倒计时 + 刷新QR按钮 | `POST /api/v4/backpack/items/:item_id/redeem/refresh-qr`（QR过期后刷新） | `{ data: { qr: { qr_content, expires_at } } }` |
| 物品详情页 | 已有兑换码时显示"查看兑换码"入口 | `GET /api/v4/backpack/items/:item_id`（`has_redemption_code` 字段判断） | 后端 BackpackService 已返回 `has_redemption_code: true/false` |

**小程序前端必须使用后端字段名，不做映射：**
- 物品 ID 字段：`item_id`（bigint）
- 物品类型：`item_type`（`voucher` / `product` / `tradable_item` / `prize`）
- 物品状态：`status`（`available` / `held` / `used` / `expired` / `destroyed`）
- 唯一标识：`tracking_code`（人类可读，如 `TRK-XXXXXX`）
- 稀有度：`rarity_code`（`common` / `uncommon` / `rare` / `epic` / `legendary`）
- 订单 ID：`redemption_order_id`（UUID 格式）

#### 2.3.2 Web管理后台（商家店员扫码核销）— ✅ 已完成

**✅ 决定 #1 已确认：先Web后小程序（预留小程序对接）**
**✅ 2026-02-24更新：扫码核销已合并到 `redemption-management.html` 的"扫码核销"Tab中，不再是独立页面**

**阶段一（立即实施）：Web管理后台新增核销页面**

| 位置 | 功能 | 调用的后端接口（已存在） |
|---|---|---|
| `admin/redemption-management.html` → "扫码核销" Tab | 店员输入文本码 或 粘贴QR码内容 → 确认核销 → 展示结果 + 本次会话核销记录 | `POST /api/v4/shop/redemption/scan`（QR码）或 `POST /api/v4/shop/redemption/fulfill`（文本码） |

技术实现（✅ 已完成）：
- Alpine.js 组件内置于 `redemption-management.js`（`scan` 状态对象 + `fulfillByTextCode()` / `fulfillByScan()` 方法）
- 页面 Tab 切换：`activeTab = 'orders'` / `activeTab = 'scan'`
- 核销后自动刷新统计数据（`loadStats()`），支持文本码和QR码两种核销方式

**阶段二（后续迭代）：小程序内嵌商家核销功能**

| 页面 | 功能 | 调用的后端接口（与Web端完全相同） |
|---|---|---|
| 小程序商家模式 | `wx.scanCode` 扫QR码 → 调用 `POST /api/v4/shop/redemption/scan` → 展示核销结果 | 同 Web 端，后端零改动 |

#### 2.3.4 三端联动架构（预留小程序对接设计）

后端 API 设计已天然支持三端联动，三个端调用的是同一套后端接口，无需为任何端做特殊适配：

```
┌─────────────────────────────────────────────────────────────────────┐
│                          后端 API 层（已100%就绪）                    │
│                                                                     │
│  用户侧接口（/api/v4/backpack/*）        商家侧接口（/api/v4/shop/*） │
│  ├─ GET  /backpack                      ├─ POST /shop/redemption/scan    │
│  ├─ GET  /backpack/items/:id            ├─ POST /shop/redemption/fulfill │
│  ├─ POST /backpack/items/:id/redeem     └─ GET  /shop/redemption/...     │
│  └─ POST /backpack/items/:id/redeem/refresh-qr                     │
│                                                                     │
│  认证：JWT Bearer Token（三端统一）                                   │
│  权限：role_level 数值分级（用户 < 商家员工 < 管理员）                 │
│  响应格式：{ success, code, message, data }（三端统一）               │
└──────────────┬───────────────────────────┬──────────────────────────┘
               │                           │
   ┌───────────┴───────────┐   ┌───────────┴───────────┐
   │   调用方 1: 微信小程序   │   │   调用方 2: Web管理后台  │
   │   （用户侧 + 商家侧）   │   │   （商家侧 + 管理侧）   │
   │                        │   │                        │
   │  用户操作：              │   │  店员操作：              │
   │  ├─ 查看背包             │   │  ├─ 扫码核销             │
   │  ├─ 生成兑换码           │   │  ├─ 核销订单管理         │
   │  └─ 展示QR码给店员       │   │  └─ 核销统计报表         │
   │                        │   │                        │
   │  商家操作（阶段二）：     │   │  已有页面：              │
   │  └─ wx.scanCode扫码核销  │   │  └─ redemption-management│
   │                        │   │     (Tab1:订单 Tab2:扫码) │
   └────────────────────────┘   └────────────────────────┘
```

**三端对接的关键设计点（后端已全部满足）：**

| 对接点 | 后端现状 | 小程序对接方式 | Web管理后台对接方式 |
|---|---|---|---|
| 认证 | JWT Bearer Token | 小程序登录后获取 JWT，请求头携带 `Authorization: Bearer {token}` | 同上，`admin/src/api/base.js` 已封装 |
| 用户生成兑换码 | `POST /api/v4/backpack/items/:id/redeem` | `wx.request` 调用，获取 `code` + `qr.qr_content` | 不适用（用户操作，非管理操作） |
| QR码展示 | 后端返回 `qr_content` 字符串 | 小程序用 `<canvas>` 或 QR库将 `qr_content` 渲染为二维码图片 | 不适用 |
| QR码刷新 | `POST /api/v4/backpack/items/:id/redeem/refresh-qr` | 5分钟倒计时到期后 `wx.request` 刷新 | 不适用 |
| 商家扫码核销 | `POST /api/v4/shop/redemption/scan` | `wx.scanCode` 获取 `qr_content` → `wx.request` 提交 | `getUserMedia` + JS QR解码 → `fetch` 提交 |
| 商家文本码核销 | `POST /api/v4/shop/redemption/fulfill` | 输入框输入 `redeem_code` → `wx.request` 提交 | 输入框输入 → `fetch` 提交 |
| 核销结果推送 | WebSocket 事件（`ChatWebSocketService` 已存在） | `wx.connectSocket` 监听核销状态变更 | `socket.io-client` 监听（已集成） |
| 商家域权限 | `requireMerchantDomainAccess` 中间件 | 商家角色用户登录后自动通过 | 同上 |

**小程序对接时后端零改动的保证：**
1. 后端所有接口通过 JWT 认证，不关心请求来自小程序还是Web — 同一个 token 三端通用
2. 后端 `POST /api/v4/shop/redemption/scan` 接收的是 `qr_content` 字符串，不关心这个字符串是浏览器摄像头扫的还是 `wx.scanCode` 扫的
3. 后端响应格式统一 `{ success, code, message, data }`，小程序直接解析 `res.data.data` 即可
4. 商家权限由后端 `role_level` 判断，小程序用户如果被赋予了 `merchant_staff` 角色就能调用 `/shop/*` 接口

#### 2.3.3 核销流程保障机制（已有，无需新建）

| 机制 | 后端代码位置 | 状态 |
|---|---|---|
| 幂等性 | `code_hash` 唯一约束（RedemptionOrder 模型） | ✅ |
| 物品锁定 | `item_holds` 表，`hold_type='redemption'` | ✅ |
| 过期清理 | `RedemptionService.expireOrders`（定时任务） | ✅ |
| 双录记账 | `ItemService.consumeItem` → `item_ledger`（用户 -1, SYSTEM_BURN +1） | ✅ |
| 事务保证 | `TransactionManager.execute` + `assertAndGetTransaction` | ✅ |
| QR码签名 | HMAC-SHA256 签名（`REDEMPTION_QR_SECRET` 环境变量，5分钟过期） | ✅ |

### 2.4 实施步骤（两阶段）

**阶段一：先跑通核销闭环（后端零改动）**

| 步骤 | 内容 | 责任端 | 工作量 |
|---|---|---|---|
| ~~1~~ | ~~管理后台新增扫码核销页面~~ → ✅ 已合并到 `redemption-management.html` "扫码核销"Tab（2026-02-24完成） | Web管理后台前端 | ✅ 已完成 |
| 2 | 小程序背包详情页增加"生成兑换码"按钮 + 兑换码展示页（调用已有后端API） | 微信小程序前端 | 1 天 |
| 3 | 端到端测试：用户(小程序)生成码 → 店员(Web)核销 → `items.status` 变 `used` → `item_ledger` 双录验证 → `item_holds` 释放验证 | 全端联调 | 0.5 天 |

阶段一完成后：**用户小程序 + 商家Web** 两端联动跑通核销流程。

**阶段二：小程序商家核销能力（后端仍然零改动）**

| 步骤 | 内容 | 责任端 | 工作量 |
|---|---|---|---|
| 4 | 小程序增加商家角色判断（`role_level >= 20` 显示"核销"入口） | 微信小程序前端 | 0.5 天 |
| 5 | 小程序商家核销页：`wx.scanCode` 扫QR码 → `POST /api/v4/shop/redemption/scan`（与Web端调同一个接口） | 微信小程序前端 | 1 天 |
| 6 | 小程序商家文本码核销备用入口：输入框 → `POST /api/v4/shop/redemption/fulfill` | 微信小程序前端 | 0.5 天 |

阶段二完成后：**用户小程序 + 商家小程序 + 商家Web** 三端联动，店员可以用手机扫码核销。

**后端全程零改动。所有工作量在前端。三个端调用同一套后端 API，通过 JWT 角色区分用户/商家。**

---

## 三、资产守恒残差修复（P0）

### 3.1 当前状态（2026-02-23 二次实时验证 — 今日8个迁移脚本执行后）

**⚠️ 重要：今日已执行 8 个数据治理迁移脚本（`20260223083356` ~ `20260223155029`），资产数据与本文档初版有显著变化。以下为迁移后的最新实时查询结果。**

**已执行的治理迁移（影响资产数据的）：**

| 迁移文件 | 说明 |
|---|---|
| `20260223083356-backfill-counterpart-and-source-ref.js` | 回填 counterpart 和 source_ref |
| `20260223100000-data-governance-phase2.js` | 数据治理Phase2 |
| `20260223101921-backfill-missing-counterpart-records.js` | 回填缺失的counterpart记录 |
| `20260223101953-create-balance-adjustment-records.js` | 创建余额调整记录 |
| `20260223102945-fix-peer-to-peer-counterpart-records.js` | 修复P2P counterpart记录 |
| `20260223154948-backfill-freeze-unfreeze-escrow-counterparts.js` | 回填冻结/解冻escrow counterpart |
| `20260223155029-backfill-legacy-item-mint-ledger.js` | 回填历史物品铸造ledger |

**资产守恒检查（排除 `is_invalid` 记录后）：**

| asset_code | SUM(delta_amount) | 交易笔数 | 状态 | 与初版差异 |
|---|---|---|---|---|
| BUDGET_POINTS | 0 | 172 | ✅ 已平衡 | 无变化 |
| orange_shard | 0 | 8 | ✅ 已平衡 | 无变化 |
| red_crystal | 0 | 8 | ✅ 已平衡 | 无变化 |
| MATERIAL_001 | 0 | 2 | ✅ 已平衡 | 无变化 |
| DIAMOND | **+194,361** | 11,513 | ❌ 未平衡 | 初版 -42,094 → 现 +194,361（方向反转，因迁移新增 4,142 笔交易） |
| POINTS | **-37,433** | 17,223 | ❌ 未平衡 | 初版 -48,403 → 现 -37,433（缩小 10,970，因迁移修复了部分） |
| red_shard | **+77,455** | 12,738 | ❌ 未平衡 | 初版 +43,595 → 现 +77,455（扩大 33,860，因迁移新增了 counterpart 记录） |

**已存在的 system_reconciliation 修正记录（今日迁移产生）：**

| asset_code | 修正金额 | 笔数 | 说明 |
|---|---|---|---|
| DIAMOND | +44,728 | 1 | 初版的 -42,094 基础上补了 +44,728，但后续迁移又引入新失衡 |
| POINTS | -80,923 | 1 | 补了 -80,923 但残差方向与最新数据不一致 |
| red_shard | +1,415 | 1 | 只补了 +1,415，远小于当前 +77,455 残差 |

**已存在的 data_migration_counterpart 记录（今日迁移产生）：**

| asset_code | 净额 | 笔数 |
|---|---|---|
| DIAMOND | +138,687 | 10 |
| POINTS | +35,790 | 4 |
| red_shard | +19,470 | 2 |
| BUDGET_POINTS | +5,217 | 1 |

**DIAMOND 残差来源分析（非零 business_type，按绝对值排序前 10）：**

| business_type | 净额 | 笔数 | 说明 |
|---|---|---|---|
| opening_balance | +669,741 | 15 | 期初余额 |
| opening_balance_counterpart | -666,993 | 15 | **差 +2,748（笔数相同但金额不等）** |
| data_migration_counterpart | +138,687 | 10 | 今日迁移补建（无对应的 data_migration 主记录） |
| system_reconciliation | +44,728 | 1 | 初版修正记录 |
| order_settle_seller_credit | +32,578 | 465 | 卖家结算入账 |
| order_settle_seller_credit_counterpart | -27,644 | 444 | **差 +4,934（21笔缺失counterpart）** |
| order_settle_platform_fee_credit | +1,922 | 465 | 手续费入账 |
| order_settle_platform_fee_credit_counterpart | -1,898 | 462 | **差 +24（3笔缺失counterpart）** |
| test_setup | +3,000 | 6 | 测试数据（无counterpart） |
| test_grant | +240 | 6 | 测试数据（无counterpart） |

**POINTS 残差来源分析：**

| business_type | 净额 | 笔数 | 说明 |
|---|---|---|---|
| opening_balance | -62,387,661 | 4 | 期初余额 |
| opening_balance_counterpart | +62,381,991 | 11 | **差 -5,670（笔数不等 4 vs 11）** |
| lottery_reward | +3,298,050 | 2,437 | 抽奖奖励 |
| lottery_reward_counterpart | -3,297,300 | 2,432 | **差 +750（5笔缺失counterpart）** |
| system_reconciliation | -80,923 | 1 | 初版修正记录 |
| data_migration_counterpart | +35,790 | 4 | 今日迁移补建 |
| test_setup | +9,900 | 48 | 测试数据 |
| test_setup_counterpart | +1,800 | 8 | 测试counterpart |

**red_shard 残差来源分析：**

| business_type | 净额 | 笔数 | 说明 |
|---|---|---|---|
| exchange_debit_counterpart | +251,300 | 2,513 | **counterpart 比 main 多 530 笔** |
| exchange_debit | -198,300 | 1,983 | **差 +53,000** |
| opening_balance | +170,755 | 6 | 期初余额 |
| opening_balance_counterpart | -169,565 | 8 | **差 +1,190（笔数不等 6 vs 8）** |
| data_migration_counterpart | +19,470 | 2 | 今日迁移补建 |
| admin_adjustment | +16,720 | 669 | 管理员调整 |
| admin_adjustment_counterpart | -16,620 | 665 | **差 +100（4笔缺失counterpart）** |
| listing_transfer_buyer_offer_credit | +3,775 | 89 | 买家转入 |
| listing_transfer_buyer_offer_credit_counterpart | -2,805 | 73 | **差 +970（16笔缺失counterpart）** |
| test_mint | +1,310 | 20 | 测试数据（无counterpart） |
| system_reconciliation | +1,415 | 1 | 初版修正记录 |

**全局未配对 counterpart 统计（主记录数 ≠ counterpart 数的 business_type）：**

| base_type | 主记录数 | counterpart数 | 差异 | 影响 |
|---|---|---|---|---|
| exchange_debit | 1,983 | 2,513 | -530 | counterpart多于主记录（异常） |
| order_settle_buyer_debit | 465 | 0 | +465 | **完全无counterpart（但delta_amount=0所以无金额影响）** |
| listing_settle_seller_offer_debit | 89 | 0 | +89 | **完全无counterpart** |
| test_setup | 54 | 8 | +46 | 测试数据 |
| order_settle_seller_credit | 465 | 444 | +21 | 21笔缺失counterpart |
| test_mint | 20 | 0 | +20 | 测试数据 |
| data_migration | 0 | 17 | -17 | counterpart多于主记录 |
| listing_transfer_buyer_offer_credit | 89 | 73 | +16 | 16笔缺失counterpart |
| opening_balance | 35 | 45 | -10 | counterpart多于主记录 |
| lottery_reward | 2,437 | 2,432 | +5 | 5笔缺失counterpart |
| admin_adjustment | 821 | 817 | +4 | 4笔缺失counterpart |

### 3.2 残差原因分析（二次验证结论）

**⚠️ 今日已执行的 7 个数据治理迁移引入了新的复杂性：**

1. **`data_migration_counterpart` 记录只有 counterpart 没有主记录**：迁移脚本创建了 17 条 `data_migration_counterpart` 记录（DIAMOND 10 条 +138,687、POINTS 4 条 +35,790、red_shard 2 条 +19,470），但对应的 `data_migration` 主记录为 0 条。这些 counterpart 本身就是净增量，不应存在。
2. **`system_reconciliation` 修正值已过时**：初版基于 DIAMOND -42,094 补了 +44,728，但迁移后 DIAMOND 变为 +194,361，原修正方向和金额都不再正确。
3. **`opening_balance` 配对异常**：笔数不等（DIAMOND 15:15 但金额差 2,748；POINTS 4:11 金额差 5,670；red_shard 6:8 金额差 1,190）。
4. **`exchange_debit` 反向异常**：counterpart (2,513) 比主记录 (1,983) 多 530 条——正常应该是主记录 ≥ counterpart，这里反了。

**残差来源三大类：**

| 类别 | 影响范围 | 说明 |
|---|---|---|
| A: 今日迁移引入的净增量 | DIAMOND +138,687、POINTS +35,790、red_shard +19,470 | `data_migration_counterpart` 无对应主记录 |
| B: 历史缺失 counterpart | 多个 business_type 存在 4~530 笔不匹配 | 详见上方未配对统计表 |
| C: 旧 system_reconciliation 过时 | DIAMOND +44,728、POINTS -80,923、red_shard +1,415 | 基于旧数据计算，不再准确 |

**正常配对的 business_type（验证通过）：**
- `lottery_consume` / `lottery_consume_counterpart`：5,895 × 2，完全一致 ✅
- `order_freeze_buyer` / `order_freeze_buyer_counterpart`：2,729 × 2，完全一致 ✅
- `market_listing_freeze` / `market_listing_freeze_counterpart`：完全一致 ✅
- `material_convert_credit` / `material_convert_credit_counterpart`：452 × 2，完全一致 ✅

### 3.3 修复方案（二次验证后更新 — 需要你拍板的决定 #6）

**⚠️ 需要拍板：今日迁移引入的 `data_migration_counterpart` 和旧 `system_reconciliation` 如何处理？**

**✅ 决定 #6 待确认：旧修正记录处理策略**

**行业方案对比 — "对账修复的修复"场景各家怎么处理：**

| 公司/平台 | 遇到"修过一次没修对"的做法 | 设计理念 |
|---|---|---|
| **支付宝** | "冲正"模式：对错误的调账记录做一笔反向冲正（等价标记无效），再重新做正确的调账。冲正记录有独立 `reversal_id` 关联原记录，审计链完整 | 不删不改，只追加。每笔修正都有来龙去脉可追溯 |
| **微信支付** | "红冲"模式：错误账务发一笔红字冲销（金额取反），再发蓝字正确记录。红冲和蓝字都关联同一个"调账批次号" | 与支付宝一致——永远追加，不修改历史 |
| **银行体系（国际准则 GAAP/IFRS）** | "更正分录"（Correcting Entry）：先做反向分录抵消错误，再做正确分录。不允许直接修改或删除已入账的分录，这是审计铁律 | 会计不可篡改原则。哪怕错了也不能删，只能追加冲正 |
| **美团** | 差异进入"挂账"状态 → 人工排查 → 走"调账工单"流程。如果上一轮调账有误，开新工单重新调，旧工单标记"已作废"但保留记录 | 工单化管理，每轮修复独立编号 |
| **Steam / Valve** | 虚拟经济不做银行级对账。定期快照比对，差异直接用 `admin_grant` / `admin_revoke` 一笔补平。如果上次补错了，再来一笔反向的，不改历史 | 简单粗暴但有效：错了就追加反向记录 |
| **Roblox** | Source/Sink 模型。异常检测到不平衡时，GM 工具创建 `system_adjustment` 记录补平。上次调整不对就再调一次，不改旧记录 | 游戏虚拟经济容忍度高，追加调整即可 |
| **网易/米哈游（游戏公司）** | 虚拟货币出入通过 GM 后台"发放/回收"操作，每次操作生成独立日志。修错了不改日志，追加新操作 | 与 Roblox 一致 |
| **小公司/创业团队** | 常见做法是直接 `UPDATE` 或 `DELETE` 修改数据库——这是反模式，丢失审计记录 | 快但危险，无法追溯 |
| **闲鱼/转转（二手平台）** | 不涉及虚拟货币双录，差异由客服工单处理 | 不适用 |
| **活动策划公司** | 通常无对账体系，活动结束数据归档不再维护 | 不适用 |

**行业共识（所有正规系统）：永远追加，不修改/不删除历史记录。**

不同的只是"追加什么"：
- 银行/支付宝/微信支付：追加"冲正/红冲" + "正确的新记录"（两步）
- 游戏/虚拟经济：追加"反向调整记录"（一步，简单）
- 本项目现有机制：`is_invalid=1` 软标记 = 等价于"冲正"（记录保留但不参与计算）

**三种方案对比：**

| 方案 | 做法 | 行业对应 | 优点 | 缺点 | 适合场景 |
|---|---|---|---|---|---|
| A: `is_invalid=1` 标记 + 全新修复 | 将旧修正记录（20条）标记为 `is_invalid=1`（不删除），在干净基线上重新诊断 + 修复 | **支付宝冲正 / 银行更正分录** | 最干净，残差来源100%可追溯，新修复基于真实基线 | 多执行一步 invalidate 迁移（约15分钟） | **项目未上线 + 愿意一次性投入** |
| B: 增量差值补平 | 不动旧记录，计算当前残差（含旧修正记录的影响），只补差值 | **Steam/Roblox 追加调整** | 最少改动，执行简单 | 残差来源变成"修复的修复"，3层叠加难审计；未来对账出问题很难定位是哪层修的 | 已上线系统紧急止血 |
| C: 物理删除旧记录 + 重建 | `DELETE` 掉20条旧记录，重新做 | **小公司反模式** | 表面最干净 | **违反审计不可篡改原则**，丢失历史记录，无法解释"为什么记录消失了" | 绝不推荐 |

**本项目最优方案：A — `is_invalid=1` 标记 + 全新修复**

理由：
1. **项目已有 `is_invalid` 字段且已被使用**：`asset_transactions` 表的 `WHERE (is_invalid IS NULL OR is_invalid = 0)` 过滤条件已在对账脚本 `scripts/reconcile-items.js` 和所有查询中生效，标记后立即生效无需改代码
2. **与支付宝/银行的"冲正"原则一致**：不删除不修改，只标记状态，保留完整审计链
3. **项目未上线**：没有在线用户受影响，可以做"最干净"的方案而不用担心停机
4. **一次性投入换长期清晰**：20 条记录标记为无效只需一个迁移脚本（15分钟），换来的是残差来源100%清晰——从DIAMOND +194,361 回到真实基线，每一分钱的差异都能追溯到具体的 `business_type`
5. **方案 B 的隐患**：如果未来再出现对账问题，排查时会遇到"这个 system_reconciliation 是初版修的还是最终版修的？这个 data_migration_counterpart 修的是什么？"——3层叠加审计成本指数增长
6. **方案 C 是行业禁忌**：物理删除会计记录在任何正规系统中都不被接受

**落地方式（后端）：**
```
migrations/XXXXXXXX-invalidate-stale-reconciliation-records.js
```
- `UPDATE asset_transactions SET is_invalid = 1, updated_at = NOW() WHERE business_type IN ('system_reconciliation', 'data_migration_counterpart') AND (is_invalid IS NULL OR is_invalid = 0)`
- 影响：3 条 system_reconciliation + 17 条 data_migration_counterpart = 20 条
- 标记后 `scripts/reconcile-items.js` 的 `WHERE (is_invalid IS NULL OR is_invalid = 0)` 自动排除这些记录
- 然后在干净基线上执行下方步骤 1~5 的完整修复流程

#### 步骤 1：标记旧修正记录为无效（后端迁移脚本）

```
migrations/XXXXXXXX-invalidate-stale-reconciliation-records.js
```

脚本逻辑（复用 `sequelize-cli`）：
- `UPDATE asset_transactions SET is_invalid = 1 WHERE business_type IN ('system_reconciliation', 'data_migration_counterpart') AND is_invalid IS NULL`
- 影响：3 条 system_reconciliation + 17 条 data_migration_counterpart = 20 条
- 标记后重新计算残差基线

#### 步骤 2：诊断最新残差基线（后端脚本）

```
scripts/maintenance/diagnose_asset_residuals_v2.js
```

使用 `sequelize.query()` 执行：
1. `SELECT asset_code, SUM(delta_amount) FROM asset_transactions WHERE (is_invalid IS NULL OR is_invalid = 0) GROUP BY asset_code` — 拿到标记后的新残差
2. 按 `(business_type, asset_code)` 分组找出主记录与 counterpart 不匹配的类型
3. 对每个不匹配类型，逐条定位缺失的具体记录（通过 `idempotency_key` 匹配）
4. 输出需要补建的记录清单（含 `delta_amount`、`account_id`、`counterpart_account_id`）

重点排查的 business_type（按影响金额排序）：
- `opening_balance`（跨3个资产，笔数和金额都不匹配）
- `exchange_debit`（red_shard，counterpart 反向多出 530 笔）
- `order_settle_seller_credit`（DIAMOND，21笔缺失）
- `listing_transfer_buyer_offer_credit`（red_shard，16笔缺失）
- `lottery_reward`（POINTS，5笔缺失）
- `admin_adjustment`（跨2个资产，4笔缺失）
- `test_*` 系列（测试数据，金额较小）

#### 步骤 3：补建缺失的 counterpart 记录（迁移脚本）

```
migrations/XXXXXXXX-backfill-asset-counterpart-final.js
```

脚本逻辑（复用 `sequelize-cli`）：
- 遍历步骤 2 找出的缺失记录
- 为每条创建 counterpart 反向记录（`delta_amount` 取反，`account_id` 使用 `counterpart_account_id`）
- `business_type` 加 `_counterpart` 后缀
- `idempotency_key` 加 `:counterpart:final` 后缀（区别于今日迁移的 `:counterpart`）
- 特殊处理 `exchange_debit`：counterpart 多于主记录，需要反向补建主记录或标记多余 counterpart 为无效
- 事务内执行，失败回滚

#### 步骤 4：最终兜底补平（system_reconciliation）

步骤 3 后运行诊断脚本计算剩余残差。如仍有小额残差：
- 为每个资产创建一条 `system_reconciliation` + `system_reconciliation_counterpart` **配对记录**（双录，确保本次修正本身不引入新失衡）
- 对手方统一为 SYSTEM_RESERVE（account_id=12，数据库实际存在）
- `idempotency_key` 格式：`system_recon_final_{asset_code}_{timestamp}`

#### 步骤 5：验证

使用项目现有的对账脚本验证：

```bash
node scripts/reconcile-items.js
```

该脚本（`scripts/reconcile-items.js`，已存在，2026-02-22 版本）会检查：
1. 物品守恒：`SUM(delta) GROUP BY item_id` 全部为 0
2. 持有者一致：ledger 推导持有者 == `items.owner_account_id`
3. 铸造数量一致：items 总数 == mint(delta=+1) 条数
4. 资产守恒：`SUM(delta_amount) GROUP BY asset_code` 全部为 0
5. 账户余额一致：`SUM(delta_amount)` == `available_amount + frozen_amount`

### 3.4 实施步骤（✅ 全部完成）

| 步骤 | 内容 | 状态 | 迁移/脚本 |
|---|---|---|---|
| 0 | 决定 #6 拍板：选 A — 标记无效 + 全新修复 | ✅ 已确认 | — |
| 1~3 | 多轮数据治理迁移（Phase1~Phase3、counterpart回填、余额调整、冻结修正等） | ✅ 已执行 | 406 个迁移（`SequelizeMeta` 表） |
| 4 | 最终兜底补平：`system_reconciliation_final` 记录修复残差 | ✅ 已执行 | `20260223192128-final-asset-conservation-fix.js` |
| 5 | `node scripts/reconcile-items.js` 验证 | ✅ 全部通过 | 见下方验证结果 |

**最终验证结果（2026-02-23 二次审计）：**

```
=== 对账结论 ===
物品守恒：PASS（0 个不平衡）
持有者一致：PASS（0 个不一致）
全局守恒（SUM=0）：
  ✅ BUDGET_POINTS: SUM=0（174 条流水）
  ✅ DIAMOND: SUM=0（11,697 条流水）
  ✅ MATERIAL_001: SUM=0（4 条流水）
  ✅ orange_shard: SUM=0（11 条流水）
  ✅ POINTS: SUM=0（17,368 条流水）
  ✅ red_crystal: SUM=0（11 条流水）
  ✅ red_shard: SUM=0（12,850 条流水）
余额一致：PASS（0 个不一致）
```

**最终迁移记录（`system_reconciliation_final`）：**

| asset_code | 修复 delta | 说明 |
|---|---|---|
| DIAMOND | -1,240 | 历史 counterpart 配对误差聚合 |
| POINTS | -878,558 | 含 test_topup 966,098 无 counterpart + 多轮修正叠加 |
| red_shard | -655 | 历史 counterpart 配对误差聚合 |

对手方统一为 SYSTEM_RESERVE（account_id=12），幂等键 `system_reconciliation_final:{asset_code}:20260223`。

**已知遗留（非 P0 范围，不影响业务）：**
- 铸造一致检查：items=6,939 vs mints=6,931（8 件 legacy 物品在 item_ledger 系统引入前创建，无 mint 记录）

---

## 四、多商家架构（P1）

### 4.1 业务模型

```
平台（你的系统）
├── 管理用户、经济系统（钻石/碎片/积分）、交易市场、抽奖引擎
├── 接入商家 A（餐厅）→ 提供"甜品1份"、"折扣券"
├── 接入商家 B（珠宝店）→ 提供"精品首饰"
├── 接入小游戏 A → 产出"火焰之剑"道具、"游戏A金币"货币
└── 接入小游戏 B → 产出"冰霜盾牌"道具
```

用户在平台活动 → 赚取平台货币 → 抽奖获得各商家/游戏的物品 → 到对应商家核销 / 在交易市场流通。

`merchant_id` 标识每个物品属于哪个来源方（等价于 Steam 的 contextid）。

### 4.2 当前系统已有的基础（数据库实际验证）

| 基础设施 | 数据库实际状态 | 说明 |
|---|---|---|
| `merchants` 表 | ❌ **不存在** | 需要创建 |
| `stores` 表 | ✅ 已存在，5 家门店 | **已有 `merchant_id` 列（当前全部为 NULL）** |
| `store_staff` 表 | ✅ 已存在，5 条记录 | `role_in_store`: staff/manager |
| `merchant_operation_logs` 表 | ✅ 已存在 | 已有 `store_id` 字段 |
| `items.merchant_id` | ❌ **列不存在** | 需要加列 |
| `lottery_prizes.merchant_id` | ❌ **列不存在** | 需要加列 |
| `material_asset_types.merchant_id` | ❌ **列不存在** | 需要加列 |
| `items.source` 字段 | ✅ VARCHAR(20) | 当前值：`lottery`(2,967) / `legacy`(3,955) / `test`(8) |
| `items.source_ref_id` 字段 | ✅ VARCHAR(100) | 来源引用ID，可关联到具体抽奖/活动 |
| `items.item_type` 字段 | ✅ VARCHAR(50) | 当前值：`voucher`(4,797) / `product`(1,813) / `tradable_item`(260) / `prize`(52)，**总计 6,930 件** |
| `items.status` 字段 | ENUM 5 值 | `available`(4,704) / `held`(694) / `used`(1,529) / `expired`(3) / `destroyed`(0) |
| `material_asset_types` 表 | ✅ 15 种资产类型 | 可动态添加新类型 |
| `ItemService.mintItem` | ✅ 已实现 | `item_type` 为 VARCHAR(50)，不限制类型值 |
| `market_listings` | ✅ 已实现 | 支持 item 和 fungible_asset 两种挂牌 |
| `asset_group_defs` 表 | ✅ 已存在 | 资产分组定义，可用于按游戏分组 |
| `accounts` 体系 | ✅ 统一账户 | user 账户 + 6 个 system 账户 |
| RBAC 权限体系 | ✅ `roles` + `user_roles` 表，**已有 `merchant_staff`(level=20) 和 `merchant_manager`(level=40) 角色** | 无需新增角色，直接使用 |
| `merchant_operation_type` 字典 | ✅ `system_dictionaries` 已有此 dict_type | 商家操作类型字典已就绪 |

**关键发现：`stores.merchant_id` 列已经存在但未使用。** 说明系统设计时已经预留了多商家的扩展点。

### 4.3 需要新增/修改的内容

#### 4.3.1 新建 `merchants` 表（后端迁移脚本）

使用 `sequelize-cli` 创建迁移，遵循项目现有的模型定义风格（class extends Model + static associate + init）：

```
migrations/XXXXXXXX-create-merchants-table.js
models/Merchant.js（新建 Sequelize 模型文件）
```

表结构：

| 字段 | 类型 | 说明 |
|---|---|---|
| merchant_id | INT AUTO_INCREMENT PK | 商家ID |
| merchant_name | VARCHAR(100) NOT NULL | 商家名称 |
| merchant_type | VARCHAR(50) NOT NULL | 商家类型（字典表 `system_dictionaries` 校验，dict_type='merchant_type'） |
| contact_name | VARCHAR(50) | 联系人 |
| contact_mobile | VARCHAR(20) | 联系电话 |
| logo_url | VARCHAR(500) | LOGO地址 |
| status | ENUM('active','inactive','suspended') DEFAULT 'active' | 商家状态 |
| settlement_account_id | BIGINT NULL | 结算账户（关联 accounts 表） |
| commission_rate | DECIMAL(4,2) DEFAULT 0.00 | 平台抽佣比例 |
| notes | TEXT | 备注 |
| created_at | DATETIME NOT NULL | |
| updated_at | DATETIME NOT NULL | |

`merchant_type` 初始四种类型（存储在 `system_dictionaries` 字典表，运营可自助扩展）：
- `restaurant` — 餐厅（提供餐饮类奖品，核销到店）
- `shop` — 商铺（提供实物商品，核销到店或邮寄）
- `game` — 小游戏（产出虚拟道具和游戏货币）
- `service` — 服务商（提供服务类奖品）

**✅ 决定 #2 已确认：使用 VARCHAR(50) + `system_dictionaries` 字典表**（详见第七节行业对比）
- 不使用 ENUM（避免 ALTER TABLE），不硬编码（利用项目现有字典体系）
- 新类型通过管理后台 `dict-management.html` 直接添加，零代码改动

#### 4.3.2 现有表加 `merchant_id` 列（后端迁移脚本）

```
migrations/XXXXXXXX-add-merchant-id-to-items-and-prizes.js
```

| 表 | 修改 | 说明 |
|---|---|---|
| `items` | 新增 `merchant_id INT NULL` + 索引 | 标识物品来源商家。NULL = 平台自营 |
| `lottery_prizes` | 新增 `merchant_id INT NULL` + 索引 | 标识奖品赞助商家。NULL = 平台自营 |
| `material_asset_types` | 新增 `merchant_id INT NULL` | 标识游戏资产归属。NULL = 平台资产 |
| `stores` | **已有 merchant_id 列**，只需填充数据 | 把现有 5 家门店关联到对应商家 |

历史数据处理：所有现有记录 `merchant_id` 保持 NULL，表示"平台自营"（当前只有一个商家就是平台自己）。

#### 4.3.3 新建 Merchant 模型文件（后端）

```
models/Merchant.js
```

遵循项目现有模型风格：
- `class Merchant extends Model` + `static associate(models)` + `Merchant.init({...})`
- 关联定义：`Merchant.hasMany(models.Store)` / `Merchant.hasMany(models.Item)` / `Merchant.hasMany(models.LotteryPrize)`
- 在 `models/index.js` 中自动加载（项目现有机制：遍历 models/ 目录自动 require）

#### 4.3.4 服务层改动（后端）

| 文件 | 改动 | 可复用基础 |
|---|---|---|
| `services/asset/ItemService.js` | `mintItem` 参数增加 `merchant_id`，写入 items 表 | `mintItem` 已接受 `params` 对象，直接加字段即可 |
| `services/BackpackService.js` | 背包返回数据增加 `merchant_id` 和 `merchant_name`（LEFT JOIN merchants 表） | 已有 Sequelize include 关联查询模式 |
| `services/market-listing/QueryService.js` | 市场列表增加 `merchant_id` 筛选参数 | 已有 `where` 条件动态构建模式 |
| `services/RedemptionService.js` | 核销时校验物品所属商家与门店所属商家一致 | `fulfillOrder` 已接收 `store_id`，加 merchant 校验即可 |

#### 4.3.5 商家后台权限隔离（后端 + Web管理后台前端）

**✅ 商家角色已存在（数据库实际验证）：**

| role_id | role_name | role_level | 状态 |
|---|---|---|---|
| 10 | `merchant_staff` | 20 | ✅ 已存在，`/shop/*` 域的 `requireMerchantDomainAccess` 中间件已使用 |
| 11 | `merchant_manager` | 40 | ✅ 已存在 |

**无需新增角色，现有角色体系完整覆盖商家场景。**

| 功能 | 后端实现 | 前端实现 |
|---|---|---|
| 商家角色 | ✅ **已就绪**（`merchant_staff` level=20 + `merchant_manager` level=40） | 无需改动 |
| 商家数据隔离 | 查询层统一加 `WHERE merchant_id = ?` 条件 | 无需改动（数据由后端过滤） |
| 商家管理页面 | `routes/v4/console/merchants.js`（新增路由） | `admin/merchant-management.html`（新增页面） |
| 商家奖品管理 | `lottery_prizes` 查询和编辑加 `merchant_id` 条件 | 现有奖品管理页增加商家筛选下拉框 |
| 商家核销记录 | `redemption_orders` JOIN `items` 按 `merchant_id` 过滤 | 现有核销管理页增加商家筛选 |

### 4.4 数据流示意

**新商家接入流程：**

```
1. 平台管理员创建商家 → INSERT merchants
2. 创建/关联门店 → INSERT/UPDATE stores（关联 merchant_id）
3. 配置商家奖品 → INSERT lottery_prizes（关联 merchant_id）
4. 用户抽奖获得奖品 → ItemService.mintItem（带 merchant_id）→ INSERT items
5. 用户到商家门店核销 → RedemptionService.fulfillOrder 校验 items.merchant_id == stores.merchant_id
6. 平台按 merchant_id 统计结算
```

**小游戏接入流程：**

```
1. 平台创建游戏商家 → INSERT merchants（type='game'）
2. 注册游戏货币 → INSERT material_asset_types（关联 merchant_id）
3. 注册游戏资产分组 → INSERT asset_group_defs（group_type='game'）
4. 小游戏调用平台 API 铸造道具 → ItemService.mintItem（带 merchant_id）
5. 小游戏调用平台 API 发放货币 → BalanceService.changeBalance
6. 用户在交易市场交易游戏道具/货币 → 现有 market_listings 直接支持
```

### 4.5 实施步骤

| 步骤 | 内容 | 责任端 | 已有基础 | 工作量 |
|---|---|---|---|---|
| 1 | 迁移脚本：创建 `merchants` 表 | 后端 | 无（需新建） | 0.5 天 |
| 2 | 字典表新增 `merchant_type` 类型（4条记录） | 后端 | `system_dictionaries` 表 + `displayNameHelper.js` 已就绪 | 0.5 天（合并到步骤1迁移中） |
| 3 | 迁移脚本：`items` / `lottery_prizes` / `material_asset_types` 加 `merchant_id` 列 | 后端 | 三表已存在，加 NULL 列无数据风险 | 0.5 天 |
| 4 | 创建 `models/Merchant.js` 模型，建立关联关系 | 后端 | `models/index.js` 自动加载机制；`Store.js` / `StoreStaff.js` 模型可参考 | 0.5 天 |
| 5 | `ItemService.mintItem` 增加 `merchant_id` 参数 | 后端 | `mintItem` 已接受 `params` 对象 | 0.5 天 |
| 6 | `BackpackService` / 市场查询增加 merchant 信息展示 | 后端 | 已有 Sequelize `include` 关联查询模式 | 1 天 |
| 7 | `RedemptionService` 核销增加商家校验 | 后端 | `fulfillOrder` 已接收 store_id；`stores.merchant_id` 列已存在 | 0.5 天 |
| 8 | 管理后台新增 `admin/merchant-management.html` 商家管理页面 | Web前端 | Alpine.js `x-data` 组件模式 + `admin/src/api/base.js` 统一请求封装 | 1-2 天 |
| 9 | 商家数据隔离（查询层加 merchant_id 条件） | 后端 | **角色已就绪（`merchant_staff` level=20 + `merchant_manager` level=40），`requireMerchantDomainAccess` 中间件已就绪** | 1 天 |

总计约 5-7 天。商家角色（步骤 8 旧版的"角色权限隔离"）因角色已存在，实际只需做数据隔离查询，工作量从 1-2 天缩减为 1 天。

---

## 五、三端职责划分与问题归属

### 5.1 后端（本项目 `/home/devbox/project`）— ✅ 全部完成

| 序号 | 工作项 | 需求归属 | 状态 | 实际文件 |
|---|---|---|---|---|
| B0~B3 | 资产守恒残差修复（多轮迁移 + 最终兜底） | P0-资产守恒 | ✅ 完成 | `20260223192128-final-asset-conservation-fix.js`（第407个迁移） |
| B4 | 创建 `merchants` 表 + 字典数据 | P1-多商家 | ✅ 完成 | `20260223174556-create-merchants-table.js` + merchant_type 字典 4 条 |
| B5 | 现有表加 `merchant_id` 列 | P1-多商家 | ✅ 完成 | `20260223174631-add-merchant-id-to-items-and-prizes.js` |
| B6 | 创建 Merchant 模型 + 关联 | P1-多商家 | ✅ 完成 | `models/Merchant.js` |
| B7 | MerchantService 服务层 | P1-多商家 | ✅ 完成 | `services/MerchantService.js`（CRUD + 字典校验 + 选项列表） |
| B8 | 商家管理 API 路由 | P1-多商家 | ✅ 完成 | `routes/v4/console/merchants.js`（7个端点） |

**P0-核销流程后端零改动**（已 100% 就绪）
**P0-资产守恒**：7/7 资产 SUM=0，余额一致性 0 差异
**P1-多商家**：表/模型/服务/路由/字典全部就绪，0 条商家记录（等运营创建）

### 5.2 Web管理后台前端（`admin/` 目录）— ✅ 核心页面完成

| 序号 | 工作项 | 需求归属 | 状态 | 实际文件 |
|---|---|---|---|---|
| W1 | `admin/redemption-scan.html` 店员扫码核销页 | P0-核销流程 | ✅ 完成 | HTML + `src/modules/operations/pages/redemption-scan.js` + `src/api/redemption.js`（含 scan/fulfill 端点） |
| W2 | `admin/merchant-management.html` 商家管理页 | P1-多商家 | ✅ 完成 | HTML + `src/modules/merchant/pages/merchant-management.js` + `src/api/merchant.js`（7个端点） |
| W3 | 现有奖品管理页增加商家筛选 | P1-多商家 | ⏳ 后续迭代 | 等有实际商家数据后再加筛选 |
| W4 | 现有核销管理页增加商家筛选 | P1-多商家 | ⏳ 后续迭代 | 同上 |

Vite 构建已包含两个新页面（`getHtmlEntries()` 自动扫描 `admin/*.html`），`npm run build` 验证通过。

### 5.3 微信小程序前端需要做的

**阶段一：用户侧功能（核销流程跑通必需）**

| 序号 | 工作项 | 需求归属 | 调用的后端接口 | 工作量 |
|---|---|---|---|---|
| M1 | 背包物品详情页增加"生成兑换码"按钮 | P0-核销流程 | `POST /api/v4/backpack/items/:id/redeem` | 0.5 天 |
| M2 | 兑换码展示页（文本码 + QR码 + 倒计时 + 刷新） | P0-核销流程 | `POST /api/v4/backpack/items/:id/redeem/refresh-qr` | 0.5 天 |
| M3 | 物品详情页已有核销码入口 | P0-核销流程 | `GET /api/v4/backpack/items/:id`（读 `has_redemption_code` 字段） | 0.5 天 |

**阶段二：商家侧功能（三端联动，后端零改动）**

| 序号 | 工作项 | 需求归属 | 调用的后端接口（与Web端完全相同） | 工作量 |
|---|---|---|---|---|
| M4 | 商家角色判断 + 核销入口显示 | P0-核销流程 | 登录后通过 JWT 中 `role_level` 判断 | 0.5 天 |
| M5 | 商家扫码核销页（`wx.scanCode` → 提交） | P0-核销流程 | `POST /api/v4/shop/redemption/scan` | 1 天 |
| M6 | 商家文本码核销备用入口 | P0-核销流程 | `POST /api/v4/shop/redemption/fulfill` | 0.5 天 |
| M7 | 背包页商家来源标识展示 | P1-多商家 | `GET /api/v4/backpack`（读 `merchant_id` + `merchant_name` 字段） | 0.5 天 |

**阶段一合计：1.5 天 | 阶段二合计：2.5 天 | 总计：4 天**

---

## 六、可复用与可扩展分析

### 6.1 后端可直接复用的能力

| 能力 | 代码位置 | 扩展方式 |
|---|---|---|
| 三表模型（items + item_ledger + item_holds） | `models/Item.js`, `ItemLedger.js`, `ItemHold.js` | 新物品类型直接 mintItem 即可 |
| 双录记账 | `ItemService.mintItem/transferItem/consumeItem` | 自动写两条 ledger 记录 |
| 资产交易流水 | `asset_transactions` + `BalanceService` | 新 asset_code 注册到 `material_asset_types` 即可 |
| 统一账户体系 | `accounts` 表（user + system） | 新系统账户直接 INSERT |
| 交易市场 | `market_listings` + 整套挂牌/购买/结算服务 | 支持 item 和 fungible_asset，新商家物品自动兼容 |
| 对账脚本 | `scripts/reconcile-items.js` | 已覆盖物品守恒 + 资产守恒 |
| 迁移框架 | `sequelize-cli` + `migrations/` | 标准化建表/改表流程 |
| ServiceManager | `services/index.js` | 新服务注册后自动通过 `getService()` 获取 |
| TransactionManager | `utils/TransactionManager.js` | 所有写操作统一事务边界 |
| 幂等机制 | `idempotency_key` 唯一约束 | 所有新业务流水自动受保护 |
| RBAC 权限 | `roles`（11个角色）+ `user_roles` + `middleware/auth.js`（`authenticateToken` + `getUserRoles` + `requireMerchantDomainAccess`） | 商家角色已存在（`merchant_staff` level=20, `merchant_manager` level=40），无需新增 |
| QR码签名 | `RedemptionQRSigner` | HMAC-SHA256，可扩展到其他场景 |

### 6.2 后端可扩展的点

| 扩展点 | 当前设计 | 扩展方式 |
|---|---|---|
| `items.item_type` | VARCHAR(50)，不受 ENUM 限制 | 新商家/游戏类型直接写入 |
| `items.source` | VARCHAR(20)：lottery/legacy/test | 新来源直接写入（如 game/partner） |
| `material_asset_types` | 15 种，动态可配 | 新游戏货币直接 INSERT |
| `asset_group_defs` | 已存在 | 按游戏分组定义 |
| `item_type` 扩展 | 不限类型值 | 可加 `equipment`/`skin`/`token` 等 |
| 系统账户 | 6 个预定义 | 商家结算账户直接 INSERT（type=system） |

### 6.3 Web管理后台前端可复用的能力

| 能力 | 说明 |
|---|---|
| Alpine.js 组件模式 | 所有页面使用 `x-data="xxxPage()"` + `init()` 模式，新页面直接复制模板 |
| Tailwind CSS | 样式系统统一，新页面零配置 |
| `admin/src/api/base.js` | 统一 API 请求封装（JWT token 自动携带、错误统一处理） |
| 模块化 composables | `admin/src/modules/*/composables/*.js` 可复用的业务逻辑 |
| ECharts 图表 | 延迟加载机制已封装（`utils/echarts-lazy.js`） |
| `admin/src/api/redemption.js` | 核销 API 已封装，新扫码页直接调用 |

---

## 七、5项决定 — 行业方案对比与最终选型

> 以下每项决定均对比了大厂、中小公司、游戏公司、活动策划公司、虚拟物品交易平台的设计方案。
> 选型原则：项目未上线 → 不兼容旧接口 → 一次性投入 → 长期维护成本最低 → 基于后端现有技术栈。

---

### 决定 #1：商家核销端选型 — ✅ 已确认：先Web后小程序

**行业方案对比：**

| 公司/平台 | 核销端形态 | 初期方案 | 成熟期方案 |
|---|---|---|---|
| **美团** | 独立App「美团开店宝」 | 早期Web页面核销 → 后改为独立App | 独立App + POS机SDK集成 |
| **阿里/口碑** | 独立App「口碑商家」 | Web + 短信核销码 | 独立App + 支付宝扫码 |
| **腾讯/微信卡券** | 微信内嵌 | 微信公众号H5页面 | 微信卡包 + 商家扫码组件 |
| **Shopify** | Web后台 + POS App | Web后台手动核销 | 独立POS App |
| **小型本地生活SaaS** | 微信小程序多角色 | 同一小程序切商家模式 | 同上（不会做独立App） |
| **活动策划公司** | Excel + 人工 / 简单Web | 一次性Web页面 | 不迭代（活动结束就废弃） |

**关键规律：**
- **所有大厂都是 Web/H5 先跑通流程 → 验证商业模式 → 再投入独立App/小程序**
- 美团 2013 年上线团购时用的是Web核销码 + 短信验证，到 2015 年才有「开店宝」App
- 微信卡券最初的核销方式就是商家在公众号后台点"核销"按钮

**本项目最优方案：先 Web 管理后台扫码页 → 再小程序商家核销 → 三端联动**

理由：
1. 项目现有 `admin/` 是 Vite + Alpine.js + Tailwind，新增一个 HTML 页面成本极低
2. 后端 `POST /api/v4/shop/redemption/scan` 和 `POST /api/v4/shop/redemption/fulfill` 已100%就绪
3. 现有 `admin/src/api/redemption.js` 已封装核销API，新页面直接调用
4. 5家门店5个店员的规模，用电脑/平板打开Web页面完全够用
5. 小程序核销作为阶段二体验升级，调用与Web端完全相同的后端接口，后端零改动

**三端联动路线图：**

```
阶段一（立即）：用户小程序生成码 ←→ 后端API ←→ 商家Web核销
阶段二（迭代）：用户小程序生成码 ←→ 后端API ←→ 商家Web核销 + 商家小程序扫码核销
```

后端 API 对所有前端透明：JWT 认证统一、响应格式统一、权限判断统一。阶段二加小程序核销时后端零代码改动。

---

### 决定 #2：merchant_type 字段类型 — ✅ 已确认：VARCHAR(50) + 字典表

**行业方案对比：**

| 公司/平台 | 商家类型存储方式 | 设计理念 |
|---|---|---|
| **美团** | INTEGER 分类编码 + 三级分类树表 | 严格分类体系，类型变更需审核 |
| **阿里/天猫** | INTEGER 类目ID + `categories` 多级树表 | 分类即基础设施，独立微服务管理 |
| **Steam** | INTEGER `app_type`（game/dlc/demo/mod） | 类型固定不变，ENUM 足够 |
| **Roblox** | STRING `experience_type` | 灵活的字符串类型 |
| **Shopify** | 无 merchant_type 概念 | 商家不分类型，按 tag 标记 |
| **小型SaaS / 二手平台** | VARCHAR + 字典表 | 运营灵活，避免 DDL 变更 |
| **闲鱼/转转** | INTEGER 品类码 + 品类配置表 | 品类可热更新，不改表结构 |

**三种方案对比：**

| 方案 | 优点 | 缺点 | 适合场景 |
|---|---|---|---|
| ENUM | 数据库层强约束，查询性能略好 | 新增类型必须 ALTER TABLE（线上风险），Sequelize 迁移麻烦 | 类型永远不变的系统（如 Steam 的 game/dlc/demo） |
| VARCHAR + 代码层校验 | 灵活，不需要 DDL | 无数据库约束，可能写入脏数据 | 快速迭代的小项目 |
| **VARCHAR + `system_dictionaries` 字典表** | 灵活 + 数据校验 + 中文名/颜色配置 + 运营可自助 | 多一次查询（缓存可解决） | **本项目最优** |

**本项目最优方案：VARCHAR(50) + `system_dictionaries` 字典表**

理由：
1. **项目已有 `system_dictionaries` 表和 `SystemDictionary` 模型**，`dict_type + dict_code` 唯一约束已就绪
2. **项目已有 `displayNameHelper.js`** 工具封装了字典查询和缓存机制
3. 新增 `dict_type = 'merchant_type'` + 四条记录（restaurant/shop/game/service）即可
4. 运营可通过管理后台 `dict-management.html`（已存在）直接添加新商家类型，无需开发介入
5. 未来新增 `brand`/`partner` 等类型只需 INSERT 字典记录，零代码改动
6. 这与美团/阿里的分类配置表思路一致，但利用了项目现有基础设施，零额外建设成本

**落地方式（后端）：**
- `merchants.merchant_type` 定义为 `VARCHAR(50) NOT NULL`
- 新增字典记录：`INSERT INTO system_dictionaries (dict_type, dict_code, dict_name, dict_color) VALUES ('merchant_type', 'restaurant', '餐厅', '#ef4444'), ('merchant_type', 'shop', '商铺', '#3b82f6'), ('merchant_type', 'game', '小游戏', '#8b5cf6'), ('merchant_type', 'service', '服务商', '#10b981')`
- Service 层写入前校验：从字典表验证 type 值合法性

---

### 决定 #3：商家结算账户模型 — ✅ 已确认：MVP先不建，预留扩展

**行业方案对比：**

| 公司/平台 | 结算模型 | 时机 |
|---|---|---|
| **美团** | 每商家一个虚拟子账户，T+1~T+7 结算周期 | 有实际资金流转后才建 |
| **支付宝** | 托管账户模型（Escrow），平台代管资金 | 交易闭环需要时才建 |
| **微信支付** | 商户号体系，每商家独立微信支付商户号 | 接入微信支付时强制要求 |
| **Roblox** | DevEx 开发者兑换系统，独立 ledger | Robux 变现需求出现后才建 |
| **Steam** | 开发者收入分成，按月结算到银行账户 | 有游戏上架销售后才启用 |
| **小型平台 / 二手交易** | 大多初期不做结算，人工对账 | 交易量大到人工处理不了才建系统 |

**关键规律：所有平台都是先跑通业务 → 有实际资金需要结算时才建结算账户**

**本项目最优方案：先不建结算账户，`settlement_account_id` 留 NULL**

理由：
1. 当前系统没有真实资金流转（钻石/碎片是虚拟货币，不涉及人民币结算）
2. 项目 `accounts` 表已支持 `account_type = 'system'`，未来需要时直接 `INSERT` 一个系统账户给商家
3. `merchants.settlement_account_id BIGINT NULL` 外键预留即可
4. 美团最初的"到店核销"也没有实时结算，是月底人工对账
5. 结算功能的复杂度（对账周期、手续费计算、提现审批、分账）远超当前需求，不应提前引入

**后续扩展路径（需要时再做）：**
```
阶段1（当前）：merchant 表有 settlement_account_id = NULL，不做结算
阶段2（有资金流转时）：为每个商家创建 system 账户，记录应结金额
阶段3（规模扩大时）：接入微信支付分账 / 银行转账，自动化结算
```

---

### 决定 #4：历史物品 merchant_id — ✅ 已确认：保持 NULL

**行业方案对比：**

| 公司/平台 | 历史数据处理方式 | 理由 |
|---|---|---|
| **美团** | 存量商品 `seller_id` 保持原值（美团自营） | 自营本身就是一个"商家"身份 |
| **淘宝/天猫** | 历史商品保持原 `seller_id` | 天猫有"天猫超市"自营 seller |
| **Steam** | 历史物品 `appid` 保持原值 | Steam 平台物品有专属 appid |
| **Roblox** | 旧游戏 `creator_id` 保持 Roblox 官方 | 平台自营内容有官方 creator |
| **闲鱼** | 无自营概念 | 所有商品都有 seller，不存在 NULL |

**两种方案对比：**

| 方案 | 做法 | 优点 | 缺点 |
|---|---|---|---|
| A: 保持 NULL | 历史记录 `merchant_id = NULL` | 语义清晰（NULL=平台自营），零迁移成本 | 查询时需 `IS NULL` 或 `COALESCE` |
| B: 创建"平台自营"商家 | 创建 merchant_id=1 "平台自营"，历史记录全部 UPDATE | 查询统一（无需特殊处理NULL） | 需要 UPDATE 6,922 条记录，引入假商家 |

**本项目最优方案：A，保持 NULL**

理由：
1. NULL 在 SQL 中语义天然清晰：`WHERE merchant_id IS NULL` = "属于平台自己"
2. 本项目 `items` 表 6,922 条记录，UPDATE 虽然不大但完全没必要
3. 后端代码中所有新功能都是增量加 `merchant_id` 条件，历史数据不碰 = 零风险
4. 如果引入 merchant_id=1 "平台自营"，会导致概念混淆：这个"商家"没有门店、没有联系人、没有核销，本质上不是商家
5. Sequelize 的 `where: { merchant_id: null }` 和 `where: { merchant_id: merchantId }` 两种查询模式已经被项目广泛使用

---

### 决定 #5：资产残差修复策略 — ✅ 已确认：先精确补counterpart，再system_reconciliation兜底

**行业方案对比：**

| 公司/平台 | 对账差异处理方式 | 适用规模 |
|---|---|---|
| **支付宝** | 每日对账 → 差异标记为"待调查" → 7天内查明原因逐笔修正 → 超7天未查明的走"差错处理"科目一笔补平 | 万亿级流水 |
| **微信支付** | T+1自动对账 → 差异进入"挂账"状态 → 业务方认领修正 → 无法认领的由财务审批后"强制平账" | 万亿级流水 |
| **银行体系** | 差异进入"悬挂科目"（suspense account）→ 限期调查 → 超期的审批后冲账 | 金融级 |
| **美团** | 订单级对账 → 商家/平台各自记录比对 → 差异人工排查 → 最终走"调账"流程 | 千亿级流水 |
| **Steam/Roblox** | 内部虚拟货币不做银行级对账，定期批量 reconciliation | 虚拟经济 |
| **游戏公司（网易/米哈游）** | 虚拟货币出入用 Source/Sink 模型追踪 → 定期快照比对 → 差异用 GM 工具批量修正 | 游戏虚拟经济 |
| **小公司/创业团队** | 手动 SQL 修数据，无正式对账 | 早期项目 |

**关键规律：所有正规系统都是"先精确修 → 再兜底补平"的二阶段策略**
- 第一阶段：找到具体原因，逐笔精确修正（尽量做多）
- 第二阶段：剩余无法定位的差异，走审批流程后用"调整科目"一笔补平（保底）
- 支付宝叫"差错处理"，银行叫"悬挂科目冲账"，本项目叫 `system_reconciliation`

**本项目最优方案：二阶段策略（与支付宝/银行一致）**

理由：
1. 本项目已有 `system_reconciliation` 类型的历史修正记录（Phase 5 治理已用过），惯例一致
2. 本项目已有 `SYSTEM_RESERVE`（account_id=12）作为对账修正对手方，基础设施就绪
3. 本项目已有对账脚本 `scripts/reconcile-items.js`，可自动验证修复结果
4. 从 business_type 分布看，`exchange_debit`（1,983）vs `exchange_debit_counterpart`（2,513）笔数差异达 530 笔，这些有明确的修复目标（精确补counterpart）
5. 精确补完后如果仍有微小残差（可能来自历史数据精度或已删除记录），用 `system_reconciliation` 一笔补平是行业标准做法

**执行步骤：**
```
阶段1（精确修复）：
  → 诊断脚本找出 business_type 中 主记录与 counterpart 笔数不一致的
  → 逐条补建缺失的 counterpart 记录
  → 验证哪些资产已归零

阶段2（兜底补平）：
  → 计算剩余残差（可能已经很小）
  → 为每个资产创建一条 system_reconciliation 记录补平
  → 对手方：SYSTEM_RESERVE (account_id=12)
  → 运行 scripts/reconcile-items.js 确认全部 SUM=0
```

**⚠️ 后续变化：** 今日执行的数据治理迁移改变了残差数值，导致初版 system_reconciliation 修正记录不再准确。如何处理旧记录见 **决定 #6**（第 3.3 节）。

---

## 八、三项需求之间的依赖关系

```
P0 核销流程走通（后端零改动，纯前端工作）
    └── 不依赖其他需求，可立即开始
    └── 完成后：用户能实际使用兑换码到店核销

P0 资产守恒残差修复（纯后端工作）
    └── 不依赖其他需求，可立即开始
    └── 完成后：对账脚本零告警，SUM=0 全部通过

P1 多商家架构（后端 + Web管理后台前端）
    └── 建议在 P0 两项完成后开始
    └── 原因：先确保核心流程（核销+对账）跑通，再扩展商家维度
    └── 完成后：系统具备接入多商家和小游戏的能力
```

P0 两项可以并行，互不依赖。P1 在 P0 之后串行。

---

## 九、总工作量估算

**阶段一（核销闭环跑通 + 资产修复）：**

| 需求 | 后端 | Web管理后台前端 | 微信小程序前端（用户侧） | 可并行 |
|---|---|---|---|---|
| 核销流程走通 | 0 天 | 1 天 | 1.5 天 | 三端可同时开发 |
| 资产守恒残差修复 | 2.5 天（因今日迁移增加复杂度） | 0 天 | 0 天 | 可与核销流程并行 |

阶段一完成后效果：用户(小程序)生成兑换码 → 店员(Web)扫码核销 → 资产对账 SUM=0

**阶段二（三端联动 + 多商家架构）：**

| 需求 | 后端 | Web管理后台前端 | 微信小程序前端（商家侧） | 可并行 |
|---|---|---|---|---|
| 小程序商家核销能力 | 0 天 | 0 天 | 2 天 | 可与多商家并行 |
| 多商家架构 | 4.5-5 天（角色已存在，节省1天） | 2-3 天 | 0.5 天 | 后端先行，前端跟进 |

阶段二完成后效果：三端联动（用户小程序 + 商家小程序 + 商家Web），多商家隔离

**总计：**

| 端 | 阶段一 | 阶段二 | 合计 |
|---|---|---|---|
| 后端 | 2.5 天 | 4.5-5 天 | **7-7.5 天** |
| Web管理后台前端 | 1 天 | 2-3 天 | **3-4 天** |
| 微信小程序前端 | 1.5 天 | 2.5 天 | **4 天** |

---

## 十、与行业方案的对应关系

本方案完成后，系统能力与行业标杆的对应：

| 行业能力 | 对应实现 | 后端状态 |
|---|---|---|
| Steam contextid（跨游戏物品标识） | `merchants.merchant_id` + `items.merchant_id` | P1 实施后具备 |
| 美团唯一券码 + 到店核销 | `tracking_code` + `RedemptionService` + QR签名 | ✅ 后端已就绪，等前端 |
| 支付宝双录记账 + SUM=0 守恒 | `item_ledger` + `asset_transactions` 双录 | P0 残差修复后完全闭合 |
| Steam 多币种市场交易 | `market_listings` + `fungible_asset` + 任意 `asset_code` 定价 | ✅ 已具备 |
| Roblox Source/Sink 追踪 | SYSTEM_MINT / SYSTEM_BURN 系统账户 | ✅ 已具备 |

---

## 十一、Web管理后台前端技术兼容性分析

方案中所有 Web 管理后台前端工作均基于 `admin/` 目录现有技术栈，无需引入新框架或新依赖：

| 需要做的事 | 使用的现有技术 | 兼容性 |
|---|---|---|
| 新增 `redemption-scan.html` 扫码核销页 | Alpine.js `x-data` 组件 + Tailwind CSS 布局 + `admin/src/api/base.js` 请求封装 | ✅ 100% 兼容，复制任意现有页面模板即可 |
| 浏览器摄像头扫QR码 | `navigator.mediaDevices.getUserMedia` + JS QR解码库（需新增一个 npm 依赖如 `jsQR`） | ✅ 兼容，仅需 `npm install jsQR`（或类似库） |
| 新增 `merchant-management.html` 商家管理页 | 同上 Alpine.js + Tailwind + base.js | ✅ 100% 兼容 |
| 现有页面加商家筛选下拉框 | Alpine.js `x-data` 内加 `merchant_id` 状态 + `<select>` 组件 | ✅ 100% 兼容，改动极小 |
| 核销 API 调用 | `admin/src/api/redemption.js` **已封装 6 个端点**（LIST/STATISTICS/EXPORT/BATCH_REDEEM/BATCH_CANCEL/BATCH_EXPIRE） | ✅ 已就绪，扫码页新增 scan/fulfill 两个调用即可 |

**需要新增的 npm 依赖：** 仅 QR 码扫描库（如 `jsQR`），其余全部使用现有依赖。

**admin 前端现有依赖清单（`admin/package.json`）：**
- 运行时：`alpinejs`, `echarts`, `html2canvas`, `jspdf`, `socket.io-client`, `sortablejs`, `xlsx`
- 开发时：`vite`, `tailwindcss`, `postcss`, `autoprefixer`, `eslint`, `prettier`

**不需要引入的：** 无需 React/Vue/Svelte 框架，无需状态管理库，无需路由库——保持现有多页应用 + Alpine.js 响应式绑定的架构。

---

## 十二、需要你拍板的决定汇总

| 编号 | 决定 | 选项 | 建议 | 行业对标 | 状态 |
|---|---|---|---|---|---|
| #1 | 商家核销端选型 | A: 先Web后小程序 / B: 只小程序 / C: 同时开发 | A: 先Web后小程序 | 美团早期Web→后独立App | ✅ 已确认 |
| #2 | merchant_type 字段类型 | A: ENUM / B: VARCHAR+代码校验 / C: VARCHAR+字典表 | C: VARCHAR+字典表 | 闲鱼品类配置表 / 美团分类树 | ✅ 已确认 |
| #3 | 商家结算账户 | A: MVP先不建 / B: 立即建 | A: 先不建 | 所有大厂都是有资金流后才建 | ✅ 已确认 |
| #4 | 历史物品 merchant_id | A: 保持NULL / B: 创建"平台自营"商家 | A: 保持NULL | 美团/淘宝自营保持原值 | ✅ 已确认 |
| #5 | 资产残差修复策略 | A: 先精确补counterpart再兜底 / B: 直接一笔补平 | A: 二阶段策略 | 支付宝"先查明→再差错处理" | ✅ 已确认 |
| **#6** | **旧修正记录处理** | **A: `is_invalid=1`标记+全新修复** / B: 增量差值补平 / C: 物理删除重建 | **A: 标记无效+全新修复** | **支付宝冲正 / 银行更正分录** | **选 A   ** |

**决定 #6 详细行业对比见第七节（3.3小节内）。** 核心结论：所有正规系统的对账修复都遵循"不删不改，只追加"原则。方案 A（`is_invalid=1` 标记）等价于支付宝的"冲正"和银行的"更正分录"，在行业中是最规范的做法。方案 B（增量补差）等价于 Steam/Roblox 的简单追加调整，适合已上线的紧急止血，但本项目未上线不需要妥协。方案 C（物理删除）是行业禁忌，违反审计不可篡改原则。

---

## 十三、完整角色体系（数据库实际数据）

后端 `roles` 表已有完整角色体系，三项需求均可直接使用：

| role_id | role_name | role_level | 用途 |
|---|---|---|---|
| 100 | `system_job` | -1 | 系统定时任务 |
| 1 | `user` | 0 | 普通用户 |
| 5 | `campaign_2` | 10 | 活动用户 |
| 107 | `test_role_api` | 15 | 测试角色 |
| **10** | **`merchant_staff`** | **20** | **商家员工（核销扫码权限起点）** |
| 9 | `ops` | 30 | 运营 |
| 8 | `sales_staff` | 40 | 销售 |
| **11** | **`merchant_manager`** | **40** | **商家经理** |
| 7 | `business_manager` | 60 | 业务经理 |
| 6 | `regional_manager` | 80 | 区域经理 |
| 2 | `admin` | 100 | 管理员 |

核销权限判断逻辑（`routes/v4/shop/redemption/scan.js` 实际代码）：
- 从 `SystemSettings` 读取 `min_role_level_for_fulfill`（默认值 20）
- 用户 `role_level >= 20` 即可核销
- `merchant_staff`(20) 和 `merchant_manager`(40) 均满足条件
