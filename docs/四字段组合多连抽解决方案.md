# å››å­—æ®µç»„åˆå¤šè¿æŠ½å®Œæ•´è§£å†³æ–¹æ¡ˆ

## ğŸ“‹ æ–‡æ¡£ä¿¡æ¯

- **é¡¹ç›®åç§°**: é¤å…ç§¯åˆ†æŠ½å¥–ç³»ç»Ÿv4.0 - å››å­—æ®µç»„åˆè§£å†³æ–¹æ¡ˆ
- **æ ¸å¿ƒéœ€æ±‚**: è§£å†³å¤šè¿æŠ½åˆ¤æ–­ã€æ—¶é—´ç®¡ç†ã€æ•°æ®å®Œæ•´æ€§ã€ç”¨æˆ·ä½“éªŒé—®é¢˜
- **æŠ€æœ¯æ–¹æ¡ˆ**: draw_type + batch_id + draw_count + draw_sequence å››å­—æ®µååŒ
- **æ–‡æ¡£ç‰ˆæœ¬**: v1.0
- **åˆ›å»ºæ—¶é—´**: 2025-09-13 14:20:20 UTC
- **ä½œè€…**: åç«¯å¼€å‘å›¢é˜Ÿ
- **æŠ€æœ¯æ ˆ**: Node.js + Express + MySQL + Sequelize + Redis

## ğŸ¯ æ–¹æ¡ˆæ¦‚è¿°

### æ ¸å¿ƒç†å¿µ

é€šè¿‡å››ä¸ªå­—æ®µçš„æœ‰æœºç»„åˆï¼Œå½¢æˆå®Œæ•´çš„å¤šè¿æŠ½æ•°æ®ä½“ç³»ï¼š

- **draw_type**: ç”¨æˆ·é€‰æ‹©çš„æŠ½å¥–æ–¹å¼ï¼ˆå•æŠ½/3è¿æŠ½/5è¿æŠ½/10è¿æŠ½ï¼‰
- **batch_id**: æ‰¹æ¬¡å…³è”æ ‡è¯†ï¼ˆåŒä¸€æ¬¡æ“ä½œçš„å¤šæ¡è®°å½•å…±äº«ï¼‰
- **draw_count**: è¯¥æ‰¹æ¬¡æ€»æŠ½å¥–æ¬¡æ•°ï¼ˆæ•°æ®å®Œæ•´æ€§éªŒè¯ï¼‰
- **draw_sequence**: æ‰¹æ¬¡å†…åºå·ï¼ˆå±•ç¤ºé¡ºåºå’Œé€»è¾‘éªŒè¯ï¼‰

### è§£å†³çš„æ ¸å¿ƒé—®é¢˜

```ascii
é—®é¢˜çŸ©é˜µï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ å­—æ®µç»„åˆå‰ VS å­—æ®µç»„åˆå                                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ âŒ ç”¨æˆ·ä¸çŸ¥é“æŠ½å¥–æ–¹å¼    â†’  âœ… draw_typeæ˜ç¡®æ ‡è¯†               â”‚
â”‚ âŒ è¿æŠ½è®°å½•æ— æ³•å…³è”      â†’  âœ… batch_idç»Ÿä¸€æ‰¹æ¬¡               â”‚
â”‚ âŒ æ•°æ®å®Œæ•´æ€§æ— æ³•éªŒè¯    â†’  âœ… draw_countæ€»æ•°éªŒè¯              â”‚
â”‚ âŒ æŠ½å¥–é¡ºåºä¿¡æ¯ç¼ºå¤±      â†’  âœ… draw_sequenceé¡ºåºå±•ç¤º           â”‚
â”‚ âŒ æ—¶é—´æ˜¾ç¤ºæ··ä¹±          â†’  âœ… æ‰¹æ¬¡ç»Ÿä¸€æ—¶é—´æˆ³                 â”‚
â”‚ âŒ å‰ç«¯ä¸šåŠ¡é€»è¾‘å¤æ‚      â†’  âœ… åç«¯å¤„ç†ï¼Œå‰ç«¯ç®€å•å±•ç¤º          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ—ï¸ å››å­—æ®µè¯¦ç»†è®¾è®¡

### 1. draw_typeï¼ˆæŠ½å¥–ç±»å‹å­—æ®µï¼‰

#### å­—æ®µå®šä¹‰

```sql
draw_type VARCHAR(20) NOT NULL COMMENT 'æŠ½å¥–ç±»å‹ï¼šsingle=å•æŠ½,triple=3è¿æŠ½,five=5è¿æŠ½,ten=10è¿æŠ½'
```

#### ä¸šåŠ¡å«ä¹‰

- **ç”¨æˆ·è§†è§’**: "æˆ‘é€‰æ‹©çš„æ˜¯ä»€ä¹ˆæŠ½å¥–æ–¹å¼ï¼Ÿ"
- **ç³»ç»Ÿä½œç”¨**: å¿«é€Ÿè¯†åˆ«æŠ½å¥–ç±»å‹ï¼Œå‰ç«¯ç›´æ¥å±•ç¤º

#### å¯é€‰å€¼è§„èŒƒ

```javascript
const DRAW_TYPES = {
  SINGLE: 'single', // å•æŠ½
  TRIPLE: 'triple', // 3è¿æŠ½
  FIVE: 'five', // 5è¿æŠ½
  TEN: 'ten' // 10è¿æŠ½
}
```

#### å®é™…åº”ç”¨åœºæ™¯

```javascript
// å‰ç«¯æŸ¥è¯¢ç¤ºä¾‹
const userLotteryHistory = await LotteryRecord.findAll({
  where: { user_id: 31 },
  attributes: ['draw_type', 'created_at', 'batch_id'],
  group: ['batch_id', 'draw_type'],
  order: [['created_at', 'DESC']]
})

// ç»“æœå±•ç¤º
// âœ… "2025-09-13 12:00:00 - è¿›è¡Œäº†1æ¬¡3è¿æŠ½" (draw_type='triple')
// âŒ "2025-09-13 12:00:01-03 - è¿›è¡Œäº†3æ¬¡å•æŠ½" (æ—§æ–¹æ¡ˆ)
```

### 2. batch_idï¼ˆæ‰¹æ¬¡æ ‡è¯†å­—æ®µï¼‰

#### å­—æ®µå®šä¹‰

```sql
batch_id VARCHAR(50) NULL COMMENT 'æ‰¹æ¬¡æ ‡è¯†ï¼ŒåŒä¸€æ¬¡å¤šè¿æŠ½æ“ä½œå…±äº«åŒä¸€ä¸ªbatch_id'
```

#### ä¸šåŠ¡å«ä¹‰

- **ç”¨æˆ·è§†è§’**: "æˆ‘ä»€ä¹ˆæ—¶å€™è¿›è¡Œçš„è¿™æ¬¡è¿æŠ½ï¼Ÿ"
- **ç³»ç»Ÿä½œç”¨**: å°†åŒä¸€æ¬¡æ“ä½œçš„å¤šæ¡è®°å½•å…³è”åœ¨ä¸€èµ·

#### ç”Ÿæˆè§„åˆ™

```javascript
/**
 * æ‰¹æ¬¡IDç”Ÿæˆè§„åˆ™
 * æ ¼å¼: batch_YYYYMMDD_HHMMSS_ç”¨æˆ·ID_éšæœºæ•°
 * ç¤ºä¾‹: batch_20250913_120000_31_a1b2c3
 */
function generateBatchId(userId) {
  const now = new Date()
  const dateStr = now.toISOString().slice(0, 19).replace(/[-T:]/g, '').slice(0, 15)
  const randomStr = Math.random().toString(36).substr(2, 6)
  return `batch_${dateStr}_${userId}_${randomStr}`
}
```

#### å…³è”æŸ¥è¯¢ä¼˜åŠ¿

```javascript
// æŸ¥è¯¢æŸæ¬¡3è¿æŠ½çš„å®Œæ•´è®°å½•
const batchRecords = await LotteryRecord.findAll({
  where: {
    batch_id: 'batch_20250913_120000_31_a1b2c3'
  },
  order: [['draw_sequence', 'ASC']]
})

// ç»“æœï¼šè·å¾—å®Œæ•´çš„3æ¡è®°å½•ï¼ŒæŒ‰æŠ½å¥–é¡ºåºæ’åˆ—
// ç¬¬1æŠ½ã€ç¬¬2æŠ½ã€ç¬¬3æŠ½ - å®Œæ•´çš„è¿æŠ½ä½“éªŒæ•°æ®
```

### 3. draw_countï¼ˆæŠ½å¥–æ€»æ¬¡æ•°å­—æ®µï¼‰

#### å­—æ®µå®šä¹‰

```sql
draw_count INT NOT NULL DEFAULT 1 COMMENT 'æœ¬æ¬¡æ“ä½œçš„æ€»æŠ½å¥–æ¬¡æ•°ï¼š1=å•æŠ½,3=3è¿æŠ½,5=5è¿æŠ½,10=10è¿æŠ½'
```

#### ä¸šåŠ¡å«ä¹‰

- **ç”¨æˆ·è§†è§’**: "è¿™æ¬¡è¿æŠ½æ€»å…±åº”è¯¥æœ‰å‡ ä¸ªç»“æœï¼Ÿ"
- **ç³»ç»Ÿä½œç”¨**: æ•°æ®å®Œæ•´æ€§éªŒè¯ï¼Œé˜²æ­¢æŠ½å¥–ç»“æœä¸¢å¤±

#### æ•°æ®å®Œæ•´æ€§éªŒè¯

```javascript
/**
 * æ‰¹æ¬¡æ•°æ®å®Œæ•´æ€§æ£€æŸ¥
 * éªŒè¯æ‰¹æ¬¡å†…è®°å½•æ•°æ˜¯å¦ä¸å£°æ˜çš„draw_countä¸€è‡´
 */
async function validateBatchIntegrity(batchId) {
  const records = await LotteryRecord.findAll({
    where: { batch_id: batchId },
    attributes: ['draw_count']
  })

  if (records.length === 0) {
    return { valid: false, error: 'æ‰¹æ¬¡è®°å½•ä¸å­˜åœ¨' }
  }

  const expectedCount = records[0].draw_count
  const actualCount = records.length

  if (expectedCount !== actualCount) {
    return {
      valid: false,
      error: `æ•°æ®ä¸å®Œæ•´ï¼šæœŸæœ›${expectedCount}æ¡è®°å½•ï¼Œå®é™…${actualCount}æ¡`,
      expected: expectedCount,
      actual: actualCount
    }
  }

  return { valid: true, message: 'æ‰¹æ¬¡æ•°æ®å®Œæ•´' }
}
```

#### åº”ç”¨åœºæ™¯

```javascript
// å‰ç«¯å±•ç¤ºé€»è¾‘
if (draw_count === 3 && actualRecords.length === 3) {
  display: '3è¿æŠ½æˆåŠŸ - è·å¾—3ä¸ªå¥–å“'
} else if (draw_count === 3 && actualRecords.length < 3) {
  display: '3è¿æŠ½å¼‚å¸¸ - æ•°æ®ä¸å®Œæ•´ï¼Œè¯·è”ç³»å®¢æœ'
}
```

### 4. draw_sequenceï¼ˆæŠ½å¥–åºå·å­—æ®µï¼‰

#### å­—æ®µå®šä¹‰

```sql
draw_sequence INT NOT NULL DEFAULT 1 COMMENT 'åœ¨å½“å‰æ‰¹æ¬¡ä¸­çš„æŠ½å¥–åºå·ï¼š1,2,3...'
```

#### ä¸šåŠ¡å«ä¹‰

- **ç”¨æˆ·è§†è§’**: "è¿æŠ½çš„ç»“æœé¡ºåºæ˜¯ä»€ä¹ˆï¼Ÿ"
- **ç³»ç»Ÿä½œç”¨**: è®°å½•æŠ½å¥–æ‰§è¡Œé¡ºåºï¼Œæ”¯æŒæœ‰åºå±•ç¤º

#### åºå·ç”Ÿæˆé€»è¾‘

```javascript
/**
 * æ‰¹æ¬¡å†…åºå·åˆ†é…
 * æ¯ä¸ªæ‰¹æ¬¡ä»1å¼€å§‹é€’å¢
 */
async function executeBatchLottery(userId, drawType, drawCount) {
  const batchId = generateBatchId(userId)
  const batchTimestamp = new Date()
  const results = []

  for (let sequence = 1; sequence <= drawCount; sequence++) {
    const lotteryResult = await lotteryEngine.executeLottery(userId)

    const record = await LotteryRecord.create({
      user_id: userId,
      draw_type: drawType, // 'triple'
      batch_id: batchId, // 'batch_20250913_120000_31_a1b2c3'
      draw_count: drawCount, // 3
      draw_sequence: sequence, // 1,2,3
      prize_id: lotteryResult.prize_id,
      points_consumed: lotteryResult.points,
      created_at: batchTimestamp // ç»Ÿä¸€æ—¶é—´æˆ³
    })

    results.push(record)
  }

  return { batchId, records: results }
}
```

#### å‰ç«¯æœ‰åºå±•ç¤º

```javascript
// å‰ç«¯è·å–æœ‰åºçš„æŠ½å¥–ç»“æœ
const orderedResults = batchRecords.sort((a, b) => a.draw_sequence - b.draw_sequence)

// å±•ç¤ºæ•ˆæœ
orderedResults.forEach((record, index) => {
  console.log(`ç¬¬${record.draw_sequence}æŠ½: ${record.prize_name}`)
})

// è¾“å‡ºï¼š
// ç¬¬1æŠ½: è‹¹æœ
// ç¬¬2æŠ½: æ©™å­
// ç¬¬3æŠ½: é¦™è•‰
```

## ğŸ”§ æŠ€æœ¯å®ç°æ–¹æ¡ˆ

### APIè®¾è®¡è§„èŒƒ

#### 1. æ‰¹æ¬¡æŠ½å¥–æ¥å£

```javascript
/**
 * POST /api/v4/unified-engine/lottery/batch-draw
 * å››å­—æ®µç»„åˆçš„æ‰¹æ¬¡æŠ½å¥–æ¥å£
 */
router.post('/batch-draw', async (req, res) => {
  try {
    const { draw_type, user_id } = req.body

    // éªŒè¯æŠ½å¥–ç±»å‹å’Œè·å–æŠ½å¥–æ¬¡æ•°
    const drawConfig = {
      single: 1,
      triple: 3,
      five: 5,
      ten: 10
    }

    const drawCount = drawConfig[draw_type]
    if (!drawCount) {
      return res.status(400).json({
        success: false,
        error: 'æ— æ•ˆçš„æŠ½å¥–ç±»å‹',
        code: 'INVALID_DRAW_TYPE'
      })
    }

    // æ‰§è¡Œæ‰¹æ¬¡æŠ½å¥–
    const result = await executeBatchLottery(user_id, draw_type, drawCount)

    // è¿”å›å®Œæ•´çš„æ‰¹æ¬¡ä¿¡æ¯
    res.json({
      success: true,
      data: {
        batch_id: result.batchId,
        draw_type: draw_type,
        draw_count: drawCount,
        draw_time: result.records[0].created_at,
        results: result.records.map(record => ({
          sequence: record.draw_sequence,
          prize_name: record.prize_name,
          prize_type: record.prize_type,
          points_consumed: record.points_consumed
        }))
      }
    })
  } catch (error) {
    console.error('æ‰¹æ¬¡æŠ½å¥–å¤±è´¥:', error)
    res.status(500).json({
      success: false,
      error: 'æŠ½å¥–ç³»ç»Ÿå¼‚å¸¸',
      code: 'LOTTERY_SYSTEM_ERROR'
    })
  }
})
```

#### 2. ç”¨æˆ·æŠ½å¥–å†å²æŸ¥è¯¢æ¥å£

```javascript
/**
 * GET /api/v4/unified-engine/lottery/history/:userId
 * æŒ‰æ‰¹æ¬¡èšåˆçš„ç”¨æˆ·æŠ½å¥–å†å²
 */
router.get('/history/:userId', async (req, res) => {
  try {
    const { userId } = req.params
    const { page = 1, limit = 10 } = req.query

    // æŸ¥è¯¢ç”¨æˆ·çš„æ‰¹æ¬¡æŠ½å¥–å†å²
    const batchHistory = await models.sequelize.query(
      `
      SELECT 
        batch_id,
        draw_type,
        draw_count,
        MIN(created_at) as draw_time,
        COUNT(*) as actual_count,
        GROUP_CONCAT(
          CONCAT('ç¬¬', draw_sequence, 'æŠ½:', prize_name) 
          ORDER BY draw_sequence ASC 
          SEPARATOR ' | '
        ) as results_summary
      FROM lottery_records 
      WHERE user_id = :userId
        AND batch_id IS NOT NULL
      GROUP BY batch_id, draw_type, draw_count
      ORDER BY draw_time DESC
      LIMIT :offset, :limit
    `,
      {
        replacements: {
          userId: userId,
          offset: (page - 1) * limit,
          limit: parseInt(limit)
        },
        type: models.sequelize.QueryTypes.SELECT
      }
    )

    // æ·»åŠ æ•°æ®å®Œæ•´æ€§æ£€æŸ¥
    const enrichedHistory = batchHistory.map(batch => ({
      ...batch,
      is_complete: batch.draw_count === batch.actual_count,
      draw_type_display:
        {
          single: 'å•æŠ½',
          triple: '3è¿æŠ½',
          five: '5è¿æŠ½',
          ten: '10è¿æŠ½'
        }[batch.draw_type] || 'æœªçŸ¥ç±»å‹'
    }))

    res.json({
      success: true,
      data: {
        history: enrichedHistory,
        pagination: {
          page: parseInt(page),
          limit: parseInt(limit),
          total: batchHistory.length
        }
      }
    })
  } catch (error) {
    console.error('æŸ¥è¯¢æŠ½å¥–å†å²å¤±è´¥:', error)
    res.status(500).json({
      success: false,
      error: 'æŸ¥è¯¢å†å²è®°å½•å¤±è´¥'
    })
  }
})
```

#### 3. æ‰¹æ¬¡è¯¦æƒ…æŸ¥è¯¢æ¥å£

```javascript
/**
 * GET /api/v4/unified-engine/lottery/batch/:batchId
 * æŸ¥è¯¢ç‰¹å®šæ‰¹æ¬¡çš„è¯¦ç»†æŠ½å¥–è®°å½•
 */
router.get('/batch/:batchId', async (req, res) => {
  try {
    const { batchId } = req.params

    // æŸ¥è¯¢æ‰¹æ¬¡è¯¦ç»†è®°å½•
    const batchRecords = await LotteryRecord.findAll({
      where: { batch_id: batchId },
      include: [
        {
          model: models.Prize,
          as: 'prize',
          attributes: ['name', 'type', 'value', 'image_url']
        }
      ],
      order: [['draw_sequence', 'ASC']]
    })

    if (batchRecords.length === 0) {
      return res.status(404).json({
        success: false,
        error: 'æ‰¹æ¬¡è®°å½•ä¸å­˜åœ¨',
        code: 'BATCH_NOT_FOUND'
      })
    }

    // æ•°æ®å®Œæ•´æ€§éªŒè¯
    const firstRecord = batchRecords[0]
    const validation = await validateBatchIntegrity(batchId)

    res.json({
      success: true,
      data: {
        batch_info: {
          batch_id: batchId,
          draw_type: firstRecord.draw_type,
          draw_count: firstRecord.draw_count,
          draw_time: firstRecord.created_at,
          user_id: firstRecord.user_id
        },
        validation: validation,
        records: batchRecords.map(record => ({
          sequence: record.draw_sequence,
          prize_info: {
            name: record.prize?.name || 'æœªçŸ¥å¥–å“',
            type: record.prize?.type || 'unknown',
            value: record.prize?.value || 0,
            image_url: record.prize?.image_url || null
          },
          points_consumed: record.points_consumed,
          is_pity: record.is_pity || false
        }))
      }
    })
  } catch (error) {
    console.error('æŸ¥è¯¢æ‰¹æ¬¡è¯¦æƒ…å¤±è´¥:', error)
    res.status(500).json({
      success: false,
      error: 'æŸ¥è¯¢æ‰¹æ¬¡è¯¦æƒ…å¤±è´¥'
    })
  }
})
```

### æ•°æ®åº“ä¼˜åŒ–æ–¹æ¡ˆ

#### 1. ç´¢å¼•ä¼˜åŒ–

```sql
-- ä¸ºå››å­—æ®µç»„åˆåˆ›å»ºå¤åˆç´¢å¼•
CREATE INDEX idx_lottery_batch_query ON lottery_records(user_id, batch_id, draw_sequence);
CREATE INDEX idx_lottery_type_time ON lottery_records(draw_type, created_at);
CREATE INDEX idx_batch_integrity ON lottery_records(batch_id, draw_count);

-- å•å­—æ®µç´¢å¼•ï¼ˆç”¨äºä¸åŒæŸ¥è¯¢åœºæ™¯ï¼‰
CREATE INDEX idx_batch_id ON lottery_records(batch_id);
CREATE INDEX idx_draw_type ON lottery_records(draw_type);
```

#### 2. æ•°æ®è¿ç§»è„šæœ¬

```javascript
/**
 * ç°æœ‰æ•°æ®è¿ç§»åˆ°å››å­—æ®µæ–¹æ¡ˆ
 * ä¸ºå†å²æ•°æ®è¡¥å……ç¼ºå¤±çš„å­—æ®µä¿¡æ¯
 */
async function migrateExistingData() {
  console.log('å¼€å§‹è¿ç§»ç°æœ‰æŠ½å¥–æ•°æ®åˆ°å››å­—æ®µæ–¹æ¡ˆ...')

  // ç¬¬1æ­¥ï¼šä¸ºNULLçš„draw_typeå­—æ®µè®¾ç½®é»˜è®¤å€¼
  await models.sequelize.query(`
    UPDATE lottery_records 
    SET draw_type = 'single' 
    WHERE draw_type IS NULL OR draw_type = ''
  `)

  // ç¬¬2æ­¥ï¼šä¸ºå•æŠ½è®°å½•è®¾ç½®draw_countå’Œdraw_sequence
  await models.sequelize.query(`
    UPDATE lottery_records 
    SET draw_count = 1, draw_sequence = 1 
    WHERE draw_type = 'single' AND (draw_count IS NULL OR draw_count = 0)
  `)

  // ç¬¬3æ­¥ï¼šåˆ†æè¿ç»­çš„æŠ½å¥–è®°å½•ï¼Œç”Ÿæˆbatch_id
  const consecutiveGroups = await models.sequelize.query(
    `
    SELECT 
      user_id,
      DATE_FORMAT(created_at, '%Y-%m-%d %H:%i:%s') as time_group,
      COUNT(*) as record_count,
      GROUP_CONCAT(id ORDER BY created_at) as record_ids
    FROM lottery_records 
    WHERE batch_id IS NULL 
      AND draw_type IN ('triple', 'five', 'ten')
    GROUP BY user_id, DATE_FORMAT(created_at, '%Y-%m-%d %H:%i')
    HAVING record_count > 1
  `,
    {
      type: models.sequelize.QueryTypes.SELECT
    }
  )

  // ç¬¬4æ­¥ï¼šä¸ºè¿ç»­è®°å½•åˆ†é…batch_id
  for (const group of consecutiveGroups) {
    const batchId = `migrated_batch_${Date.now()}_${group.user_id}`
    const recordIds = group.record_ids.split(',')

    // æ›´æ–°batch_idå’Œdraw_sequence
    for (let i = 0; i < recordIds.length; i++) {
      await models.sequelize.query(
        `
        UPDATE lottery_records 
        SET batch_id = :batchId, 
            draw_sequence = :sequence,
            draw_count = :drawCount
        WHERE id = :recordId
      `,
        {
          replacements: {
            batchId: batchId,
            sequence: i + 1,
            drawCount: recordIds.length,
            recordId: recordIds[i]
          }
        }
      )
    }
  }

  console.log(`âœ… æ•°æ®è¿ç§»å®Œæˆï¼Œå¤„ç†äº†${consecutiveGroups.length}ä¸ªæ‰¹æ¬¡`)
}
```

#### 3. æ•°æ®ä¸€è‡´æ€§æ£€æŸ¥

```javascript
/**
 * å››å­—æ®µæ•°æ®ä¸€è‡´æ€§æ£€æŸ¥å·¥å…·
 */
async function checkDataConsistency() {
  console.log('å¼€å§‹å››å­—æ®µæ•°æ®ä¸€è‡´æ€§æ£€æŸ¥...')

  const issues = []

  // æ£€æŸ¥1ï¼šbatch_idä¸ä¸ºç©ºä½†draw_countä¸å®é™…è®°å½•æ•°ä¸åŒ¹é…
  const batchCountMismatch = await models.sequelize.query(
    `
    SELECT 
      batch_id,
      draw_count,
      COUNT(*) as actual_count
    FROM lottery_records 
    WHERE batch_id IS NOT NULL
    GROUP BY batch_id, draw_count
    HAVING draw_count != COUNT(*)
  `,
    { type: models.sequelize.QueryTypes.SELECT }
  )

  if (batchCountMismatch.length > 0) {
    issues.push({
      type: 'BATCH_COUNT_MISMATCH',
      description: 'æ‰¹æ¬¡è®°å½•æ•°ä¸å£°æ˜çš„draw_countä¸åŒ¹é…',
      affected_batches: batchCountMismatch.length,
      details: batchCountMismatch
    })
  }

  // æ£€æŸ¥2ï¼šdraw_sequenceåºå·ä¸è¿ç»­
  const sequencGaps = await models.sequelize.query(
    `
    SELECT batch_id, 
           GROUP_CONCAT(draw_sequence ORDER BY draw_sequence) as sequences
    FROM lottery_records 
    WHERE batch_id IS NOT NULL
    GROUP BY batch_id
    HAVING sequences NOT REGEXP '^1(,2)*(,3)*(,4)*(,5)*(,6)*(,7)*(,8)*(,9)*(,10)?$'
  `,
    { type: models.sequelize.QueryTypes.SELECT }
  )

  if (sequencGaps.length > 0) {
    issues.push({
      type: 'SEQUENCE_GAPS',
      description: 'æ‰¹æ¬¡å†…åºå·ä¸è¿ç»­',
      affected_batches: sequencGaps.length,
      details: sequencGaps
    })
  }

  // æ£€æŸ¥3ï¼šdraw_typeä¸draw_countä¸åŒ¹é…
  const typeMismatch = await models.sequelize.query(
    `
    SELECT DISTINCT draw_type, draw_count, COUNT(*) as occurrences
    FROM lottery_records 
    WHERE 
      (draw_type = 'single' AND draw_count != 1) OR
      (draw_type = 'triple' AND draw_count != 3) OR
      (draw_type = 'five' AND draw_count != 5) OR
      (draw_type = 'ten' AND draw_count != 10)
    GROUP BY draw_type, draw_count
  `,
    { type: models.sequelize.QueryTypes.SELECT }
  )

  if (typeMismatch.length > 0) {
    issues.push({
      type: 'TYPE_COUNT_MISMATCH',
      description: 'draw_typeä¸draw_countä¸åŒ¹é…',
      affected_records: typeMismatch.reduce((sum, item) => sum + item.occurrences, 0),
      details: typeMismatch
    })
  }

  // è¾“å‡ºæ£€æŸ¥ç»“æœ
  if (issues.length === 0) {
    console.log('âœ… å››å­—æ®µæ•°æ®ä¸€è‡´æ€§æ£€æŸ¥é€šè¿‡')
    return { valid: true, issues: [] }
  } else {
    console.log('âŒ å‘ç°æ•°æ®ä¸€è‡´æ€§é—®é¢˜:')
    issues.forEach((issue, index) => {
      console.log(`   ${index + 1}. ${issue.type}: ${issue.description}`)
    })
    return { valid: false, issues }
  }
}
```

## ğŸ¨ å‰ç«¯å¯¹æ¥æŒ‡å—

### 1. æ•°æ®å±•ç¤ºæ ¼å¼

```javascript
// å‰ç«¯æ¥æ”¶åˆ°çš„æ ‡å‡†æ•°æ®æ ¼å¼
const batchLotteryResult = {
  success: true,
  data: {
    batch_id: 'batch_20250913_120000_31_a1b2c3',
    draw_type: 'triple',
    draw_count: 3,
    draw_time: '2025-09-13T12:00:00.000Z',
    results: [
      {
        sequence: 1,
        prize_name: 'è‹¹æœ',
        prize_type: 'food',
        points_consumed: 100
      },
      {
        sequence: 2,
        prize_name: 'æ©™å­',
        prize_type: 'food',
        points_consumed: 100
      },
      {
        sequence: 3,
        prize_name: 'é¦™è•‰',
        prize_type: 'food',
        points_consumed: 100
      }
    ]
  }
}
```

### 2. å‰ç«¯å±•ç¤ºé€»è¾‘

```javascript
// å‰ç«¯å±•ç¤ºå¤„ç†å‡½æ•°
function displayLotteryResult(result) {
  const { draw_type, draw_count, draw_time, results } = result.data

  // æŠ½å¥–ç±»å‹æ˜¾ç¤º
  const typeDisplay =
    {
      single: 'å•æŠ½',
      triple: '3è¿æŠ½',
      five: '5è¿æŠ½',
      ten: '10è¿æŠ½'
    }[draw_type] || 'æœªçŸ¥ç±»å‹'

  // æ—¶é—´æ ¼å¼åŒ–
  const timeDisplay = new Date(draw_time).toLocaleString('zh-CN', {
    year: 'numeric',
    month: '2-digit',
    day: '2-digit',
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit'
  })

  // æ„å»ºå±•ç¤ºå†…å®¹
  const displayContent = {
    title: `${timeDisplay} - ${typeDisplay}`,
    summary: `è·å¾—${draw_count}ä¸ªå¥–å“`,
    details: results
      .map(item => `ç¬¬${item.sequence}æŠ½: ${item.prize_name} (æ¶ˆè€—${item.points_consumed}ç§¯åˆ†)`)
      .join('\n')
  }

  return displayContent
}

// ä½¿ç”¨ç¤ºä¾‹
const display = displayLotteryResult(batchLotteryResult)
console.log(display.title) // "2025-09-13 20:00:00 - 3è¿æŠ½"
console.log(display.summary) // "è·å¾—3ä¸ªå¥–å“"
console.log(display.details) // "ç¬¬1æŠ½: è‹¹æœ (æ¶ˆè€—100ç§¯åˆ†)\nç¬¬2æŠ½: æ©™å­ (æ¶ˆè€—100ç§¯åˆ†)..."
```

### 3. å†å²è®°å½•å±•ç¤ºç»„ä»¶

```javascript
// å‰ç«¯å†å²è®°å½•å±•ç¤ºç»„ä»¶
function LotteryHistoryComponent({ userId }) {
  const [history, setHistory] = useState([])
  const [loading, setLoading] = useState(true)

  useEffect(() => {
    fetchLotteryHistory()
  }, [userId])

  const fetchLotteryHistory = async () => {
    try {
      const response = await fetch(`/api/v4/unified-engine/lottery/history/${userId}`)
      const result = await response.json()

      if (result.success) {
        setHistory(result.data.history)
      }
    } catch (error) {
      console.error('è·å–æŠ½å¥–å†å²å¤±è´¥:', error)
    } finally {
      setLoading(false)
    }
  }

  return (
    <div className="lottery-history">
      <h3>æŠ½å¥–å†å²</h3>
      {loading ? (
        <div>åŠ è½½ä¸­...</div>
      ) : (
        history.map(batch => (
          <div key={batch.batch_id} className="history-item">
            <div className="batch-header">
              <span className="draw-type">{batch.draw_type_display}</span>
              <span className="draw-time">{new Date(batch.draw_time).toLocaleString('zh-CN')}</span>
              {!batch.is_complete && <span className="warning">âš ï¸ æ•°æ®ä¸å®Œæ•´</span>}
            </div>
            <div className="results-summary">{batch.results_summary}</div>
          </div>
        ))
      )}
    </div>
  )
}
```

## ğŸ§ª æµ‹è¯•éªŒè¯æ–¹æ¡ˆ

### 1. å•å…ƒæµ‹è¯•

```javascript
// å››å­—æ®µåŠŸèƒ½å•å…ƒæµ‹è¯•
describe('å››å­—æ®µç»„åˆæŠ½å¥–åŠŸèƒ½æµ‹è¯•', () => {
  test('æ‰¹æ¬¡æŠ½å¥– - å­—æ®µæ­£ç¡®æ€§æµ‹è¯•', async () => {
    const userId = 31
    const drawType = 'triple'
    const drawCount = 3

    const result = await executeBatchLottery(userId, drawType, drawCount)

    // éªŒè¯æ‰¹æ¬¡ä¿¡æ¯
    expect(result.batchId).toMatch(/^batch_\d{15}_31_[a-z0-9]{6}$/)
    expect(result.records).toHaveLength(3)

    // éªŒè¯æ¯æ¡è®°å½•çš„å››å­—æ®µ
    result.records.forEach((record, index) => {
      expect(record.draw_type).toBe('triple')
      expect(record.batch_id).toBe(result.batchId)
      expect(record.draw_count).toBe(3)
      expect(record.draw_sequence).toBe(index + 1)
    })
  })

  test('æ•°æ®å®Œæ•´æ€§éªŒè¯æµ‹è¯•', async () => {
    const batchId = 'test_batch_12345'

    // åˆ›å»ºä¸å®Œæ•´çš„æ‰¹æ¬¡æ•°æ®è¿›è¡Œæµ‹è¯•
    await LotteryRecord.bulkCreate([
      { batch_id: batchId, draw_count: 3, draw_sequence: 1, user_id: 31, draw_type: 'triple' },
      { batch_id: batchId, draw_count: 3, draw_sequence: 2, user_id: 31, draw_type: 'triple' }
      // æ•…æ„ç¼ºå°‘ç¬¬3æ¡è®°å½•
    ])

    const validation = await validateBatchIntegrity(batchId)

    expect(validation.valid).toBe(false)
    expect(validation.error).toContain('æ•°æ®ä¸å®Œæ•´')
    expect(validation.expected).toBe(3)
    expect(validation.actual).toBe(2)
  })

  test('åºå·ç”Ÿæˆè¿ç»­æ€§æµ‹è¯•', async () => {
    const userId = 31
    const result = await executeBatchLottery(userId, 'five', 5)

    const sequences = result.records.map(r => r.draw_sequence).sort()
    expect(sequences).toEqual([1, 2, 3, 4, 5])
  })

  test('ç»Ÿä¸€æ—¶é—´æˆ³éªŒè¯', async () => {
    const userId = 31
    const result = await executeBatchLottery(userId, 'triple', 3)

    // æ‰€æœ‰è®°å½•åº”è¯¥æœ‰ç›¸åŒçš„created_atæ—¶é—´æˆ³
    const timestamps = result.records.map(r => r.created_at.getTime())
    const uniqueTimestamps = [...new Set(timestamps)]

    expect(uniqueTimestamps).toHaveLength(1)
  })
})
```

### 2. é›†æˆæµ‹è¯•

```javascript
// APIæ¥å£é›†æˆæµ‹è¯•
describe('æ‰¹æ¬¡æŠ½å¥–APIé›†æˆæµ‹è¯•', () => {
  test('POST /api/v4/unified-engine/lottery/batch-draw - 3è¿æŠ½', async () => {
    const response = await request(app).post('/api/v4/unified-engine/lottery/batch-draw').send({
      user_id: 31,
      draw_type: 'triple'
    })

    expect(response.status).toBe(200)
    expect(response.body.success).toBe(true)

    const { data } = response.body
    expect(data.draw_type).toBe('triple')
    expect(data.draw_count).toBe(3)
    expect(data.results).toHaveLength(3)

    // éªŒè¯åºå·è¿ç»­æ€§
    data.results.forEach((result, index) => {
      expect(result.sequence).toBe(index + 1)
    })
  })

  test('GET /api/v4/unified-engine/lottery/history/:userId - å†å²æŸ¥è¯¢', async () => {
    // å…ˆåˆ›å»ºä¸€äº›æµ‹è¯•æ•°æ®
    await executeBatchLottery(31, 'triple', 3)
    await executeBatchLottery(31, 'single', 1)

    const response = await request(app).get('/api/v4/unified-engine/lottery/history/31')

    expect(response.status).toBe(200)
    expect(response.body.success).toBe(true)

    const history = response.body.data.history
    expect(Array.isArray(history)).toBe(true)

    // éªŒè¯è¿”å›æ•°æ®åŒ…å«å››å­—æ®µä¿¡æ¯
    history.forEach(batch => {
      expect(batch).toHaveProperty('batch_id')
      expect(batch).toHaveProperty('draw_type')
      expect(batch).toHaveProperty('draw_count')
      expect(batch).toHaveProperty('is_complete')
    })
  })
})
```

### 3. æ€§èƒ½æµ‹è¯•

```javascript
// æ€§èƒ½å’Œå‹åŠ›æµ‹è¯•
describe('å››å­—æ®µæ–¹æ¡ˆæ€§èƒ½æµ‹è¯•', () => {
  test('æ‰¹é‡åˆ›å»ºæ€§èƒ½æµ‹è¯•', async () => {
    const startTime = Date.now()

    // æ¨¡æ‹Ÿ100ä¸ªç”¨æˆ·åŒæ—¶è¿›è¡Œ3è¿æŠ½
    const promises = []
    for (let i = 1; i <= 100; i++) {
      promises.push(executeBatchLottery(i, 'triple', 3))
    }

    const results = await Promise.all(promises)
    const endTime = Date.now()

    expect(results).toHaveLength(100)
    expect(endTime - startTime).toBeLessThan(5000) // åº”åœ¨5ç§’å†…å®Œæˆ

    console.log(`100ä¸ªæ‰¹æ¬¡æŠ½å¥–è€—æ—¶: ${endTime - startTime}ms`)
  })

  test('å¤æ‚æŸ¥è¯¢æ€§èƒ½æµ‹è¯•', async () => {
    // åˆ›å»ºå¤§é‡æµ‹è¯•æ•°æ®
    for (let i = 1; i <= 50; i++) {
      await executeBatchLottery(1, 'triple', 3)
    }

    const startTime = Date.now()

    // æ‰§è¡Œå¤æ‚çš„å†å²æŸ¥è¯¢
    const history = await models.sequelize.query(
      `
      SELECT * FROM (
        SELECT 
          batch_id, draw_type, draw_count,
          MIN(created_at) as draw_time,
          COUNT(*) as actual_count
        FROM lottery_records 
        WHERE user_id = 1 AND batch_id IS NOT NULL
        GROUP BY batch_id, draw_type, draw_count
        ORDER BY draw_time DESC
        LIMIT 20
      ) as recent_batches
    `,
      { type: models.sequelize.QueryTypes.SELECT }
    )

    const endTime = Date.now()

    expect(endTime - startTime).toBeLessThan(1000) // æŸ¥è¯¢åº”åœ¨1ç§’å†…å®Œæˆ
    expect(history.length).toBeGreaterThan(0)

    console.log(`å¤æ‚æŸ¥è¯¢è€—æ—¶: ${endTime - startTime}ms`)
  })
})
```

## ğŸš€ éƒ¨ç½²å’Œè¿ç§»è®¡åˆ’

### ç¬¬ä¸€é˜¶æ®µï¼šåŸºç¡€è®¾æ–½å‡†å¤‡

1. **æ•°æ®åº“å­—æ®µéªŒè¯**
   - ç¡®è®¤å››ä¸ªå­—æ®µå·²å­˜åœ¨ä¸”ç±»å‹æ­£ç¡®
   - åˆ›å»ºå¿…è¦çš„æ•°æ®åº“ç´¢å¼•
   - å¤‡ä»½ç°æœ‰æ•°æ®

2. **APIæ¥å£å¼€å‘**
   - å®ç°æ‰¹æ¬¡æŠ½å¥–æ¥å£
   - å®ç°å†å²æŸ¥è¯¢æ¥å£
   - å®ç°æ•°æ®éªŒè¯å·¥å…·

### ç¬¬äºŒé˜¶æ®µï¼šæ•°æ®è¿ç§»

1. **ç°æœ‰æ•°æ®åˆ†æ**
   - ç»Ÿè®¡ç°æœ‰è®°å½•çš„åˆ†å¸ƒæƒ…å†µ
   - è¯†åˆ«éœ€è¦è¿ç§»çš„æ•°æ®é‡
   - åˆ¶å®šè¿ç§»æ—¶é—´çª—å£

2. **åˆ†æ‰¹è¿ç§»æ‰§è¡Œ**
   - å°æ‰¹é‡æµ‹è¯•è¿ç§»æµç¨‹
   - éªŒè¯è¿ç§»ç»“æœçš„æ­£ç¡®æ€§
   - å…¨é‡æ•°æ®è¿ç§»

### ç¬¬ä¸‰é˜¶æ®µï¼šåŠŸèƒ½éªŒè¯

1. **APIåŠŸèƒ½æµ‹è¯•**
   - å•å…ƒæµ‹è¯•å’Œé›†æˆæµ‹è¯•
   - æ€§èƒ½å‹åŠ›æµ‹è¯•
   - æ•°æ®ä¸€è‡´æ€§éªŒè¯

2. **å‰ç«¯å¯¹æ¥æµ‹è¯•**
   - ç•Œé¢å±•ç¤ºæ•ˆæœéªŒè¯
   - ç”¨æˆ·ä½“éªŒæµ‹è¯•
   - å¼‚å¸¸æƒ…å†µå¤„ç†æµ‹è¯•

### ç¬¬å››é˜¶æ®µï¼šæ­£å¼ä¸Šçº¿

1. **ç°åº¦å‘å¸ƒ**
   - å°éƒ¨åˆ†ç”¨æˆ·å…ˆè¡Œä½“éªŒ
   - ç›‘æ§ç³»ç»Ÿç¨³å®šæ€§
   - æ”¶é›†ç”¨æˆ·åé¦ˆ

2. **å…¨é‡æ¨å¹¿**
   - æ‰€æœ‰ç”¨æˆ·å¯ç”¨æ–°åŠŸèƒ½
   - æŒç»­ç›‘æ§å’Œä¼˜åŒ–
   - å»ºç«‹é•¿æœŸç»´æŠ¤æœºåˆ¶

## ğŸ“ˆ æ•ˆæœè¯„ä¼°

### ç”¨æˆ·ä½“éªŒæ”¹è¿›

- âœ… **æŠ½å¥–ç±»å‹æ˜ç¡®**: ç”¨æˆ·æ¸…æ¥šçŸ¥é“è¿›è¡Œçš„æ˜¯å“ªç§æŠ½å¥–
- âœ… **æ—¶é—´æ˜¾ç¤ºç»Ÿä¸€**: è¿æŠ½æ˜¾ç¤ºä¸ºç»Ÿä¸€çš„æ‰§è¡Œæ—¶é—´
- âœ… **ç»“æœé¡ºåºæ¸…æ™°**: å¯ä»¥çœ‹åˆ°æŠ½å¥–çš„æ‰§è¡Œé¡ºåº
- âœ… **æ•°æ®å®Œæ•´æ€§ä¿éšœ**: ç³»ç»Ÿä¿è¯æŠ½å¥–ç»“æœä¸ä¸¢å¤±

### æŠ€æœ¯æ¶æ„ä¼˜åŒ–

- âœ… **æ•°æ®æ¨¡å‹è§„èŒƒ**: å››å­—æ®µæ¸…æ™°è¡¨è¾¾æŠ½å¥–çš„å„ä¸ªç»´åº¦
- âœ… **æŸ¥è¯¢æ€§èƒ½æå‡**: é€šè¿‡ç´¢å¼•ä¼˜åŒ–æå‡æŸ¥è¯¢æ•ˆç‡
- âœ… **ä»£ç ç»´æŠ¤æ€§**: ç»Ÿä¸€çš„æ•°æ®å¤„ç†é€»è¾‘ï¼Œä¾¿äºç»´æŠ¤
- âœ… **æ‰©å±•æ€§å¢å¼º**: æ”¯æŒæ›´å¤šè¿æŠ½ç±»å‹çš„æ‰©å±•

### ä¸šåŠ¡ä»·å€¼å®ç°

- âœ… **è¿è¥æ•°æ®å‡†ç¡®**: å‡†ç¡®ç»Ÿè®¡å„ç§æŠ½å¥–ç±»å‹çš„ä½¿ç”¨æƒ…å†µ
- âœ… **ç”¨æˆ·è¡Œä¸ºåˆ†æ**: å¯ä»¥åˆ†æç”¨æˆ·çš„æŠ½å¥–åå¥½
- âœ… **é—®é¢˜æ’æŸ¥æ•ˆç‡**: å¿«é€Ÿå®šä½å’Œè§£å†³æŠ½å¥–ç›¸å…³é—®é¢˜
- âœ… **ç³»ç»Ÿç¨³å®šæ€§**: å‡å°‘æ•°æ®ä¸ä¸€è‡´å¯¼è‡´çš„ç³»ç»Ÿé—®é¢˜

## ğŸ” æ½œåœ¨é£é™©å’Œè§£å†³æ–¹æ¡ˆ

### é£é™©1ï¼šæ•°æ®è¿ç§»é£é™©

**é—®é¢˜**: ç°æœ‰æ•°æ®è¿ç§»å¯èƒ½å‡ºç°æ•°æ®ä¸¢å¤±æˆ–é”™è¯¯
**è§£å†³æ–¹æ¡ˆ**:

- å®Œæ•´çš„æ•°æ®å¤‡ä»½ç­–ç•¥
- åˆ†æ‰¹æ¬¡å°é‡è¿ç§»éªŒè¯
- è¿ç§»å‰åæ•°æ®å¯¹æ¯”éªŒè¯
- è¿ç§»å›æ»šé¢„æ¡ˆ

### é£é™©2ï¼šæ€§èƒ½å½±å“é£é™©

**é—®é¢˜**: å››å­—æ®µæŸ¥è¯¢å¯èƒ½å½±å“æ•°æ®åº“æ€§èƒ½
**è§£å†³æ–¹æ¡ˆ**:

- å»ºç«‹åˆé€‚çš„å¤åˆç´¢å¼•
- æŸ¥è¯¢è¯­å¥ä¼˜åŒ–å’Œæµ‹è¯•
- æ•°æ®åº“è¿æ¥æ± é…ç½®ä¼˜åŒ–
- ç›‘æ§å’Œé¢„è­¦æœºåˆ¶

### é£é™©3ï¼šå‰ç«¯å…¼å®¹æ€§é£é™©

**é—®é¢˜**: æ–°çš„æ•°æ®æ ¼å¼å¯èƒ½å½±å“å‰ç«¯å±•ç¤º
**è§£å†³æ–¹æ¡ˆ**:

- ä¿æŒAPIå‘åå…¼å®¹
- å‰ç«¯æ¸è¿›å¼å‡çº§
- å……åˆ†çš„å‰ç«¯æµ‹è¯•
- ç°åº¦å‘å¸ƒç­–ç•¥

### é£é™©4ï¼šä¸šåŠ¡é€»è¾‘å¤æ‚æ€§é£é™©

**é—®é¢˜**: å››å­—æ®µç»„åˆå¢åŠ äº†ä¸šåŠ¡é€»è¾‘å¤æ‚åº¦
**è§£å†³æ–¹æ¡ˆ**:

- è¯¦ç»†çš„å¼€å‘æ–‡æ¡£å’Œæ³¨é‡Š
- å®Œå–„çš„å•å…ƒæµ‹è¯•è¦†ç›–
- ä»£ç å®¡æŸ¥æœºåˆ¶
- å›¢é˜ŸæŠ€æœ¯åŸ¹è®­

## ğŸ“š é™„å½•

### A. ç›¸å…³æŠ€æœ¯æ–‡æ¡£

- [æŠ½å¥–ç³»ç»Ÿæ¶æ„è®¾è®¡æ–‡æ¡£](./å¤šè¿æŠ½æ—¶é—´ç®¡ç†æŠ€æœ¯æ–¹æ¡ˆ.md)
- [æ•°æ®åº“è®¾è®¡è§„èŒƒ](./database-architecture-decision.md)
- [APIæ¥å£è®¾è®¡è§„èŒƒ](./æ¥å£å¯¹æ¥è§„èŒƒæ–‡æ¡£.md)

### B. æµ‹è¯•æ•°æ®æ ·ä¾‹

```sql
-- å››å­—æ®µç»„åˆæµ‹è¯•æ•°æ®
INSERT INTO lottery_records (
  user_id, draw_type, batch_id, draw_count, draw_sequence,
  prize_id, points_consumed, created_at
) VALUES
-- 3è¿æŠ½æ‰¹æ¬¡ç¤ºä¾‹
(31, 'triple', 'batch_20250913_120000_31_a1b2c3', 3, 1, 1, 100, '2025-09-13 12:00:00'),
(31, 'triple', 'batch_20250913_120000_31_a1b2c3', 3, 2, 2, 100, '2025-09-13 12:00:00'),
(31, 'triple', 'batch_20250913_120000_31_a1b2c3', 3, 3, 3, 100, '2025-09-13 12:00:00'),
-- å•æŠ½ç¤ºä¾‹
(31, 'single', NULL, 1, 1, 4, 100, '2025-09-13 13:00:00');
```

### C. å¸¸ç”¨æŸ¥è¯¢è¯­å¥æ¨¡æ¿

```sql
-- æŸ¥è¯¢ç”¨æˆ·çš„æ‰¹æ¬¡æŠ½å¥–å†å²
SELECT
  batch_id,
  draw_type,
  draw_count,
  MIN(created_at) as draw_time,
  COUNT(*) as actual_count,
  GROUP_CONCAT(prize_name ORDER BY draw_sequence ASC) as prizes
FROM lottery_records lr
LEFT JOIN prizes p ON lr.prize_id = p.id
WHERE lr.user_id = ? AND lr.batch_id IS NOT NULL
GROUP BY batch_id, draw_type, draw_count
ORDER BY draw_time DESC;

-- æ•°æ®å®Œæ•´æ€§æ£€æŸ¥
SELECT
  batch_id,
  draw_count,
  COUNT(*) as actual_count,
  CASE
    WHEN draw_count = COUNT(*) THEN 'COMPLETE'
    ELSE 'INCOMPLETE'
  END as status
FROM lottery_records
WHERE batch_id IS NOT NULL
GROUP BY batch_id, draw_count
HAVING draw_count != COUNT(*);
```

---

**æ–‡æ¡£ç»“æŸ**

_æœ¬æ–‡æ¡£ç‰ˆæœ¬: v1.0_  
_æœ€åæ›´æ–°: 2025-09-13 14:20:20 UTC_  
_æ–‡æ¡£ä½œè€…: åç«¯å¼€å‘å›¢é˜Ÿ_
