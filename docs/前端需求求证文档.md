# 背包物品「使用」与「核销」— 后端协作需求（后端求证版）

> **项目**: 天工小程序（餐厅积分抽奖系统 V4.0）  
> **创建时间**: 2026-02-20  
> **提出方**: 微信小程序前端  
> **求证时间**: 2026-02-20（后端数据库实际求证，Node.js 连接真实数据库验证）  
> **状态**: 后端已求证（二次校验），发现 1 个现有 BUG（rarity 字典缺失）+ 1 个文档事实性错误（FK 约束已纠正），D1-D6 全部已决策

---

## 零、后端实际技术栈和架构概况

> 以下信息均来自后端项目实际代码和数据库真实数据，不引用任何历史报告。

### 后端技术栈

| 层级 | 技术 | 版本 |
|------|------|------|
| 运行时 | Node.js | >= 20.18.0 |
| Web框架 | Express | 4.18 |
| ORM | Sequelize | 6.35 |
| 数据库 | MySQL | Sealos 云托管 |
| 缓存 | Redis (ioredis) | 5.7 |
| 认证 | JWT (jsonwebtoken) | 9.0 |
| 实时通信 | Socket.io | 4.8 |
| API版本 | V4 | 路径前缀 `/api/v4` |

### Web管理后台前端技术栈

| 层级 | 技术 | 版本 |
|------|------|------|
| 框架 | Alpine.js | 3.15 |
| 构建工具 | Vite | 6.4 |
| CSS | Tailwind CSS | 3.4 |
| 图表 | ECharts | 6.0 |
| 实时通信 | Socket.io Client | 4.8 |
| API层 | `admin/src/api/base.js` | Bearer Token 认证 |

### 后端架构模式

- **ServiceManager 模式**: 路由通过 `req.app.locals.services.getService('xxx')` 获取服务
- **TransactionManager**: 所有写操作通过 `TransactionManager.execute()` 管理事务边界
- **Event Sourcing**: `item_instance_events` 表记录物品全生命周期事件（mint/lock/unlock/transfer/use）
- **幂等控制**: 通过 `idempotency_key` 字段实现写操作幂等
- **系统字典**: `system_dictionaries` 表管理枚举值的中文显示名称
- **系统配置**: `system_configs` 表存储 JSON 格式的运行时可配置参数

---

## 一、数据库真实数据现状

### 1.1 item_instances 表（物品实例）

**表结构（实际字段）**:

| 字段 | 类型 | 说明 |
|------|------|------|
| `item_instance_id` | BIGINT PK | 物品实例ID（自增） |
| `owner_user_id` | INT | 所有者用户ID |
| `item_type` | VARCHAR(50) | 物品类型 |
| `item_template_id` | BIGINT (nullable) | 关联模板ID |
| `status` | ENUM | available/locked/transferred/used/expired |
| `meta` | JSON | 元数据（name/value/description等） |
| `locks` | JSON | 多级锁定机制 |
| `source` | VARCHAR(20) | 来源（exchange/bid_settlement/lottery） |
| `created_at` | DATETIME | 创建时间 |
| `updated_at` | DATETIME | 更新时间 |

**真实数据分布**（2026-02-20 实时查询）:

| item_type | 数量 | 占比 |
|-----------|------|------|
| voucher | 4505 | 68.7% |
| product | 1673 | 25.5% |
| NULL（数据异常） | 197 | 3.0% |
| tradable_item | 136 | 2.1% |
| prize | 48 | 0.7% |
| **合计** | **6559** | **100%** |

| status | 数量 |
|--------|------|
| available | 3570 |
| used | 1421 |
| locked | 1128 |
| transferred | 437 |
| expired | 3 |

**数据质量问题**:
- **197 条** `item_type` 为 NULL — 经查全部属于用户 31 和 135，名称为 `生命周期测试物品_*` / `挂牌生命周期测试物品_*`，确认为**测试数据**
- **5897 条**（89.9%）`item_template_id` 为 NULL，仅 662 条（10.1%）关联了模板
- **全部 6559 条** `source` 字段为 NULL（来源追溯完全缺失）
- **绝大多数物品** `meta.rarity` 为 NULL，实际都走 BackpackService 的默认值 `'common'`

### 1.2 item_templates 表（物品模板）

| 字段 | 类型 | 说明 |
|------|------|------|
| `item_template_id` | BIGINT PK | 模板ID |
| `template_code` | VARCHAR(100) UNIQUE | 模板编码 |
| `item_type` | VARCHAR(50) | 物品类型 |
| `category_code` | VARCHAR(50) | 分类编码（关联 category_defs） |
| `rarity_code` | VARCHAR(50) | 稀有度编码（关联 rarity_defs） |
| `display_name` | VARCHAR(200) | 显示名称 |
| `description` | TEXT | 描述 |
| `image_url` / `thumbnail_url` | VARCHAR(500) | 图片URL |
| `reference_price_points` | DECIMAL(10,2) | 参考积分价格 |
| `is_tradable` | BOOLEAN | 是否可交易 |
| `is_enabled` | BOOLEAN | 是否启用 |
| `meta` | JSON | 扩展元数据 |

模板 item_type 分布：collectible(1)、product(5)、voucher(10)，共 16 条。

**关键发现**：所有 16 条模板的 `meta` 字段均为 NULL。文档中提到的「模板级 `meta.use_instructions` 覆盖」策略在技术上可行（JSON 字段天然支持），但当前没有任何模板写入过 meta 数据。

### 1.3 redemption_orders 表（核销订单）

| 字段 | 类型 | 说明 |
|------|------|------|
| `redemption_order_id` | CHAR(36) PK | UUID主键 |
| `code_hash` | VARCHAR(64) UNIQUE | 核销码SHA-256哈希 |
| `item_instance_id` | BIGINT | 关联物品实例 |
| `redeemer_user_id` | INT (nullable) | 核销操作者 |
| `status` | ENUM | pending/fulfilled/cancelled/expired |
| `expires_at` | DATETIME | 过期时间（默认30天） |

真实数据（2026-02-20）：pending(641)、expired(564)、fulfilled(5)、cancelled(1)，共 1211 条。

### 1.4 system_dictionaries 中的 item_type / item_status 字典

**dict_type = 'item_type'**:

| dict_code | dict_name | dict_color | sort_order |
|-----------|-----------|------------|------------|
| `prize` | 奖品 | bg-warning | 1 |
| `product` | 商品 | bg-primary | 2 |
| `voucher` | 兑换券 | bg-success | 3 |
| `tradable_item` | 可交易物品 | bg-info | 4 |
| `service` | 服务 | bg-secondary | 5 |

**dict_type = 'item_status'**:

| dict_code | dict_name | dict_color |
|-----------|-----------|------------|
| `available` | 可用 | bg-success |
| `locked` | 已锁定 | bg-warning |
| `transferred` | 已转移 | bg-info |
| `used` | 已使用 | bg-secondary |
| `expired` | 已过期 | bg-danger |

### 1.5 rarity_defs（稀有度定义）

| rarity_code | display_name | color_hex | tier |
|-------------|-------------|-----------|------|
| common | 普通 | #9E9E9E | 1 |
| uncommon | 稀有 | #4CAF50 | 2 |
| rare | 精良 | #2196F3 | 3 |
| epic | 史诗 | #9C27B0 | 4 |
| legendary | 传说 | #FF9800 | 5 |

**🔴 关键发现：`rarity` 的 dict_type 在 system_dictionaries 中不存在**

BackpackService 代码调用 `attachDisplayNames(items, [{ field: 'rarity', dictType: 'rarity' }])`，但 system_dictionaries 表中**没有** `dict_type = 'rarity'` 的任何记录。这意味着当前 API 返回的 `rarity_display` 和 `rarity_color` 字段实际上是**空值**（displayNameHelper 找不到匹配时的降级行为）。

rarity 的中文名和颜色数据存在于 `rarity_defs` 表中，但该表与 `system_dictionaries` 是**独立的两套机制**，attachDisplayNames 只查 system_dictionaries。

**已决策（D1）**：往 system_dictionaries 补录 5 条 `dict_type='rarity'` 记录，与现有 `attachDisplayNames` 机制一致，零代码改动。

### 1.6 system_configs 现状

数据库中共 11 条配置，按 config_category 分布：

| config_category | 数量 | 说明 |
|-----------------|------|------|
| batch_operation | 6 | 批量操作限流 |
| feature | 2 | 功能开关 |
| general | 2 | 通用配置 |
| ad_system | 1 | 广告系统 |

**`backpack` 分类不存在**。本次需求需要新建 `backpack` 分类。`config_category` 字段为 VARCHAR(50) 无 ENUM 约束，直接写入即可。

### 1.7 item_instance_events 事件分布

| event_type | business_type | 数量 | 说明 |
|------------|---------------|------|------|
| mint | lottery | 2909 | 抽奖产出（主要业务来源） |
| use | redemption_use | 1309 | 核销使用 |
| transfer | market_transfer | 335 | 市场交易转移 |
| mint | test* (多种) | ~400+ | 测试数据 |
| unlock | trade_timeout_release | 5 | 交易超时解锁 |
| use | backpack_use | **2** | 背包直接使用（几乎未使用） |
| use | admin_redemption_fulfill | 1 | 管理员核销 |

**发现**：`backpack_use` 事件仅有 2 条，说明 `/use` 接口在实际业务中极少被调用，与「94.5% 物品为 product/voucher 需要走 redeem 流程」的分析一致。

---

## 二、后端现有接口现状（实际代码）

### 2.1 GET /api/v4/backpack — 查询用户背包

**BackpackService.getUserBackpack()** 返回双轨结构：

```json
{
  "success": true,
  "data": {
    "assets": [
      {
        "asset_code": "MATERIAL_001",
        "display_name": "蓝色碎片",
        "total_amount": 100,
        "frozen_amount": 10,
        "available_amount": 90
      }
    ],
    "items": [
      {
        "item_instance_id": 28738,
        "item_type": "product",
        "item_type_display": "商品",
        "name": "青菜1份",
        "status": "available",
        "status_display": "可用",
        "rarity": "common",
        "rarity_display": "",
        "rarity_color": "",
        "description": "",
        "has_redemption_code": false,
        "acquired_at": "2026-02-20T13:05:14.000Z",
        "expires_at": null
      }
    ]
  }
}
```

> **🔴 注意**：上述示例中 `rarity_display` 和 `rarity_color` 当前实际为空值，因为 system_dictionaries 缺少 `dict_type='rarity'` 的记录。执行步骤 0 修复后将正常返回 `"rarity_display": "普通"`, `"rarity_color": "#9E9E9E"`。

**实际代码逻辑** (`BackpackService._getItems()`):
- 只返回 `status = 'available'` 的物品
- `name` 从 `item_instances.meta.name` 获取，默认 `'未命名物品'`
- `rarity` 从 `item_instances.meta.rarity` 获取，默认 `'common'`（实测绝大多数物品 meta.rarity 为 null，都走默认值）
- `has_redemption_code` 通过批量查询 `redemption_orders` 表（status='pending'）得到
- 通过 `attachDisplayNames()` 附加 `_display` / `_color` 后缀：
  - `status` → dict_type `'item_status'` ✅ 正常工作
  - `item_type` → dict_type `'item_type'` ✅ 正常工作
  - `rarity` → dict_type `'rarity'` **🔴 空值**（system_dictionaries 中无此 dict_type）

### 2.2 POST /api/v4/backpack/items/:item_instance_id/use — 直接使用

**当前响应**:

```json
{
  "success": true,
  "code": "SUCCESS",
  "message": "物品使用成功",
  "data": {
    "item_instance_id": 28738,
    "status": "used",
    "is_duplicate": false
  }
}
```

**实际代码逻辑** (`routes/v4/backpack/index.js` → `ItemService.consumeItem()`):
1. 通过 `BackpackService.getItemDetail()` 验证物品存在且属于当前用户
2. 检查 `status === 'available'`
3. 调用 `ItemService.consumeItem()` → `item_instance.markAsUsed()` → status 变为 `used`
4. 通过 `ItemInstanceEvent.recordEvent()` 记录 use 事件（event_type='use', business_type='backpack_use'）
5. **当前不返回 `instructions` 字段**

### 2.3 POST /api/v4/backpack/items/:item_instance_id/redeem — 生成核销码

**当前响应**:

```json
{
  "success": true,
  "code": "SUCCESS",
  "message": "核销码生成成功，请在有效期内到店出示",
  "data": {
    "order": {
      "redemption_order_id": "uuid",
      "status": "pending",
      "expires_at": "2026-03-22T03:50:51.318+08:00"
    },
    "code": "EWB3-WE4G-F625"
  }
}
```

**实际代码逻辑** (`RedemptionService.createOrder()`):
1. 行锁查询物品实例（`SELECT ... FOR UPDATE`）
2. 幂等检查：同一物品不重复创建 pending 订单
3. 生成12位 Base32 核销码 + SHA-256 哈希存储
4. 创建 `redemption_orders` 记录（30天有效期）
5. 返回明文码（仅此一次）
6. **物品状态不变**（仍为 available，核销完成后由商家侧 `/shop/redemption/fulfill` 标记 used）

### 2.4 use 与 redeem 的实际业务区别

| 维度 | use（直接使用） | redeem（生成核销码） |
|------|----------------|---------------------|
| 场景 | 纯线上，立即生效 | O2O，到店出示核销码 |
| 物品状态变化 | available → used（立即） | available → 不变（核销后才变 used） |
| 适用类型 | 虚拟道具、服务权益、线上体验卡 | 实物商品、优惠券、需到店领取的奖品 |
| 事件记录 | event_type='use', business_type='backpack_use' | 通过 RedemptionService 管理生命周期 |

---

## 三、需求分析：哪些是谁的问题

### 3.1 后端需要做的事

| 编号 | 需求 | 优先级 | 复杂度 | 说明 |
|------|------|--------|--------|------|
| B1 | **修复 rarity 字典缺失** | **P0** | 低 | system_dictionaries 缺少 `dict_type='rarity'` 的 5 条记录，导致 `rarity_display` / `rarity_color` 当前为空值。**现有 BUG，非新需求** |
| B2 | **数据清洗：197条 null item_type** | **P1** | 低 | 全部为用户 31/135 的测试数据，直接标记 expired |
| B3 | `/use` 响应增加 `instructions` 字段 | P2 | 低 | 在路由层 response 中增加一个字段，值从 system_configs 读取 |
| B4 | 新增 2 条 system_configs 配置记录 | P2 | 低 | `backpack_use_instructions` 和 `item_type_action_rules`，config_category 为 `'backpack'`（新分类） |
| B5 | 背包列表增加 `allowed_actions` 字段 | P3 | 中 | BackpackService._getItems() 中根据 item_type 附加动作列表 |
| B6 | item_templates.meta 扩展 `use_instructions` 字段（可选） | P3 | 低 | 用于模板级别覆盖 item_type 级别的默认文案。注意：当前所有模板 meta 均为 NULL |

### 3.2 微信小程序前端需要做的事

| 编号 | 需求 | 优先级 | 说明 |
|------|------|--------|------|
| M1 | 使用 `allowed_actions` 数组控制按钮显示 | P3 | 替代当前「status=available 显示所有按钮」的逻辑 |
| M2 | 展示后端返回的 `instructions` 文案 | P2 | 已完成 Modal 展示框架，只需读取字段 |
| M3 | 字段名直接使用后端字段名 | P1 | `item_type`/`status`/`rarity`/`has_redemption_code` 等 |
| M4 | 使用 `_display` 后缀字段展示中文 | P1 | 后端已通过 attachDisplayNames 自动附加 |

### 3.3 Web管理后台前端需要做的事

| 编号 | 需求 | 优先级 | 说明 |
|------|------|--------|------|
| W1 | item-templates 管理页新增 `use_instructions` 编辑 | P3 | 在模板编辑表单的 meta JSON 中增加字段 |
| W2 | 无需 API 改动 | - | admin 已有 `/api/v4/console/item-templates` 完整 CRUD |

---

## 四、后端实施方案（基于现有技术栈）

### 4.1 方案一：`instructions` 字段（P2）

**实现思路**: 利用现有 `system_configs` 表存储 item_type → instructions 的映射，在 `/use` 路由层查询配置并返回。

**第一步：插入 system_configs 配置**

在 `system_configs` 表中新增一行：

```
config_key: 'backpack_use_instructions'
config_value: {
  "product": "请到服务台出示此记录，领取您的商品。",
  "voucher": "优惠券已激活，请在有效期内使用。",
  "prize": "奖品已确认领取，请联系工作人员安排发放。",
  "service": "服务权益已激活，请在有效期内使用。",
  "tradable_item": "物品已使用，效果已生效。"
}
config_category: 'backpack'
description: '背包物品使用后的操作指引文案（按item_type区分）'
```

**第二步：修改 `/use` 路由处理器**

文件: `routes/v4/backpack/index.js`，在 `/items/:item_instance_id/use` 的响应部分：

- 通过 `SystemConfig.getValue('backpack_use_instructions')` 获取配置（SystemConfig 模型已有此静态方法，返回解析后的 JSON 对象）
- 根据被使用物品的 `item_type` 取出对应 instructions
- 支持 `item_templates.meta.use_instructions` 优先级覆盖（如果该物品关联了模板且模板 meta 中有此字段）
- 优先级：模板级 > item_type 级 > 通用默认

修改后的响应格式：

```json
{
  "success": true,
  "code": "SUCCESS",
  "message": "物品使用成功",
  "data": {
    "item_instance_id": 28738,
    "status": "used",
    "is_duplicate": false,
    "instructions": "请到服务台出示此记录，领取您的商品。"
  }
}
```

**可复用的后端现有能力**:
- `system_configs` 表 + JSON `config_value`：`config_category` 为 VARCHAR(50)，无 ENUM 约束，直接写入 `'backpack'` 新分类。运营可通过管理后台热更新文案，无需改代码部署
- `SystemConfig` 模型已有静态方法 `SystemConfig.getValue(config_key)` 返回解析后的 JSON 对象，`SystemConfig.getProperty(config_key, property)` 获取 JSON 中的某个属性
- `item_templates.meta` JSON 字段：天然支持扩展字段，无需改表结构。但注意当前所有 16 条模板的 meta 均为 NULL，需要管理后台提供编辑入口后才能使用模板级覆盖
- `ItemInstance.item_type` + `ItemInstance.item_template_id`：已有关联关系，可以做两级查询。但仅 10.1% 的物品实例关联了模板，绝大多数物品只走 item_type 级别配置

**扩展能力**:
- 未来如果需要按 category_code 或 rarity_code 区分不同的 instructions，只需扩展 `backpack_use_instructions` 的 JSON 结构
- 可以为单个物品模板配置专属文案，覆盖 item_type 级别的默认值

### 4.2 方案二：`allowed_actions` 字段（P3）

**实现思路**: 在 `system_configs` 中定义 item_type → 允许操作的映射规则，BackpackService._getItems() 在格式化物品数据时查询配置并附加。

**第一步：插入 system_configs 配置**

```
config_key: 'item_type_action_rules'
config_value: {
  "product": ["redeem", "sell"],
  "voucher": ["redeem", "sell"],
  "prize": ["redeem"],
  "service": ["use"],
  "tradable_item": ["use", "sell"]
}
config_category: 'backpack'
description: '按物品类型定义的允许操作列表（use=直接使用/redeem=生成核销码/sell=上架交易市场）'
```

**第二步：修改 BackpackService._getItems()**

文件: `services/BackpackService.js`，在 `_getItems()` 的第2步格式化物品数据时：

- 从 `system_configs` 读取 `item_type_action_rules`（可加内存缓存，TTL 5分钟）
- 根据每个物品的 `item_type` 附加 `allowed_actions` 数组
- 同样支持模板级覆盖：`item_templates.meta.allowed_actions`

修改后的背包 items 响应：

```json
{
  "item_instance_id": 28738,
  "item_type": "product",
  "item_type_display": "商品",
  "name": "青菜1份",
  "status": "available",
  "status_display": "可用",
  "rarity": "common",
  "rarity_display": "普通",
  "description": "",
  "has_redemption_code": false,
  "allowed_actions": ["redeem", "sell"],
  "acquired_at": "2026-02-20T13:05:14.000Z",
  "expires_at": null
}
```

**可复用的后端现有能力**:
- `system_configs` 已有完整的 CRUD 管理接口（`GET/PUT /api/v4/console/settings/:category`），Web管理后台的 system-settings.js + composable/config.js 已实现按分类加载/保存
- BackpackService._getItems() 已有「批量查询 + Map 映射」模式（`redemption_orders` 的 `hasCodeMap`），添加 `allowed_actions` 完全复用相同模式
- `attachDisplayNames()` 工具函数模式可参考，为 `allowed_actions` 的每个 action 也可附加中文标签（需在 system_dictionaries 中新增 `dict_type='backpack_action'`）

**扩展能力**:
- 新增 item_type 时只需在 `item_type_action_rules` 的 JSON 中加一行，无需改代码
- 可以结合物品状态做动态判断（如 locked 状态时过滤掉 sell 操作）

---

## 五、微信小程序前端适配方案

### 5.1 直接使用后端字段名（P1，无映射）

小程序前端代码应直接使用后端返回的字段名，不做任何映射转换：

| 后端返回字段 | 用途 | 注意 |
|-------------|------|------|
| `item_instance_id` | 唯一标识，用于所有操作接口的路由参数 | BIGINT，小程序中作为 Number 使用 |
| `item_type` | 物品类型原始值 | 值为 product/voucher/prize/tradable_item/service |
| `item_type_display` | 物品类型中文名 | 直接展示，无需前端维护映射表 |
| `name` | 物品名称 | 来自 `meta.name`，后端已提取 |
| `status` | 物品状态原始值 | available/locked/transferred/used/expired |
| `status_display` | 物品状态中文名 | 直接展示 |
| `rarity` | 稀有度原始值 | common/uncommon/rare/epic/legendary |
| `rarity_display` | 稀有度中文名 | 直接展示 |
| `has_redemption_code` | 是否已有核销码 | Boolean，控制「核销码」按钮状态 |
| `allowed_actions` | 允许的操作列表（方案二完成后） | 字符串数组，如 `["redeem", "sell"]` |
| `acquired_at` | 获取时间 | ISO 8601 格式 |
| `expires_at` | 过期时间 | 可能为 null（无过期） |

### 5.2 按钮显示策略

**方案二（`allowed_actions`）上线前**：维持现有逻辑

**方案二上线后**：

```
if allowed_actions 包含 "use"    → 显示「使用」按钮
if allowed_actions 包含 "redeem" → 显示「核销码」按钮
if allowed_actions 包含 "sell"   → 显示「上架」按钮
```

### 5.3 使用成功后展示 instructions

**方案一上线后**：`/use` 响应中的 `data.instructions` 字段直接作为 Modal 内容展示。

---

## 六、Web管理后台前端适配方案

### 6.1 已完全对齐后端的功能

Web管理后台技术栈：Alpine.js 3.15 + Vite 6.4 + Tailwind CSS 3.4，采用 composable + mixin 模式。

`admin/src/api/asset.js` 中的接口已与后端 V4 API 路径完全一致：

- `GET /api/v4/console/item-templates` — 模板列表（已有，含筛选/分页）
- `POST /api/v4/console/item-templates` — 创建模板（已有）
- `PUT /api/v4/console/item-templates/:id` — 更新模板（已有）
- `DELETE /api/v4/console/item-templates/:id` — 删除模板（已有）
- `GET /api/v4/console/item-instances` — 物品实例查询（已有）

### 6.2 需要新增的功能

| 需求 | 页面 | 工作量 | 说明 |
|------|------|--------|------|
| 模板编辑表单增加 `use_instructions` 输入框 | `admin/src/modules/system/pages/item-templates.js`（566行） | 小 | 现有表单用 `createCrudMixin()` 模式，在 form 对象中增加字段即可 |
| system_configs 管理页可编辑 backpack 相关配置 | `admin/src/modules/system/pages/system-settings.js`（396行） | 中 | 现有页面管理 5 个分类（basic/points/notification/security/marketplace），需新增 `backpack` 分类 tab |

**system-settings.js 现有分类**:
- `basic` — 系统名称、客服、维护模式
- `points` — 抽奖消耗、签到积分、预算比例
- `notification` — 短信、邮件、APP 推送
- `security` — 登录限制、密码策略、API限流
- `marketplace` — 挂牌数量、过期天数、价格阈值

新增 `backpack` 分类后，运营可在管理后台直接编辑 `backpack_use_instructions` 和 `item_type_action_rules` 配置。

该页面使用 composable 模式（`admin/src/modules/system/composables/config.js`，337行），通过 `GET /api/v4/console/settings/:category` 按分类加载配置。新增分类只需：
1. 后端 system_configs 表写入 `config_category = 'backpack'` 的记录
2. 前端 system-settings.js 的分类列表中增加 `backpack` 选项

### 6.3 无需改动的部分

- API 层（`admin/src/api/base.js`）：Bearer Token + native fetch 封装，不变
- 核销订单管理（`admin/src/modules/operations/pages/redemption-management.js`）：已完整
- 物品实例管理（`admin/src/modules/asset/pages/asset-management.js`）：已完整
- API 版本前缀（`API_PREFIX = '/api/v4'`）：与后端一致

---

## 七、后端执行步骤

### 步骤 0（P0）：修复 rarity 字典缺失

**问题**：BackpackService 调用 `attachDisplayNames(items, [{ field: 'rarity', dictType: 'rarity' }])`，但 system_dictionaries 中不存在 `dict_type='rarity'` 的记录，导致 `rarity_display` 和 `rarity_color` 为空值。这是**已有 BUG**。

**执行方式**：Sequelize migration（与数据清洗同一个迁移文件）

```sql
INSERT INTO system_dictionaries (dict_type, dict_code, dict_name, dict_color, sort_order, is_enabled, version, created_at, updated_at)
VALUES
  ('rarity', 'common', '普通', '#9E9E9E', 1, 1, 1, NOW(), NOW()),
  ('rarity', 'uncommon', '稀有', '#4CAF50', 2, 1, 1, NOW(), NOW()),
  ('rarity', 'rare', '精良', '#2196F3', 3, 1, 1, NOW(), NOW()),
  ('rarity', 'epic', '史诗', '#9C27B0', 4, 1, 1, NOW(), NOW()),
  ('rarity', 'legendary', '传说', '#FF9800', 5, 1, 1, NOW(), NOW());
```

**可复用**：数据直接从 `rarity_defs` 表的 `display_name` 和 `color_hex` 字段对齐，保证两套机制的显示名称一致。

**影响范围**：
- 修改文件：新增 1 个 migration 文件
- 涉及表：`system_dictionaries`（插入 5 条）
- 受益接口：`GET /api/v4/backpack`、`GET /api/v4/backpack/items/:id` — `rarity_display`/`rarity_color` 恢复正常

**归属：后端数据库问题（已有 BUG 修复）**

### 步骤 1（P1）：数据清洗 — DELETE 测试数据 + 约束加固

**问题**：197 条 `item_type` 为 NULL 的记录，全部为用户 31/135 的测试数据。

**决策结论**：直接 DELETE（D2 决策）+ NOT NULL 无 DEFAULT（D3 决策）

**🔴 二次校验发现**：存在 3 个 FK 约束（DELETE_RULE = RESTRICT），必须先级联删除子表记录。197 条 NULL 记录关联了 69 条 events 和 6 条 market_listings。

**执行方式**：Sequelize migration（注意执行顺序）

```sql
-- 1. 先删除子表记录（FK RESTRICT 要求先删子表）
-- 1a. 删除 item_instance_events 中关联的 69 条事件
DELETE e FROM item_instance_events e
JOIN item_instances i ON e.item_instance_id = i.item_instance_id
WHERE i.item_type IS NULL;

-- 1b. 删除 market_listings 中关联的 6 条挂牌
DELETE m FROM market_listings m
JOIN item_instances i ON m.offer_item_instance_id = i.item_instance_id
WHERE i.item_type IS NULL;

-- 1c. redemption_orders 无关联记录（0 条），无需处理

-- 2. 再删除 197 条测试数据主表记录
DELETE FROM item_instances WHERE item_type IS NULL;

-- 3. 加 NOT NULL 约束，无 DEFAULT（严格模式）
ALTER TABLE item_instances MODIFY COLUMN item_type VARCHAR(50) NOT NULL;
```

**归属：后端数据库问题**

**D6 已决策：级联删除**。删除 69 条 events + 6 条 market_listings + 197 条 item_instances，共 272 条测试数据。全部为用户 31/135 的生命周期测试物品，不影响正式业务数据

### 步骤 1.5（P1）：source 字段回填 + 约束加固

**决策结论**：回填历史 source + 加约束（D4 决策）

**执行方式**：在同一个 migration 中

```sql
-- 1. 通过 item_instance_events 的 mint 事件回填 source
UPDATE item_instances i
JOIN item_instance_events e 
  ON i.item_instance_id = e.item_instance_id AND e.event_type = 'mint'
SET i.source = CASE
  WHEN e.business_type = 'lottery' THEN 'lottery'
  WHEN e.business_type LIKE 'test%' THEN 'test'
  WHEN e.business_type = 'stress_test' THEN 'test'
  ELSE 'unknown'
END
WHERE i.source IS NULL;

-- 2. 兜底：没有 mint 事件的记录标记为 unknown
UPDATE item_instances SET source = 'unknown' WHERE source IS NULL;

-- 3. 加 NOT NULL 约束
ALTER TABLE item_instances MODIFY COLUMN source VARCHAR(20) NOT NULL DEFAULT 'unknown';
```

**归属：后端数据库问题**

### 步骤 2（P2）：新增 system_configs 配置

通过同一个 Sequelize migration 插入两条配置：

```sql
-- 1. 使用操作指引文案
INSERT INTO system_configs (config_key, config_value, description, config_category, is_active, created_at, updated_at)
VALUES (
  'backpack_use_instructions',
  '{"service": "服务已激活，有效期内可享受对应权益。", "tradable_item": "道具已使用，效果已生效。", "product": "请到服务台出示核销码，领取您的商品。", "voucher": "请到服务台出示核销码使用。", "prize": "恭喜中奖！请到服务台出示核销码领取奖品。"}',
  '背包物品使用后的操作指引文案（按item_type区分）',
  'backpack',
  1,
  NOW(), NOW()
);

-- 2. 物品类型允许操作规则
INSERT INTO system_configs (config_key, config_value, description, config_category, is_active, created_at, updated_at)
VALUES (
  'item_type_action_rules',
  '{"product": ["redeem", "sell"], "voucher": ["redeem", "sell"], "prize": ["redeem"], "service": ["use"], "tradable_item": ["use", "sell"]}',
  '按物品类型定义的允许操作列表（use=直接使用/redeem=生成核销码/sell=上架交易市场）',
  'backpack',
  1,
  NOW(), NOW()
);
```

**影响范围**：
- 修改文件：同一个 migration 文件（合并步骤 0/1/1.5/2 所有数据变更）
- 涉及表：`system_configs`（插入 2 条）
- `config_category = 'backpack'` 是新增分类

**归属：后端数据库问题**

### 步骤 3（P2）：修改 `/use` 路由返回 instructions

**修改文件**：`routes/v4/backpack/index.js`

在 `POST /items/:item_instance_id/use` 路由的 `res.apiSuccess()` 之前：

1. 直接使用 `SystemConfig.getValue('backpack_use_instructions')`（SystemConfig 模型的静态方法，无需通过 ServiceManager，返回解析后的 JSON 对象）
2. 用物品的 `item_type` 从配置 JSON 中取出对应 instructions
3. 如果物品有 `item_template_id`，查询模板实例的 `meta.use_instructions`，不为空则覆盖
4. 附加到响应 data 中

**可复用**：
- `SystemConfig.getValue(config_key)` — 静态方法，直接 `require('../models').SystemConfig` 调用，返回 JSON
- `SystemConfig.getProperty(config_key, property, defaultValue)` — 获取 JSON 中某个键的值
- 也可通过 ServiceManager 获取：`req.app.locals.services.getService('system_config')` → SystemConfigService（注册名为 `system_config`）

**影响范围**：
- 修改文件：`routes/v4/backpack/index.js`（仅修改 `/use` 路由处理器，约 +15 行）
- 不影响其他路由

**归属：后端代码问题**

### 步骤 4（P3）：修改 BackpackService._getItems() 返回 allowed_actions

**修改文件**：`services/BackpackService.js`

在 `_getItems()` 方法中，第 3 步批量查询核销码之后、第 4 步 attachDisplayNames 之前，新增：

1. 从 `SystemConfig.getValue('item_type_action_rules')` 读取配置
2. 建议加内存缓存（5 分钟 TTL），避免每次请求都查数据库。参考项目中 `services/UnifiedLotteryEngine/compute/config/StrategyConfig.js` 的缓存模式：`CONFIG_CACHE_TTL = parseInt(process.env.STRATEGY_CONFIG_CACHE_TTL) || 5 * 60 * 1000`
3. 为每个 item 根据 `item_type` 附加 `allowed_actions` 数组
4. 如果物品有 `item_template_id`，查询模板 `meta.allowed_actions` 做覆盖（当前所有 16 条模板 meta 为 NULL，此逻辑不会生效但为未来预留）

**可复用**：
- BackpackService._getItems() 已有类似的「批量查询 + Map 映射」模式（`_getItems()` 第 3 步的 `hasCodeMap` 模式 — 批量查 redemption_orders 然后用 `Map.set()` / `Map.has()` 映射）
- `_getAssets()` 第 2 步的 `assetTypeMap` 模式（批量查 MaterialAssetType 然后 Map 映射）
- SystemConfig 缓存模式参考 `StrategyConfig.js` 的 `DynamicConfigLoader`

**影响范围**：
- 修改文件：`services/BackpackService.js`（约 +30 行）
- 影响接口：`GET /api/v4/backpack` 的 items 数组增加 `allowed_actions` 字段

**归属：后端代码问题**

### 步骤 5（P3）：Web管理后台 — item-templates 编辑页增加 meta 字段编辑

**修改文件**：`admin/src/modules/system/pages/item-templates.js`

在现有模板编辑表单（form 对象）中增加：
- `use_instructions`（文本输入框）— 保存时写入 `meta.use_instructions`
- `allowed_actions`（多选下拉）— 保存时写入 `meta.allowed_actions`

**可复用**：
- 现有 `createCrudMixin()` 提供统一的 CRUD 操作
- API 端点 `PUT /api/v4/console/item-templates/:id` 已支持更新 meta 字段（JSON 合并写入）

**归属：Web管理后台前端问题**

### 步骤 6（P3）：Web管理后台 — system-settings 增加 backpack 分类

**修改文件**：`admin/src/modules/system/pages/system-settings.js` + `admin/src/modules/system/composables/config.js`

在分类列表中增加 `backpack` 选项。

**二次校验确认**：分类列表是**前端硬编码**的，位于 `admin/src/modules/system/composables/config.js` 第 18-24 行的 `CATEGORY_DISPLAY` 对象：

```
const CATEGORY_DISPLAY = {
  basic: { name: '基础设置', icon: '⚙️', description: '系统名称、客服信息、维护模式' },
  points: { name: '积分设置', icon: '🪙', description: '抽奖消耗、签到积分、预算比例' },
  notification: { name: '通知设置', icon: '🔔', description: '短信、邮件、APP推送开关' },
  security: { name: '安全设置', icon: '🔐', description: '登录限制、密码策略、API限流' },
  marketplace: { name: '市场设置', icon: '🏪', description: '上架数量、过期天数、价格阈值' }
}
```

需新增一行：`backpack: { name: '背包配置', icon: '🎒', description: '使用引导文案、物品操作规则' }`

`loadCategoryConfig(category)` 方法（第 117 行）已支持任意分类名参数，会调用 `GET /api/v4/console/settings/:category` 按分类加载。新增分类后此方法无需改动。

**归属：Web管理后台前端问题**

---

## 八、行业方案对比分析

> 以下调研覆盖大厂 O2O、游戏公司、SaaS 平台、二手交易平台四大类，对比各自在 allowed_actions、instructions、数据清洗三个维度的设计差异，最终给出本项目的推荐方案。

### 8.1 allowed_actions：各家怎么定义「物品能做什么操作」

#### A. 大厂 O2O 模式（美团、大众点评）

**核心逻辑**: 操作由消费场景决定，不由 item_type 单独决定。

- 团购券/到店优惠券 → 只能「到店核销」（redeem），不能线上直接使用
- 外卖代金券 → 只能「在线下单抵扣」（use），不能到店核销
- 美团将「线上使用」和「线下核销」视为两种完全不同的产品形态，API 和前端流程完全分开
- 操作列表由券的类型固定绑定，运营不可随意切换

**适合场景**: 业务明确、操作不重叠、不需要灵活配置。

#### B. 游戏公司模式（Steam / Valve、腾讯游戏、米哈游）

**核心逻辑**: 操作在物品定义（模板）层面用布尔标志声明。

**Steam Inventory Schema**:
- 每个 ItemDef（物品定义）有 `tradable`（可交易）和 `marketable`（可上架市场）两个布尔属性
- 支持 `exchange` recipes（物品合成/分解）
- 操作能力由模板定义一次，所有同模板的实例继承
- 运营/开发者可以随时修改模板属性，全局生效

**腾讯 QQ 游戏背包**:
- 物品操作：使用、复制CDKey、赠送
- 不能在背包中使用的道具需到游戏内使用
- 操作由物品类别决定（装备/补给/材料/携带），写在类别属性中

**云风（网易级架构师）的背包系统设计**:
- 定义标准操作集：CONSUME（消耗）、SPLIT（拆分）、EXCHANGE（交换）、TRADEIN/TRADEOUT（交易出入）
- 每种物品类型声明自己支持哪些操作
- 解耦核心：副本、任务、商城等系统不互相依赖，统一调用物品操作接口

**适合场景**: 物品类型多、同类型不同模板需要差异化操作、长期运营需要灵活调整。

#### C. 二手交易平台模式（闲鱼、转转）

**核心逻辑**: 操作由当前状态动态计算，不固定绑定类型。

- 闲鱼的订单系统是"多业务、多状态、多操作"架构
- 同一个物品在不同状态下可用的操作不同（如"已下单未付款"→ 可"付款"或"关闭"）
- 操作列表通过渲染接口动态下发，服务端根据当前状态实时计算
- 底层用状态机驱动，每次状态变更重新计算可用操作

**适合场景**: 复杂交易流程、多种逆向流程（退款/退货/仲裁）、操作随状态剧烈变化。

#### D. SaaS 优惠券平台模式（Voucherify 等）

**核心逻辑**: 验证（validation）和兑换（redemption）完全分离，通过规则引擎控制。

- validation API 负责判断"这张券能不能用"（资格、时间窗、预算、限额、防欺诈）
- redemption API 负责执行"用掉这张券"
- 操作不是简单的 allowed/disallowed，而是通过一套完整的规则引擎评估
- 运营通过 Dashboard 配置规则，无需改代码

**适合场景**: 大规模营销活动、复杂的优惠叠加规则、需要精细化风控。

#### E. 游戏虚拟物品交易平台（Roblox）

**核心逻辑**: 物品分为「可重复购买的消耗品」和「一次性永久道具」两大类。

- Developer Products（消耗品）：可反复购买使用，如金币、弹药
- Passes（永久道具）：一次性购买永久生效，如特殊武器
- Marketplace 物品：有 `tradable` 属性控制是否可上架交易
- 经济系统要求追踪：谁买了什么、什么行为产出货币、赚取/购买货币比例、货币如何花出

**适合场景**: 虚拟经济体系、需要控制通胀/通缩、长期运营。

#### **各方案对比总结**

| 方案 | 代表公司 | 操作定义层级 | 灵活性 | 复杂度 | 适合规模 |
|------|---------|-------------|--------|--------|---------|
| 类型固定绑定 | 美团 | item_type → 固定操作 | 低 | 低 | 业务明确的小型项目 |
| 模板属性声明 | Steam、腾讯游戏 | item_template → 布尔标志 | 高 | 中 | 物品种类多的中大型项目 |
| 状态动态计算 | 闲鱼 | 当前 status → 实时计算 | 极高 | 高 | 复杂交易链路 |
| 规则引擎驱动 | Voucherify | 规则+条件 → 评估结果 | 极高 | 极高 | 大规模营销/SaaS |
| 混合模式（类型默认+模板覆盖） | 多数游戏公司 | item_type 默认 + template 覆盖 | 高 | 中低 | 需要平衡灵活性和简洁性的项目 |

#### **本项目推荐方案：混合模式（类型默认 + 模板覆盖）**

**理由**:
1. 你的项目是餐厅积分抽奖系统，本质是 **O2O 场景 + 虚拟道具混合体**
2. 大部分物品（product 25.5% + voucher 68.7% = 94.2%）需要到店核销（redeem），符合美团模式
3. 少部分物品（tradable_item 2.1% + service 0%）是纯线上，需要直接使用（use）
4. 后端已有 `system_configs`（类型级默认）和 `item_templates.meta`（模板级覆盖），天然支持混合模式
5. 未来上线后如果某个模板需要特殊操作（例如某款限量商品允许交易），只需改模板 meta，不用改代码
6. 项目未上线，不需要闲鱼那样的复杂状态机；也不需要 Voucherify 那样的规则引擎

**最终 allowed_actions 规则**:

| item_type | allowed_actions | 对标行业实践 |
|-----------|----------------|-------------|
| product（商品） | `["redeem", "sell"]` | 美团团购券模式：实物必须到店核销领取 |
| voucher（兑换券） | `["redeem", "sell"]` | 美团优惠券模式：到店出示核销 |
| prize（奖品） | `["redeem"]` | 抽奖奖品不可交易（防刷奖倒卖） |
| service（服务） | `["use"]` | 腾讯游戏模式：线上权益直接激活 |
| tradable_item（可交易物品） | `["use", "sell"]` | Steam 模式：虚拟道具可用可交易 |

product 和 voucher 不支持直接「使用」，因为参考美团/大众点评：**需要到店领取的物品，线上点"使用"没有实际意义**，用户点了只会困惑"使用完了但东西在哪？"。正确流程是生成核销码 → 到店出示 → 商家扫码核销。

prize 不允许交易，因为参考游戏行业通行做法：**抽奖获得的奖品如果允许交易，会产生刷号倒卖问题**。如果未来需要开放，只需改 system_configs 配置即可。

支持模板级覆盖：如果某个特殊商品模板需要额外支持 `use` 操作，在 `item_templates.meta.allowed_actions` 中覆盖即可，不影响其他同类型物品。

### 8.2 instructions 文案：各家怎么引导用户

#### 行业实践对比

| 平台 | 使用/核销后引导方式 | 文案风格 |
|------|-------------------|---------|
| 美团 | "请到店出示二维码" + 门店地址 + 有效期 | 极简、行动导向 |
| 支付宝（蚂蚁森林/芭芭农场） | "能量已收取" / "肥料已使用" | 结果确认，无后续引导 |
| Steam | 物品描述中写明用途，使用后无额外弹窗 | 物品自描述 |
| 腾讯游戏 | "道具已使用，效果持续X分钟" | 结果+效果说明 |
| Voucherify | 由商家自定义 redemption message | 完全可配置 |

#### 本项目的 instructions 方案

参考美团的极简行动导向风格，结合 Voucherify 的可配置思路：

| item_type | instructions 文案 | 设计依据 |
|-----------|------------------|---------|
| product | 请到服务台出示核销码，领取您的商品。 | 美团模式：明确告知去哪、做什么 |
| voucher | 请到服务台出示核销码使用。 | 美团模式：简明行动指引 |
| prize | 恭喜中奖！请到服务台出示核销码领取奖品。 | 增加情感化表达 |
| service | 服务已激活，有效期内可享受对应权益。 | 腾讯游戏模式：确认结果+有效期 |
| tradable_item | 道具已使用，效果已生效。 | 腾讯游戏模式：结果确认 |

注意：product/voucher/prize 实际上**不应走 `/use` 接口**（它们的 allowed_actions 不包含 `use`），所以它们的 instructions 主要是容错场景。正常流程下这三种类型只会走 `/redeem` 接口，核销码 API 的响应已经包含完整信息。

**真正需要 instructions 的只有 service 和 tradable_item**（它们走 `/use` 接口）。

### 8.3 null item_type 数据清洗：各家怎么处理脏数据

#### 行业实践对比

| 策略 | 代表 | 做法 | 适合场景 |
|------|------|------|---------|
| 严格清洗+约束加固 | Oracle、AWS | 查明来源→修复/归档→加 NOT NULL 约束 | 未上线/可停机维护 |
| 软删除+兜底 | 闲鱼、美团 | 异常数据标记为不可用，代码层对 null 做兜底 | 已上线/不能停机 |
| 归档审计 | 金融系统 | 移到归档表，保留审计痕迹，主表加约束 | 合规要求高 |
| COALESCE 兜底 | 通用 | SQL/代码层用默认值填充 null | 临时方案 |

#### 本项目推荐：严格清洗+约束加固（选项 A + 加固）

**理由**: 项目未上线，现在是修复数据质量的最佳时机，上线后再改成本翻倍。

**执行步骤**:

1. 已查明：197 条 NULL 记录全部属于用户 31 和 135（测试账号），名称为 `生命周期测试物品_*`，确认为测试数据
2. 直接 DELETE 197 条（项目未上线，清理测试数据是标准操作；item_instance_events 保留审计记录）
3. 清洗完成后，对 `item_type` 字段加 NOT NULL 无 DEFAULT 约束（严格模式，Sequelize migration）
4. source 字段：通过 item_instance_events 的 mint 事件 business_type 回填历史 source，然后加 NOT NULL 约束

### 8.4 决策 4：保底进度 API

已确认：拆为独立需求文档，不在本次 backpack 需求中实现。

---

## 九、技术栈兼容性评估

### 9.1 后端项目：兼容性评估

| 现有机制 | 本次需求使用方式 | 兼容性 | 备注 |
|----------|-----------------|--------|------|
| system_configs (JSON) | 存储 instructions 文案和 action 规则 | ✅ 完全复用 | config_category 为 VARCHAR(50)，直接写入 `'backpack'` |
| item_templates.meta (JSON) | 模板级 instructions/actions 覆盖 | ⚠️ 需初始化 | 当前所有 16 条模板 meta 均为 NULL，需要在管理后台提供编辑入口 |
| BackpackService._getItems() | 附加 allowed_actions 字段 | ✅ 扩展现有逻辑 | 参考已有的 `hasCodeMap` 批量映射模式 |
| attachDisplayNames() | 附加 _display/_color 后缀 | ⚠️ 需修复 | `rarity` 的 dict_type 缺失，需先执行步骤 0 补录字典 |
| TransactionManager | /use 接口的事务管理 | ✅ 已在使用 | — |
| ItemInstanceEvent | 事件溯源记录 | ✅ 已在使用 | — |
| ServiceManager 模式 | 获取 system_configs 配置服务 | ✅ 完全复用 | **已确认注册名**：`system_config` → SystemConfigService，`backpack` → BackpackService，`asset_item` → ItemService，`redemption_order` → RedemptionService |
| SystemConfig 模型 | `getValue(config_key)` / `getProperty(config_key, prop)` 静态方法 | ✅ 完全复用 | 直接 `const { SystemConfig } = require('../models')` 然后 `SystemConfig.getValue('backpack_use_instructions')` |

**不需要**：新建表、新建模型、新建服务类。
**需要**：1 个 migration 文件（合并步骤 0/1/1.5/2 的数据变更，注意步骤 1 需先级联删除 69 条 events + 6 条 market_listings）+ 修改 2 个后端文件 + 修改 2 个前端文件。

### 9.2 Web管理后台前端：兼容性评估

| 现有机制 | 本次需求使用方式 | 兼容性 | 备注 |
|----------|-----------------|--------|------|
| item-templates 管理页（566行） | 增加 use_instructions / allowed_actions 编辑 | ✅ 扩展现有表单 | 使用 `createCrudMixin()` 模式 |
| system-settings 管理页（396行） | 增加 backpack 分类 tab | ⚠️ 需扩展 | 现有 5 个分类，需在 `CATEGORY_DISPLAY` 对象增加第 6 个 |
| composable/config.js（337行） | 按分类动态加载配置 | ✅ 完全复用 | `loadCategoryConfig(category)` 第 117 行已支持任意分类名，**仅需修改 `CATEGORY_DISPLAY` 对象**（第 18-24 行）新增 `backpack` 条目 |
| Alpine.js 响应式 | 表单字段绑定 | ✅ 完全兼容 | — |
| API 层 (asset.js) | PUT /api/v4/console/item-templates/:id | ✅ 已有 | — |
| API 层 (system/) | GET/PUT /api/v4/console/settings/:category | ✅ 已有 | — |

### 9.3 微信小程序前端：直接适配

| 改动项 | 工作量 |
|--------|--------|
| 使用后端字段名（去掉前端映射） | 一次性搜索替换 |
| 根据 allowed_actions 控制按钮 | 简单条件判断 |
| 展示 instructions | 已有 Modal 框架 |

---

## 十、最终决策结果与优先级总结

### 决策项分析与最终结论

#### D1：rarity 字典缺失修复方式

**最终结论：选 A — 补录 5 条 system_dictionaries 记录**

| 方案 | 行业参考 | 工作量 | 风险 | 长期维护成本 |
|------|---------|--------|------|------------|
| A. 补录字典记录 | 美团（品类表和标签表分离）、腾讯游戏（品质定义和 i18n 分离）、Steam（ItemDef 和 localization 分离） | 5 条 SQL | 零（不改代码） | 极低（新增稀有度时同步新增字典，极低频事件） |
| B. 改代码查 rarity_defs | 无大厂采用此模式 | 改 displayNameHelper 核心工具函数 | 中（该函数被全系统 50+ 处调用） | 高（引入特殊分支，增加维护者认知负担） |

**理由**：`rarity_defs` 管业务逻辑（tier 层级、掉落权重），`system_dictionaries` 管 UI 展示（中文名、颜色 class），这是**职责分离**，5 条展示标签的「重复」不是技术债务。所有大厂都把业务属性表和 UI 标签表分开维护。

#### D2：197 条 NULL item_type 测试数据

**最终结论：选 B — 直接 DELETE**

| 方案 | 行业参考 | 数据影响 | 长期影响 |
|------|---------|---------|---------|
| A. 标记 expired | 金融系统（合规审计要求） | 197 条永久留在表中 | 污染统计/报表/筛选，`expired` 语义被滥用 |
| B. 直接 DELETE | 美团（上线前清理测试数据）、游戏公司（测试服清库后上正式服）、Steam（沙盒环境和生产隔离） | 干净 | 零长期成本 |

**理由**：
1. 项目未上线，清理测试数据是标准操作（美团/腾讯游戏/Steam 全都这么做）
2. `expired` 是有业务含义的状态（物品过期），不应用来标记「脏数据」

**🔴 二次校验纠正**：原文档声称"item_instance_events 与 item_instances 之间无外键约束，DELETE 无阻塞"，经 2026-02-20 实际数据库校验，**此结论错误**。实际存在 3 个 FK 约束（全部为 `DELETE_RULE = RESTRICT`）：

| 子表 | FK 约束名 | DELETE_RULE | NULL item_type 关联记录数 |
|------|----------|-------------|------------------------|
| `item_instance_events` | `item_instance_events_ibfk_1` | RESTRICT | **69 条**（全部为 `transfer/market_transfer` 事件） |
| `market_listings` | `fk_market_listings_offer_item_instance_id` | RESTRICT | **6 条** |
| `redemption_orders` | `redemption_orders_ibfk_1` | RESTRICT | 0 条 |

**影响**：不能直接 `DELETE FROM item_instances WHERE item_type IS NULL`，FK RESTRICT 会阻塞。必须先删除子表记录。详见步骤 1 修正后的 SQL

#### D3：item_type NOT NULL 约束的默认值

**最终结论：选 A — NOT NULL 无 DEFAULT（严格模式）**

| 方案 | 行业参考 | 安全性 | 适用场景 |
|------|---------|--------|---------|
| A. NOT NULL 无 DEFAULT | Stripe（支付枚举必填）、美团（券类型必填）、Steam（ItemDef type 必填） | 高（错误立即暴露） | 影响业务流程的关键字段 |
| B. DEFAULT 'product' | 小公司 MVP、快速迭代项目 | 低（错误被掩盖） | 仅影响展示的非关键字段 |

**理由**：`item_type` 决定了 `allowed_actions`（用户看到的操作按钮）和核销/使用流程分流。DEFAULT 'product' 意味着一个本该是 `service` 的物品会被静默归为 `product` → 用户看到「核销码」按钮而非「使用」按钮 → **静默错误比报错更危险**。

**前提条件**：需在 DELETE 197 条测试数据之后再 ALTER TABLE 加约束，否则 NULL 行会阻塞 DDL。执行顺序：DELETE → ALTER TABLE。

#### D4：source 字段 6559 条全 NULL

**最终结论：选 B — 回填 + 约束加固**

| 方案 | 行业参考 | 一次性成本 | 长期收益 |
|------|---------|-----------|---------|
| A. 不回填仅止损 | 小公司（先跑起来再说） | 低 | 低（source 字段加不了 NOT NULL 约束，未来还会有 NULL 数据） |
| B. 回填 + NOT NULL 约束 | 美团（来源追溯是核心能力）、腾讯游戏（经济系统追踪产出来源）、Stripe（交易 source 必填） | 中（一条 UPDATE JOIN SQL + 映射逻辑） | 高（彻底消灭技术债务，上线后永远不会再出现 NULL） |

**理由**：
1. 你说「愿意一次性投入大量成本」，回填实际工作量很低（一条 SQL）
2. 回填完才能加 NOT NULL 约束，不回填 = 约束加不上 = 未来还会有 NULL
3. item_instance_events 的 `event_type='mint'` + `business_type` 提供了清晰的回填数据源

**回填映射规则**：

| events.business_type | → source 值 | 数量 |
|---------------------|-------------|------|
| `lottery` | `lottery` | 2909 |
| `test*`（所有 test 开头的变体） | 这些记录在 D2 中已被 DELETE | ~400+ |
| 其他/无 mint 事件 | `unknown` | 少量 |

#### D5：Web管理后台 backpack 分类 tab

**最终结论：选 A — 新增 backpack 分类 tab**

| 方案 | 行业参考 | 工作量 | 长期收益 |
|------|---------|--------|---------|
| A. 新增 tab | 美团（券管理专属 tab）、Shopify（Settings 20+ 分类 tab）、Voucherify（Dashboard 按业务域分模块） | 极小（前端分类数组加一项） | 运营自助编辑配置 |
| B. 不新增 | 小公司（所有配置混在一起） | 零 | 运营找开发改数据库 |

**理由**：`admin/src/modules/system/composables/config.js` 第 117 行的 `loadCategoryConfig(category)` 已支持任意分类名参数，前端只需在第 18 行的 `CATEGORY_DISPLAY` 对象加一行。

#### D6：测试数据级联删除范围（二次校验新增）

**⚠️ 需用户拍板**

| 方案 | 影响范围 | 数据安全性 | 实现复杂度 |
|------|---------|-----------|-----------|
| A. 级联删除（推荐） | 删除 item_instances(197) + events(69) + listings(6) = 共 272 条 | 高（全部为用户 31/135 的测试数据，不影响正式业务） | 低（3 条 DELETE SQL） |
| B. 先 DROP FK → DELETE → 重建 FK | 仅删除 item_instances(197)，保留 events/listings 中的孤儿记录 | 中（events 中留下了指向已删除 item 的记录，查询可能报错） | 中（需重建约束） |
| C. 不删除，改为加 DEFAULT 兜底 | 0 条删除 | 低（197 条脏数据永久存在） | 低 |

**已决策：选 A — 级联删除**。理由：这 69 条 events 全部是 `transfer/market_transfer` 类型（测试市场转让），6 条 market_listings 也是测试挂牌。项目未上线，清除所有测试痕迹是最干净的方案。方案 B 会留下孤儿记录，长期维护成本更高。

### 全部决策（含 D1-D6）

| 决策项 | 最终结论 | 行业依据 |
|--------|---------|---------|
| D1: rarity 字典修复 | 补录 5 条 system_dictionaries 记录（零代码改动） | 美团/腾讯/Steam：业务属性表和 UI 标签表职责分离 |
| D2: 197 条测试数据 | 直接 DELETE | 美团/游戏公司/Steam：上线前清理测试数据是标准操作 |
| D3: item_type NOT NULL | 无 DEFAULT，严格模式 | Stripe/美团/Steam：影响业务流程的枚举字段不能有默认值 |
| D4: source 字段回填 | 通过 events 回填 + NOT NULL 约束 | 美团/腾讯游戏：来源追溯是经济系统基础能力 |
| D5: 管理后台 backpack tab | 新增 backpack 分类 | 美团/Shopify/Voucherify：运营后台按业务域分 tab |
| D6: 测试数据级联删除范围 | 级联删除（先删 69 events + 6 listings，再删 197 instances，共 272 条） | 项目未上线，清除所有测试痕迹最干净 |
| allowed_actions 规则 | 混合模式：system_configs 类型默认 + item_templates.meta 模板覆盖 | Steam 模板属性 + 美团类型绑定的混合 |
| product/voucher 不支持 use | 确认：只支持 redeem + sell | 美团 O2O：实物必须到店核销 |
| prize 不允许交易 | 确认：只支持 redeem | 游戏行业：防刷号倒卖 |
| instructions 文案 | 行动导向极简风格，可通过管理后台热更新 | 美团极简引导 + Voucherify 可配置 |
| 保底进度 API | 拆为独立需求文档 | 职责分离 |

### 实施优先级

| 优先级 | 内容 | 归属 | 影响 | 修改文件 |
|--------|------|------|------|----------|
| **P0** | 修复 rarity 字典缺失（已有 BUG）— 补录 5 条 system_dictionaries | 后端数据库 | `rarity_display`/`rarity_color` 恢复正常 | 1 个 migration |
| **P1** | 级联删除测试数据（先删 69 events + 6 listings，再删 197 instances）+ item_type 加 NOT NULL 约束（D6 已决策：级联删除） | 后端数据库 | 数据质量基础 | 同上 migration |
| **P1** | source 字段回填（从 item_instance_events.business_type）+ 加 NOT NULL 约束 | 后端数据库 | 来源追溯完整性 | 同上 migration |
| **P2** | 新增 system_configs 配置（backpack_use_instructions + item_type_action_rules） | 后端数据库 | instructions + allowed_actions 的数据基础 | 同上 migration |
| **P2** | `/use` 响应增加 `instructions` 字段 | 后端代码 | 提升使用体验 | `routes/v4/backpack/index.js` |
| **P3** | 背包列表增加 `allowed_actions` 字段 | 后端代码 | 精确控制物品操作按钮 | `services/BackpackService.js` |
| **P3** | item-templates 编辑页增加 meta 字段编辑 | Web管理后台前端 | 运营可管理模板级配置 | `admin/src/modules/system/pages/item-templates.js` |
| **P3** | system-settings 增加 backpack 分类 | Web管理后台前端 | 运营可管理背包配置 | `admin/src/modules/system/composables/config.js`（`CATEGORY_DISPLAY` 对象第 18 行） |
| **P3** | 小程序按 `allowed_actions` 控制按钮 + 展示 `instructions` | 微信小程序前端 | 按钮策略 + 使用引导 | 小程序前端代码 |

### 修改文件汇总

**后端项目（本仓库）**:

| 文件 | 改动类型 | 说明 |
|------|---------|------|
| `migrations/xxxxxx-fix-rarity-dict-and-backpack-configs.js` | **新建** | 合并：补录 rarity 字典 + 级联删除测试数据（先删 69 events + 6 listings，再删 197 instances）+ item_type 加 NOT NULL + source 回填 + source 加 NOT NULL + 插入 system_configs |
| `routes/v4/backpack/index.js` | 修改 | `/use` 路由增加 instructions 返回 |
| `services/BackpackService.js` | 修改 | `_getItems()` 增加 allowed_actions 附加逻辑 |

**Web管理后台前端（admin/ 目录）**:

| 文件 | 改动类型 | 说明 |
|------|---------|------|
| `admin/src/modules/system/pages/item-templates.js` | 修改 | 表单增加 use_instructions / allowed_actions 编辑 |
| `admin/src/modules/system/pages/system-settings.js` | 修改 | 分类列表增加 backpack |
| `admin/src/modules/system/composables/config.js` | 修改 | `CATEGORY_DISPLAY` 对象增加 `backpack` 条目（第 18-24 行） |

**微信小程序前端（独立仓库，本次文档提供对接规范）**:
- 直接使用后端字段名（去掉前端映射）
- 根据 `allowed_actions` 控制按钮显示
- 展示 `instructions` 文案
