# èƒŒåŒ…åŒè½¨æ¶æ„è¿ç§»æ‰§è¡Œæ–¹æ¡ˆï¼ˆåŸºäºçœŸå®ä»£ç çŠ¶æ€ï¼‰

> **æ–‡æ¡£ç‰ˆæœ¬**ï¼šv1.0  
> **åˆ›å»ºæ—¶é—´**ï¼š2025-12-17  
> **ä»£ç åŸºå‡†**ï¼šå½“å‰ä¸»å¹²åˆ†æ”¯å®é™…çŠ¶æ€  
> **æ‰§è¡ŒåŸåˆ™**ï¼šä¸ä¿ç•™å…¼å®¹æ€§ï¼Œå½»åº•è¿ç§»ï¼Œä¸€æ­¥åˆ°ä½

---

## ğŸ“Š å½“å‰çœŸå®çŠ¶æ€

### âœ… å·²å®ç°çš„åŸºç¡€è®¾æ–½

```yaml
æ•°æ®åº“è¡¨:
  - account_asset_balances: âœ… å­˜åœ¨ (æ”¯æŒ available_amount + frozen_amount)
  - item_instances: âœ… å­˜åœ¨ (çŠ¶æ€æœº: available/locked/transferred/used/expired)
  - asset_transactions: âœ… å­˜åœ¨ (å®Œæ•´æµæ°´è®°å½•)
  - accounts: âœ… å­˜åœ¨ (ç”¨æˆ·è´¦æˆ· + ç³»ç»Ÿè´¦æˆ·)

æœåŠ¡å±‚:
  - AssetService: âœ… å®Œæ•´å®ç°
    - freeze/unfreeze/settleFromFrozen âœ…
    - changeBalance (å¹‚ç­‰æ€§æ§åˆ¶) âœ…
    - getBalance/getAllBalances âœ…
  - ItemInstance Model: âœ… å®Œæ•´å®ç°
    - lock/unlock/transferOwnership âœ…
    - çŠ¶æ€æ£€æŸ¥æ–¹æ³• âœ…

é—ç•™ç³»ç»Ÿ:
  - user_inventory: âš ï¸ ä»åœ¨ä½¿ç”¨
    - type: voucher/product/service
    - item_type: å·²åºŸå¼ƒä½†ä»æœ‰æ•°æ®
    - verification_code: 8ä½HEXæ˜æ–‡
    - verification_expires_at: 24å°æ—¶TTL
```

### âŒ ä¸å­˜åœ¨çš„ç»„ä»¶

```yaml
redemption_orders è¡¨: âŒ ä¸å­˜åœ¨
RedemptionOrder æ¨¡å‹: âŒ ä¸å­˜åœ¨
RedemptionOrderService: âŒ ä¸å­˜åœ¨
12ä½Base32æ ¸é”€ç å·¥å…·: âŒ ä¸å­˜åœ¨
èƒŒåŒ…åŒè½¨æ¥å£: â“ æœªç¡®è®¤ (å¯èƒ½ä»è¿”å›å•ä¸€ inventory[])
```

### ğŸ¯ è¿ç§»ç›®æ ‡æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    èƒŒåŒ… (Backpack)                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚   å¯å åŠ èµ„äº§è½¨é“      â”‚  â”‚  ä¸å¯å åŠ å®ä¾‹è½¨é“    â”‚  â”‚
â”‚  â”‚  (Assets Track)     â”‚  â”‚  (Items Track)      â”‚  â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚
â”‚  â”‚ â€¢ DIAMOND           â”‚  â”‚ â€¢ ä¼˜æƒ åˆ¸å®ä¾‹        â”‚  â”‚
â”‚  â”‚ â€¢ red_shard         â”‚  â”‚ â€¢ å®ç‰©å•†å“å®ä¾‹      â”‚  â”‚
â”‚  â”‚ â€¢ red_crystal       â”‚  â”‚ â€¢ æƒç›Šå¡å®ä¾‹        â”‚  â”‚
â”‚  â”‚ â€¢ ææ–™/ç¢ç‰‡         â”‚  â”‚ â€¢ è£…å¤‡/å¡ç‰Œå®ä¾‹     â”‚  â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚
â”‚  â”‚ å­˜å‚¨ä½ç½®:            â”‚  â”‚ å­˜å‚¨ä½ç½®:            â”‚  â”‚
â”‚  â”‚ account_asset_      â”‚  â”‚ item_instances      â”‚  â”‚
â”‚  â”‚ balances            â”‚  â”‚                     â”‚  â”‚
â”‚  â”‚                     â”‚  â”‚ æ ¸é”€æ–¹å¼:            â”‚  â”‚
â”‚  â”‚ æŸ¥è¯¢æ–¹å¼:            â”‚  â”‚ redemption_orders   â”‚  â”‚
â”‚  â”‚ AssetService.       â”‚  â”‚ (12ä½Base32+hash)   â”‚  â”‚
â”‚  â”‚ getAllBalances()    â”‚  â”‚                     â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

åºŸå¼ƒ: user_inventory è¡¨ (å®Œå…¨åˆ é™¤ï¼Œä¸ä¿ç•™)
```

---

## ğŸ›¤ï¸ æ‰§è¡Œè·¯çº¿å›¾

### Phase 1: å…‘æ¢è®¢å•ç³»ç»Ÿæ­å»ºï¼ˆ3å¤©ï¼‰

#### ç›®æ ‡

ä»é›¶æ­å»ºå®Œæ•´çš„å…‘æ¢è®¢å•ç³»ç»Ÿï¼Œæ›¿ä»£ `UserInventory.verification_code`

#### 1.1 æ•°æ®åº“è¡¨åˆ›å»º

**è¿ç§»æ–‡ä»¶**: `migrations/YYYYMMDDHHMMSS-create-redemption-orders.js`

```sql
CREATE TABLE redemption_orders (
  -- ä¸»é”®
  order_id VARCHAR(36) PRIMARY KEY COMMENT 'è®¢å•ID (UUID)',

  -- æ ¸é”€ç  (åªå­˜hash)
  code_hash VARCHAR(64) NOT NULL UNIQUE COMMENT 'æ ¸é”€ç SHA-256å“ˆå¸Œ',

  -- å…³è”å®ä¾‹
  item_instance_id BIGINT NOT NULL COMMENT 'ç‰©å“å®ä¾‹ID',

  -- æ ¸é”€äºº
  redeemer_user_id INT NULL COMMENT 'æ ¸é”€ç”¨æˆ·ID',

  -- çŠ¶æ€
  status ENUM('pending', 'fulfilled', 'cancelled', 'expired') NOT NULL DEFAULT 'pending',

  -- æ—¶é—´
  expires_at DATETIME NOT NULL COMMENT 'è¿‡æœŸæ—¶é—´ (åˆ›å»º+30å¤©)',
  fulfilled_at DATETIME NULL COMMENT 'æ ¸é”€æ—¶é—´',
  created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  -- ç´¢å¼•
  INDEX idx_status_expires (status, expires_at),
  INDEX idx_item_instance (item_instance_id),
  INDEX idx_redeemer (redeemer_user_id),
  UNIQUE KEY uk_code_hash (code_hash),

  -- å¤–é”®
  FOREIGN KEY (item_instance_id) REFERENCES item_instances(item_instance_id),
  FOREIGN KEY (redeemer_user_id) REFERENCES users(user_id) ON DELETE SET NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='å…‘æ¢è®¢å•è¡¨';
```

#### 1.2 Sequelize æ¨¡å‹

**æ–‡ä»¶**: `models/RedemptionOrder.js`

```javascript
const { DataTypes } = require('sequelize')

module.exports = sequelize => {
  const RedemptionOrder = sequelize.define(
    'RedemptionOrder',
    {
      order_id: {
        type: DataTypes.UUID,
        defaultValue: DataTypes.UUIDV4,
        primaryKey: true
      },
      code_hash: {
        type: DataTypes.STRING(64),
        allowNull: false,
        unique: true,
        comment: 'æ ¸é”€ç SHA-256å“ˆå¸Œ'
      },
      item_instance_id: {
        type: DataTypes.BIGINT,
        allowNull: false
      },
      redeemer_user_id: {
        type: DataTypes.INTEGER,
        allowNull: true
      },
      status: {
        type: DataTypes.ENUM('pending', 'fulfilled', 'cancelled', 'expired'),
        defaultValue: 'pending'
      },
      expires_at: {
        type: DataTypes.DATE,
        allowNull: false
      },
      fulfilled_at: {
        type: DataTypes.DATE,
        allowNull: true
      }
    },
    {
      tableName: 'redemption_orders',
      timestamps: true,
      underscored: true
    }
  )

  RedemptionOrder.associate = models => {
    RedemptionOrder.belongsTo(models.ItemInstance, {
      foreignKey: 'item_instance_id',
      as: 'itemInstance'
    })
    RedemptionOrder.belongsTo(models.User, {
      foreignKey: 'redeemer_user_id',
      as: 'redeemer'
    })
  }

  // å®ä¾‹æ–¹æ³•
  RedemptionOrder.prototype.isExpired = function () {
    return new Date() > new Date(this.expires_at)
  }

  RedemptionOrder.prototype.canFulfill = function () {
    return this.status === 'pending' && !this.isExpired()
  }

  return RedemptionOrder
}
```

#### 1.3 æ ¸é”€ç å·¥å…·ç±»

**æ–‡ä»¶**: `utils/RedemptionCodeGenerator.js`

```javascript
const crypto = require('crypto')

// Base32 å­—ç¬¦é›† (å»é™¤æ˜“æ··æ·†å­—ç¬¦ 0OIL1)
const BASE32_CHARS = '23456789ABCDEFGHJKMNPQRSTUVWXYZ'

class RedemptionCodeGenerator {
  /**
   * ç”Ÿæˆ12ä½Base32æ ¸é”€ç 
   * @returns {string} æ ¼å¼: XXXX-YYYY-ZZZZ
   */
  static generate() {
    let code = ''
    for (let i = 0; i < 12; i++) {
      const randomIndex = crypto.randomInt(0, BASE32_CHARS.length)
      code += BASE32_CHARS[randomIndex]
    }
    // æ ¼å¼åŒ–: 3K7J-2MQP-WXYZ
    return code.slice(0, 4) + '-' + code.slice(4, 8) + '-' + code.slice(8, 12)
  }

  /**
   * è®¡ç®—æ ¸é”€ç SHA-256å“ˆå¸Œ
   * @param {string} code - åŸå§‹ç  (å¸¦æˆ–ä¸å¸¦è¿å­—ç¬¦)
   * @returns {string} 64ä½hexå­—ç¬¦ä¸²
   */
  static hash(code) {
    const cleanCode = code.replace(/-/g, '').toUpperCase()
    return crypto.createHash('sha256').update(cleanCode).digest('hex')
  }

  /**
   * éªŒè¯æ ¸é”€ç æ ¼å¼
   * @param {string} code
   * @returns {boolean}
   */
  static validate(code) {
    const pattern =
      /^[23456789ABCDEFGHJKMNPQRSTUVWXYZ]{4}-[23456789ABCDEFGHJKMNPQRSTUVWXYZ]{4}-[23456789ABCDEFGHJKMNPQRSTUVWXYZ]{4}$/
    return pattern.test(code)
  }
}

module.exports = RedemptionCodeGenerator
```

#### 1.4 å…‘æ¢è®¢å•æœåŠ¡

**æ–‡ä»¶**: `services/RedemptionOrderService.js`

```javascript
const { RedemptionOrder, ItemInstance } = require('../models')
const RedemptionCodeGenerator = require('../utils/RedemptionCodeGenerator')
const { sequelize } = require('../config/database')
const logger = require('../utils/logger')

class RedemptionOrderService {
  /**
   * åˆ›å»ºå…‘æ¢è®¢å• (ç”Ÿæˆæ ¸é”€ç )
   */
  static async createOrder(itemInstanceId, options = {}) {
    const { transaction: externalTx } = options
    const tx = externalTx || (await sequelize.transaction())
    const shouldCommit = !externalTx

    try {
      // éªŒè¯ç‰©å“å®ä¾‹å­˜åœ¨ä¸”å¯ç”¨
      const item = await ItemInstance.findByPk(itemInstanceId, { transaction: tx })
      if (!item) {
        throw new Error(`ç‰©å“å®ä¾‹ä¸å­˜åœ¨: ${itemInstanceId}`)
      }
      if (!item.isAvailable()) {
        throw new Error(`ç‰©å“å®ä¾‹ä¸å¯ç”¨: status=${item.status}`)
      }

      // ç”Ÿæˆæ ¸é”€ç  (æœ€å¤šé‡è¯•3æ¬¡)
      let code,
        codeHash,
        isUnique = false,
        attempts = 0
      while (!isUnique && attempts < 3) {
        code = RedemptionCodeGenerator.generate()
        codeHash = RedemptionCodeGenerator.hash(code)

        const existing = await RedemptionOrder.findOne({
          where: { code_hash: codeHash },
          transaction: tx
        })
        isUnique = !existing
        attempts++
      }

      if (!isUnique) {
        throw new Error('æ ¸é”€ç ç”Ÿæˆå¤±è´¥: ç¢°æ’é‡è¯•æ¬¡æ•°è¶…é™')
      }

      // åˆ›å»ºè®¢å•
      const expiresAt = new Date()
      expiresAt.setDate(expiresAt.getDate() + 30) // 30å¤©æœ‰æ•ˆæœŸ

      const order = await RedemptionOrder.create(
        {
          code_hash: codeHash,
          item_instance_id: itemInstanceId,
          expires_at: expiresAt,
          status: 'pending'
        },
        { transaction: tx }
      )

      if (shouldCommit) await tx.commit()

      logger.info('å…‘æ¢è®¢å•åˆ›å»ºæˆåŠŸ', {
        order_id: order.order_id,
        item_instance_id: itemInstanceId,
        expires_at: expiresAt
      })

      // âš ï¸ æ˜æ–‡ç åªè¿”å›ä¸€æ¬¡ï¼Œä¸å†å­˜å‚¨
      return { order, code }
    } catch (error) {
      if (shouldCommit) await tx.rollback()
      logger.error('å…‘æ¢è®¢å•åˆ›å»ºå¤±è´¥', { error: error.message, itemInstanceId })
      throw error
    }
  }

  /**
   * æ ¸é”€è®¢å•
   */
  static async fulfillOrder(code, redeemerUserId, options = {}) {
    const { transaction: externalTx } = options
    const tx = externalTx || (await sequelize.transaction())
    const shouldCommit = !externalTx

    try {
      // éªŒè¯ç æ ¼å¼
      if (!RedemptionCodeGenerator.validate(code)) {
        throw new Error('æ ¸é”€ç æ ¼å¼é”™è¯¯')
      }

      const codeHash = RedemptionCodeGenerator.hash(code)

      // æŸ¥æ‰¾è®¢å• (åŠ é”)
      const order = await RedemptionOrder.findOne({
        where: { code_hash: codeHash },
        lock: tx.LOCK.UPDATE,
        transaction: tx,
        include: [
          {
            model: ItemInstance,
            as: 'itemInstance'
          }
        ]
      })

      if (!order) {
        throw new Error('æ ¸é”€ç ä¸å­˜åœ¨')
      }

      if (!order.canFulfill()) {
        if (order.status === 'fulfilled') {
          throw new Error('æ ¸é”€ç å·²è¢«ä½¿ç”¨')
        }
        if (order.status === 'expired') {
          throw new Error('æ ¸é”€ç å·²è¿‡æœŸ')
        }
        if (order.isExpired()) {
          throw new Error('æ ¸é”€ç å·²è¶…è¿‡æœ‰æ•ˆæœŸ')
        }
        throw new Error(`æ ¸é”€ç ä¸å¯ç”¨: status=${order.status}`)
      }

      // æ›´æ–°è®¢å•çŠ¶æ€ (CAS)
      await order.update(
        {
          status: 'fulfilled',
          redeemer_user_id: redeemerUserId,
          fulfilled_at: new Date()
        },
        { transaction: tx }
      )

      // æ ‡è®°ç‰©å“å®ä¾‹ä¸ºå·²ä½¿ç”¨
      await order.itemInstance.markAsUsed({ transaction: tx })

      if (shouldCommit) await tx.commit()

      logger.info('æ ¸é”€æˆåŠŸ', {
        order_id: order.order_id,
        redeemer_user_id: redeemerUserId
      })

      return order
    } catch (error) {
      if (shouldCommit) await tx.rollback()
      logger.error('æ ¸é”€å¤±è´¥', { error: error.message, code_partial: code.slice(0, 4) })
      throw error
    }
  }

  /**
   * å®šæ—¶ä»»åŠ¡: æ¸…ç†è¿‡æœŸè®¢å•
   */
  static async expireOrders() {
    const tx = await sequelize.transaction()
    try {
      const result = await RedemptionOrder.update(
        {
          status: 'expired'
        },
        {
          where: {
            status: 'pending',
            expires_at: { [sequelize.Op.lt]: new Date() }
          },
          transaction: tx
        }
      )

      await tx.commit()
      logger.info('è¿‡æœŸè®¢å•æ¸…ç†å®Œæˆ', { count: result[0] })
      return result[0]
    } catch (error) {
      await tx.rollback()
      logger.error('è¿‡æœŸè®¢å•æ¸…ç†å¤±è´¥', { error: error.message })
      throw error
    }
  }
}

module.exports = RedemptionOrderService
```

#### 1.5 å®šæ—¶ä»»åŠ¡é…ç½®

**æ–‡ä»¶**: `jobs/expire-redemption-orders.js`

```javascript
const cron = require('node-cron')
const RedemptionOrderService = require('../services/RedemptionOrderService')
const logger = require('../utils/logger')

// æ¯å°æ—¶æ‰§è¡Œä¸€æ¬¡
cron.schedule('0 * * * *', async () => {
  try {
    logger.info('å¼€å§‹æ¸…ç†è¿‡æœŸå…‘æ¢è®¢å•')
    const count = await RedemptionOrderService.expireOrders()
    logger.info('è¿‡æœŸå…‘æ¢è®¢å•æ¸…ç†å®Œæˆ', { expired_count: count })
  } catch (error) {
    logger.error('è¿‡æœŸå…‘æ¢è®¢å•æ¸…ç†å¤±è´¥', { error: error.message })
  }
})
```

---

### Phase 2: èƒŒåŒ…åŒè½¨æ¥å£é‡æ„ï¼ˆ4å¤©ï¼‰

#### ç›®æ ‡

èƒŒåŒ…æŸ¥è¯¢è¿”å› `{ assets: [], items: [] }`ï¼Œå½»åº•åºŸå¼ƒ `UserInventory` æŸ¥è¯¢

#### 2.1 èƒŒåŒ…æŸ¥è¯¢æœåŠ¡é‡æ„

**æ–‡ä»¶**: `services/BackpackService.js` (æ–°å»º)

```javascript
const { AccountAssetBalance, ItemInstance, Account } = require('../models')
const AssetService = require('./AssetService')
const logger = require('../utils/logger')

class BackpackService {
  /**
   * è·å–ç”¨æˆ·èƒŒåŒ… (åŒè½¨: assets + items)
   */
  static async getUserBackpack(userId, options = {}) {
    const { transaction } = options

    try {
      logger.info('è·å–ç”¨æˆ·èƒŒåŒ…', { user_id: userId })

      // å¹¶è¡ŒæŸ¥è¯¢èµ„äº§å’Œå®ä¾‹
      const [assets, items] = await Promise.all([
        this._getAssets(userId, { transaction }),
        this._getItems(userId, { transaction })
      ])

      logger.info('èƒŒåŒ…æŸ¥è¯¢æˆåŠŸ', {
        user_id: userId,
        assets_count: assets.length,
        items_count: items.length
      })

      return { assets, items }
    } catch (error) {
      logger.error('èƒŒåŒ…æŸ¥è¯¢å¤±è´¥', {
        user_id: userId,
        error: error.message
      })
      throw error
    }
  }

  /**
   * æŸ¥è¯¢ç”¨æˆ·èµ„äº§ (å¯å åŠ )
   * @private
   */
  static async _getAssets(userId, options = {}) {
    const { transaction } = options

    // è·å–è´¦æˆ·
    const account = await AssetService.getOrCreateAccount({ user_id: userId }, { transaction })

    // æŸ¥è¯¢æ‰€æœ‰éé›¶ä½™é¢èµ„äº§
    const balances = await AccountAssetBalance.findAll({
      where: {
        account_id: account.account_id
      },
      transaction,
      order: [['asset_code', 'ASC']]
    })

    // è¿‡æ»¤é›¶ä½™é¢å¹¶æ ¼å¼åŒ–
    return balances.filter(b => b.getTotalBalance() > 0).map(b => this._formatAsset(b))
  }

  /**
   * æŸ¥è¯¢ç”¨æˆ·ç‰©å“å®ä¾‹ (ä¸å¯å åŠ )
   * @private
   */
  static async _getItems(userId, options = {}) {
    const { transaction } = options

    const instances = await ItemInstance.findAll({
      where: {
        owner_user_id: userId,
        status: {
          [require('sequelize').Op.notIn]: ['consumed', 'expired']
        }
      },
      transaction,
      order: [['created_at', 'DESC']]
    })

    return instances.map(i => this._formatItem(i))
  }

  /**
   * æ ¼å¼åŒ–èµ„äº§
   * @private
   */
  static _formatAsset(balance) {
    // èµ„äº§å…ƒæ•°æ®é…ç½®
    const assetMeta = {
      DIAMOND: { name: 'é’»çŸ³', icon: 'ğŸ’', type: 'currency' },
      red_shard: { name: 'çº¢è‰²ç¢ç‰‡', icon: 'ğŸ”´', type: 'material' },
      red_crystal: { name: 'çº¢æ°´æ™¶', icon: 'ğŸ”¶', type: 'material' },
      blue_shard: { name: 'è“è‰²ç¢ç‰‡', icon: 'ğŸ”µ', type: 'material' },
      blue_crystal: { name: 'è“æ°´æ™¶', icon: 'ğŸ”·', type: 'material' },
      green_shard: { name: 'ç»¿è‰²ç¢ç‰‡', icon: 'ğŸŸ¢', type: 'material' },
      green_crystal: { name: 'ç»¿æ°´æ™¶', icon: 'ğŸŸ©', type: 'material' }
    }

    const meta = assetMeta[balance.asset_code] || {
      name: balance.asset_code,
      icon: 'ğŸ“¦',
      type: 'unknown'
    }

    return {
      asset_code: balance.asset_code,
      name: meta.name,
      icon: meta.icon,
      type: meta.type,
      available_amount: Number(balance.available_amount),
      frozen_amount: Number(balance.frozen_amount),
      total_amount: balance.getTotalBalance()
    }
  }

  /**
   * æ ¼å¼åŒ–ç‰©å“å®ä¾‹
   * @private
   */
  static _formatItem(instance) {
    return {
      item_instance_id: instance.item_instance_id,
      item_type: instance.item_type,
      status: instance.status,
      meta: instance.meta,
      locked_by_order_id: instance.locked_by_order_id,
      locked_at: instance.locked_at,
      created_at: instance.created_at,
      updated_at: instance.updated_at
    }
  }
}

module.exports = BackpackService
```

#### 2.2 è·¯ç”±æ¥å£

**æ–‡ä»¶**: `routes/v4/unified-engine/backpack.js` (æ–°å»º)

```javascript
const express = require('express')
const router = express.Router()
const { authenticateToken } = require('../../../middleware/auth')
const BackpackService = require('../../../services/BackpackService')
const { handleServiceError } = require('../../../middleware/validation')

/**
 * è·å–ç”¨æˆ·èƒŒåŒ…
 * GET /api/v4/backpack
 */
router.get('/', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.user_id
    const result = await BackpackService.getUserBackpack(userId)

    return res.apiSuccess(result, 'è·å–èƒŒåŒ…æˆåŠŸ')
  } catch (error) {
    return handleServiceError(error, res, 'è·å–èƒŒåŒ…å¤±è´¥')
  }
})

module.exports = router
```

**æ³¨å†Œè·¯ç”±**: `app.js`

```javascript
// æ–°å¢èƒŒåŒ…æ¥å£
app.use('/api/v4/backpack', require('./routes/v4/unified-engine/backpack'))
```

---

### Phase 3: å†å²æ•°æ®è¿ç§»ï¼ˆ5å¤©ï¼‰

#### ç›®æ ‡

å°† `user_inventory` è¡¨æ•°æ®å®Œæ•´è¿ç§»åˆ°åŒè½¨ç³»ç»Ÿ

#### 3.1 è¿ç§»è„šæœ¬

**æ–‡ä»¶**: `scripts/migrate-user-inventory-to-dual-track.js`

```javascript
const {
  UserInventory,
  ItemInstance,
  AccountAssetBalance,
  Account,
  AssetTransaction,
  RedemptionOrder
} = require('../models')
const AssetService = require('../services/AssetService')
const RedemptionCodeGenerator = require('../utils/RedemptionCodeGenerator')
const { sequelize } = require('../config/database')
const logger = require('../utils/logger')

class InventoryMigration {
  constructor() {
    this.stats = {
      total: 0,
      migrated_to_items: 0,
      migrated_to_assets: 0,
      redemption_codes_created: 0,
      errors: []
    }
  }

  async run() {
    logger.info('å¼€å§‹è¿ç§» user_inventory')

    try {
      // 1. ç»Ÿè®¡æ•°æ®
      const total = await UserInventory.count()
      this.stats.total = total
      logger.info('å¾…è¿ç§»è®°å½•æ•°', { total })

      // 2. åˆ†æ‰¹è¿ç§» (æ¯æ‰¹100æ¡)
      const batchSize = 100
      const batches = Math.ceil(total / batchSize)

      for (let i = 0; i < batches; i++) {
        await this._migrateBatch(i * batchSize, batchSize)
        logger.info('è¿ç§»è¿›åº¦', {
          current: Math.min((i + 1) * batchSize, total),
          total
        })
      }

      // 3. è¾“å‡ºç»Ÿè®¡
      logger.info('è¿ç§»å®Œæˆ', this.stats)
      return this.stats
    } catch (error) {
      logger.error('è¿ç§»å¤±è´¥', { error: error.message })
      throw error
    }
  }

  async _migrateBatch(offset, limit) {
    const records = await UserInventory.findAll({
      offset,
      limit,
      order: [['inventory_id', 'ASC']]
    })

    for (const record of records) {
      await this._migrateRecord(record)
    }
  }

  async _migrateRecord(record) {
    const tx = await sequelize.transaction()
    try {
      // åˆ¤æ–­è¿ç§»ç›®æ ‡
      if (this._shouldMigrateToAsset(record)) {
        await this._migrateToAsset(record, tx)
        this.stats.migrated_to_assets++
      } else {
        await this._migrateToItem(record, tx)
        this.stats.migrated_to_items++
      }

      await tx.commit()
    } catch (error) {
      await tx.rollback()
      this.stats.errors.push({
        inventory_id: record.inventory_id,
        error: error.message
      })
      logger.error('è®°å½•è¿ç§»å¤±è´¥', {
        inventory_id: record.inventory_id,
        error: error.message
      })
    }
  }

  /**
   * åˆ¤æ–­æ˜¯å¦åº”è¿ç§»åˆ°èµ„äº§è½¨
   */
  _shouldMigrateToAsset(record) {
    // è§„åˆ™: item_type='material' æˆ– nameåŒ…å«"ç¢ç‰‡"/"æ°´æ™¶"
    return (
      record.item_type === 'material' ||
      record.name.includes('ç¢ç‰‡') ||
      record.name.includes('æ°´æ™¶') ||
      record.name.includes('ææ–™')
    )
  }

  /**
   * è¿ç§»åˆ°èµ„äº§è½¨
   */
  async _migrateToAsset(record, tx) {
    // æ¨å¯¼ asset_code
    const assetCode = this._deriveAssetCode(record.name)

    // è·å–è´¦æˆ·
    const account = await AssetService.getOrCreateAccount(
      { user_id: record.user_id },
      { transaction: tx }
    )

    // å¢åŠ ä½™é¢ (ä½¿ç”¨è¿ç§»ä¸šåŠ¡ç±»å‹)
    await AssetService.changeBalance(
      {
        user_id: record.user_id,
        asset_code: assetCode,
        delta_amount: 1, // æ¯æ¡è®°å½• = 1ä¸ªææ–™
        business_id: `migration_inventory_${record.inventory_id}`,
        business_type: 'migration_from_user_inventory',
        meta: {
          source_inventory_id: record.inventory_id,
          source_name: record.name,
          source_type: record.type
        }
      },
      { transaction: tx }
    )

    logger.debug('è¿ç§»åˆ°èµ„äº§', {
      inventory_id: record.inventory_id,
      asset_code: assetCode
    })
  }

  /**
   * è¿ç§»åˆ°å®ä¾‹è½¨
   */
  async _migrateToItem(record, tx) {
    // åˆ›å»ºç‰©å“å®ä¾‹
    const instance = await ItemInstance.create(
      {
        owner_user_id: record.user_id,
        item_type: record.type,
        status: this._mapStatus(record.status),
        meta: {
          name: record.name,
          description: record.description,
          value: record.value,
          icon: record.icon,
          expires_at: record.expires_at,
          source_inventory_id: record.inventory_id,
          migrated_at: new Date()
        }
      },
      { transaction: tx }
    )

    // å¦‚æœæœ‰æ ¸é”€ç ï¼Œåˆ›å»ºå…‘æ¢è®¢å•
    if (record.verification_code) {
      await this._migrateVerificationCode(record, instance, tx)
      this.stats.redemption_codes_created++
    }

    logger.debug('è¿ç§»åˆ°å®ä¾‹', {
      inventory_id: record.inventory_id,
      item_instance_id: instance.item_instance_id,
      has_code: !!record.verification_code
    })
  }

  /**
   * è¿ç§»æ ¸é”€ç 
   */
  async _migrateVerificationCode(record, instance, tx) {
    // âš ï¸ æ—§ç æ˜¯8ä½HEXï¼Œæ— æ³•è½¬æ¢ä¸º12ä½Base32
    // ç­–ç•¥: é‡æ–°ç”Ÿæˆæ–°ç ï¼Œæ—§ç ä½œåºŸ

    let code,
      codeHash,
      isUnique = false,
      attempts = 0
    while (!isUnique && attempts < 3) {
      code = RedemptionCodeGenerator.generate()
      codeHash = RedemptionCodeGenerator.hash(code)

      const existing = await RedemptionOrder.findOne({
        where: { code_hash: codeHash },
        transaction: tx
      })
      isUnique = !existing
      attempts++
    }

    if (!isUnique) {
      throw new Error('æ ¸é”€ç ç”Ÿæˆå¤±è´¥: ç¢°æ’é‡è¯•æ¬¡æ•°è¶…é™')
    }

    // åˆ›å»ºå…‘æ¢è®¢å•
    const status = record.status === 'used' ? 'fulfilled' : 'pending'
    const expiresAt =
      record.verification_expires_at || new Date(Date.now() + 30 * 24 * 60 * 60 * 1000)

    await RedemptionOrder.create(
      {
        code_hash: codeHash,
        item_instance_id: instance.item_instance_id,
        redeemer_user_id: record.operator_id,
        status,
        expires_at: expiresAt,
        fulfilled_at: record.used_at,
        meta: {
          old_verification_code: record.verification_code, // è®°å½•æ—§ç ç”¨äºå›æº¯
          migrated_from_inventory_id: record.inventory_id,
          new_code: code // âš ï¸ ä¸´æ—¶å­˜å‚¨ï¼Œè¿ç§»ååˆ é™¤
        }
      },
      { transaction: tx }
    )

    logger.debug('æ ¸é”€ç è¿ç§»', {
      inventory_id: record.inventory_id,
      old_code: record.verification_code,
      new_code: code,
      status
    })
  }

  /**
   * æ¨å¯¼èµ„äº§ä»£ç 
   */
  _deriveAssetCode(name) {
    const mapping = {
      çº¢è‰²ç¢ç‰‡: 'red_shard',
      çº¢æ°´æ™¶: 'red_crystal',
      è“è‰²ç¢ç‰‡: 'blue_shard',
      è“æ°´æ™¶: 'blue_crystal',
      ç»¿è‰²ç¢ç‰‡: 'green_shard',
      ç»¿æ°´æ™¶: 'green_crystal',
      é’»çŸ³: 'DIAMOND'
    }
    return mapping[name] || name.toLowerCase().replace(/\s+/g, '_')
  }

  /**
   * æ˜ å°„çŠ¶æ€
   */
  _mapStatus(oldStatus) {
    const mapping = {
      available: 'available',
      pending: 'locked',
      used: 'used',
      expired: 'expired',
      transferred: 'transferred'
    }
    return mapping[oldStatus] || 'available'
  }
}

// æ‰§è¡Œè¿ç§»
if (require.main === module) {
  ;(async () => {
    const migration = new InventoryMigration()
    try {
      await migration.run()
      process.exit(0)
    } catch (error) {
      console.error('è¿ç§»å¤±è´¥', error)
      process.exit(1)
    }
  })()
}

module.exports = InventoryMigration
```

#### 3.2 è¿ç§»æ‰§è¡Œæ­¥éª¤

```bash
# 1. ç”Ÿäº§æ•°æ®åº“å¤‡ä»½
mysqldump -u root -p restaurant_lottery > backup_before_migration_$(date +%Y%m%d_%H%M%S).sql

# 2. æµ‹è¯•ç¯å¢ƒæ¼”ç»ƒ (å¿…é¡»å…ˆåœ¨æµ‹è¯•ç¯å¢ƒæˆåŠŸ)
NODE_ENV=test node scripts/migrate-user-inventory-to-dual-track.js

# 3. æ•°æ®å¯¹è´¦
node scripts/reconcile-inventory-migration.js

# 4. ç”Ÿäº§ç¯å¢ƒæ‰§è¡Œ (æœåŠ¡ç»´æŠ¤çª—å£)
NODE_ENV=production node scripts/migrate-user-inventory-to-dual-track.js

# 5. éªŒè¯è¿ç§»ç»“æœ
node scripts/verify-migration-result.js
```

#### 3.3 å¯¹è´¦è„šæœ¬

**æ–‡ä»¶**: `scripts/reconcile-inventory-migration.js`

```javascript
const { UserInventory, ItemInstance, AccountAssetBalance, AssetTransaction } = require('../models')
const logger = require('../utils/logger')

class MigrationReconciliation {
  async run() {
    logger.info('å¼€å§‹å¯¹è´¦')

    const report = {
      user_inventory: await this._checkUserInventory(),
      item_instances: await this._checkItemInstances(),
      assets: await this._checkAssets(),
      overall: 'PENDING'
    }

    // åˆ¤æ–­æ€»ä½“çŠ¶æ€
    const hasIssues =
      report.user_inventory.unmigrated_count > 0 ||
      report.item_instances.orphaned_count > 0 ||
      report.assets.inconsistent_count > 0

    report.overall = hasIssues ? 'FAILED' : 'PASSED'

    logger.info('å¯¹è´¦å®Œæˆ', report)
    return report
  }

  async _checkUserInventory() {
    // æ£€æŸ¥æœªè¿ç§»è®°å½•
    const unmigrated = await UserInventory.count()

    return {
      unmigrated_count: unmigrated,
      status: unmigrated === 0 ? 'OK' : 'ERROR'
    }
  }

  async _checkItemInstances() {
    // æ£€æŸ¥å­¤å„¿å®ä¾‹ (æ²¡æœ‰å¯¹åº”çš„ user_inventory æºè®°å½•)
    const instances = await ItemInstance.findAll({
      where: {
        'meta.source_inventory_id': { [require('sequelize').Op.ne]: null }
      }
    })

    let orphaned = 0
    for (const instance of instances) {
      const sourceId = instance.meta.source_inventory_id
      const source = await UserInventory.findByPk(sourceId)
      if (!source) orphaned++
    }

    return {
      total_count: instances.length,
      orphaned_count: orphaned,
      status: orphaned === 0 ? 'OK' : 'WARNING'
    }
  }

  async _checkAssets() {
    // æ£€æŸ¥èµ„äº§ä½™é¢ä¸æµæ°´ä¸€è‡´æ€§
    const balances = await AccountAssetBalance.findAll()
    let inconsistent = 0

    for (const balance of balances) {
      const transactions = await AssetTransaction.findAll({
        where: { account_id: balance.account_id, asset_code: balance.asset_code }
      })

      const calculatedBalance = transactions.reduce((sum, tx) => sum + Number(tx.delta_amount), 0)
      const actualBalance = Number(balance.available_amount)

      if (Math.abs(calculatedBalance - actualBalance) > 0.01) {
        inconsistent++
        logger.warn('ä½™é¢ä¸ä¸€è‡´', {
          account_id: balance.account_id,
          asset_code: balance.asset_code,
          calculated: calculatedBalance,
          actual: actualBalance
        })
      }
    }

    return {
      total_count: balances.length,
      inconsistent_count: inconsistent,
      status: inconsistent === 0 ? 'OK' : 'ERROR'
    }
  }
}

// æ‰§è¡Œå¯¹è´¦
if (require.main === module) {
  ;(async () => {
    const reconciliation = new MigrationReconciliation()
    const report = await reconciliation.run()
    process.exit(report.overall === 'PASSED' ? 0 : 1)
  })()
}

module.exports = MigrationReconciliation
```

#### 3.4 ä¸‹çº¿æ—§è¡¨

**è¿ç§»æ–‡ä»¶**: `migrations/YYYYMMDDHHMMSS-drop-user-inventory.js`

```javascript
'use strict'

module.exports = {
  up: async (queryInterface, Sequelize) => {
    // é‡å‘½åä¸ºåºŸå¼ƒè¡¨ (ä¿ç•™7å¤©è§‚å¯ŸæœŸ)
    await queryInterface.renameTable('user_inventory', '_deprecated_user_inventory_20251217')

    console.log('âœ… user_inventory è¡¨å·²é‡å‘½åä¸º _deprecated_user_inventory_20251217')
    console.log('âš ï¸ 7å¤©è§‚å¯ŸæœŸåæ‰§è¡Œ down() æ°¸ä¹…åˆ é™¤')
  },

  down: async (queryInterface, Sequelize) => {
    // âš ï¸ æ°¸ä¹…åˆ é™¤ (ä¸å¯æ¢å¤)
    await queryInterface.dropTable('_deprecated_user_inventory_20251217')
    console.log('ğŸ—‘ï¸ åºŸå¼ƒè¡¨å·²æ°¸ä¹…åˆ é™¤')
  }
}
```

---

### Phase 4: äº¤æ˜“å¸‚åœºå†»ç»“é“¾è·¯å¯¹é½ï¼ˆ3å¤©ï¼‰

#### ç›®æ ‡

ç¡®ä¿äº¤æ˜“å¸‚åœºæ­£ç¡®èµ°è´¦æœ¬å†»ç»“â†’ç»“ç®—é“¾è·¯

#### 4.1 å¸‚åœºæœåŠ¡æ”¹é€ 

**æ–‡ä»¶**: `services/ExchangeMarketService.js` (ä¿®æ”¹ç°æœ‰æ–‡ä»¶)

```javascript
// åœ¨ç°æœ‰æ–‡ä»¶ä¸­æ·»åŠ /ä¿®æ”¹ä»¥ä¸‹æ–¹æ³•

/**
 * ä¸Šæ¶å•†å“ (åŒºåˆ†èµ„äº§ vs å®ä¾‹)
 */
static async createListing(sellerId, params, options = {}) {
  const { asset_code, item_instance_id, price_asset_code, price_amount } = params;
  const { transaction: externalTx } = options;

  // å‚æ•°éªŒè¯
  if (!asset_code && !item_instance_id) {
    throw new Error('å¿…é¡»æä¾› asset_code æˆ– item_instance_id');
  }
  if (asset_code && item_instance_id) {
    throw new Error('ä¸èƒ½åŒæ—¶æä¾› asset_code å’Œ item_instance_id');
  }

  const tx = externalTx || await sequelize.transaction();
  const shouldCommit = !externalTx;

  try {
    let listingData;

    // æƒ…å†µ1: ä¸Šæ¶èµ„äº§ (ææ–™/ç¢ç‰‡)
    if (asset_code) {
      listingData = await this._createAssetListing(sellerId, {
        asset_code,
        amount: params.amount,
        price_asset_code,
        price_amount
      }, { transaction: tx });
    }
    // æƒ…å†µ2: ä¸Šæ¶å®ä¾‹ (é“å…·)
    else {
      listingData = await this._createItemListing(sellerId, {
        item_instance_id,
        price_asset_code,
        price_amount
      }, { transaction: tx });
    }

    if (shouldCommit) await tx.commit();
    return listingData;
  } catch (error) {
    if (shouldCommit) await tx.rollback();
    throw error;
  }
}

/**
 * ä¸Šæ¶èµ„äº§ (å†»ç»“ä½™é¢)
 * @private
 */
static async _createAssetListing(sellerId, params, options = {}) {
  const { asset_code, amount, price_asset_code, price_amount } = params;
  const { transaction } = options;

  // å†»ç»“å–å®¶èµ„äº§
  const freezeResult = await AssetService.freeze({
    user_id: sellerId,
    asset_code,
    amount,
    business_id: `market_freeze_${Date.now()}_${sellerId}`,
    business_type: 'market_listing_freeze_seller'
  }, { transaction });

  // åˆ›å»ºæŒ‚ç‰Œè®°å½•
  const listing = await MarketListing.create({
    seller_user_id: sellerId,
    listing_type: 'asset',
    asset_code,
    asset_amount: amount,
    price_asset_code,
    price_amount,
    status: 'on_sale',
    frozen_transaction_id: freezeResult.transaction_record.transaction_id
  }, { transaction });

  return listing;
}

/**
 * ä¸Šæ¶å®ä¾‹ (é”å®šç‰©å“)
 * @private
 */
static async _createItemListing(sellerId, params, options = {}) {
  const { item_instance_id, price_asset_code, price_amount } = params;
  const { transaction } = options;

  // éªŒè¯æ‰€æœ‰æƒ
  const instance = await ItemInstance.findByPk(item_instance_id, { transaction });
  if (!instance || instance.owner_user_id !== sellerId) {
    throw new Error('ç‰©å“ä¸å­˜åœ¨æˆ–ä¸å±äºè¯¥ç”¨æˆ·');
  }

  // é”å®šç‰©å“
  const orderId = `market_${Date.now()}_${item_instance_id}`;
  await instance.lock(orderId, { transaction });

  // åˆ›å»ºæŒ‚ç‰Œè®°å½•
  const listing = await MarketListing.create({
    seller_user_id: sellerId,
    listing_type: 'item',
    item_instance_id,
    price_asset_code,
    price_amount,
    status: 'on_sale',
    locked_order_id: orderId
  }, { transaction });

  return listing;
}

/**
 * è´­ä¹°å•†å“ (æˆäº¤ç»“ç®—)
 */
static async purchaseListing(buyerId, listingId, options = {}) {
  const { transaction: externalTx } = options;
  const tx = externalTx || await sequelize.transaction();
  const shouldCommit = !externalTx;

  try {
    // æŸ¥æ‰¾æŒ‚ç‰Œ (åŠ é”)
    const listing = await MarketListing.findByPk(listingId, {
      lock: tx.LOCK.UPDATE,
      transaction: tx
    });

    if (!listing || listing.status !== 'on_sale') {
      throw new Error('æŒ‚ç‰Œä¸å­˜åœ¨æˆ–å·²ä¸‹æ¶');
    }

    // æ ¹æ®ç±»å‹æ‰§è¡Œä¸åŒç»“ç®—é€»è¾‘
    if (listing.listing_type === 'asset') {
      await this._settleAssetPurchase(buyerId, listing, { transaction: tx });
    } else {
      await this._settleItemPurchase(buyerId, listing, { transaction: tx });
    }

    // æ›´æ–°æŒ‚ç‰ŒçŠ¶æ€
    await listing.update({
      status: 'sold',
      buyer_user_id: buyerId,
      sold_at: new Date()
    }, { transaction: tx });

    if (shouldCommit) await tx.commit();
    return listing;
  } catch (error) {
    if (shouldCommit) await tx.rollback();
    throw error;
  }
}

/**
 * èµ„äº§æˆäº¤ç»“ç®—
 * @private
 */
static async _settleAssetPurchase(buyerId, listing, options = {}) {
  const { transaction } = options;
  const sellerId = listing.seller_user_id;
  const tradeId = `trade_${listing.listing_id}`;

  // 1. ä¹°å®¶æ”¯ä»˜ DIAMOND
  await AssetService.changeBalance({
    user_id: buyerId,
    asset_code: listing.price_asset_code,
    delta_amount: -listing.price_amount,
    business_id: `${tradeId}_buyer_pay`,
    business_type: 'market_trade_buyer_payment',
    meta: { listing_id: listing.listing_id }
  }, { transaction });

  // 2. å–å®¶ä»å†»ç»“æ‰£å‡æ ‡çš„èµ„äº§
  await AssetService.settleFromFrozen({
    user_id: sellerId,
    asset_code: listing.asset_code,
    amount: listing.asset_amount,
    business_id: `${tradeId}_seller_debit`,
    business_type: 'market_trade_seller_asset_debit',
    meta: { listing_id: listing.listing_id }
  }, { transaction });

  // 3. ä¹°å®¶è·å¾—æ ‡çš„èµ„äº§
  await AssetService.changeBalance({
    user_id: buyerId,
    asset_code: listing.asset_code,
    delta_amount: listing.asset_amount,
    business_id: `${tradeId}_buyer_receive`,
    business_type: 'market_trade_buyer_asset_credit',
    meta: { listing_id: listing.listing_id }
  }, { transaction });

  // 4. å–å®¶è·å¾— DIAMOND (æ‰£é™¤æ‰‹ç»­è´¹)
  const feeRate = 0.05; // 5% æ‰‹ç»­è´¹
  const fee = Math.floor(listing.price_amount * feeRate);
  const sellerReceive = listing.price_amount - fee;

  await AssetService.changeBalance({
    user_id: sellerId,
    asset_code: listing.price_asset_code,
    delta_amount: sellerReceive,
    business_id: `${tradeId}_seller_receive`,
    business_type: 'market_trade_seller_payment_credit',
    meta: { listing_id: listing.listing_id, fee }
  }, { transaction });

  // 5. å¹³å°æ”¶å–æ‰‹ç»­è´¹
  await AssetService.changeBalance({
    system_code: 'SYSTEM_PLATFORM_FEE',
    asset_code: listing.price_asset_code,
    delta_amount: fee,
    business_id: `${tradeId}_platform_fee`,
    business_type: 'market_trade_platform_fee',
    meta: { listing_id: listing.listing_id }
  }, { transaction });
}

/**
 * å®ä¾‹æˆäº¤ç»“ç®—
 * @private
 */
static async _settleItemPurchase(buyerId, listing, options = {}) {
  const { transaction } = options;
  const sellerId = listing.seller_user_id;
  const tradeId = `trade_${listing.listing_id}`;

  // 1. ä¹°å®¶æ”¯ä»˜ DIAMOND
  await AssetService.changeBalance({
    user_id: buyerId,
    asset_code: listing.price_asset_code,
    delta_amount: -listing.price_amount,
    business_id: `${tradeId}_buyer_pay`,
    business_type: 'market_trade_buyer_payment'
  }, { transaction });

  // 2. è½¬ç§»ç‰©å“æ‰€æœ‰æƒ
  const instance = await ItemInstance.findByPk(listing.item_instance_id, { transaction });
  await instance.transferOwnership(buyerId, { transaction });

  // 3. å–å®¶è·å¾— DIAMOND (æ‰£é™¤æ‰‹ç»­è´¹)
  const feeRate = 0.05;
  const fee = Math.floor(listing.price_amount * feeRate);
  const sellerReceive = listing.price_amount - fee;

  await AssetService.changeBalance({
    user_id: sellerId,
    asset_code: listing.price_asset_code,
    delta_amount: sellerReceive,
    business_id: `${tradeId}_seller_receive`,
    business_type: 'market_trade_seller_payment_credit',
    meta: { listing_id: listing.listing_id, fee }
  }, { transaction });

  // 4. å¹³å°æ”¶å–æ‰‹ç»­è´¹
  await AssetService.changeBalance({
    system_code: 'SYSTEM_PLATFORM_FEE',
    asset_code: listing.price_asset_code,
    delta_amount: fee,
    business_id: `${tradeId}_platform_fee`,
    business_type: 'market_trade_platform_fee'
  }, { transaction });
}
```

---

### Phase 5: ç›‘æ§ä¸è¡¥å¿ï¼ˆ2å¤©ï¼‰

#### 5.1 å¯¹è´¦ä»»åŠ¡

**æ–‡ä»¶**: `jobs/daily-asset-reconciliation.js`

```javascript
const cron = require('node-cron')
const { AccountAssetBalance, AssetTransaction } = require('../models')
const logger = require('../utils/logger')

// æ¯æ—¥å‡Œæ™¨2ç‚¹æ‰§è¡Œ
cron.schedule('0 2 * * *', async () => {
  try {
    logger.info('å¼€å§‹èµ„äº§å¯¹è´¦')

    const balances = await AccountAssetBalance.findAll()
    const discrepancies = []

    for (const balance of balances) {
      // æŸ¥è¯¢æ‰€æœ‰æµæ°´
      const transactions = await AssetTransaction.findAll({
        where: {
          account_id: balance.account_id,
          asset_code: balance.asset_code
        }
      })

      // è®¡ç®—åº”æœ‰ä½™é¢
      const expectedBalance = transactions.reduce((sum, tx) => {
        return sum + Number(tx.delta_amount)
      }, 0)

      const actualBalance = Number(balance.available_amount)
      const diff = Math.abs(expectedBalance - actualBalance)

      // å·®å¼‚é˜ˆå€¼: 0.01
      if (diff > 0.01) {
        discrepancies.push({
          account_id: balance.account_id,
          asset_code: balance.asset_code,
          expected: expectedBalance,
          actual: actualBalance,
          diff
        })
      }
    }

    if (discrepancies.length > 0) {
      logger.error('å‘ç°ä½™é¢ä¸ä¸€è‡´', {
        count: discrepancies.length,
        discrepancies
      })
      // TODO: å‘é€å‘Šè­¦é€šçŸ¥
    } else {
      logger.info('èµ„äº§å¯¹è´¦å®Œæˆ', { status: 'OK' })
    }
  } catch (error) {
    logger.error('èµ„äº§å¯¹è´¦å¤±è´¥', { error: error.message })
  }
})
```

#### 5.2 è¡¥å¿å·¥å…·

**æ–‡ä»¶**: `scripts/admin-tools/recalculate-balance.js`

```javascript
const { AccountAssetBalance, AssetTransaction } = require('../../models')
const { sequelize } = require('../../config/database')
const logger = require('../../utils/logger')

/**
 * é‡ç®—è´¦æˆ·èµ„äº§ä½™é¢ (ä»æµæ°´è¡¨èšåˆ)
 */
async function recalculateBalance(accountId, assetCode) {
  const tx = await sequelize.transaction()

  try {
    logger.info('å¼€å§‹é‡ç®—ä½™é¢', { account_id: accountId, asset_code: assetCode })

    // æŸ¥è¯¢æ‰€æœ‰æµæ°´
    const transactions = await AssetTransaction.findAll({
      where: { account_id: accountId, asset_code: assetCode },
      order: [['created_at', 'ASC']],
      transaction: tx
    })

    // è®¡ç®—æ­£ç¡®ä½™é¢
    const correctBalance = transactions.reduce((sum, tx) => {
      return sum + Number(tx.delta_amount)
    }, 0)

    // æ›´æ–°ä½™é¢
    const [updated] = await AccountAssetBalance.update(
      {
        available_amount: correctBalance
      },
      {
        where: { account_id: accountId, asset_code: assetCode },
        transaction: tx
      }
    )

    if (updated === 0) {
      throw new Error('ä½™é¢è®°å½•ä¸å­˜åœ¨')
    }

    await tx.commit()

    logger.info('ä½™é¢é‡ç®—å®Œæˆ', {
      account_id: accountId,
      asset_code: assetCode,
      new_balance: correctBalance
    })

    return correctBalance
  } catch (error) {
    await tx.rollback()
    logger.error('ä½™é¢é‡ç®—å¤±è´¥', {
      account_id: accountId,
      asset_code: assetCode,
      error: error.message
    })
    throw error
  }
}

// CLI æ‰§è¡Œ
if (require.main === module) {
  const [accountId, assetCode] = process.argv.slice(2)

  if (!accountId || !assetCode) {
    console.error('ç”¨æ³•: node recalculate-balance.js <account_id> <asset_code>')
    process.exit(1)
  }

  recalculateBalance(Number(accountId), assetCode)
    .then(() => process.exit(0))
    .catch(() => process.exit(1))
}

module.exports = recalculateBalance
```

---

## ğŸ“… æ‰§è¡Œæ—¶é—´çº¿

```
Day 1-3:   Phase 1 (å…‘æ¢è®¢å•ç³»ç»Ÿæ­å»º)
Day 4-7:   Phase 2 (èƒŒåŒ…åŒè½¨æ¥å£é‡æ„)
Day 8-12:  Phase 3 (å†å²æ•°æ®è¿ç§»)
Day 13-15: Phase 4 (äº¤æ˜“å¸‚åœºå†»ç»“é“¾è·¯)
Day 16-17: Phase 5 (ç›‘æ§ä¸è¡¥å¿)
Day 18:    æœ€ç»ˆéªŒæ”¶ä¸ä¸Šçº¿
```

**æ€»å·¥æœŸ**: 18 å¤©ï¼ˆçº¦ 3 å‘¨ï¼‰

---

## âœ… æœ€ç»ˆéªŒæ”¶æ¸…å•

### æ•°æ®å®Œæ•´æ€§

- [ ] `user_inventory` è¡¨å·²é‡å‘½åä¸º `_deprecated_*`
- [ ] æ‰€æœ‰å†å²æ•°æ®å·²è¿ç§»åˆ°åŒè½¨ç³»ç»Ÿ
- [ ] å¯¹è´¦è„šæœ¬éªŒè¯é€šè¿‡ï¼ˆå·®å¼‚ = 0ï¼‰
- [ ] æ ¸é”€ç  100% æ”¹ä¸º 12 ä½ Base32 + hash å­˜å‚¨

### åŠŸèƒ½å®Œæ•´æ€§

- [ ] èƒŒåŒ…æ¥å£è¿”å› `{ assets: [], items: [] }`
- [ ] ææ–™/ç¢ç‰‡ 100% åœ¨ `assets[]` ä¸­
- [ ] é“å…·/æƒç›Š 100% åœ¨ `items[]` ä¸­
- [ ] æ ¸é”€åŠŸèƒ½æ­£å¸¸ï¼ˆ12 ä½ç å¯æˆåŠŸæ ¸é”€ï¼‰
- [ ] äº¤æ˜“å¸‚åœºèµ°è´¦æœ¬å†»ç»“â†’ç»“ç®—é“¾è·¯

### æ€§èƒ½æŒ‡æ ‡

- [ ] èƒŒåŒ…æŸ¥è¯¢ < 200msï¼ˆ1000+ é“å…·ç”¨æˆ·ï¼‰
- [ ] æ ¸é”€æˆåŠŸç‡ > 95%
- [ ] äº¤æ˜“æˆäº¤å»¶è¿Ÿ < 3s

### ç›‘æ§è¿ç»´

- [ ] å¯¹è´¦ä»»åŠ¡æ¯æ—¥è‡ªåŠ¨è¿è¡Œ
- [ ] å¼‚å¸¸è‡ªåŠ¨å‘Šè­¦ï¼ˆä½™é¢ä¸ä¸€è‡´ã€æ ¸é”€å¤±è´¥ç‡ï¼‰
- [ ] è¡¥å¿å·¥å…·å¯ç”¨ä¸”æœ‰å®¡è®¡æ—¥å¿—

---

## ğŸš¨ é£é™©æ§åˆ¶

### æ•°æ®å®‰å…¨

```bash
# è¿ç§»å‰å¿…é¡»å®Œæ•´å¤‡ä»½
mysqldump -u root -p restaurant_lottery > backup_$(date +%Y%m%d_%H%M%S).sql

# æµ‹è¯•ç¯å¢ƒå®Œæ•´æ¼”ç»ƒ (è‡³å°‘3æ¬¡)
# ç¡®ä¿è¿ç§»è„šæœ¬å¹‚ç­‰æ€§å’Œé”™è¯¯æ¢å¤èƒ½åŠ›
```

### å›æ»šé¢„æ¡ˆ

```sql
-- å¦‚æœè¿ç§»å¤±è´¥ï¼Œæ‰§è¡Œå›æ»š
-- 1. æ¢å¤æ•°æ®åº“å¤‡ä»½
mysql -u root -p restaurant_lottery < backup_20251217_020000.sql

-- 2. æ¸…ç†è¿ç§»äº§ç”Ÿçš„æ•°æ®
DELETE FROM redemption_orders WHERE created_at > '2025-12-17 00:00:00';
DELETE FROM item_instances WHERE created_at > '2025-12-17 00:00:00';
DELETE FROM asset_transactions WHERE business_type = 'migration_from_user_inventory';

-- 3. æ¢å¤æ—§è¡¨
RENAME TABLE _deprecated_user_inventory_20251217 TO user_inventory;
```

### æœåŠ¡åœæœºçª—å£

```
å»ºè®®åœæœºæ—¶é—´: å‡Œæ™¨ 2:00-6:00 (4å°æ—¶)
è¿ç§»è€—æ—¶é¢„ä¼°: 2-3 å°æ—¶ (10ä¸‡æ¡è®°å½•)
éªŒè¯æ—¶é—´: 1 å°æ—¶
ç¼“å†²æ—¶é—´: 1 å°æ—¶
```

---

## ğŸ“š ç›¸å…³æ–‡æ¡£

- API æ–‡æ¡£: `/docs/api/backpack-v4.md`
- æ•°æ®åº“ Schema: `/docs/database/dual-track-schema.md`
- è¿ç»´æ‰‹å†Œ: `/docs/ops/migration-ops-guide.md`
- æ•…éšœæ’æŸ¥: `/docs/troubleshooting/asset-balance-issues.md`

---

**æ‰§è¡ŒåŸåˆ™**: ä¸ä¿ç•™å…¼å®¹æ€§ï¼Œå½»åº•è¿ç§»ï¼Œä¸€æ­¥åˆ°ä½ï¼Œç¡®ä¿æ•°æ®å®Œæ•´æ€§å’Œç³»ç»Ÿç¨³å®šæ€§ã€‚
