# 管理员告警持久化 — 实施方案

> 创建时间：2026-02-24
> **数据来源：Node.js (mysql2) 连接 Sealos 真实数据库实时验证（dbconn.sealosbja.site:42569）**
> **代码来源：`/home/devbox/project` 后端源码实际审计**
> 优先级：低（项目未上线，方案 B 用户通知独立化优先）
> 状态：方案已出，等待排期
管理员手动公告是统一到 admin_notifications 表，还是继续走广告系统 AdCampaignService。我建议统一到一张表，逻辑简单。
---

## 一、问题描述

`NotificationService.sendToAdmins()` 是管理员告警的统一入口，当前实现**只做 WebSocket 广播，不写数据库**。管理员不在线时告警直接丢失。

### 1.1 当前代码流程

```
sendToAdmins(options)
  └─ ChatWebSocketService.broadcastNotificationToAllAdmins(notification)
       └─ 遍历 connectedAdmins Map
            └─ io.to(socketId).emit('notification', notification)
                 ├─ 管理员在线 → 收到
                 └─ 管理员不在线 → 丢失
```

关键代码位置：

- `services/NotificationService.js` 第 227-281 行：`sendToAdmins()` 方法
- `services/ChatWebSocketService.js` 第 564-578 行：`broadcastNotificationToAllAdmins()` 方法

### 1.2 受影响的告警场景（10 个生产代码触发点）

| 触发位置 | 告警类型 | 触发条件 |
|---|---|---|
| `NotificationService.notifyNewExchangeAudit` | 新兑换订单待审核 | 用户提交兑换申请 |
| `NotificationService.notifyTimeoutAlert` | 待审核订单超时 | 定时任务检测到超时 |
| `NotificationService.notifyAnnouncement` | 系统公告广播 | 管理员发布公告（无指定用户时） |
| `NotificationService.notifyActivityStatusChange` | 活动状态变更 | 抽奖活动启动/暂停/结束 |
| `jobs/daily-asset-reconciliation.js` | 资产对账告警 | 每日对账发现差异 |
| `jobs/daily-asset-reconciliation.js` | 业务记录关联对账告警 | 业务记录对账异常 |
| `jobs/hourly-market-listing-monitor.js` | 市场挂牌异常 | 挂牌监控检测到异常 |
| `jobs/daily-orphan-frozen-check.js` | 孤儿冻结检测告警 | 检测到孤儿冻结资产 |
| `jobs/daily-orphan-frozen-check.js` | 检测任务失败 | 检测 job 本身执行出错 |
| `services/ReminderEngineService.js` | 提醒规则触发 | 配置的提醒规则条件满足 |

### 1.3 已有但未使用的基础设施

`admin_notifications` 表和 `AdminNotification` 模型已经存在，但**从未被任何路由或服务调用**，表内 0 行数据。

**表结构（已建好，无需 DDL 变更）：**

| 字段 | 类型 | 说明 |
|---|---|---|
| admin_notification_id | INT 主键 自增 | — |
| admin_id | INT NOT NULL | 接收管理员 ID（外键 → users.user_id） |
| title | VARCHAR(200) NOT NULL | 通知标题 |
| content | TEXT | 通知内容 |
| notification_type | ENUM(system/alert/reminder/task) | 类型，默认 system |
| priority | ENUM(low/normal/high/urgent) | 优先级，默认 normal |
| is_read | TINYINT(1) NOT NULL | 已读标记，默认 0 |
| read_at | DATETIME | 已读时间 |
| source_type | VARCHAR(50) | 来源类型（如 lottery_alert, reconciliation） |
| source_id | INT | 来源实体 ID |
| extra_data | JSON | 附加业务数据 |
| expires_at | DATETIME | 过期时间 |
| created_at | DATETIME | 创建时间 |
| updated_at | DATETIME | 更新时间 |

**索引（已建好）：**

- `idx_admin_notifications_admin_read` (admin_id, is_read)
- `idx_admin_notifications_type_created` (notification_type, created_at)
- `idx_admin_notifications_priority_read` (priority, is_read)
- `idx_admin_notifications_source` (source_type, source_id)

**模型已有的方法（`models/AdminNotification.js`）：**

- `markAsRead()` — 标记单条已读
- `isExpired()` — 检查是否过期
- `getUnreadCount(adminId)` — 获取某管理员未读数量
- `getUrgentUnreadCount(adminId)` — 获取高优先级未读数量
- `markAllAsRead(adminId, notificationIds?)` — 批量/全部标记已读
- `createSystemNotification(adminId, title, content, options)` — 创建系统通知
- `createAlertNotification(adminId, title, content, options)` — 创建告警通知
- `cleanupExpired(daysToKeep)` — 清理过期通知

### 1.4 当前管理员数据（实时查询）

| user_id | nickname |
|---|---|
| 31 | 管理员用户 |
| 135 | 测试用户2 |
| 11114 | 用户8002 |
| 11132 | 用户0001 |

共 4 个 role_level >= 100 的管理员账号。

---

## 二、改造方案

### 2.1 核心思路

在 `sendToAdmins()` 现有 WebSocket 广播逻辑**之前**，给每个管理员写一条 `AdminNotification` 记录。表和模型已经建好，只需要接上。

### 2.2 改动范围

| 改动项 | 类型 | 文件 | 说明 |
|---|---|---|---|
| `sendToAdmins()` 增加持久化逻辑 | 修改 | `services/NotificationService.js` | 写入 `AdminNotification` 表后再 WebSocket 广播 |
| 管理后台消息中心切换数据源 | 修改 | `routes/v4/system/notifications.js` | 从 `AdCampaignService` 切换为 `AdminNotification` 模型 |
| 管理后台未读角标 API | 新增或修改 | `routes/v4/system/notifications.js` | 调用 `AdminNotification.getUnreadCount()` |

### 2.3 `sendToAdmins()` 改造后流程

```
sendToAdmins(options)
  ├─ 1. 查询所有管理员（role_level >= 100）
  ├─ 2. 批量写入 AdminNotification（每个管理员一条）
  ├─ 3. ChatWebSocketService.broadcastNotificationToAllAdmins()（原有逻辑不变）
  └─ 4. 返回结果（含持久化状态 + WebSocket 推送数量）
```

### 2.4 管理后台消息中心数据源切换

当前 `routes/v4/system/notifications.js` 的 `GET /` 接口调用 `AdCampaignService.getSystemNotifications()`，查的是 `ad_campaigns WHERE campaign_category='system'`。

改造后切换为直接查 `AdminNotification` 模型：

- `GET /` → `AdminNotification.findAll({ where: { admin_id: req.user.user_id }, order: [['created_at', 'DESC']] })`
- `GET /unread-count` → `AdminNotification.getUnreadCount(req.user.user_id)`（模型方法已实现）
- `POST /:id/read` → `AdminNotification.findByPk(id).markAsRead()`（模型方法已实现）
- `POST /read-all` → `AdminNotification.markAllAsRead(req.user.user_id)`（模型方法已实现）

### 2.5 管理员手动公告的处理

管理员通过 `POST /api/v4/system/notifications/send` 发送的手动公告，当前走 `AdCampaignService.sendSystemNotification()`。改造后有两个选项：

| 选项 | 做法 |
|---|---|
| A）统一到 AdminNotification | 手动公告也写 `admin_notifications` 表，不再走 `AdCampaignService` |
| B）保持现状 | 手动公告继续走 `AdCampaignService`，自动告警走 `AdminNotification`，两个数据源合并展示 |

**建议选 A**，统一数据源，消息中心只查一张表，逻辑简单。

---

## 三、不变的部分

| 模块 | 说明 |
|---|---|
| `admin_notifications` 表结构 | 已建好，无需 DDL 变更 |
| `AdminNotification` 模型方法 | 已实现 markAsRead / getUnreadCount / markAllAsRead 等 |
| `ChatWebSocketService.broadcastNotificationToAllAdmins()` | 保持不变，持久化是新增逻辑 |
| 所有 10 个告警触发点的业务代码 | 不需要改动，它们都调 `sendToAdmins()`，内部增加持久化后自动生效 |
| 管理后台前端页面 `admin/message-center.html` | API 接口签名不变，数据源切换对前端透明 |
| 用户通知系统（方案 B） | 完全独立，互不影响 |

---

## 四、实施步骤

### Step 1：改造 `sendToAdmins()`

在 `services/NotificationService.js` 的 `sendToAdmins()` 方法中，WebSocket 广播之前增加 `AdminNotification` 批量写入逻辑。

### Step 2：改造通知路由数据源

`routes/v4/system/notifications.js` 的 GET / POST 接口从 `AdCampaignService` 切换到 `AdminNotification` 模型。

### Step 3：验证

- 触发一次挂牌/购买操作，确认 `admin_notifications` 表有新记录
- 管理后台消息中心刷新，确认能显示告警列表
- 标记已读，确认 is_read 状态变更
- 关闭管理后台，再触发告警，重新打开确认历史告警可见

---

## 五、回滚方案

回滚只需在 `sendToAdmins()` 中移除持久化逻辑，恢复为纯 WebSocket 广播。`admin_notifications` 表数据可保留不影响其他功能。

---

## 附录：与方案 B（用户通知独立化）的关系

| 维度 | 方案 B（用户通知） | 本方案（管理员告警持久化） |
|---|---|---|
| 解决的问题 | 用户通知淹没客服聊天 | 管理员不在线告警丢失 |
| 受众 | 微信小程序普通用户 | 管理后台管理员 |
| 新建表 | `user_notifications`（需新建） | `admin_notifications`（已存在） |
| 新建模型 | `UserNotification`（需新建） | `AdminNotification`（已存在） |
| 核心改动 | `send()` 从 `sendToChat()` 切到 `sendToNotification()` | `sendToAdmins()` 增加写入逻辑 |
| 优先级 | 高（直接影响用户体验） | 低（管理员可看日志补救） |
| 依赖关系 | 无依赖，独立实施 | 无依赖，独立实施 |
| 建议实施顺序 | 先做 | 后做 |
