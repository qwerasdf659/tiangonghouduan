# 方案A：商家员工域权限体系升级方案（单 users + RBAC + 分域治理）

**文档版本**: v1.2（项目未上线一步到位版）  
**创建时间**: 2025年1月11日  
**最后修订**: 2026年1月11日  
**适用范围**: 后端数据库设计 + 后端服务层实现（不含前端、不含运维）  
**技术栈**: Node.js + Sequelize + MySQL + Redis

---

## 🚀 项目未上线特别说明

> **核心策略**：项目尚未上线，**无存量用户、无历史数据、无旧接口兼容压力**，可直接实施最优方案。

### 关键优势与策略调整

| 维度             | 已上线项目（常规）               | 项目未上线（本方案）                    |
| ---------------- | -------------------------------- | --------------------------------------- |
| **二维码升级**   | 需灰度过渡（v1→v2），2周兼容期   | ✅ **直接上 v2**，删除所有 v1 代码      |
| **数据库字段**   | `store_id` 可为 NULL（兼容历史） | ✅ **直接 NOT NULL**，强制关联门店      |
| **历史数据迁移** | 复杂的回填脚本                   | ✅ **无需迁移**，从第一条记录就符合规范 |
| **接口兼容**     | 需维护旧接口或版本路由           | ✅ **不兼容旧接口**，直接最优设计       |
| **实施周期**     | 5-8 周（含灰度期）               | ✅ **约 4 周**（无兼容逻辑）            |
| **代码复杂度**   | 高（v1/v2 分支，NULL 判断）      | ✅ **低**（单一路径，严格约束）         |
| **测试覆盖**     | 需测试兼容分支                   | ✅ **简化**（仅测试最优路径）           |

### 本方案采用的"一步到位"策略

1. **二维码**：仅实现 v2 动态码（exp+nonce+签名），v1 永久码直接拒绝，无兼容代码
2. **门店维度**：`consumption_records.store_id` 直接 NOT NULL，从第一条记录就强制关联门店
3. **权限校验**：直接按最严格标准实施（`/submit` 强制 `requirePermission`），无渐进式放开
4. **审计日志**：根据业务需求直接选最优方案（复用或新建），无需考虑历史兼容
5. **代码清理**：删除所有旧逻辑（如 `QRCodeValidator.generateQRCode` 永久码生成），保持代码库整洁

---

## 📋 文档概述

> **文档版本**: v1.1（基于真实代码与数据库验证后修订）  
> **最后验证时间**: 2026年1月11日  
> **验证方式**: 真实数据库直连只读查询 + 代码静态分析

### "商家员工"定义与现有角色体系的关系

**明确定义**：本方案中的"商家员工"（`merchant_staff`）是指**需要在线下门店录入消费记录的操作主体**，与现有内部业务团队角色（`sales_staff/business_manager/regional_manager`）**平行但独立**。

| 角色类型                   | 代表角色                                                | 职责                                             | 归属体系                                      |
| -------------------------- | ------------------------------------------------------- | ------------------------------------------------ | --------------------------------------------- |
| **平台管理员**             | `admin` / `ops`                                         | 全局管理、系统配置、审核                         | 平台内部                                      |
| **内部业务团队**           | `sales_staff` / `business_manager` / `regional_manager` | 业务拓展、商务对接、区域管理                     | 平台内部，通过 `user_hierarchy.store_id` 分派 |
| **商家员工**（本方案新增） | `merchant_staff` / `merchant_manager`                   | 线下门店录入消费、查询本店数据（店长可管理员工） | 商家侧，通过 `store_staff` 归属（✅已确定）   |

**关键区别**：

- **内部业务团队**：平台雇员，负责拓展/管理商家，可能需要跨门店查看数据（权限较高）
- **商家员工**：商家雇员，仅能录入/查看本门店数据（权限受门店范围限制）

**✅ 已确定设计决策**（2026年1月11-12日拍板）：

### 核心定位决策（2026年1月12日拍板）

- **✅ 录入操作主体**：**商家店员/店长在门店录入**（非平台内部代录）
- **✅ 可追责性要求**：**必须可追责**（谁扫的、谁提交的、属于哪个门店，全链路可追溯）
- **✅ 业务规模预期**：**多门店多人多设备**（需要完整的员工生命周期管理 + 门店隔离）

### 技术方案决策

- **二维码方案**：✅ **选 B（短期一次性码）**，payload 含 exp+nonce，签名用独立的 `CONSUMPTION_QR_SECRET`（不复用 JWT_SECRET）
- **门店归属体系**：✅ **新建 `store_staff`**（语义最清晰、权限隔离最强）
- **每笔消费必须归属门店**：✅ **`consumption_records.store_id` NOT NULL**（项目未上线，从第一条记录就强制关联门店）
- **审计日志方案**：✅ **独立 `merchant_operation_logs`**（语义清晰、权限隔离更容易）
- **店长角色**：✅ **加 `merchant_manager` 角色**（门店自管理更完整）
- **`store_id` 获取**：✅ **单门店自动填充，多门店必传**（见 AC2.2）
- **风控阈值**：✅ **保持默认**（10次/分钟、5000/50000、3店/10分钟）
- **门店数据来源**：✅ **后台录入，平台管理员维护**
- **手机号脱敏策略**：✅ **商家员工和管理员都返回全量手机号**（不脱敏）
- **幂等键策略（P0）**：✅ **继续保持强制 `Idempotency-Key`**（Header 缺失直接 400），商家端为自家可控客户端（小程序/自家App，不开放第三方接入），**接入方规范**：商家端必须能生成并在重试时复用同一个 key（本地持久化直到成功/失败落地）

### 本文档解决的核心问题（共 6 个，按真实紧急度排序）

> **核心原则**："商家员工"在本方案中特指需要录入消费记录的操作主体，与现有 `sales_staff/business_manager` 等内部业务团队角色**平行但独立**。

#### 🔴 P0级（立刻修复，否则有安全/信任风险）

1. **二维码复用风险**（高危）：当前永久身份码可被拍照复用，缺少防重放机制，**真实数据已出现同一二维码8分钟内被提交9次**，存在严重的安全隐患和用户信任风险
2. **权限缺失比预期更严重**：
   - `/submit` 接口**实际只有 `authenticateToken`**（无角色/权限校验），任何登录用户只要拿到二维码就能提交
   - `/user-info` 被 `requireAdmin` 卡死（但实际使用者当前是 admin，不是"商家员工"）

#### ⚠️ P1级（有数据/能力但缺管理机制）

3. **组织边界缺失**：消费记录缺少门店维度（`stores` 表当前 0 行，无业务数据），无法实现"员工只能看/录入本门店数据"的数据隔离
4. **员工生命周期管理缺失**：无法管理商家员工的入职/离职/禁用，存在离职员工仍可操作的安全风险
5. **审计追责可复用现有体系**：当前已有 `AuditLogService` 和 `admin_operation_logs`，需明确是否新增 `merchant_operation_logs` 还是扩展现有表
6. **风控辅助审核能力薄弱**：缺少频次/金额/异常检测等规则告警，审核员无法快速识别高风险单，审核效率低

### 解决方案核心思路

**保持现有架构**（单 `users` 账号体系 + `roles/user_roles/permissions` RBAC），在此基础上升级为：

- **权限能力化**：从"平台管理员"拆分出"商家域能力"（`consumption:scan_user`、`consumption:create`等）
- **组织边界化**：✅ **新增 `store_staff` 多对多关系表**（已确定），支持员工多门店/门店内角色/完整生命周期管理
- **范围控制**：所有商家域操作自动关联 `store_id`，查询/统计按门店隔离
- **治理可视化**：✅ **独立 `merchant_operation_logs` 审计日志**（已确定）+ 规则风控告警（辅助审核，所有记录仍需人工审核）
- **完整生命周期**：入职/离职/调店/禁用 + 权限缓存失效 + 历史追溯
- **角色体系**：✅ **新增 `merchant_manager`（店长）角色**（已确定），支持门店自管理（员工管理/查看全店记录）

---

## 🎯 验收标准（Acceptance Criteria）

> **项目未上线策略说明**：无需兼容旧接口/旧码，直接实施最优方案，验收标准更简洁严格。

### 功能验收标准

#### 1. 权限能力验收（P0）

- [ ] **AC1.1**: `/api/v4/shop/consumption/submit` 增加 `requirePermission('consumption:create')`（**修复当前无权限校验的高危问题**）
- [ ] **AC1.2**: `/api/v4/shop/consumption/user-info` 从 `requireAdmin` 改为 `requirePermission('consumption:scan_user')`
- [ ] **AC1.3**: 新增角色 `merchant_staff`（role_level=50），权限包含 `consumption:scan_user` 和 `consumption:create`
- [ ] **AC1.4**: 平台管理员（admin/regional_manager）仍可调用所有接口，权限不受影响
- [ ] **AC1.5**: `/user-info` 返回的手机号**✅ 统一返回全量手机号**（商家员工和管理员都不脱敏，2026年1月11日拍板）
- [ ] **AC1.6**: `/api/v4/shop/consumption/submit` **✅ 继续强制要求 `Idempotency-Key` Header**（缺失直接 400），商家端为自家可控客户端（小程序/自家App），**接入方规范**：
  - 商家端必须在提交前生成幂等键（建议格式：`<device_id>_<timestamp>_<random>`）
  - 幂等键必须本地持久化（localStorage/AsyncStorage），在收到明确的成功/失败响应前，**所有重试必须使用同一个幂等键**
  - 收到 200/201/409（已提交）后清除本地幂等键，下次提交生成新键
  - 不开放第三方接入，无需提供 SDK（2026年1月12日拍板）

#### 2. 组织边界验收（P0 - 方案2：store_staff 多对多）

- [ ] **AC2.1**: `consumption_records` 表增加 `store_id` 字段（INT，外键关联 `stores.store_id`，**✅ NOT NULL - 项目未上线，从第一条记录就强制关联门店，2026年1月11日拍板**）
- [ ] **AC2.2**: 新建 `store_staff` 表，记录员工-门店多对多关系（`user_id`、`store_id`、`status`、`role_in_store`、`joined_at`、`left_at`）
- [ ] **AC2.3**: 提交消费记录时，服务端从 `store_staff` 查询员工的 active 门店列表：
  - 如果只有 1 个：自动填充 `store_id`
  - 如果多个：要求客户端传 `store_id`，服务端验证该门店在员工的 active 列表中
  - 如果 0 个：返回 403 Forbidden（"您未绑定任何门店"）
- [ ] **AC2.4**: 商家员工查询消费记录时，仅返回其负责门店的数据（`WHERE store_id IN (员工的active门店列表)`）
- [ ] **AC2.5**: 区域经理/平台管理员可跨门店查询（基于 `role_level` 或 `permissions.stores:*` 能力）
- [ ] **AC2.6**: 店长（`role_in_store='manager'`）可查看/管理本门店所有员工的记录；普通员工（`role_in_store='staff'`）仅可查看自己录入的记录

#### 3. 员工生命周期验证（P1 - 完整生命周期管理）

- [ ] **AC3.1**: 后端提供员工管理 API（完整 CRUD）：
  - 添加员工到门店（`POST /admin/staff`）：创建 `store_staff` 记录，`status='active'`，自动记录 `created_by`
  - 调店（`POST /admin/staff/:id/transfer`）：将旧门店记录置 `inactive`（保留历史），新增新门店的 `active` 记录
  - 禁用员工（`PUT /admin/staff/:id/status`）：将该员工**所有门店**的记录置 `inactive`，同时调用 `invalidateUserPermissions()`
  - 恢复员工（`PUT /admin/staff/:id/status`）：将指定门店记录恢复为 `active`
  - 查询员工列表（`GET /admin/staff`）：支持按门店/状态/角色筛选
- [ ] **AC3.2**: 禁用员工时，必须同步清除权限缓存（`invalidateUserPermissions(user_id, '员工禁用', operator_id)`），确保下次请求立刻生效
- [ ] **AC3.3**: 被禁用员工（该门店的 `store_staff.status='inactive'`）调用消费接口时返回 403 Forbidden + 明确错误消息（"您已从该门店离职"）
- [ ] **AC3.4**: 员工列表 API 返回字段：姓名、手机号、所属门店列表（含门店内角色）、状态、入职时间、最后操作时间、累计操作次数
- [ ] **AC3.5**: 员工历史追溯：查询员工的所有 `store_staff` 记录（含 inactive），用于审计和调岗历史查询

#### 4. 审计追责验证（P1）

- [ ] **AC4.1**: 新建 `merchant_operation_logs` 表（或复用 `admin_operation_logs` 增加 `operation_domain='merchant'`）
- [ ] **AC4.2**: 消费提交/扫码拿用户信息时，记录审计日志（operator_id、store_id、target_user_id、amount、ip、ua、request_id、result）
- [ ] **AC4.3**: 后端提供商家操作日志查询 API，支持按门店/员工/时间范围/操作类型筛选
- [ ] **AC4.4**: 审计日志保留 180 天（可配置），提供导出 CSV 接口

#### 5. 风控辅助审核验证（P2 - 所有记录仍需人工审核）

> **核心说明**：本系统**所有消费记录都是 `pending` 状态，必须经过人工审核通过后才发放积分**。风控的作用是"辅助审核员快速识别高风险单"，不改变"全员人工审核"的流程。

- [ ] **AC5.1**: 实现频次风控：同一员工 1 分钟内提交次数 > 10 次，**阻断提交**并返回 429 Too Many Requests（防止批量刷单）
- [ ] **AC5.2**: 实现金额告警：单笔 > 5000 元或日累计 > 50000 元，**仅记录告警到 `risk_alerts` 表**（帮助审核员优先复核大额订单）
- [ ] **AC5.3**: 实现关联告警：同一用户 10 分钟内被不同门店录入 > 3 次，**仅记录告警**（帮助审核员识别异常模式）
- [ ] **AC5.4**: 后端提供风控告警查询 API（`GET /admin/risk-alerts`），审核员可按严重程度/状态筛选，快速定位需优先处理的记录
- [ ] **AC5.5**: 审核页面可关联显示告警信息（通过 `related_record_id` 关联 `consumption_records`），辅助审核决策

**风控策略明确**：

- **频次超限** → 直接阻断提交（429），防止恶意刷单
- **金额/关联异常** → 允许提交，但告警提示审核员"这单需要更严格复核"
- **不存在"自动通过"**：所有记录（含低风险单）都必须走人工审核流程

#### 6. 二维码防复用验证（P0，必选）

> **修订说明**：基于真实数据库查询，同一二维码8分钟内被提交9次的情况已真实发生，这是硬风险。
>
> **项目未上线策略**：直接废弃旧永久码（v1），仅实现动态身份码 v2，无需兼容逻辑，代码更简洁。

- [ ] **AC6.1**: **统一身份二维码为唯一格式（动态身份码 v2）**：二维码 payload 必须包含 `user_uuid + exp(5分钟) + nonce(一次性) + 签名`
- [ ] **AC6.2**: 提交消费接口**仅接收一个字段 `qr_code`**（仅支持 v2 格式），服务端验证 `exp/nonce/签名`
- [ ] **AC6.3**: 动态码使用后立即失效（服务端存 `nonce` 到 Redis，TTL=5分钟，`SET NX EX` 原子防重放）；检测到重放返回 409 `REPLAY_DETECTED`
- [ ] **AC6.4**: **旧永久码（v1 `QR_...`）直接拒绝**：服务端检测到 v1 格式直接返回 400 `INVALID_QRCODE_FORMAT`，错误消息："二维码格式不支持，请刷新获取最新二维码"
- [ ] **AC6.5**: **删除所有 v1 永久码生成与验证逻辑**：`utils/QRCodeValidator.js` 仅保留 v2 动态码方法，清理历史代码

---

# 二维码防复用验证方案

> **文档状态**: 分析报告 + 落地方案  
> **创建时间**: 2026年1月11日  
> **基于**: 当前后端代码实际实现 + 真实数据库只读查询结果

---

## 一、问题背景

### 1.1 原始需求（P3 可选）

- （已升级）本方案将“短期会话码”收敛为 **统一的动态身份二维码 v2**（`qr_code` 一种格式），其 payload 必须包含 `exp + nonce`，并通过 Redis 一次性校验防重放

### 1.2 核心风险描述

**当前永久身份码可被拍照复用，缺少防重放机制。**

---

## 二、现状分析（基于真实代码与数据库）

> **验证方式**: 2026年1月11日真实数据库直连只读查询 + 代码静态分析  
> **数据库**: 当前配置的生产/测试环境（通过 `.env` 连接）

### 2.1 真实数据库现状（关键事实）

| 维度                  | 查询结果                                                                                     | 对方案的影响                                      |
| --------------------- | -------------------------------------------------------------------------------------------- | ------------------------------------------------- |
| **门店数据**          | `stores` 表 **0 行**（表存在但无数据）                                                       | ⚠️ "门店维度隔离"当前无业务落点，需先补数据       |
| **消费记录门店字段**  | `consumption_records` 表**无 `store_id` 字段**                                               | ✅ 确认需要迁移（方案提到的字段不存在是对的）     |
| **员工门店关系表**    | `store_staff` 表**不存在**                                                                   | ✅ 确认需要新建（但设计有缺陷，见下文修正）       |
| **审计日志表**        | `merchant_operation_logs` 表**不存在**                                                       | ⚠️ 需明确是否复用现有 `admin_operation_logs`      |
| **风控告警表**        | `risk_alerts` 表**不存在**                                                                   | ✅ 确认需要新建                                   |
| **二维码重放证据**    | 同一 `qr_code` 在 **8分钟内被提交9次**（真实数据存在）                                       | 🔴 **硬风险**，P0级优先修复                       |
| **消费记录提交者**    | `merchant_id` 主要是 `role_level=100` 的 **admin 用户**                                      | ⚠️ 当前不是"商家员工"在用，是平台管理员           |
| **现有角色体系**      | `regional_manager / business_manager / sales_staff / ops / admin`（**无 `merchant_staff`**） | ⚠️ 需明确"商家员工"是新增主体还是现有角色权限下沉 |
| **user_hierarchy 表** | 存在 `store_id` 字段，用于"内部销售团队分派体系"                                             | ⚠️ 需明确与 `store_staff` 的关系，避免两套体系    |

### 2.2 代码层证据：二维码确实是"永久码 + 只验签名"

#### 二维码生成逻辑（`utils/QRCodeValidator.js`）

```javascript
generateQRCode(userUuid) {
  // 仅对 user_uuid 做 HMAC 签名，永不过期
  const signData = userUuid
  const signature = this._generateSignature(signData)
  const qrCode = `QR_${userUuid}_${signature}`
  return qrCode
}
```

#### 返回的有效期标记就是 `permanent`

```javascript
generateQRCodeInfo(userUuid) {
  const qrCode = this.generateQRCode(userUuid)
  return {
    qr_code: qrCode,
    user_uuid: userUuid,
    signature: this.extractSignature(qrCode),
    generated_at: BeijingTimeHelper.now(),
    algorithm: 'HMAC-SHA256',
    validity: 'permanent'  // ← 永久有效
  }
}
```

#### 验证逻辑（只验签名，不验过期/nonce）

```javascript
validateQRCode(qrCode) {
  // 仅验证签名是否正确
  const expectedSignature = this._generateSignature(userUuid)
  const isValid = signature === expectedSignature
  // 无 exp 检查、无 nonce 检查
  return { valid: isValid, ... }
}
```

### 2.3 权限层证据：提交接口**实际无权限校验**（比文档描述更危险）

**文档原描述不准确**：方案开头说"现有'商家扫码录入'功能要求 `requireAdmin`（平台管理员），导致商家员工无法使用"

**真实代码情况**：

| 接口                                     | 实际权限                                      | 风险                                              |
| ---------------------------------------- | --------------------------------------------- | ------------------------------------------------- |
| `POST /api/v4/shop/consumption/submit`   | **仅 `authenticateToken`**（无角色/权限校验） | 🔴 **任何登录用户**只要拿到二维码就能提交消费记录 |
| `GET /api/v4/shop/consumption/user-info` | `requireAdmin`                                | ✅ 确实被管理员权限卡死（方案提到的对）           |

```javascript
// routes/v4/shop/consumption/submit.js (第 55 行)
router.post('/submit', authenticateToken, async (req, res) => {
  // ❌ 无 requireAdmin / requirePermission
  // 任何通过 JWT 认证的用户都能调用
```

```javascript
// routes/v4/shop/consumption/qrcode.js (第 158 行)
router.get('/user-info', authenticateToken, requireAdmin, async (req, res) => {
  // ✅ 确实有 requireAdmin
```

**结论**：权限问题比方案描述的更严重——不是"被迫requireAdmin"，而是"完全无权限控制"。

### 2.3 当前消费链路总结

```
用户出示二维码（动态身份码 v2，含 exp+nonce）
    ↓
商家/员工扫码录入消费金额
    ↓
服务端验证二维码（签名+过期+nonce一次性）
    ↓
生成 pending 记录（consumption_records，含 store_id）
    ↓
【所有记录都进入人工审核队列】
    ↓
审核员查看记录（可按风控告警筛选高风险单）
    ↓
审核通过后发放积分/预算积分
```

**关键特性**：

- **无自动通过**：所有消费记录都是 `pending`，必须人工审核
- **风控辅助审核**：频次阻断（防刷单）+ 金额/关联告警（帮助审核员优先处理）

---

## 三、业务模式与风险模型

### 3.1 商业模式描述

- **商家**在线下实地扫描**用户**的身份二维码，提交积分审核流程
- **用户**先付钱给商家
- **商家**再付钱给平台（按"审核通过"计费）
- **平台**审核通过后，向用户发放积分/预算积分

### 3.2 经济约束下的风险分析

#### "商家自己主动不在场刷单"动机弱

如果规则是 **"先付款给平台 → 平台再审核通过发放权益"**，且 **平台发放的奖品/权益价值 < 商家付款**：

- 商家"为了让用户多拿点积分"去刷，**商家自己亏钱**，不符合常识动机
- ✅ **串通套利被经济约束压制**

#### 但"永久身份码重放风险"仍然存在

风险不只来自"商家老板主观作恶"，还来自：

| 风险来源          | 说明                                          |
| ----------------- | --------------------------------------------- |
| **权限滥用**      | 员工私存用户二维码后，日后随时可提交          |
| **误操作**        | 重复扫描、扫错用户                            |
| **账号被盗**      | 攻击者拿到商家 token + 历史永久码，可批量造单 |
| **设备丢失**      | 手机里保存的用户二维码截图被他人使用          |
| **流程/对账成本** | 系统里有 N 条提交，但店里实际只有 M 笔消费    |

### 3.3 关键事实：用户端会展示"待审核消费记录"

这意味着：

- **"假提交/误提交"会直接变成用户可见的体验问题与投诉入口**
- 用户看到一堆"待审核消费记录"，但他并没消费或金额不对，会直接投诉平台/商家
- 即使最终不付款不会通过，攻击者制造的是**用户侧信任损失 + 客服/审核工作量爆炸**

---

## 四、风险详解

### 4.1 风险如何"转嫁给商家自己"（哪怕按审核通过计费）

#### 发生了什么（机制层面）

当前提交逻辑是：**只要拿到永久身份码（二维码字符串），就能提交一条 `consumption_records` pending 记录**。

无论这笔后续会不会被审核通过、商家会不会付款：

- **这条 pending 都已经写进数据库**
- **用户端会看到**

#### 为什么这会伤到商家（不是平台）

即使商家只为"审核通过的单"付款，商家仍会承担三类实际成本：

| 成本类型                       | 具体表现                                                                                                                                            |
| ------------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------- |
| **对账/管理成本**（商家内部）  | 系统里有 N 条提交，但店里实际只有 M 笔消费。需要花时间查：哪些是员工误扫/重复提交？哪些是离店后被人拿旧二维码补录的？哪些是恶意提交（比如被盗号）？ |
| **门店运营成本**（现场与售后） | 用户拿着小程序里的 pending 记录来问："我没来过/我来过但金额不对/你们是不是把我记录刷了？" 变成店员解释、查单、安抚、甚至退钱的成本。                |
| **信誉与合作成本**（三方）     | 用户不信任商家（觉得被乱记账/被冒用）；商家不信任平台（觉得系统不严谨）；平台客服/运营介入协调（成本上升）。                                        |

**结论**：按审核通过计费确实避免了"商家白送钱"，但无法避免"提交本身造成的用户可见脏数据 + 纠纷"。

### 4.2 "账号被盗/设备丢失"为什么仍然危险

#### 当前提交门槛太低

当前门槛是：

1. 有商家端 token（或商家员工账号）
2. 有任意用户永久二维码字符串（从拍照、历史聊天、截图、打印卡、甚至员工私存）

→ 就能批量制造 pending

#### 即使最终不付款，也已经造成损害

攻击者制造的不是"平台损失"，而是：

- **用户侧信任损失**：用户看到一堆"待审核消费记录"，但他并没消费或金额不对，会直接投诉平台/商家
- **客服/审核工作量爆炸**：平台要处理"为什么我有这条记录"的咨询、申诉、拒绝审核、封禁商家账号等
- **商家被连带误伤**：商家会被用户认为"乱提交"；平台也可能临时冻结商家账号/门店提交流程，影响真实生意

> **关键洞察**：攻击不需要让审核通过，只要制造大量"用户可见的假记录"，就能造成很强的负面效果（典型的业务层 DoS / 声誉攻击）。

---

## 五、行业方案对比

### 5.1 大公司常见模式（美团/阿里/腾讯）

| 场景                           | 二维码类型        | 说明                               |
| ------------------------------ | ----------------- | ---------------------------------- |
| 身份/会员/门店/活动入口        | **永久码**        | 低风险，扫码本身不直接产生资产变动 |
| 支付、核销、下单确认、登录授权 | **动态码/短期码** | 高风险，通常几十秒到几分钟有效     |

配套机制：

- 服务端强风控：设备指纹、地理围栏、频控、黑名单、商户信誉、审计追踪
- 一次性随机数（nonce）/ 会话态
- 服务端做重放拦截

### 5.2 小公司常见模式

| 阶段                  | 做法                                                    |
| --------------------- | ------------------------------------------------------- |
| 早期（为了体验/成本） | 直接用永久码做提交（当前状态）                          |
| 出问题后补救          | 加人工审核、加频控、加"短期码/一次性码"，逐步把风险前置 |

**关键差异**：小公司往往没有大公司的全套风控，只能靠"短期码 + 业务规则 + 审核"组合拳。

### 5.3 游戏公司/活动策划常见模式

| 场景          | 做法                                                          |
| ------------- | ------------------------------------------------------------- |
| 兑换码/礼品码 | 一次性 + 服务器记账（已用即失效）                             |
| 登录二维码    | 短期 + 一次性（防截图登录）                                   |
| 活动入场      | 低价值可用永久票面码；高价值（奖品/核销）用一次性或短期滚动码 |

### 5.4 虚拟物品交易/二手平台（高风险场景）

- 基本不会让"一个永久码 = 直接成交/直接发货/直接资产变动"
- 通常是：会话态 + 订单态 + 托管/担保 + 风控
- 关键确认都"短期化/一次性化"

### 5.5 微信二维码是永久的么？

微信里确实有很多"可长期使用的二维码"（加好友、公众号、群等），但它们的共同点是：**扫码本身不直接完成可套利交易**。

一旦进入"资产/支付/登录/敏感操作"：

- 通常是**短期有效**（几十秒到几分钟）
- 通常带**一次性随机数（nonce）/会话态**
- 服务端会做**重放拦截**

**结论**："微信有永久二维码"并不能推出"交易入口也应该永久"。

---

## 六、核心概念：什么是 nonce

### 6.1 定义

**nonce（Number used once，一次性随机数）** 就是一个**"只能用一次的随机令牌"**，用来防止同一张码被截图/拍照后反复重放。

### 6.2 在本项目中如何使用

1. **用户端展示一个短期二维码**，二维码里包含：
   - `user_uuid`
   - `exp`（5分钟有效期）
   - `nonce`（一次性随机数）
   - 签名/加密防伪

2. **商家扫码提交时**把这个短期码带给后端

3. **后端做两步验证**：
   - **验真**：短期码签名正确、没过期（`exp`）
   - **验一次性**：把 `nonce` 写入 Redis，要求"只允许第一次写入成功"

```
第一次：Redis里没有这个 nonce → 写入成功 → 允许创建 pending 记录
第二次：Redis里已存在这个 nonce → 判定"重放" → 直接拒绝
```

### 6.3 直观类比

| 概念       | 类比             | 说明                                                                 |
| ---------- | ---------------- | -------------------------------------------------------------------- |
| 永久身份码 | 身份证号         | 别人拍下来，理论上可以一直拿来用来冒充"我见过这个人"                 |
| nonce      | 当场盖的一次性章 | **只在这一次有效**，别人拍下来也没用，因为系统会说"这枚章已经用过了" |

### 6.4 nonce 需要满足什么

| 要求           | 说明                                                  |
| -------------- | ----------------------------------------------------- |
| **足够随机**   | 16~32 字节随机数（不要用自增ID/时间戳当 nonce）       |
| **有有效期**   | 设定 5 分钟，Redis 也用 TTL=5分钟自动清理             |
| **服务端记账** | 必须由服务端记录"这个 nonce 已用过"，否则就无法防重放 |

---

## 七、推荐方案

### 7.1 核心结论

> **对外只保留一种“身份二维码”，但其内容必须“短期 + 一次性”（exp + nonce）**

这也是大多数成熟系统的分层思路。

### 7.2 方案设计

#### 统一方案：仅支持动态身份码 v2（项目未上线，一步到位）

- 用户二维码页面**仅展示一种二维码**：动态身份码 v2（默认 5 分钟自动刷新）
- 商家扫码流程不变：**扫一次 → 直接提交**（服务端用 `exp + nonce` 防重放）
- 后端提交接口保持 **一个入参字段**：`qr_code`
- **旧永久码（v1 `QR_{uuid}_{sig}`）不支持**：检测到 v1 格式直接返回 400 错误

**优点**：

- 从根上解决"拍照复用/重放"
- 用户体验简单（只有一种二维码）
- 商家操作流程不变（仍只扫一次）
- 技术架构清晰（无历史包袱，代码简洁）
- **项目未上线优势**：无存量旧码，直接上最优方案

### 7.3 技术实现要点

#### AC6.1：统一二维码生成（动态身份码 v2）

```
GET /api/v4/shop/consumption/qrcode
```

**调用方**：用户端（用户打开二维码页时自动刷新/手动刷新）

**返回**：

```json
{
  "qr_code": "QR2_base64(payload)_hmac",
  "exp": 1704931200,
  "nonce": "a1b2c3d4e5f6...",
  "user_uuid": "xxx",
  "generated_at": "2026-01-11T10:00:00+08:00"
}
```

**签名方式**（已拍板：仅自定义 HMAC，无 JWT 分支）：

| 方案        | 说明                                                                                                |
| ----------- | --------------------------------------------------------------------------------------------------- |
| 自定义 HMAC | `QR2_{base64(payload)}_{hmac}`，服务端使用独立密钥 `CONSUMPTION_QR_SECRET`（避免复用 `JWT_SECRET`） |

#### AC6.2：提交消费时验证 v2 动态码（统一字段 `qr_code`）

**接口层兼容**：

- 保持现有 `qr_code` 参数不变（但其内容升级为 v2 动态码）

**服务端策略**（项目未上线，无需兼容逻辑）：

```javascript
// 验证 qr_code（仅支持 v2 格式：QR2_...）
function validateQRCodeV2(qrCode) {
  // 1. 格式检查：必须是 v2 格式
  if (!qrCode.startsWith('QR2_')) {
    throw new ValidationError('INVALID_QRCODE_FORMAT', '二维码格式不支持，请刷新获取最新二维码')
  }

  // 2. 解析 payload，提取 user_uuid + exp + nonce
  const payload = parseQRCodePayload(qrCode)

  // 3. 验证签名（HMAC）
  if (!verifySignature(payload, qrCode)) {
    throw new ValidationError('INVALID_SIGNATURE', '二维码签名验证失败')
  }

  // 4. 验证未过期（exp > 当前时间）
  if (Date.now() > payload.exp) {
    throw new ValidationError('QRCODE_EXPIRED', '二维码已过期，请刷新后重试')
  }

  // 5. 验证 nonce 一次性（Redis SET NX EX，原子性防重放）
  const nonceKey = `consumption:nonce:${payload.nonce}`
  const isFirstUse = await redis.set(nonceKey, '1', 'EX', 300, 'NX')

  if (!isFirstUse) {
    throw new ValidationError('REPLAY_DETECTED', '二维码已使用，请刷新后重试', 409)
  }

  // 所有验证通过，返回用户信息
  return { user_uuid: payload.user_uuid }
}
```

**关键优势**（项目未上线）：

- **无向后兼容代码**：不需要判断 v1/v2 版本，代码逻辑简洁
- **一步到位安全**：从第一个用户开始就是最安全的方案
- **测试覆盖更简单**：只需测试 v2 路径，无需测试兼容分支

#### AC6.3：临时码用后立即失效

**Redis Key 设计**（统一命名）：

```
consumption:nonce:{nonce}
```

**Value**（用于审计与排障）：

```json
{
  "user_uuid": "xxx",
  "used_at": "2026-01-11T10:00:05+08:00",
  "merchant_id": 123,
  "idempotency_key": "xxx"
}
```

**判定规则**：

```javascript
// 使用 SET NX EX 保证原子性
const result = await redis.set(
  `consumption:nonce:${nonce}`,
  JSON.stringify(value),
  'EX',
  300, // TTL=5分钟
  'NX' // 仅当不存在时才设置
)

if (result === 'OK') {
  // nonce 首次使用，继续创建消费记录
} else {
  // 已存在，判定"重放"
  return res.status(409).json({ code: 'REPLAY_DETECTED', message: '二维码已使用，请刷新后重试' })
}
```

---

## 八、预期收益

| 维度         | 当前状态                      | 实施后                     |
| ------------ | ----------------------------- | -------------------------- |
| 重放防护     | ❌ 无                         | ✅ nonce 一次性 + exp 过期 |
| 脏数据控制   | ⚠️ 依赖人工审核               | ✅ 在提交层自动拦截        |
| 纠纷成本     | 高（用户看到假 pending 投诉） | 显著降低                   |
| 商家对账成本 | 高（需人肉判断哪些是误扫）    | 显著降低                   |
| 账号被盗影响 | 可批量造单                    | 仅能造 5 分钟窗口内的单    |
| 技术债务     | 旧码兼容逻辑复杂              | ✅ 完全废弃旧码，架构清晰  |

---

## 九、补充建议

### 9.1 权限层补齐

当前 `/api/v4/shop/consumption/submit` 只有 `authenticateToken`，没有限制"谁可以提交消费记录"（没有商家/员工权限校验）。

**建议**：在权限层补齐"只有商家员工能录入"的校验，否则即使上了临时码，仍可能被滥用（只是把滥用窗口从永久缩短到 5 分钟）。

### 9.2 用户侧确认（可选增强）

对于高价值订单,可引入"用户侧确认"作为第二道闸：

- 商家提交后，给用户发一条小程序通知/站内消息
- 用户在 X 分钟内确认"门店+金额"
- 未确认则保持高风险/自动拒绝或必须人工复核

这比单纯加风控规则更能直接对齐"用户确实到场且金额真实"。

### 9.3 幂等键策略确认（已拍板）

**✅ 最终决策**（2026年1月12日）：**继续保持强制 `Idempotency-Key`（P0必选）**

**理由**：

- 商家端是自家可控客户端（小程序/自家App），**不开放第三方接入**
- 多门店多人多设备环境 + 必须可追责，**更怕脏数据**（重复提交造成用户可见 pending + 审核压力 + 对账灾难）
- 结合二维码一次性 nonce 体系，弱网重试场景更需要幂等来"兜住重试"

**接入方规范**：

1. **商家端生成**：提交前生成幂等键（建议格式：`<device_id>_<timestamp>_<random>`，如 `iphone12_1673456789000_a1b2c3`）
2. **本地持久化**：写入 localStorage/AsyncStorage，在收到明确成功/失败响应前，**所有重试必须使用同一个幂等键**
3. **响应后清除**：
   - 收到 200/201（成功）→ 清除本地幂等键，下次提交生成新键
   - 收到 409（已提交，幂等键冲突）→ 清除本地键，提示用户"该笔消费已提交，请勿重复操作"
   - 收到 400/500（其他错误）→ 可选择清除或保留（取决于是否允许重试）
4. **服务端校验**：
   - 缺失 `Idempotency-Key` Header → 直接 400
   - DB 有 `idempotency_key` 唯一约束 → 兜底防重复写
   - 审计日志记录幂等键 → 追溯重试行为

**不提供SDK**：商家端为自家开发，无需对外开放 SDK/接入规范。

---

## 十、总结

### 核心原则

> **统一动态身份码 v2，完全废弃旧永久码 v1**

### 技术方案

| 场景             | 方案                                         |
| ---------------- | -------------------------------------------- |
| 用户出示身份     | 统一动态身份码 v2（exp + nonce，5 分钟有效） |
| 商家扫码提交消费 | 验证 v2 动态码（签名+过期+nonce 一次性）     |
| 旧永久码（v1）   | **完全废弃**，提交时直接拒绝并返回明确错误   |

### 为什么这样设计

- **不增加用户操作复杂度**：仍然只扫一次
- **不破坏现有商业流程**：商家操作链路不变
- **把风险前置**：在系统层自动拦截重放，而不是靠审核人工识别
- **减少纠纷**：用户不会看到"假 pending"，商家不用花时间对账"哪些是误扫"
- **技术架构清晰**：无历史包袱，代码逻辑简洁

---

## 附录：相关代码位置

| 文件                                   | 说明                              |
| -------------------------------------- | --------------------------------- |
| `routes/v4/shop/consumption/qrcode.js` | 二维码生成接口                    |
| `routes/v4/shop/consumption/submit.js` | 消费提交接口                      |
| `utils/QRCodeValidator.js`             | 二维码生成与验证工具类            |
| `services/ConsumptionService.js`       | 消费业务逻辑                      |
| `models/ConsumptionRecord.js`          | 消费记录模型                      |
| `utils/UnifiedRedisClient.js`          | Redis 客户端（可用于 nonce 存储） |

### 技术验收标准

#### 数据库层面

- [ ] **TS1.1**: 所有新增表/字段必须有完整的注释（中英文）
- [ ] **TS1.2**: 所有外键关联必须声明 `ON DELETE` 和 `ON UPDATE` 策略
- [ ] **TS1.3**: 所有查询必须有索引支持（`EXPLAIN` 验证，type 不能为 ALL）
- [ ] **TS1.4**: 数据库迁移脚本必须可回滚（提供 `up` 和 `down` 方法）
- [ ] **TS1.5**: 时间字段统一使用北京时间（GMT+8），注释明确标注时区

#### 后端服务层面

- [ ] **TS2.1**: 所有权限检查必须在路由层完成（`requirePermission()`），不得在服务层判断
- [ ] **TS2.2**: 所有写操作必须在事务内执行（`TransactionManager.execute()`）
- [ ] **TS2.3**: 所有资产变动必须有幂等键（`idempotency_key`），**✅ 强制要求 `Idempotency-Key` Header**（缺失直接 400），商家端必须在重试时复用同一个 key（本地持久化直到成功/失败落地）（2026年1月12日拍板）
- [ ] **TS2.4**: 所有审计日志必须异步记录（不阻塞主流程，catch 错误不抛出）
- [ ] **TS2.5**: 所有 API 响应必须使用统一格式（`ApiResponse.success/error`）
- [ ] **TS2.6**: 权限缓存失效必须调用 `invalidateUserPermissions()`，不得直接操作 Redis
- [ ] **TS2.7**: 所有 API 接口必须有完整的参数校验和错误处理

---

## 🗄️ 数据库设计方案

### 1. 新增表：`store_staff`（门店员工关系表，**修正版**）

> **修正说明**：原方案的 `UNIQUE (user_id, store_id, status)` 设计有严重缺陷（无法保留多次入职/离职历史，也无法保证"仅一条active"）。修正后采用：
>
> - 去掉 status 参与唯一约束（避免历史记录冲突）
> - 增加应用层+触发器保证"同一用户在同一门店仅一条active"
> - 增加 `sequence_no` 字段用于同一用户多次入职/离职的排序

**表名**: `store_staff`  
**用途**: 记录用户与门店的归属关系，支持一个用户属于多个门店（兼职/调岗场景），支持多次入职/离职历史追溯

```sql
CREATE TABLE `store_staff` (
  `id` BIGINT NOT NULL AUTO_INCREMENT COMMENT '主键ID',
  `user_id` INT NOT NULL COMMENT '员工用户ID（外键关联 users.user_id）',
  `store_id` INT NOT NULL COMMENT '门店ID（外键关联 stores.store_id）',
  `sequence_no` INT NOT NULL DEFAULT 1 COMMENT '同一用户在同一门店的入职序号（1=首次，2=第二次...）',
  `role_in_store` ENUM('staff', 'manager', 'owner') NOT NULL DEFAULT 'staff' COMMENT '门店内角色：staff-普通员工，manager-店长，owner-门店负责人',
  `status` ENUM('active', 'inactive', 'pending') NOT NULL DEFAULT 'pending' COMMENT '状态：active-在职，inactive-离职/禁用，pending-待入职',
  `joined_at` DATETIME NOT NULL COMMENT '本次入职时间（北京时间）',
  `left_at` DATETIME DEFAULT NULL COMMENT '本次离职时间（北京时间）',
  `notes` TEXT COMMENT '备注信息（如：调岗原因、离职原因等）',
  `created_by` INT DEFAULT NULL COMMENT '创建人ID（谁添加的这个员工）',
  `created_at` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间（北京时间）',
  `updated_at` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间（北京时间）',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_user_store_seq` (`user_id`, `store_id`, `sequence_no`), -- 同一用户在同一门店的每次入职有唯一序号
  KEY `idx_user_status` (`user_id`, `status`),
  KEY `idx_store_status` (`store_id`, `status`),
  KEY `idx_joined_at` (`joined_at`),
  CONSTRAINT `fk_store_staff_user` FOREIGN KEY (`user_id`) REFERENCES `users` (`user_id`) ON DELETE CASCADE ON UPDATE CASCADE,
  CONSTRAINT `fk_store_staff_store` FOREIGN KEY (`store_id`) REFERENCES `stores` (`store_id`) ON DELETE CASCADE ON UPDATE CASCADE,
  CONSTRAINT `fk_store_staff_creator` FOREIGN KEY (`created_by`) REFERENCES `users` (`user_id`) ON DELETE SET NULL ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='门店员工关系表（支持多次入职/离职历史，修正版）';

-- 触发器：保证同一用户在同一门店仅一条 active 记录（MySQL 5.7+ 支持）
DELIMITER $$
CREATE TRIGGER `before_insert_store_staff_check_active`
BEFORE INSERT ON `store_staff`
FOR EACH ROW
BEGIN
  IF NEW.status = 'active' THEN
    IF EXISTS (
      SELECT 1 FROM store_staff
      WHERE user_id = NEW.user_id
        AND store_id = NEW.store_id
        AND status = 'active'
        AND id != NEW.id
    ) THEN
      SIGNAL SQLSTATE '45000'
      SET MESSAGE_TEXT = '同一员工在同一门店已有 active 记录，请先将旧记录置为 inactive';
    END IF;
  END IF;
END$$

CREATE TRIGGER `before_update_store_staff_check_active`
BEFORE UPDATE ON `store_staff`
FOR EACH ROW
BEGIN
  IF NEW.status = 'active' AND OLD.status != 'active' THEN
    IF EXISTS (
      SELECT 1 FROM store_staff
      WHERE user_id = NEW.user_id
        AND store_id = NEW.store_id
        AND status = 'active'
        AND id != NEW.id
    ) THEN
      SIGNAL SQLSTATE '45000'
      SET MESSAGE_TEXT = '同一员工在同一门店已有 active 记录，请先将旧记录置为 inactive';
    END IF;
  END IF;
END$$
DELIMITER ;
```

**索引说明**:

- `uk_user_store_seq`: 唯一索引，保证同一用户在同一门店的每次入职有唯一序号（支持多次离职/再入职）
- `idx_user_status`: 支持"查询某用户的所有在职门店"
- `idx_store_status`: 支持"查询某门店的所有在职员工"
- `idx_joined_at`: 支持按入职时间排序/统计

**修正要点**:

1. **去掉 `status` 参与唯一约束**：避免历史记录冲突（员工多次入职/离职）
2. **增加 `sequence_no`**：同一用户在同一门店多次入职时递增（1=首次，2=第二次...）
3. **触发器保证"仅一条active"**：在插入/更新为 active 前检查是否已有 active 记录（应用层+数据库层双重保护）

---

### 2. 修改表：`consumption_records`（增加门店维度）

> **项目未上线优势**：无历史数据，`store_id` 可直接设为 NOT NULL，强制关联门店

**变更内容**: 增加 `store_id` 字段，关联门店，**强制非空**

```sql
-- 迁移脚本（up）
ALTER TABLE `consumption_records`
ADD COLUMN `store_id` INT NOT NULL COMMENT '门店ID（外键关联 stores.store_id，项目未上线，强制非空）' AFTER `merchant_id`,
ADD KEY `idx_store_created` (`store_id`, `created_at`),
ADD KEY `idx_merchant_store` (`merchant_id`, `store_id`, `created_at`),
ADD CONSTRAINT `fk_consumption_store` FOREIGN KEY (`store_id`) REFERENCES `stores` (`store_id`) ON DELETE RESTRICT ON UPDATE CASCADE;

-- 迁移脚本（down，回滚）
ALTER TABLE `consumption_records`
DROP FOREIGN KEY `fk_consumption_store`,
DROP KEY `idx_store_created`,
DROP KEY `idx_merchant_store`,
DROP COLUMN `store_id`;
```

**关键差异**（对比已上线项目）：

- **NOT NULL 约束**：从第一条消费记录开始就必须关联门店，避免"空值历史数据"问题
- **无数据迁移脚本**：省略复杂的历史数据回填逻辑
- **外键 ON DELETE RESTRICT**：防止误删门店导致消费记录孤立

**索引说明**:

- `idx_store_created`: 支持"按门店查询消费记录（按时间倒序）"
- `idx_merchant_store`: 支持"查询某员工在某门店的操作记录"（审计/统计场景）

---

### 3. 新增表：`merchant_operation_logs`（商家域审计日志）

> **实用主义建议**：当前项目已有完整的审计日志体系（`AuditLogService` + `admin_operation_logs`）。建议先评估是否可以**复用现有表**（通过增加 `operation_domain='merchant'` 字段区分）。如确需独立表，再按下方设计新建。

**表名**: `merchant_operation_logs`  
**用途**: 记录商家员工的所有操作（扫码、录入、查询等），独立于平台管理员日志

**复用现有表的最小改动方案**（推荐优先考虑）：

```sql
-- 在现有 admin_operation_logs 表增加字段
ALTER TABLE `admin_operation_logs`
ADD COLUMN `operation_domain` ENUM('admin', 'merchant', 'user') NOT NULL DEFAULT 'admin' COMMENT '操作域：admin-平台管理，merchant-商家，user-用户' AFTER `operation_type`,
ADD COLUMN `store_id` INT DEFAULT NULL COMMENT '关联门店ID（商家域专用）' AFTER `operator_id`,
ADD KEY `idx_domain_store` (`operation_domain`, `store_id`, `created_at`);
```

**如需独立表，则按此设计**：

```sql
CREATE TABLE `merchant_operation_logs` (
  `log_id` BIGINT NOT NULL AUTO_INCREMENT COMMENT '日志ID（主键）',
  `operator_id` INT NOT NULL COMMENT '操作人ID（员工user_id）',
  `store_id` INT DEFAULT NULL COMMENT '操作所属门店ID',
  `operation_type` ENUM('scan_user', 'create_consumption', 'query_consumption', 'query_store_stats') NOT NULL COMMENT '操作类型',
  `target_type` VARCHAR(50) DEFAULT NULL COMMENT '操作对象类型（如：User、ConsumptionRecord）',
  `target_id` BIGINT DEFAULT NULL COMMENT '操作对象ID',
  `action` VARCHAR(100) NOT NULL COMMENT '具体动作（如：scan_qrcode、submit_consumption）',
  `request_id` VARCHAR(100) DEFAULT NULL COMMENT '请求追踪ID（关联API请求）',
  `idempotency_key` VARCHAR(100) DEFAULT NULL COMMENT '幂等键（如有）',
  `ip_address` VARCHAR(45) DEFAULT NULL COMMENT '操作IP地址',
  `user_agent` TEXT COMMENT '用户代理（浏览器/设备信息）',
  `request_params` JSON DEFAULT NULL COMMENT '请求参数（脱敏后）',
  `response_code` VARCHAR(50) DEFAULT NULL COMMENT '响应码（SUCCESS、FORBIDDEN等）',
  `response_message` TEXT COMMENT '响应消息',
  `execution_time_ms` INT DEFAULT NULL COMMENT '执行耗时（毫秒）',
  `created_at` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '操作时间（北京时间）',
  PRIMARY KEY (`log_id`),
  KEY `idx_operator_time` (`operator_id`, `created_at`),
  KEY `idx_store_time` (`store_id`, `created_at`),
  KEY `idx_operation_type` (`operation_type`, `created_at`),
  KEY `idx_request_id` (`request_id`),
  KEY `idx_target` (`target_type`, `target_id`),
  CONSTRAINT `fk_merchant_log_operator` FOREIGN KEY (`operator_id`) REFERENCES `users` (`user_id`) ON DELETE CASCADE ON UPDATE CASCADE,
  CONSTRAINT `fk_merchant_log_store` FOREIGN KEY (`store_id`) REFERENCES `stores` (`store_id`) ON DELETE SET NULL ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='商家域操作审计日志（如复用现有表则不需要此表）';
```

**索引说明**:

- `idx_operator_time`: 支持"查询某员工的操作历史"
- `idx_store_time`: 支持"查询某门店的操作历史"
- `idx_operation_type`: 支持"按操作类型统计/查询"
- `idx_request_id`: 支持全链路追踪（关联API日志）

---

### 4. 修改表：`roles`（补齐商家域角色）

**变更内容**: 新增 `merchant_staff` 角色及其权限配置

```sql
-- 插入商家员工角色
INSERT INTO `roles` (
  `role_name`,
  `role_level`,
  `permissions`,
  `is_active`,
  `description`
) VALUES (
  'merchant_staff',
  50,
  JSON_OBJECT(
    'consumption', JSON_ARRAY('scan_user', 'create', 'read_self'),
    'stores', JSON_ARRAY('read'),
    'profile', JSON_ARRAY('read', 'update')
  ),
  1,
  '商家员工角色：可扫码录入消费、查看本门店数据'
);

-- 插入商家店长角色（可选，权限更高）
INSERT INTO `roles` (
  `role_name`,
  `role_level`,
  `permissions`,
  `is_active`,
  `description`
) VALUES (
  'merchant_manager',
  55,
  JSON_OBJECT(
    'consumption', JSON_ARRAY('scan_user', 'create', 'read_store', 'update', 'delete'),
    'stores', JSON_ARRAY('read', 'update'),
    'staff', JSON_ARRAY('read'),
    'profile', JSON_ARRAY('read', 'update')
  ),
  1,
  '商家店长角色：可管理本门店员工和消费记录'
);
```

**权限能力说明**:

| 能力键                   | 能力值 | 说明                                  |
| ------------------------ | ------ | ------------------------------------- |
| `consumption:scan_user`  | -      | 扫码获取用户信息（调用 `/user-info`） |
| `consumption:create`     | -      | 提交消费记录（调用 `/submit`）        |
| `consumption:read_self`  | -      | 查询自己录入的消费记录                |
| `consumption:read_store` | -      | 查询本门店所有消费记录（店长权限）    |
| `consumption:update`     | -      | 修改消费记录（店长权限）              |
| `consumption:delete`     | -      | 删除消费记录（店长权限）              |
| `stores:read`            | -      | 查看门店信息                          |
| `stores:update`          | -      | 修改门店信息（店长权限）              |
| `staff:read`             | -      | 查看员工列表（店长权限）              |

---

### 5. 权限矩阵表（最终拍板版）

> **核心原则**（2026年1月12日拍板）：
>
> - **录入操作主体**：商家店员/店长在门店录入（非平台代录）
> - **可追责性要求**：全链路可追溯（谁扫的、谁提交的、属于哪个门店）
> - **业务规模**：多门店多人多设备（需完整员工生命周期管理）

| 角色                               | role_level | 扫码查用户<br>(`/user-info`) | 提交消费<br>(`/submit`)  | 查询消费记录            | 审核消费<br>(`/review`) | 员工管理    | 门店管理    | 数据范围                 |
| ---------------------------------- | ---------- | ---------------------------- | ------------------------ | ----------------------- | ----------------------- | ----------- | ----------- | ------------------------ |
| **admin**                          | 100        | ✅ 可用                      | ✅ 可用<br>（兜底/应急） | ✅ 全部门店             | ✅ 可审核               | ✅ 全部     | ✅ 全部     | **全局**                 |
| **ops**                            | 100        | ✅ 可用                      | ✅ 可用<br>（兜底/应急） | ✅ 全部门店             | ✅ 可审核               | ✅ 全部     | ✅ 全部     | **全局**                 |
| **regional_manager**               | 80         | ✅ 可用                      | ✅ 可用                  | ✅ 跨门店<br>（区域内） | ❌ 不可                 | ✅ 区域内   | ✅ 区域内   | **区域**                 |
| **merchant_manager**<br>（店长）   | 55         | ✅ 可用                      | ✅ 可用                  | ✅ 本门店全部           | ❌ 不可                 | ✅ 本店员工 | ✅ 本店信息 | **本门店**               |
| **merchant_staff**<br>（商家员工） | 50         | ✅ 可用                      | ✅ 可用                  | ✅ 自己录入的           | ❌ 不可                 | ❌ 不可     | ❌ 不可     | **本门店<br>（仅自己）** |

**关键说明**：

1. **提交消费（`/submit`）**：
   - ✅ **P0 强制收口**：必须有 `consumption:create` 能力（不再是"任意登录用户"）
   - 商家员工/店长：日常录入
   - 管理员/ops：兜底/应急/排障使用（兼容当前 DB 事实：现在确实是 admin/ops 在用）

2. **扫码查用户（`/user-info`）**：
   - ✅ **P0 放开管理员限制**：从 `requireAdmin` 改为 `requirePermission('consumption:scan_user')`
   - 所有授权角色都可用（含商家员工）

3. **审核消费（`/review`）**：
   - ✅ **保持管理员专用**：仅 admin/ops 可审核（这是你的业务模式）

4. **数据范围自动隔离**：
   - 商家员工/店长：自动按 `store_staff` 绑定的门店过滤数据
   - 区域经理：按 `user_hierarchy` 区域过滤
   - 管理员/ops：无限制（全局视图）

5. **可追责性保证**：
   - 所有操作记录到 `merchant_operation_logs`（operator_id + store_id + timestamp + ip + ua）
   - 消费记录强制关联 `merchant_id`（谁提交的）+ `store_id`（哪个门店）
   - WebSocket/审计日志全链路可追溯

---

### 5. 新增表：`risk_alerts`（风控告警记录，可选）

**表名**: `risk_alerts`  
**用途**: 记录触发风控规则的异常事件，供人工复核

```sql
CREATE TABLE `risk_alerts` (
  `alert_id` BIGINT NOT NULL AUTO_INCREMENT COMMENT '告警ID（主键）',
  `alert_type` ENUM('frequency_limit', 'amount_limit', 'duplicate_user', 'suspicious_pattern') NOT NULL COMMENT '告警类型',
  `severity` ENUM('low', 'medium', 'high', 'critical') NOT NULL DEFAULT 'medium' COMMENT '严重程度',
  `operator_id` INT DEFAULT NULL COMMENT '触发告警的操作人ID',
  `store_id` INT DEFAULT NULL COMMENT '涉及门店ID',
  `target_user_id` INT DEFAULT NULL COMMENT '涉及用户ID',
  `related_record_id` BIGINT DEFAULT NULL COMMENT '关联消费记录ID',
  `rule_name` VARCHAR(100) NOT NULL COMMENT '触发的风控规则名称',
  `rule_threshold` VARCHAR(100) DEFAULT NULL COMMENT '规则阈值（如：10次/分钟）',
  `actual_value` VARCHAR(100) DEFAULT NULL COMMENT '实际值（如：15次/分钟）',
  `alert_message` TEXT NOT NULL COMMENT '告警消息',
  `status` ENUM('pending', 'confirmed', 'ignored', 'resolved') NOT NULL DEFAULT 'pending' COMMENT '处理状态',
  `reviewed_by` INT DEFAULT NULL COMMENT '复核人ID',
  `reviewed_at` DATETIME DEFAULT NULL COMMENT '复核时间（北京时间）',
  `review_notes` TEXT COMMENT '复核备注',
  `created_at` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '告警时间（北京时间）',
  PRIMARY KEY (`alert_id`),
  KEY `idx_type_status` (`alert_type`, `status`, `created_at`),
  KEY `idx_operator` (`operator_id`, `created_at`),
  KEY `idx_store` (`store_id`, `created_at`),
  KEY `idx_severity` (`severity`, `status`),
  CONSTRAINT `fk_alert_operator` FOREIGN KEY (`operator_id`) REFERENCES `users` (`user_id`) ON DELETE SET NULL ON UPDATE CASCADE,
  CONSTRAINT `fk_alert_store` FOREIGN KEY (`store_id`) REFERENCES `stores` (`store_id`) ON DELETE SET NULL ON UPDATE CASCADE,
  CONSTRAINT `fk_alert_reviewer` FOREIGN KEY (`reviewed_by`) REFERENCES `users` (`user_id`) ON DELETE SET NULL ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='风控告警记录表（记录异常事件供人工复核）';
```

---

## 🔧 后端服务层改造方案

### 1. 员工门店绑定查询服务（新增 `getUserStores` 方法）

**文件**: `middleware/auth.js`  
**用途**: 查询员工的 active 门店列表，供权限范围控制使用

```javascript
/**
 * 查询用户所属门店（方案2：基于 store_staff 表）
 * @param {number} user_id - 用户ID
 * @returns {Promise<Array>} 门店列表 [{store_id, role_in_store, joined_at}, ...]
 */
async function getUserStores(user_id) {
  const { StoreStaff } = require('../models')
  const stores = await StoreStaff.findAll({
    where: { user_id, status: 'active' },
    attributes: ['store_id', 'role_in_store', 'joined_at'],
    order: [['joined_at', 'DESC']] // 最新入职的排前面
  })
  return stores.map(s => ({
    store_id: s.store_id,
    role: s.role_in_store,
    joined_at: s.joined_at
  }))
}
```

**关键逻辑**：

- 只返回 `status='active'` 的门店（离职/禁用的不返回）
- 返回 `role_in_store`，用于后续判断是否为店长（店长可看本店所有记录）
- 按入职时间倒序，方便取"最新门店"作为默认值

---

### 2. 权限中间件增强（`middleware/auth.js`）

**新增中间件**: `requirePermission(capability, scope)`

```javascript
/**
 * 权限能力检查中间件（基于 roles.permissions JSON）
 * @param {string} capability - 能力键（如：'consumption:create'）
 * @param {string} scope - 数据范围（可选：'self'、'store'、'all'）
 * @returns {Function} Express中间件
 */
function requirePermission(capability, scope = 'all') {
  return async (req, res, next) => {
    try {
      const userId = req.user.user_id
      const userPermissions = await getUserRoles(userId) // 已有方法，返回 { roles, permissions }

      // 解析能力键（如：'consumption:create' -> domain='consumption', action='create'）
      const [domain, action] = capability.split(':')

      // 检查权限（支持通配符 '*'）
      const domainPerms = userPermissions.permissions[domain] || []
      const hasPermission = domainPerms.includes('*') || domainPerms.includes(action)

      if (!hasPermission) {
        logger.warn('权限不足', { user_id: userId, capability, scope })
        return res.apiError(
          `权限不足：需要 ${capability} 权限`,
          'FORBIDDEN',
          { required_capability: capability },
          403
        )
      }

      // 如果需要 scope 检查（如：'store' 范围），则验证用户是否属于该门店
      if (scope === 'store') {
        const storeId = req.params.store_id || req.query.store_id || req.body.store_id
        if (storeId) {
          const userStores = await getUserStores(userId) // 新方法，查询 store_staff
          if (!userStores.some(s => s.store_id === parseInt(storeId))) {
            return res.apiError('无权访问该门店数据', 'FORBIDDEN', null, 403)
          }
        }
      }

      next()
    } catch (error) {
      logger.error('权限检查失败', { error: error.message })
      return res.apiError('权限检查失败', 'INTERNAL_ERROR', null, 500)
    }
  }
}

/**
 * 查询用户所属门店（新增方法）
 * @param {number} user_id - 用户ID
 * @returns {Promise<Array>} 门店列表
 */
async function getUserStores(user_id) {
  const { StoreStaff } = require('../models')
  const stores = await StoreStaff.findAll({
    where: { user_id, status: 'active' },
    attributes: ['store_id', 'role_in_store']
  })
  return stores.map(s => ({ store_id: s.store_id, role: s.role_in_store }))
}

module.exports = {
  authenticateToken,
  requireAdmin,
  requireRole,
  requirePermission, // 新增导出
  getUserRoles,
  getUserStores, // 新增导出
  invalidateUserPermissions
}
```

**完整代码示例**（含门店范围校验）:

```javascript
function requirePermission(capability, scope = 'all') {
  return async (req, res, next) => {
    try {
      const userId = req.user.user_id
      const userPermissions = await getUserRoles(userId)

      const [domain, action] = capability.split(':')
      const domainPerms = userPermissions.permissions[domain] || []
      const hasPermission = domainPerms.includes('*') || domainPerms.includes(action)

      if (!hasPermission) {
        return res.apiError(
          `权限不足：需要 ${capability} 权限`,
          'FORBIDDEN',
          { required_capability: capability },
          403
        )
      }

      // 门店范围校验（scope='store' 时）
      if (scope === 'store') {
        const storeId = req.params.store_id || req.query.store_id || req.body.store_id
        if (storeId) {
          const userStores = await getUserStores(userId)
          const hasStoreAccess = userStores.some(s => s.store_id === parseInt(storeId))

          if (!hasStoreAccess && req.user.role_level < 100) {
            return res.apiError(
              '无权访问该门店数据',
              'FORBIDDEN',
              { store_id: storeId, user_stores: userStores.map(s => s.store_id) },
              403
            )
          }
        }
      }

      next()
    } catch (error) {
      logger.error('权限检查失败', { error: error.message })
      return res.apiError('权限检查失败', 'INTERNAL_ERROR', null, 500)
    }
  }
}
```

---

### 3. 路由层改造（`routes/v4/shop/consumption/*.js`）

**修改文件**: `routes/v4/shop/consumption/qrcode.js`

```javascript
// 修改前（第 158 行）
router.get('/user-info', authenticateToken, requireAdmin, async (req, res) => {

// 修改后
const { requirePermission } = require('../../../../middleware/auth')
router.get('/user-info', authenticateToken, requirePermission('consumption:scan_user'), async (req, res) => {
```

**修改文件**: `routes/v4/shop/consumption/submit.js`

```javascript
// 修改前（第 55 行）
router.post('/submit', authenticateToken, async (req, res) => {

// 修改后
const { requirePermission } = require('../../../../middleware/auth')
router.post('/submit', authenticateToken, requirePermission('consumption:create'), async (req, res) => {
```

---

### 4. 服务层改造（`services/ConsumptionService.js`）

**增强方法**: `merchantSubmitConsumption`（方案2：支持多门店场景的 store_id 自动填充）

```javascript
// 在 ConsumptionService.merchantSubmitConsumption 方法内（约第 200 行后）
static async merchantSubmitConsumption(data, options = {}) {
  const transaction = assertAndGetTransaction(options, 'ConsumptionService.merchantSubmitConsumption')

  // ... 原有验证逻辑 ...

  // 【方案2：多门店场景处理】查询员工所属门店
  const { StoreStaff } = require('../models')
  const activeStores = await StoreStaff.findAll({
    where: {
      user_id: data.merchant_id,
      status: 'active'
    },
    order: [['joined_at', 'DESC']],
    transaction
  })

  if (activeStores.length === 0) {
    throw new Error('当前用户未绑定任何门店，无法录入消费记录')
  }

  let storeId

  if (activeStores.length === 1) {
    // 单门店员工：自动填充
    storeId = activeStores[0].store_id
    logger.info(`员工单门店自动填充: store_id=${storeId}, role=${activeStores[0].role_in_store}`)
  } else {
    // 多门店员工：必须由客户端传入 store_id，服务端验证
    if (!data.store_id) {
      throw new Error('您同时负责多个门店，请选择本次操作的门店')
    }

    const hasAccess = activeStores.some(s => s.store_id === data.store_id)
    if (!hasAccess) {
      throw new Error(`您无权在门店 ${data.store_id} 录入消费记录`)
    }

    storeId = data.store_id
    logger.info(`员工多门店场景，使用客户端传入: store_id=${storeId}`)
  }

  // ... 原有幂等检查、积分计算逻辑 ...

  // 创建消费记录（增加 store_id）
  const consumptionRecord = await ConsumptionRecord.create(
    {
      business_id,
      user_id: userId,
      merchant_id: data.merchant_id,
      store_id: storeId, // 【新增】门店ID（方案2逻辑填充）
      consumption_amount: data.consumption_amount,
      points_to_award: pointsToAward,
      status: 'pending',
      qr_code: data.qr_code,
      idempotency_key,
      merchant_notes: data.merchant_notes || null,
      created_at: BeijingTimeHelper.createDatabaseTime(),
      updated_at: BeijingTimeHelper.createDatabaseTime()
    },
    { transaction }
  )

  // 【新增】记录商家域审计日志
  await logMerchantOperation({
    operator_id: data.merchant_id,
    store_id: storeId,
    operation_type: 'create_consumption',
    target_type: 'User',
    target_id: userId,
    action: 'submit_consumption',
    request_id: data.request_id, // 需要从路由层传入
    idempotency_key: data.idempotency_key,
    request_params: { consumption_amount: data.consumption_amount },
    response_code: 'SUCCESS',
    transaction
  })

  // ... 原有返回逻辑 ...
}
```

**新增方法**: `logMerchantOperation`（商家域审计日志）

```javascript
/**
 * 记录商家域操作日志（异步，不阻塞主流程）
 * @param {Object} logData - 日志数据
 * @param {Object} options - 选项（包含 transaction）
 */
async function logMerchantOperation(logData, options = {}) {
  try {
    const { MerchantOperationLog } = require('../models')
    await MerchantOperationLog.create(
      {
        operator_id: logData.operator_id,
        store_id: logData.store_id,
        operation_type: logData.operation_type,
        target_type: logData.target_type,
        target_id: logData.target_id,
        action: logData.action,
        request_id: logData.request_id,
        idempotency_key: logData.idempotency_key,
        ip_address: logData.ip_address,
        user_agent: logData.user_agent,
        request_params: logData.request_params,
        response_code: logData.response_code,
        response_message: logData.response_message,
        execution_time_ms: logData.execution_time_ms,
        created_at: BeijingTimeHelper.createDatabaseTime()
      },
      { transaction: options.transaction }
    )
  } catch (error) {
    // 审计日志失败不抛出异常（非致命错误）
    logger.warn('商家操作日志记录失败（非致命）', { error: error.message })
  }
}
```

**查询层改造**（范围控制）:

```javascript
/**
 * 查询员工可见的消费记录（方案2：按 store_staff 过滤）
 * @param {number} userId - 用户ID
 * @param {Object} options - 查询选项
 */
static async getUserConsumptionRecords(userId, options = {}) {
  const { page = 1, page_size = 20, status } = options

  // 1. 获取用户信息和角色
  const user = await User.findByPk(userId)
  const userRoles = await getUserRoles(userId) // 从 middleware/auth.js 导入

  // 2. 判断数据范围
  let whereClause = {}

  if (userRoles.role_level >= 100) {
    // 平台管理员：查看所有记录
    whereClause = status ? { status } : {}
  } else if (userRoles.role_level >= 80) {
    // 区域经理：可跨门店查询（可选：按 user_hierarchy 进一步限制）
    whereClause = status ? { status } : {}
  } else {
    // 普通员工/店长：只能查看自己负责门店的记录
    const userStores = await getUserStores(userId)
    const storeIds = userStores.map(s => s.store_id)

    if (storeIds.length === 0) {
      return { records: [], total: 0, page, page_size } // 无门店权限
    }

    // 判断是否为店长
    const isManager = userStores.some(s => s.role === 'manager')

    if (isManager) {
      // 店长：查看本门店所有记录
      whereClause = {
        store_id: { [Op.in]: storeIds },
        ...(status && { status })
      }
    } else {
      // 普通员工：只能查看自己录入的记录
      whereClause = {
        merchant_id: userId,
        store_id: { [Op.in]: storeIds },
        ...(status && { status })
      }
    }
  }

  // 3. 执行查询
  const { count, rows } = await ConsumptionRecord.findAndCountAll({
    where: whereClause,
    order: [['created_at', 'DESC']],
    limit: page_size,
    offset: (page - 1) * page_size
  })

  return {
    records: rows.map(r => r.toAPIResponse()),
    total: count,
    page,
    page_size
  }
}
```

---

### 5. 员工管理服务（新增 `services/StaffManagementService.js`）

**文件路径**: `services/StaffManagementService.js`  
**用途**: 管理员工的入职/调店/禁用/查询

```javascript
const logger = require('../utils/logger').logger
const { StoreStaff, User, Store } = require('../models')
const BeijingTimeHelper = require('../utils/timeHelper')
const { invalidateUserPermissions } = require('../middleware/auth')
const { Op } = require('sequelize')

class StaffManagementService {
  /**
   * 添加员工到门店
   * @param {Object} data - 员工数据
   * @param {number} data.user_id - 员工用户ID
   * @param {number} data.store_id - 门店ID
   * @param {string} data.role_in_store - 门店内角色（staff/manager）
   * @param {number} data.operator_id - 操作人ID
   * @param {Object} options - 选项（含 transaction）
   */
  static async addStaffToStore(data, options = {}) {
    const transaction = options.transaction

    // 验证用户和门店存在
    const user = await User.findByPk(data.user_id, { transaction })
    if (!user) throw new Error('用户不存在')

    const store = await Store.findByPk(data.store_id, { transaction })
    if (!store) throw new Error('门店不存在')

    // 检查是否已存在 active 记录
    const existing = await StoreStaff.findOne({
      where: {
        user_id: data.user_id,
        store_id: data.store_id,
        status: 'active'
      },
      transaction
    })

    if (existing) {
      throw new Error('该员工已在此门店，无需重复添加')
    }

    // 创建员工记录
    const staffRecord = await StoreStaff.create(
      {
        user_id: data.user_id,
        store_id: data.store_id,
        role_in_store: data.role_in_store || 'staff',
        status: 'active',
        joined_at: BeijingTimeHelper.createDatabaseTime(),
        created_by: data.operator_id,
        created_at: BeijingTimeHelper.createDatabaseTime(),
        updated_at: BeijingTimeHelper.createDatabaseTime()
      },
      { transaction }
    )

    // 清除员工权限缓存（确保新门店权限立刻生效）
    await invalidateUserPermissions(data.user_id, '员工入职', data.operator_id)

    logger.info(`✅ 员工入职成功: user_id=${data.user_id}, store_id=${data.store_id}`)

    return staffRecord
  }

  /**
   * 调店（员工从旧门店转到新门店）
   * @param {Object} data - 调店数据
   * @param {number} data.user_id - 员工ID
   * @param {number} data.from_store_id - 原门店ID
   * @param {number} data.to_store_id - 新门店ID
   * @param {string} data.notes - 调店原因
   * @param {number} data.operator_id - 操作人ID
   * @param {Object} options - 选项（含 transaction）
   */
  static async transferStaff(data, options = {}) {
    const transaction = options.transaction

    // 1. 将旧门店记录置为 inactive
    const oldRecord = await StoreStaff.findOne({
      where: {
        user_id: data.user_id,
        store_id: data.from_store_id,
        status: 'active'
      },
      transaction
    })

    if (!oldRecord) {
      throw new Error('员工不在原门店或已离职')
    }

    await oldRecord.update(
      {
        status: 'inactive',
        left_at: BeijingTimeHelper.createDatabaseTime(),
        notes: data.notes || '调岗',
        updated_at: BeijingTimeHelper.createDatabaseTime()
      },
      { transaction }
    )

    // 2. 创建新门店记录
    const newRecord = await StoreStaff.create(
      {
        user_id: data.user_id,
        store_id: data.to_store_id,
        role_in_store: oldRecord.role_in_store, // 保持原角色
        status: 'active',
        joined_at: BeijingTimeHelper.createDatabaseTime(),
        notes: `从门店 ${data.from_store_id} 调入`,
        created_by: data.operator_id,
        created_at: BeijingTimeHelper.createDatabaseTime(),
        updated_at: BeijingTimeHelper.createDatabaseTime()
      },
      { transaction }
    )

    // 3. 清除权限缓存
    await invalidateUserPermissions(data.user_id, '员工调店', data.operator_id)

    logger.info(
      `✅ 员工调店成功: user_id=${data.user_id}, from=${data.from_store_id}, to=${data.to_store_id}`
    )

    return { old: oldRecord, new: newRecord }
  }

  /**
   * 禁用员工（所有门店）
   * @param {number} userId - 员工ID
   * @param {number} operatorId - 操作人ID
   * @param {string} reason - 禁用原因
   * @param {Object} options - 选项（含 transaction）
   */
  static async disableStaff(userId, operatorId, reason, options = {}) {
    const transaction = options.transaction

    // 将该员工所有 active 记录置为 inactive
    const updated = await StoreStaff.update(
      {
        status: 'inactive',
        left_at: BeijingTimeHelper.createDatabaseTime(),
        notes: reason || '员工禁用',
        updated_at: BeijingTimeHelper.createDatabaseTime()
      },
      {
        where: {
          user_id: userId,
          status: 'active'
        },
        transaction
      }
    )

    if (updated[0] === 0) {
      throw new Error('该员工未绑定任何门店或已被禁用')
    }

    // 清除权限缓存
    await invalidateUserPermissions(userId, '员工禁用', operatorId)

    logger.info(`✅ 员工禁用成功: user_id=${userId}, 影响门店数=${updated[0]}`)

    return { affected_stores: updated[0] }
  }

  /**
   * 查询员工列表
   * @param {Object} filters - 筛选条件
   * @param {number} filters.store_id - 门店ID（可选）
   * @param {string} filters.status - 状态（可选）
   * @param {string} filters.role_in_store - 门店内角色（可选）
   * @param {number} filters.page - 页码
   * @param {number} filters.page_size - 每页数量
   */
  static async getStaffList(filters = {}) {
    const { store_id, status, role_in_store, page = 1, page_size = 20 } = filters

    const whereClause = {}
    if (store_id) whereClause.store_id = store_id
    if (status) whereClause.status = status
    if (role_in_store) whereClause.role_in_store = role_in_store

    const { count, rows } = await StoreStaff.findAndCountAll({
      where: whereClause,
      include: [
        {
          model: User,
          as: 'user',
          attributes: ['user_id', 'mobile', 'nickname']
        },
        {
          model: Store,
          as: 'store',
          attributes: ['store_id', 'store_name', 'store_code']
        }
      ],
      order: [['joined_at', 'DESC']],
      limit: page_size,
      offset: (page - 1) * page_size
    })

    return {
      staff: rows.map(s => ({
        id: s.id,
        user_id: s.user_id,
        nickname: s.user?.nickname,
        mobile: s.user?.mobile,
        store_id: s.store_id,
        store_name: s.store?.store_name,
        role_in_store: s.role_in_store,
        status: s.status,
        joined_at: s.joined_at,
        left_at: s.left_at
      })),
      total: count,
      page,
      page_size
    }
  }
}

module.exports = StaffManagementService
```

---

### 6. 风控服务（新增 `services/MerchantRiskControlService.js`）

**文件路径**: `services/MerchantRiskControlService.js`  
**设计原则**: 辅助人工审核，不改变"全员人工审核"流程

```javascript
const logger = require('../utils/logger').logger
const { ConsumptionRecord, RiskAlert, StoreStaff } = require('../models')
const { Op } = require('sequelize')
const BeijingTimeHelper = require('../utils/timeHelper')

/**
 * 商家域风控服务（辅助审核，不自动决策）
 * 职责：频次阻断（防刷单）、金额/关联告警（辅助审核员识别高风险单）
 *
 * 核心原则：所有消费记录都进入人工审核队列（pending），风控只是"前置拦截恶意 + 后置辅助审核"
 */
class MerchantRiskControlService {
  /**
   * 频次风控：检查员工提交频率（硬阻断，防止批量刷单）
   * @param {number} operator_id - 员工ID
   * @param {number} time_window_seconds - 时间窗口（秒）✅ 默认 60 秒（已确定）
   * @param {number} max_count - 最大次数 ✅ 默认 10 次（已确定）
   * @returns {Promise<Object>} { allowed: boolean, current_count: number, message: string }
   *
   * 设计说明：频次超限直接阻断提交（返回 429），防止恶意批量提交造成审核队列堵塞
   * ✅ 阈值已拍板：10 次/60 秒（2026年1月11日确定）
   */
  static async checkFrequencyLimit(operator_id, time_window_seconds = 60, max_count = 10) {
    const since = new Date(Date.now() - time_window_seconds * 1000)

    const count = await ConsumptionRecord.count({
      where: {
        merchant_id: operator_id,
        created_at: { [Op.gte]: since }
      }
    })

    if (count >= max_count) {
      logger.warn('频次风控触发', { operator_id, count, max_count, time_window_seconds })

      // 记录风控告警
      await RiskAlert.create({
        alert_type: 'frequency_limit',
        severity: 'medium',
        operator_id,
        rule_name: 'consumption_frequency_limit',
        rule_threshold: `${max_count}次/${time_window_seconds}秒`,
        actual_value: `${count}次/${time_window_seconds}秒`,
        alert_message: `员工 ${operator_id} 在 ${time_window_seconds} 秒内提交了 ${count} 次消费记录，超过限制 ${max_count} 次`,
        status: 'pending',
        created_at: BeijingTimeHelper.createDatabaseTime()
      })

      return {
        allowed: false,
        current_count: count,
        message: `操作过于频繁，请稍后再试（${time_window_seconds}秒内最多${max_count}次）`
      }
    }

    return { allowed: true, current_count: count }
  }

  /**
   * 金额告警：检查单笔/累计金额（仅告警，辅助审核员优先处理大额订单）
   * @param {number} operator_id - 员工ID
   * @param {number} amount - 本次金额
   * @param {number} single_limit - 单笔告警阈值（元）✅ 默认 5000 元（已确定）
   * @param {number} daily_limit - 日累计告警阈值（元）✅ 默认 50000 元（已确定）
   * @returns {Promise<Object>} { has_alert: boolean, message: string }
   *
   * 设计说明：
   * - 金额超限仅记录告警，不阻断提交（仍允许创建 pending 记录）
   * - 审核员在审核页面可看到"此单已触发金额告警"标识，优先/更严格复核
   * - 最终是否通过仍由审核员人工决定
   * ✅ 阈值已拍板：单笔 5000 元 / 日累计 50000 元（2026年1月11日确定）
   */
  static async checkAmountLimit(operator_id, amount, single_limit = 5000, daily_limit = 50000) {
    let hasAlert = false

    // 单笔金额检查（仅告警）
    if (amount > single_limit) {
      logger.warn('单笔金额超限告警', { operator_id, amount, single_limit })

      await RiskAlert.create({
        alert_type: 'amount_limit',
        severity: 'high',
        operator_id,
        rule_name: 'single_amount_limit',
        rule_threshold: `${single_limit}元`,
        actual_value: `${amount}元`,
        alert_message: `员工 ${operator_id} 提交单笔消费 ${amount} 元，超过告警阈值 ${single_limit} 元`,
        status: 'pending',
        created_at: BeijingTimeHelper.createDatabaseTime()
      })

      hasAlert = true
    }

    // 日累计金额检查（仅告警）
    const todayStart = BeijingTimeHelper.getTodayRange().start
    const todaySum =
      (await ConsumptionRecord.sum('consumption_amount', {
        where: {
          merchant_id: operator_id,
          created_at: { [Op.gte]: todayStart }
        }
      })) || 0

    const totalAfterThis = todaySum + amount

    if (totalAfterThis > daily_limit) {
      logger.warn('日累计金额超限告警', {
        operator_id,
        todaySum,
        amount,
        totalAfterThis,
        daily_limit
      })

      await RiskAlert.create({
        alert_type: 'amount_limit',
        severity: 'high',
        operator_id,
        rule_name: 'daily_amount_limit',
        rule_threshold: `${daily_limit}元/天`,
        actual_value: `${totalAfterThis}元/天`,
        alert_message: `员工 ${operator_id} 今日累计提交 ${totalAfterThis} 元，超过告警阈值 ${daily_limit} 元`,
        status: 'pending',
        created_at: BeijingTimeHelper.createDatabaseTime()
      })

      hasAlert = true
    }

    // 仅返回告警状态，不阻断提交
    return {
      has_alert: hasAlert,
      message: hasAlert ? '金额较大，已记录告警' : null
    }
  }

  /**
   * 关联告警：检查用户是否被多次/多店录入（仅告警，辅助审核员识别异常模式）
   * @param {number} user_id - 用户ID
   * @param {number} time_window_minutes - 时间窗口（分钟）✅ 默认 10 分钟（已确定）
   * @param {number} max_stores - 最大门店数 ✅ 默认 3 个门店（已确定）
   * @returns {Promise<Object>} { has_risk: boolean, store_count: number, message: string }
   *
   * 设计说明：
   * - 用户短时间内被多个门店录入，可能是正常（用户连续消费）或异常（重复提交/串通）
   * - 仅记录告警，不阻断提交
   * - 审核员在审核页面可看到"此用户短期内被多店录入"标识，重点核实
   * ✅ 阈值已拍板：10 分钟内 ≥3 个门店（2026年1月11日确定）
   */
  static async checkDuplicateUser(user_id, time_window_minutes = 10, max_stores = 3) {
    const since = new Date(Date.now() - time_window_minutes * 60 * 1000)

    const records = await ConsumptionRecord.findAll({
      where: {
        user_id,
        created_at: { [Op.gte]: since }
      },
      attributes: ['store_id'],
      group: ['store_id']
    })

    const storeCount = records.length

    if (storeCount >= max_stores) {
      logger.warn('用户重复录入风险', { user_id, storeCount, max_stores, time_window_minutes })

      await RiskAlert.create({
        alert_type: 'duplicate_user',
        severity: 'critical',
        target_user_id: user_id,
        rule_name: 'duplicate_user_limit',
        rule_threshold: `${max_stores}个门店/${time_window_minutes}分钟`,
        actual_value: `${storeCount}个门店/${time_window_minutes}分钟`,
        alert_message: `用户 ${user_id} 在 ${time_window_minutes} 分钟内被 ${storeCount} 个不同门店录入消费，疑似异常`,
        status: 'pending',
        created_at: BeijingTimeHelper.createDatabaseTime()
      })

      return {
        has_risk: true,
        store_count: storeCount,
        message: `该用户短时间内被多个门店录入（${storeCount}个），已触发风控告警`
      }
    }

    return { has_risk: false, store_count: storeCount }
  }
}

module.exports = MerchantRiskControlService
```

**集成到提交流程**（在 `ConsumptionService.merchantSubmitConsumption` 内调用）:

```javascript
// 在创建消费记录前，增加风控检查
const MerchantRiskControlService = require('./MerchantRiskControlService')

// 1. 频次风控（硬阻断，防止批量刷单堵塞审核队列）
const freqCheck = await MerchantRiskControlService.checkFrequencyLimit(data.merchant_id, 60, 10)
if (!freqCheck.allowed) {
  throw new Error(freqCheck.message) // 返回 429 Too Many Requests，直接拒绝
}

// 2. 金额告警（仅记录，不阻断，辅助审核员优先处理）
const amountCheck = await MerchantRiskControlService.checkAmountLimit(
  data.merchant_id,
  data.consumption_amount,
  5000,
  50000
)
if (amountCheck.has_alert) {
  logger.warn('触发金额告警（仍允许提交）', {
    merchant_id: data.merchant_id,
    amount: data.consumption_amount,
    message: amountCheck.message
  })
  // 继续提交，创建 pending 记录，审核员会看到告警标识
}

// 3. 用户关联告警（仅记录，不阻断）
const dupCheck = await MerchantRiskControlService.checkDuplicateUser(userId, 10, 3)
if (dupCheck.has_risk) {
  logger.warn('触发用户重复录入告警（仍允许提交）', {
    user_id: userId,
    store_count: dupCheck.store_count
  })
  // 继续提交，审核员会看到"此用户短期内被多店录入"提示
}

// 所有风控检查完成（频次通过，金额/关联仅告警），创建 pending 记录
// 记录进入人工审核队列，审核员根据告警信息决定是否通过
```

**审核流程说明**：

1. 商家员工提交消费 → 服务端创建 `pending` 记录
2. 风控系统同步创建告警记录（如触发）
3. 审核员在审核页面看到记录列表，告警记录会关联显示（如："⚠️ 此单触发金额告警"）
4. 审核员根据告警信息 + 业务判断，决定 `approved` 或 `rejected`
5. 无论是否有告警，都必须人工审核，不存在"自动通过"

---

## 🔌 后端 API 接口设计

### 1. 员工管理 API（方案2：完整生命周期）

**基础路径**: `/api/v4/admin/staff`

#### 1.1 查询员工列表

**接口**: `GET /api/v4/admin/staff`  
**权限要求**: `staff:read`

**请求参数**:

```json
{
  "store_id": 1, // 可选，门店ID筛选
  "status": "active", // 可选，状态筛选（active/inactive）
  "role_in_store": "manager", // 可选，门店内角色筛选（staff/manager/owner）
  "page": 1, // 页码，默认1
  "page_size": 20 // 每页条数，默认20
}
```

**响应示例**:

```json
{
  "success": true,
  "code": "SUCCESS",
  "data": {
    "staff": [
      {
        "id": 1,
        "user_id": 123,
        "nickname": "张三",
        "mobile": "13800138000",
        "store_id": 1,
        "store_name": "总店",
        "role_in_store": "staff",
        "status": "active",
        "joined_at": "2025-01-01 09:00:00",
        "left_at": null
      }
    ],
    "total": 50,
    "page": 1,
    "page_size": 20
  }
}
```

#### 1.2 添加员工到门店

**接口**: `POST /api/v4/admin/staff`  
**权限要求**: `staff:create`

**请求参数**:

```json
{
  "user_id": 123, // 必填，员工用户ID（必须已存在 users 表）
  "store_id": 1, // 必填，门店ID
  "role_in_store": "staff", // 必填，门店角色（staff/manager/owner）
  "notes": "新员工入职" // 可选，备注
}
```

**响应示例**:

```json
{
  "success": true,
  "code": "SUCCESS",
  "data": {
    "id": 1,
    "user_id": 123,
    "store_id": 1,
    "status": "active",
    "joined_at": "2026-01-11 15:00:00"
  },
  "message": "员工添加成功"
}
```

#### 1.3 调店（员工转移到新门店）

**接口**: `POST /api/v4/admin/staff/:id/transfer`  
**权限要求**: `staff:update`

**请求参数**:

```json
{
  "from_store_id": 1, // 必填，原门店ID
  "to_store_id": 2, // 必填，新门店ID
  "notes": "工作调动" // 可选，调岗原因
}
```

**响应示例**:

```json
{
  "success": true,
  "code": "SUCCESS",
  "data": {
    "old_record_id": 1,
    "new_record_id": 2,
    "transferred_at": "2026-01-11 15:00:00"
  },
  "message": "员工调店成功"
}
```

#### 1.4 禁用员工（所有门店）

**接口**: `PUT /api/v4/admin/staff/user/:user_id/disable`  
**权限要求**: `staff:update`

**请求参数**:

```json
{
  "reason": "员工离职" // 必填，禁用原因
}
```

**响应示例**:

```json
{
  "success": true,
  "code": "SUCCESS",
  "data": {
    "user_id": 123,
    "affected_stores": 2, // 影响的门店数
    "disabled_at": "2026-01-11 15:00:00"
  },
  "message": "员工已从所有门店禁用"
}
```

#### 1.5 查询员工历史（调岗/离职追溯）

**接口**: `GET /api/v4/admin/staff/user/:user_id/history`  
**权限要求**: `staff:read`

**响应示例**:

```json
{
  "success": true,
  "code": "SUCCESS",
  "data": {
    "user_id": 123,
    "nickname": "张三",
    "records": [
      {
        "id": 2,
        "store_id": 2,
        "store_name": "分店A",
        "status": "active",
        "joined_at": "2026-01-11 15:00:00",
        "left_at": null
      },
      {
        "id": 1,
        "store_id": 1,
        "store_name": "总店",
        "status": "inactive",
        "joined_at": "2025-01-01 09:00:00",
        "left_at": "2026-01-11 15:00:00",
        "notes": "工作调动"
      }
    ]
  }
}
```

### 2. 商家操作日志 API

**基础路径**: `/api/v4/admin/merchant-logs`

#### 2.1 查询操作日志

**接口**: `GET /api/v4/admin/merchant-logs`  
**权限要求**: `logs:read`

**请求参数**:

```json
{
  "store_id": 1, // 可选，门店ID筛选
  "operator_mobile": "13800138000", // 可选，员工手机号筛选
  "operation_type": "scan_user", // 可选，操作类型筛选
  "start_time": "2025-01-01 00:00:00", // 可选，开始时间
  "end_time": "2025-01-11 23:59:59", // 可选，结束时间
  "page": 1,
  "page_size": 20
}
```

**响应示例**:

```json
{
  "success": true,
  "code": "SUCCESS",
  "data": {
    "logs": [
      {
        "log_id": 1,
        "created_at": "2025-01-11 14:30:00",
        "operator_id": 123,
        "operator_name": "张三",
        "store_id": 1,
        "store_name": "总店",
        "operation_type": "create_consumption",
        "target_type": "User",
        "target_id": 456,
        "response_code": "SUCCESS",
        "ip_address": "192.168.1.100"
      }
    ],
    "total": 100,
    "page": 1,
    "page_size": 20
  }
}
```

#### 2.2 导出操作日志

**接口**: `GET /api/v4/admin/merchant-logs/export`  
**权限要求**: `logs:export`

**请求参数**: 同查询接口

**响应**: CSV 文件流

---

### 3. 风控告警 API

**基础路径**: `/api/v4/admin/risk-alerts`

#### 3.1 查询风控告警

**接口**: `GET /api/v4/admin/risk-alerts`  
**权限要求**: `risk:read`

**请求参数**:

```json
{
  "severity": "high", // 可选，严重程度筛选（low/medium/high/critical）
  "status": "pending", // 可选，状态筛选（pending/confirmed/ignored/resolved）
  "page": 1,
  "page_size": 20
}
```

**响应示例**:

```json
{
  "success": true,
  "code": "SUCCESS",
  "data": {
    "alerts": [
      {
        "alert_id": 1,
        "created_at": "2025-01-11 14:30:00",
        "alert_type": "frequency_limit",
        "severity": "high",
        "operator_id": 123,
        "store_id": 1,
        "rule_name": "consumption_frequency_limit",
        "alert_message": "员工 123 在 60 秒内提交了 15 次消费记录",
        "status": "pending"
      }
    ],
    "total": 50,
    "page": 1,
    "page_size": 20
  }
}
```

#### 3.2 复核/忽略告警

**接口**: `PUT /api/v4/admin/risk-alerts/:id`  
**权限要求**: `risk:review`

**请求参数**:

```json
{
  "status": "confirmed", // 必填，新状态（confirmed/ignored/resolved）
  "review_notes": "已确认为正常操作" // 可选
}
```

**响应示例**:

```json
{
  "success": true,
  "code": "SUCCESS",
  "message": "告警状态已更新"
}
```

---

## 📊 实施计划与里程碑

### Phase 1: 权限收口与二维码防重放（P0，1周，项目未上线加速实施）

> **核心价值**：修复当前最严重的安全风险（无权限校验 + 二维码可重放）
>
> **项目未上线优势**：无存量数据，无需兼容逻辑，直接上最优方案，实施周期从 1-2周 缩短到 **1周**

**里程碑**: 完成权限能力校验、二维码 v2 升级（仅支持 v2，不兼容 v1）

- [ ] **修复 `/submit` 无权限校验问题**：增加 `requirePermission('consumption:create')`
- [ ] **放开 `/user-info` 管理员限制**：从 `requireAdmin` 改为 `requirePermission('consumption:scan_user')`
- [ ] **✅ 手机号返回策略**：商家员工和管理员**都返回全量手机号**（不脱敏，2026年1月11日拍板）
- [ ] **插入 `merchant_staff` 角色**：role_level=50，权限包含 `consumption:scan_user` 和 `consumption:create`
- [ ] **✅ 实现二维码 v2 生成**：修改 `/qrcode` 接口**仅返回** v2 动态码（exp + nonce + **独立密钥 CONSUMPTION_QR_SECRET 签名**，不复用 JWT_SECRET，2026年1月11日拍板）
- [ ] **实现二维码 v2 验证**：修改 `/submit` 接口验证逻辑（签名+过期+nonce一次性），**v1 格式直接拒绝**
- [ ] **Redis 存储 nonce**：TTL=5分钟，SET NX EX 原子性防重放
- [ ] **清理所有 v1 永久码代码**：删除 `QRCodeValidator.js` 中 `generateQRCode`、`validity: 'permanent'` 等旧逻辑，仅保留 v2 方法
- [ ] **集成测试**：
  - 未授权用户调用 `/submit` → 返回 403
  - merchant_staff 调用 `/user-info` → 返回全量手机号
  - v2 动态码提交 → 成功，nonce失效
  - v2 码重放 → 返回 409 `REPLAY_DETECTED`
  - v1 旧码提交 → 返回 400 `INVALID_QRCODE_FORMAT`（直接拒绝）

**验收**:

- 权限漏洞修复，任意用户不能随意提交
- 二维码重放风险解决（v2码一次性）
- **代码简洁**：无 v1/v2 兼容逻辑，无灰度判断，仅一套 v2 实现

---

### Phase 2: 门店数据补齐（P1前置，3天）

> **核心价值**：为门店维度隔离打好数据基础（当前 stores=0，无法直接推进员工归属）
>
> **项目未上线优势**：无历史数据约束，可直接设计最优门店模型

**里程碑**: 补齐门店主数据，明确与 `user_hierarchy.store_id` 的关系

- [ ] **设计门店数据模型**：确认 `stores` 表字段满足需求（含 merchant_id / region / status / business_hours 等）
- [ ] **准备门店主数据**：
  - ✅ **已确定维护方式**：后台录入，平台管理员维护（2026年1月11日拍板）
  - 测试环境：至少 3-5 个门店记录（用于开发测试）
  - 生产环境：真实门店数据由平台管理员通过后台管理界面录入
- [ ] **明确门店归属体系设计决策**：
  - ✅ **已选择方案B**（2026年1月11日拍板）：新增 `store_staff` 表，与 `user_hierarchy` 分离
    - 优点：语义最清晰、权限隔离最强、支持完整的员工生命周期管理
    - 适用：商家员工和内部业务团队的门店归属逻辑不同，需要独立管理

**验收**:

- `stores` 表至少有 3 条测试数据
- 门店数据模型与业务需求对齐
- ✅ 已确定采用方案B（新增 `store_staff`）

---

### Phase 3: 组织边界与审计（P1，1.5周，依赖 Phase 2）

> **项目未上线优势**：无历史数据需要迁移，可直接按最优模型创建

**里程碑**: 完成门店员工归属、消费记录关联门店、审计日志

- [ ] **✅ 已确认审计日志方案**（2026年1月11日拍板）：新建独立的 `merchant_operation_logs` 表
- [ ] **创建 `merchant_operation_logs` 表**（语义清晰、权限隔离更容易）
- [ ] **✅ 根据已确定的方案B实施员工归属**：创建 `store_staff` 表（修正版）+ `StaffManagementService`
- [ ] **`consumption_records` 增加 `store_id` 字段**（NOT NULL，因为新系统从第一条记录就有门店）
- [ ] **`ConsumptionService` 增加 `store_id` 自动填充/校验逻辑**（✅ 已确定：单门店自动填充，多门店必传）
- [ ] **实现审计日志记录方法**（异步，不阻塞主流程）
- [ ] **后端 API：员工管理接口**（如采用方案B才需要）
- [ ] **后端 API：审计日志接口**（查询、导出）
- [ ] **权限范围控制**：普通员工/店长/区域经理的查询边界实现
- [ ] **集成测试**：
  - 单门店员工提交消费 → 自动填充 store_id → 记录审计日志
  - 多门店员工提交消费 → 选择门店 → 验证权限 → 记录审计日志
  - 禁用员工 → 权限缓存失效 → 接口返回 403

**验收**:

- 所有消费记录必须有 `store_id`（NOT NULL 约束）
- ✅ 员工门店归属清晰（已确定采用方案B: `store_staff` 表）
- 权限范围控制正确
- 所有操作有审计日志（已确定使用独立 `merchant_operation_logs` 表）

---

### Phase 4: 风控辅助审核（P2，1周）

> **项目未上线优势**：从第一个用户开始就有完整风控保护

**里程碑**: 完成规则风控告警（辅助审核员识别高风险单）

- [ ] 实现 `MerchantRiskControlService`（✅ 阈值已确定：10次/60秒、5000/50000元、3店/10分钟）
- [ ] 创建 `risk_alerts` 表
- [ ] 集成风控到消费提交流程（频次硬阻断，金额/关联仅告警）
- [ ] 后端 API：风控告警接口（查询、复核、忽略）
- [ ] 审核页面集成（前端需配合）：消费记录可关联显示告警
- [ ] 压力测试：验证频次限制触发、告警记录正确

**验收**:

- 频次风控正确阻断（429）
- 金额/关联告警仅记录不阻断，所有记录仍为 `pending`
- 告警记录可关联到具体消费记录

---

## 🎯 总实施周期（项目未上线加速版）

| Phase    | 预估时间    | 关键交付                                      |
| -------- | ----------- | --------------------------------------------- |
| Phase 1  | **1周**     | 权限收口 + 二维码 v2（无兼容代码）            |
| Phase 2  | **3天**     | 门店数据补齐 + 归属方案确定                   |
| Phase 3  | **1.5周**   | 门店隔离 + 审计（无历史数据迁移）             |
| Phase 4  | **1周**     | 风控辅助审核                                  |
| **总计** | **约 4 周** | 完整权限体系 + 二维码防重放 + 门店隔离 + 风控 |

**对比原方案**（含兼容逻辑）：总计 5-8 周 → **节省 1-4 周**

---

## 🧪 测试方案

### 单元测试

- `requirePermission()` 中间件：权限检查逻辑、scope 验证
- `MerchantRiskControlService`：频次/金额/关联检测算法
- `getUserStores()`：员工门店查询逻辑

### 集成测试

- 商家员工提交消费 → 自动关联门店 → 记录审计日志 → 触发风控
- 禁用员工 → 清除权限缓存 → 调用接口返回 403
- 平台管理员跨门店查询 → 返回所有门店数据

### 性能测试

- 并发提交消费（100 QPS）→ 验证频次限制、幂等性
- 查询审计日志（10万条数据）→ 验证索引效率（<500ms）

---

## 📚 附录

### 附录A：API接口清单（新增/修改）

| 接口路径                             | 方法 | 权限要求                | 说明                       |
| ------------------------------------ | ---- | ----------------------- | -------------------------- |
| `/api/v4/shop/consumption/user-info` | GET  | `consumption:scan_user` | 扫码获取用户信息（已修改） |
| `/api/v4/shop/consumption/submit`    | POST | `consumption:create`    | 提交消费记录（已修改）     |
| `/api/v4/admin/staff`                | GET  | `staff:read`            | 查询员工列表（新增）       |
| `/api/v4/admin/staff`                | POST | `staff:create`          | 添加员工（新增）           |
| `/api/v4/admin/staff/:id/status`     | PUT  | `staff:update`          | 更新员工状态（新增）       |
| `/api/v4/admin/merchant-logs`        | GET  | `logs:read`             | 查询商家操作日志（新增）   |
| `/api/v4/admin/merchant-logs/export` | GET  | `logs:export`           | 导出日志CSV（新增）        |
| `/api/v4/admin/risk-alerts`          | GET  | `risk:read`             | 查询风控告警（新增）       |
| `/api/v4/admin/risk-alerts/:id`      | PUT  | `risk:review`           | 复核告警（新增）           |

### 附录B：数据库迁移脚本清单（修订版，基于真实现状）

> **修订说明**：基于真实数据库验证结果（stores=0，store_staff不存在），调整迁移优先级与前置依赖

| 迁移文件                                     | 说明                                                  | 优先级     | 前置依赖     | 备注                                                                                      |
| -------------------------------------------- | ----------------------------------------------------- | ---------- | ------------ | ----------------------------------------------------------------------------------------- |
| `20250111_insert_merchant_roles.js`          | 插入商家角色配置（含权限 JSON）                       | **P0**     | 无           | `merchant_staff`/`merchant_manager`                                                       |
| `20250111_add_mobile_masking.js`             | ✅ **已废弃**（改为商家员工和管理员都返回全量手机号） | ~~**P0**~~ | 无           | **✅ 已拍板：不脱敏，2026年1月11日确定**                                                  |
| `20250111_upgrade_qrcode_v2_only.js`         | **二维码 v2 升级（仅支持 v2，删除所有 v1 代码）**     | **P0**     | 无           | **✅ 已拍板：使用独立密钥 CONSUMPTION_QR_SECRET，不复用 JWT_SECRET（2026年1月11日确定）** |
| `20250111_import_stores_data.js`             | 导入门店主数据（至少3-5条测试数据）                   | **P1前置** | 无           | ✅ 维护方式已确定：后台录入，平台管理员维护                                               |
| `20250111_create_store_staff.js`             | 创建门店员工多对多关系表（修正版）                    | **P1**     | 门店数据存在 | ✅ 已确定方案B：支持一人多店、sequence_no、触发器保证唯一active                           |
| `20250111_alter_consumption_add_store_id.js` | 消费记录增加门店字段（**NOT NULL**）                  | **P1**     | 门店数据存在 | **✅ 已拍板：项目未上线，直接 NOT NULL，强制关联门店（2026年1月11日确定）**               |
| `20250111_create_merchant_operation_logs.js` | 创建商家域审计日志表                                  | **P1**     | 无           | ✅ 已确定方案：新建独立的 `merchant_operation_logs` 表                                    |
| `20250111_create_risk_alerts.js`             | 创建风控告警表                                        | **P2**     | 无           | ✅ 阈值已确定：频次10次/60秒、金额5000/50000、关联3店/10分钟                              |

**关键修订点（项目未上线优势，已拍板决策）**：

1. **✅ 二维码方案**：直接上 v2（exp+nonce），删除所有 v1 相关代码，使用独立密钥 `CONSUMPTION_QR_SECRET`（不复用 JWT_SECRET）
2. **✅ store_id 直接 NOT NULL**：无历史数据，消费记录从第一条就强制关联门店
3. **✅ 手机号不脱敏**：商家员工和管理员都返回全量手机号
4. **✅ 门店归属体系**：新建 `store_staff` 表（方案B）
5. **✅ 审计日志**：新建独立的 `merchant_operation_logs` 表
6. **无历史数据回填脚本**：省略 `backfill_consumption_store_id.js`
7. **实施周期缩短**：从 5-8 周缩短到 **约 4 周**

### 附录C：配置项清单

| 配置项                              | 默认值       | 说明                                                                            |
| ----------------------------------- | ------------ | ------------------------------------------------------------------------------- |
| **✅ `CONSUMPTION_QR_SECRET`**      | **随机生成** | **二维码签名密钥（✅ 已拍板：独立密钥，不复用 JWT_SECRET，2026年1月11日确定）** |
| `MERCHANT_FREQUENCY_LIMIT_SECONDS`  | 60           | 频次风控时间窗口（秒），超限直接阻断                                            |
| `MERCHANT_FREQUENCY_LIMIT_COUNT`    | 10           | 频次风控最大次数，超限返回 429                                                  |
| `MERCHANT_SINGLE_AMOUNT_ALERT`      | 5000         | 单笔金额告警阈值（元），仅告警不阻断                                            |
| `MERCHANT_DAILY_AMOUNT_ALERT`       | 50000        | 日累计金额告警阈值（元），仅告警不阻断                                          |
| `MERCHANT_DUPLICATE_USER_MINUTES`   | 10           | 用户重复录入检测窗口（分钟），仅告警                                            |
| `MERCHANT_DUPLICATE_USER_STORES`    | 3            | 用户重复录入门店数告警阈值，仅告警                                              |
| `MERCHANT_AUDIT_LOG_RETENTION_DAYS` | 180          | 审计日志保留天数                                                                |
| `STAFF_MAX_STORES_PER_USER`         | 10           | 单个员工最多可绑定门店数（防止数据异常）                                        |
| `STAFF_TRANSFER_COOLDOWN_HOURS`     | 24           | 调店冷却时间（小时，防止频繁调店）                                              |

**风控策略说明**：

- **频次风控**：硬阻断（返回 429 Too Many Requests），防止批量刷单
- **金额/关联告警**：软告警（记录到 `risk_alerts`，不阻断提交），辅助审核员优先处理
- **所有记录都需人工审核**：即使未触发任何告警，也必须走 `pending` → 审核 → `approved` 流程

---

**文档结束**

如有疑问或需要进一步细化某个模块，请联系技术负责人。
