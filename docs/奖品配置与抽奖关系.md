> **文档版本**: V4.0  
> **最后更新**: 2026-01-09  
> **适用项目**: 餐厅积分抽奖系统

---

## 📋 目录

1. [核心字段关系说明](#1-核心字段关系说明)
2. [抽奖流程与影响机制](#2-抽奖流程与影响机制)
3. [概率配置必要性分析](#3-概率配置必要性分析)
4. [商业模式配置策略](#4-商业模式配置策略)
5. [常见问题与注意事项](#5-常见问题与注意事项)

---

## 1. 核心字段关系说明

### 1.1 两条独立的控制轴

在 `lottery_prizes` 表中，以下两个字段是**完全独立**的控制维度：

| 字段名               | 数据类型       | 控制维度     | 实际用途                                             |
| -------------------- | -------------- | ------------ | ---------------------------------------------------- |
| `win_probability`    | `DECIMAL(8,6)` | **发放频率** | 从"可抽中奖品池"中按权重随机选择一个奖品             |
| `prize_value_points` | `INT`          | **成本预算** | 预算过滤（决定能否被抽中）+ 预算扣减（抽中后扣预算） |

### 1.2 `win_probability`（概率）的作用

**核心功能**：权重随机抽样

```
用途 = 在"可抽中集合"中，决定每个奖品被抽到的相对频率
```

**重要规则**：

- ✅ `win_probability > 0`：奖品参与随机抽取
- ❌ `win_probability = 0`：奖品**永远不会被随机抽到**（但仍可通过保底/预设机制发放）
- ⚠️ 可抽中奖品的 `win_probability` 总和应接近 `1.0`（100%），否则实际分布会偏离预期

**代码实现位置**：

```javascript
// BasicGuaranteeStrategy.js 第 1177-1252 行
async selectPrize(prizes, user_id = null) {
  // 过滤可用奖品（概率大于0）
  let availablePrizes = prizes.filter(prize => {
    return prize.win_probability > 0 // 只有设置了中奖概率的奖品才参与抽奖
  })

  // 累计区间随机选择（权重抽样）
  const randomValue = Math.random() // 0-1 随机数
  let currentProbability = 0
  for (const prize of availablePrizes) {
    currentProbability += parseFloat(prize.win_probability)
    if (randomValue <= currentProbability) {
      return prize // 命中此奖品
    }
  }
}
```

### 1.3 `prize_value_points`（奖品价值积分）的作用

**核心功能**：预算体系控制

```
用途 1 = 预算过滤（抽奖前）：只允许抽到 prize_value_points <= 剩余预算 的奖品
用途 2 = 预算扣减（抽中后）：如果 prize_value_points > 0，扣减对应预算
```

**预算来源**（由活动的 `budget_mode` 决定）：

| `budget_mode` 值 | 预算来源                       | 过滤规则                                      | 扣减对象             |
| ---------------- | ------------------------------ | --------------------------------------------- | -------------------- |
| `user`           | 用户的 `BUDGET_POINTS` 余额    | `prize_value_points <= 用户BUDGET_POINTS`     | 用户 `BUDGET_POINTS` |
| `pool`           | 活动池 `pool_budget_remaining` | `prize_value_points <= pool_budget_remaining` | 活动池预算           |
| `none`           | 无预算限制（测试用）           | 不过滤                                        | 不扣减               |

**代码实现位置**：

```javascript
// BasicGuaranteeStrategy.js 第 1419-1582 行
async getAvailablePrizes(campaignId, userId = null, options = {}) {
  // 步骤1：查询活动所有激活的奖品
  const prizes = await LotteryPrize.findAll({ ... })

  // 步骤2：根据 budget_mode 进行预算过滤
  const budgetMode = campaign.budget_mode || 'user'

  if (budgetMode === 'user' && userId) {
    // 获取用户的 BUDGET_POINTS 余额
    const remainingBudget = await this.getUserTotalBudgetPoints(userId, ...)

    // 过滤：只保留 prize_value_points <= 剩余预算 的奖品
    filteredPrizes = prizes.filter(prize => {
      return (prize.prize_value_points || 0) <= remainingBudget
    })

    // 如果预算用完了，至少保证有空奖（prize_value_points = 0）可抽
    if (filteredPrizes.length === 0) {
      filteredPrizes = prizes.filter(p => (p.prize_value_points || 0) === 0)
    }
  }

  return filteredPrizes
}
```

### 1.4 容易混淆的字段：`prize_value` vs `prize_value_points`

| 字段名               | 用途                     | 示例                                                                |
| -------------------- | ------------------------ | ------------------------------------------------------------------- |
| `prize_value`        | 发放给用户的**奖励数量** | `prize_type='points'` 时，`prize_value=500` 表示发放 500 积分给用户 |
| `prize_value_points` | 从预算扣减的**成本积分** | `prize_value_points=400` 表示抽中此奖品会扣 400 预算积分            |

**关键区别**：

- `prize_value`：用户得到什么（奖励）
- `prize_value_points`：系统付出什么（成本）

---

## 2. 抽奖流程与影响机制

### 2.1 完整抽奖流程（非保底/非预设）

```
┌─────────────────────────────────────────────────────────────┐
│ 步骤1：确定"可抽中奖品集合"（过滤）                         │
├─────────────────────────────────────────────────────────────┤
│ 1.1 活动内 status='active' 的奖品                           │
│ 1.2 库存检查：stock_quantity > 0 或 stock_quantity = null   │
│ 1.3 每日上限：daily_win_count < max_daily_wins（如有配置）  │
│ 1.4 🔥 预算过滤（budget_mode 决定）：                       │
│     - user: prize_value_points <= 用户BUDGET_POINTS余额     │
│     - pool: prize_value_points <= 活动池剩余预算            │
│     - none: 不过滤                                          │
│ 1.5 概率过滤：win_probability > 0                           │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│ 步骤2：从"可抽中集合"中随机选择一个奖品（权重抽样）        │
├─────────────────────────────────────────────────────────────┤
│ 2.1 计算总概率 = Σ(可抽中奖品的 win_probability)            │
│ 2.2 生成随机数 randomValue ∈ [0, 1)                         │
│ 2.3 累计区间匹配：                                          │
│     当 randomValue 落在某个奖品的累计区间时，选中该奖品     │
│                                                             │
│ 示例（假设可抽中集合有3个奖品）：                           │
│   奖品A: win_probability=0.3 → 区间 [0.0, 0.3)             │
│   奖品B: win_probability=0.5 → 区间 [0.3, 0.8)             │
│   奖品C: win_probability=0.2 → 区间 [0.8, 1.0)             │
│   如果 randomValue=0.65 → 命中奖品B                         │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│ 步骤3：记账和发放                                           │
├─────────────────────────────────────────────────────────────┤
│ 3.1 扣用户抽奖成本：-100 POINTS（固定，不取 cost_points）   │
│ 3.2 扣预算（如果 prize_value_points > 0 且 budget_mode≠none）│
│     - user: 扣用户 BUDGET_POINTS                            │
│     - pool: 扣活动池 pool_budget_remaining                  │
│ 3.3 扣奖品库存：stock_quantity -= 1（如有库存限制）         │
│ 3.4 发放奖品到用户：                                        │
│     - points: 增加 prize_value 积分                         │
│     - coupon/physical: 写入 item_instances 表               │
│     - virtual: 增加材料余额（如配置 material_asset_code）   │
│ 3.5 记录抽奖历史：写入 lottery_draws 表                     │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 预算不足时的降级机制

**问题场景**：用户的 `BUDGET_POINTS = 0`，而活动有 9 个奖品，其中只有 1 个奖品的 `prize_value_points = 0`

**系统行为**：

1. 预算过滤后，只剩下 1 个奖品（`prize_value_points = 0`）
2. 用户 100% 抽中这个唯一的奖品（无论原始 `win_probability` 是多少）

**实际案例**（你的当前配置）：

```sql
-- 你的活动配置
budget_mode = 'user'
allowed_campaign_ids = ['CONSUMPTION_DEFAULT']

-- 测试用户 user_id=31 的预算状态
BUDGET_POINTS = 0

-- 奖品池配置
奖品1: 八八折       | prize_value_points=100 | win_probability=0%    → ❌ 被过滤（预算不足）
奖品2: 100积分      | prize_value_points=80  | win_probability=30%   → ❌ 被过滤（预算不足）
奖品3: 甜品1份      | prize_value_points=60  | win_probability=20%   → ❌ 被过滤（预算不足）
奖品4: 青菜1份      | prize_value_points=0   | win_probability=30%   → ✅ 唯一可抽中
奖品5: 2000积分券   | prize_value_points=150 | win_probability=1%    → ❌ 被过滤（预算不足）
...

最终结果：用户 100% 抽中"青菜1份"
```

---

## 3. 概率配置必要性分析

### 3.1 概率是否有必要设置？

**结论：有必要。** 理由如下：

#### 理由 1：它决定随机分配

在同一"可抽中集合"中，`win_probability` 是唯一决定"谁更常被抽到"的因素。

**示例**：假设预算充足，有 3 个奖品都可抽中

| 奖品      | prize_value_points | win_probability | 期望命中率 |
| --------- | ------------------ | --------------- | ---------- |
| 甜品1份   | 60                 | 0.2 (20%)       | 20%        |
| 100积分   | 80                 | 0.3 (30%)       | 30%        |
| 500积分券 | 400                | 0.18 (18%)      | 18%        |

如果不设置 `win_probability`（或全部设为相同值），就无法控制高价值奖品和低价值奖品的相对发放频率。

#### 理由 2：它还是"开关"

`win_probability = 0` 的奖品会被直接排除出随机抽取。

**应用场景**：

- **保底专用奖品**（如"九八折券"）：`win_probability=0`，只通过累计10次保底发放
- **后台预设奖品**：`win_probability=0`，只通过管理员预设队列发放
- **临时下架奖品**：无需修改 `status`，仅将 `win_probability` 改为 `0` 即可暂停随机发放

#### 理由 3：它影响预算消耗曲线（商业模型）

你的**平均每抽预算成本**由以下公式决定：

```
期望预算成本 = Σ(win_probability_i × prize_value_points_i)
```

**示例计算**（假设可抽中集合稳定）：

| 奖品       | win_probability | prize_value_points | 贡献成本  |
| ---------- | --------------- | ------------------ | --------- |
| 青菜1份    | 0.30            | 0                  | 0         |
| 甜品1份    | 0.20            | 60                 | 12        |
| 100积分    | 0.30            | 80                 | 24        |
| 500积分券  | 0.18            | 400                | 72        |
| 2000积分券 | 0.01            | 150                | 1.5       |
| **总计**   | **0.99**        | -                  | **109.5** |

**结论**：在此配置下，每抽的期望预算成本约为 **109.5 预算积分**。

如果你想降低成本（例如降到 50 预算积分/抽），可以：

- 降低高成本奖品的 `win_probability`
- 提高低成本/零成本奖品的 `win_probability`

### 3.2 非常关键的现实约束

⚠️ **概率总和问题**

当前实现假设"可抽中奖品的 `win_probability` 总和 ≈ 1.0（100%）"。

**问题场景**：

1. 你配置了 9 个奖品，总概率 = 100%
2. 但用户预算不足，预算过滤后只剩 2 个奖品，它们的概率总和 = 50%

**实际行为**：

- 如果 `randomValue ∈ [0.5, 1.0)`，会触发"备用选择"逻辑（返回最后一个奖品）
- 这会导致最后一个奖品的**实际命中率**远高于其配置的 `win_probability`

**解决方案**：

- **运营侧校验**：在配置奖品时，明确定义"不同预算阶段下的有效奖池"，并确保每个阶段的概率总和接近 100%
- **代码侧优化**（未来可选）：在预算过滤后，自动归一化剩余奖品的概率

---

## 4. 商业模式配置策略

### 4.1 两张"控制面板"

你可以把这两个字段理解成两张独立的控制面板：

| 控制面板              | 字段                 | 控制维度                 | 问题     |
| --------------------- | -------------------- | ------------------------ | -------- |
| **成本/预算消耗标尺** | `prize_value_points` | 能不能给、给了扣多少预算 | 成本可控 |
| **发放频率标尺**      | `win_probability`    | 在能给的前提下，给多少次 | 体验可控 |

### 4.2 推荐的落地策略

#### 第一步：先定预算策略（决定预算从哪里来）

根据你的商业目标选择：

| 商业目标                              | 推荐配置           | 必要操作                                                                       | 适用场景                      |
| ------------------------------------- | ------------------ | ------------------------------------------------------------------------------ | ----------------------------- |
| **每个用户成本可控 + 分层运营**       | `budget_mode=user` | 必须给目标用户发放 `BUDGET_POINTS`，否则只能抽到 `prize_value_points=0` 的奖品 | VIP用户高预算、普通用户低预算 |
| **整场活动总成本可控 + 用户不分预算** | `budget_mode=pool` | 设置活动的 `pool_budget_remaining`                                             | 限时活动、成本封顶            |
| **完全不受预算限制，只看概率**        | `budget_mode=none` | 无（仅用于测试）                                                               | 测试环境、不控成本的福利活动  |

**你的当前配置分析**：

```sql
-- 当前活动配置
SELECT campaign_id, campaign_name, budget_mode, allowed_campaign_ids
FROM lottery_campaigns WHERE campaign_id = 1;

结果：
campaign_id = 1
campaign_name = '餐厅积分抽奖'
budget_mode = 'user'
allowed_campaign_ids = ['CONSUMPTION_DEFAULT']

-- 测试用户预算
SELECT asset_code, available_amount, campaign_id
FROM account_asset_balances WHERE user_id = 31 AND asset_code = 'BUDGET_POINTS';

结果：无记录（预算为 0）
```

**结论**：你选择了 `user` 模式，但测试用户没有 `BUDGET_POINTS`，所以只能抽到 `prize_value_points=0` 的奖品（"青菜1份"）。

#### 第二步：再定概率策略（决定用户体验与成本期望）

**策略 1：定义期望成本，反推概率**

1. 确定"每抽期望预算成本"（例如 20 预算积分）
2. 列出所有奖品的 `prize_value_points`
3. 反推概率：高成本奖品 → 低概率，低成本奖品 → 高概率

**示例配置**：

| 奖品名称   | prize_value_points | win_probability | 贡献成本 |
| ---------- | ------------------ | --------------- | -------- |
| 青菜1份    | 0                  | 0.40 (40%)      | 0        |
| 甜品1份    | 60                 | 0.30 (30%)      | 18       |
| 100积分    | 80                 | 0.20 (20%)      | 16       |
| 500积分券  | 400                | 0.08 (8%)       | 32       |
| 2000积分券 | 150                | 0.02 (2%)       | 3        |
| **总计**   | -                  | **1.00 (100%)** | **69**   |

期望成本 = 69 预算积分/抽

**策略 2：保底/预设专用奖品单独管理**

对于不希望"随机抽到"的奖品：

- 设置 `win_probability = 0`
- 通过保底机制（累计10次）或后台预设发放

**示例**：

```sql
-- 九八折券（保底专用）
UPDATE lottery_prizes SET win_probability = 0 WHERE prize_id = 9;

-- 八八折（后台预设专用）
UPDATE lottery_prizes SET win_probability = 0 WHERE prize_id = 1;
```

#### 第三步：做一致性校验（运营侧必须做的检查项）

**校验目标**：确保"不同预算阶段下的有效奖池"概率总和接近 100%

**校验脚本示例**：

```sql
-- 场景1：预算 = 0（当前测试用户的状态）
SELECT prize_name, prize_value_points, win_probability
FROM lottery_prizes
WHERE campaign_id = 1 AND status = 'active'
  AND prize_value_points <= 0 -- 预算过滤
  AND win_probability > 0;     -- 概率过滤

-- 场景2：预算 <= 100
SELECT prize_name, prize_value_points, win_probability
FROM lottery_prizes
WHERE campaign_id = 1 AND status = 'active'
  AND prize_value_points <= 100
  AND win_probability > 0;

-- 场景3：预算 >= 400（充足预算）
SELECT prize_name, prize_value_points, win_probability,
       SUM(win_probability) OVER () as total_probability
FROM lottery_prizes
WHERE campaign_id = 1 AND status = 'active'
  AND prize_value_points <= 400
  AND win_probability > 0;
```

**检查要点**：

- 每个场景的 `SUM(win_probability)` 应接近 `1.0`（100%）
- 如果总和 < 1.0，会导致"最后一个奖品"实际命中率偏高
- 如果总和 > 1.0，说明配置错误（需要调整）

### 4.3 你的当前配置问题与修复建议

#### 问题诊断

**问题 1**：测试用户没有 `BUDGET_POINTS`，导致只能抽到"青菜1份"

```sql
-- 当前状态
用户 user_id=31 的 BUDGET_POINTS = 0

-- 可抽中奖品
只有 1 个奖品：青菜1份（prize_value_points=0）

-- 实际体验
100% 抽中"青菜1份"，其他奖品永远抽不到
```

**问题 2**：部分奖品的 `win_probability = 0`（八八折、九八折券、生腌拼盘158）

```sql
-- 零概率奖品
奖品ID=1: 八八折         | win_probability=0%
奖品ID=9: 九八折券       | win_probability=0%
奖品ID=8: 生腌拼盘158    | win_probability=0%
```

这些奖品永远不会被随机抽到（除非通过保底/预设机制）。

**问题 3**：可抽中奖品的概率总和 = 100%（看似正确，但预算不足时会失效）

```sql
-- 全部奖品的概率总和
SUM(win_probability) = 1.0 (100%)

-- 但预算不足时（BUDGET_POINTS=0），只剩 1 个奖品
可抽中奖品概率总和 = 0.3 (30%)
剩余 70% 的概率空档会落到"青菜1份"上（实际命中率 = 100%）
```

#### 修复方案（3选1）

**方案 A：给测试用户充值预算（推荐）**

如果你想测试完整的抽奖体验（能抽到多种奖品）：

```sql
-- 步骤1：查询/创建用户账户
SELECT account_id FROM accounts WHERE user_id = 31 AND account_type = 'user';

-- 步骤2：充值 BUDGET_POINTS（使用 AssetService）
-- 需要通过后端接口或脚本调用，示例：
-- AssetService.changeBalance({
--   user_id: 31,
--   asset_code: 'BUDGET_POINTS',
--   delta_amount: 500,  -- 充值 500 预算积分
--   campaign_id: 'CONSUMPTION_DEFAULT',
--   business_type: 'admin_grant',
--   idempotency_key: 'test_grant_20260109',
--   meta: { reason: '测试用户预算充值' }
-- })
```

充值后，用户可以抽到所有 `prize_value_points <= 500` 的奖品。

**方案 B：修改活动为 `budget_mode=none`（测试专用）**

如果只是想测试抽奖逻辑，不想管理预算：

```sql
UPDATE lottery_campaigns SET budget_mode = 'none' WHERE campaign_id = 1;
```

修改后，所有奖品都可以被抽到（不受预算限制）。

⚠️ **注意**：此模式下预算不会被扣减，仅用于测试环境。

**方案 C：修改活动为 `budget_mode=pool` + 设置活动池预算**

如果想要"整场活动总成本可控"：

```sql
UPDATE lottery_campaigns
SET budget_mode = 'pool',
    pool_budget_remaining = 10000  -- 设置活动池预算为 10000 预算积分
WHERE campaign_id = 1;
```

修改后，所有用户共享活动池预算，抽完为止。

---

## 5. 常见问题与注意事项

### Q1: 为什么我配置了 `win_probability=30%`，但用户每次都抽到这个奖品？

**原因**：预算过滤后，只剩下这一个奖品可抽。

**解决**：

1. 检查用户的 `BUDGET_POINTS` 余额
2. 检查活动的 `budget_mode` 和 `pool_budget_remaining`
3. 确保有多个奖品满足预算条件

### Q2: 如何实现"新用户首抽必中大奖"？

**方案**：使用**预设队列**（不修改概率）

```sql
-- 在 lottery_management_settings 表中为新用户预设奖品
INSERT INTO lottery_management_settings (user_id, setting_type, setting_data, status)
VALUES (
  12345,  -- 新用户ID
  'preset_queue',
  JSON_OBJECT(
    'prizes', JSON_ARRAY(
      JSON_OBJECT('prize_id', 5, 'quantity', 1)  -- 预设 2000积分券
    )
  ),
  'active'
);
```

系统会在用户首次抽奖时优先发放预设奖品。

### Q3: 如何避免用户预算不足时体验变差？

**策略组合**：

1. **确保有零成本奖品**：至少保留 1-2 个 `prize_value_points=0` 的奖品（作为"保底兜底"）
2. **分层预算充值**：根据用户等级/消费额度自动充值 `BUDGET_POINTS`
3. **预算预警**：当用户预算 < 100 时，前端提示"预算不足，可能抽到低价值奖品"

### Q4: 保底机制（累计10次）会受预算限制吗？

**会受限制。**

保底奖品（九八折券，prize_id=9）如果 `prize_value_points > 0`，在预算不足时也会被过滤掉。

**建议**：

- 如果保底奖品希望"无论如何都能发放"，应设置 `prize_value_points=0`
- 或者确保目标用户在触发保底前有足够预算

### Q5: 如何查看当前活动的期望预算成本？

**查询 SQL**：

```sql
SELECT
  SUM(win_probability * COALESCE(prize_value_points, 0)) as expected_budget_cost,
  SUM(win_probability) as total_probability,
  COUNT(*) as active_prize_count
FROM lottery_prizes
WHERE campaign_id = 1
  AND status = 'active'
  AND win_probability > 0;
```

**解读**：

- `expected_budget_cost`：每抽的期望预算成本（预算积分）
- `total_probability`：应接近 1.0（100%）
- `active_prize_count`：参与随机抽取的奖品数量

### Q6: 如何调试"为什么用户抽到了这个奖品"？

**检查日志**：

```sql
-- 查看抽奖记录
SELECT draw_id, prize_name, reward_tier, cost_points, prize_value_points,
       budget_points_before, budget_points_after, created_at
FROM lottery_draws
WHERE user_id = 31
ORDER BY created_at DESC LIMIT 10;
```

**日志字段含义**：

- `prize_value_points`：此奖品的预算成本
- `budget_points_before`：抽奖前的预算余额
- `budget_points_after`：抽奖后的预算余额
- `reward_tier`：奖励档次（`low`/`mid`/`high`）

---

## 📚 附录：相关数据库表结构

### `lottery_prizes` 表（奖品配置）

| 字段名               | 类型            | 说明                                               |
| -------------------- | --------------- | -------------------------------------------------- |
| `prize_id`           | `INT`           | 奖品ID（主键）                                     |
| `campaign_id`        | `INT`           | 所属活动ID                                         |
| `prize_name`         | `VARCHAR(100)`  | 奖品名称                                           |
| `prize_type`         | `ENUM`          | 奖品类型（`points`/`coupon`/`physical`/`virtual`） |
| `prize_value`        | `DECIMAL(10,2)` | 奖品价值（发放给用户的数量）                       |
| `prize_value_points` | `INT`           | 奖品价值积分（预算成本）                           |
| `win_probability`    | `DECIMAL(8,6)`  | 中奖概率（0-1）                                    |
| `stock_quantity`     | `INT`           | 库存数量                                           |
| `max_daily_wins`     | `INT`           | 每日最大中奖次数                                   |
| `status`             | `ENUM`          | 状态（`active`/`inactive`）                        |

### `lottery_campaigns` 表（活动配置）

| 字段名                  | 类型           | 说明                                           |
| ----------------------- | -------------- | ---------------------------------------------- |
| `campaign_id`           | `INT`          | 活动ID（主键）                                 |
| `campaign_name`         | `VARCHAR(100)` | 活动名称                                       |
| `budget_mode`           | `VARCHAR(20)`  | 预算模式（`user`/`pool`/`none`）               |
| `pool_budget_remaining` | `BIGINT`       | 活动池剩余预算（仅 `budget_mode=pool` 时有效） |
| `allowed_campaign_ids`  | `JSON`         | 允许使用的预算活动ID列表                       |
| `status`                | `ENUM`         | 状态（`active`/`inactive`）                    |

### `account_asset_balances` 表（用户资产余额）

| 字段名             | 类型          | 说明                                  |
| ------------------ | ------------- | ------------------------------------- |
| `account_id`       | `BIGINT`      | 账户ID                                |
| `asset_code`       | `VARCHAR(32)` | 资产代码（`POINTS`/`BUDGET_POINTS`）  |
| `available_amount` | `BIGINT`      | 可用余额                              |
| `frozen_amount`    | `BIGINT`      | 冻结余额                              |
| `campaign_id`      | `VARCHAR(64)` | 关联活动ID（仅 `BUDGET_POINTS` 需要） |

---

## 🔗 相关文档

- 抽奖引擎实现：`services/UnifiedLotteryEngine/strategies/BasicGuaranteeStrategy.js`
- 资产服务：`services/AssetService.js`
- 数据模型：`models/LotteryPrize.js`、`models/LotteryCampaign.js`

---

**文档维护者**: 系统开发团队  
**问题反馈**: 发现配置问题或文档错误，请提交至项目 Issue
