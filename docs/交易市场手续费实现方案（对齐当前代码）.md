# 交易市场手续费实现方案（对齐当前代码）

> 本文档基于**当前仓库代码状态**整理，目标是：在不推倒重来的前提下，将“C2C交易市场手续费”业务需求落到**最新积分账本架构**中，并明确需要改动/补齐的点与验收标准。

---

## 一、范围与术语

### 1.1 范围（本方案覆盖什么）

- **交易市场（C2C）**：用户把背包物品上架到市场，其他用户用积分购买。
- **目标入口**：`InventoryService.purchaseMarketProduct(buyerId, productId, options)`（由路由 `POST /api/v4/inventory/market/products/:id/purchase` 触发）。

### 1.2 关键术语

- **商品价值**：`UserInventory.value`（用于决定费率档位；不等于结算货币）。
- **结算资产**：市场交易实际使用的“货币”，用二元组表达：`(asset_code, amount)`。
  - `asset_code`：资产代码（如 `diamond` / `red_shard` / `red_crystal`，可扩展）。
  - `amount`：整数金额（可部分扣减）。
- **售价**：`selling_amount`（买家支付基数，单位为 `selling_asset_code`）。
- **售价资产**：`selling_asset_code`（本次交易使用哪种资产进行结算）。
- **手续费**：平台收取的结算资产差额（卖家承担）。
- **卖家实收**：`net_amount = selling_amount - fee`（同一 `selling_asset_code` 单位）。
- **展示积分（Display Points）**：仅用于用户感知/列表展示的“参考价值”，不参与结算与扣账。
  - 典型用法：奖品/物品对外显示 `display_points`（例如 100 / 1000），但实际兑换/交易支付走资产。
- **兑换门槛（Redeem Cost）**：用于“兑换实物/权益”时的实际消耗口径，形如：`(cost_asset_code, cost_amount)`。
  - 示例：奖品A展示 100 积分，但兑换条件是 `red_shard × 10`；奖品B展示 1000 积分，但兑换条件是 `orange_shard × 1`。
- **预算控成本凭证（Voucher-as-Asset）**：红/橙水晶（碎片）本质是“抽奖预算控成本后发放给用户的兑换凭证”：
  - 用户只能通过抽奖获得；
  - 抽奖出奖时已按 `prize_value_points` 扣 `remaining_budget_points`（系统侧控成本）；
  - 后续“兑换实物”是凭证兑现（成本在发货/兑换订单侧落地记录），不应再次扣预算点。

> ⚠️ 重要：本方案**将交易市场结算从“可见积分 available_points”迁移为“多资产结算”**，以避免出现“可见积分越来越多但预算积分越来越少，用户越抽奖越只能抽中垃圾奖品”的割裂感。

---

## 二、业务需求（验收口径）

把需求写成“可验收行为”，便于上线后核对：

1. **按商品价值分档计费**
   - 费率档位依据：`UserInventory.value`（而不是订单总额、用户等级、活动期等）。
2. **卖家承担手续费**
   - 买家支付：为 `selling_amount` 全额（单位：`selling_asset_code`）。
   - 卖家到账：`net_amount = selling_amount - fee`（单位：`selling_asset_code`）。
3. **手续费可开关**
   - 关闭时：`fee=0`、卖家实收=售价。
4. **手续费需可追溯**
   - 至少要在“交易记录/资产流水”中能查到：买家支付、卖家实收、平台手续费（含费率/档位解释信息）。
5. **交易市场不得使用可见积分结算（新增硬约束）**
   - 市场购买/出售/手续费结算 **不得扣减或增加** `UserPointsAccount.available_points`。
   - 市场结算 **不得检查或扣减** `remaining_budget_points`（预算积分仅用于抽奖控成本）。
   - 市场结算必须使用“资产余额账本”（多资产）。

---

## 二点五、已决策（首版不可变更的约束）

为避免实现过程中反复讨论，这里记录已拍板项，作为首版上线的“硬约束”：

0. **市场结算账本：采用“可交易的余额资产”（✅ 已拍板）**
   - 含义：交易市场购买/出售/手续费结算，**不再**扣减或增加 `UserPointsAccount.available_points`。
   - 需要说明（与当前代码对齐）：
     - 当前代码的市场结算仍是 `selling_points + PointsService`（积分账本）；要实现“可交易余额资产”，必须新增一套“资产余额 + 资产流水”的账本能力，并迁移市场结算到该账本。
     - 当前仓库中尚未落地 `diamond/red_shard/...` 作为可扣减余额资产的模型/服务（代码里没有 `AssetService/MaterialService` 或 `selling_asset_code` 字段）。

1. **手续费去向：monetize（平台收入）**
   - 首版固定采用：手续费进入平台账户（system user）的**资产余额账本**。
   - 不做：销毁（destroy）/回流奖池（recycle）/分润（split）等其它策略。
2. **平台账户落地：专用 system user + 生产环境变量 `PLATFORM_USER_ID`**
   - 首版必须新建一个“平台账户”专用 user（system user）承接手续费，避免与管理员/普通用户混用。
   - 生产环境必须配置 `PLATFORM_USER_ID=<该专用用户的 user_id>`。
3. **幂等口径：首选 header `Idempotency-Key`，兼容 body `business_id`（生产缺失直接 400）**
   - 首选：前端每次“购买”请求必须携带 header `Idempotency-Key`（重试必须保持不变）。
   - 兼容：后端允许 body 里传 `business_id`（用于旧客户端/快速联调），但推荐逐步迁移到 header。
   - 生产策略：缺少 `Idempotency-Key`/`business_id` 时直接返回 **400**，避免不可控的重复扣款/重复入账。
4. **TradeRecord 落库口径：采用方案A（新增 `market_purchase` + 数据库迁移）**
   - 首版市场成交的 `TradeRecord.trade_type` 统一使用：`market_purchase`。
   - 必做：`models/TradeRecord.js` 的 `DataTypes.ENUM(...)` 增加 `market_purchase`，并同步数据库枚举/约束迁移。
   - 首版不额外新增 `market_sale`（如后续需要“卖家侧独立订单口径/状态机”再评估）。
5. **双账户商业逻辑对齐：市场手续费不作用于可见积分/预算积分，只作用于“交易结算资产”**
   - **用户可见积分（`available_points`）**：用于抽奖门票/参与资格、活动入口等（✅ 保持）；**不用于交易市场结算**（❌ 禁止）。
   - **预算积分（`remaining_budget_points`）**：仅用于控制“能中什么奖品/系统成本”，市场交易 **不检查也不扣减**（✅ 保持）。
   - **交易市场结算资产（多资产）**：用于 C2C 市场买卖结算与手续费结算（✅ 新增），不影响可见积分与预算积分的长期关系。
   - **重要澄清**：平台收取的市场手续费将进入平台账户的**资产余额**（而不是可见积分余额），用于后续运营（手续费抵扣/活动门票/兑换等）或回收策略演进。
   - **兑换链路对齐**：当前新兑换市场（`ExchangeMarketService`）明确禁止使用 `available_points` 支付；本方案让交易市场也遵循同一原则（避免可见积分不断累积造成割裂）。
6. **市场结算模式：多资产结算（方案B，✅ 已拍板）**
   - 市场交易价格表达为 `selling_asset_code + selling_amount`，支持多种资产作为定价货币（更灵活）。
   - 首版建议设置“市场可用资产白名单”（例如仅允许 1~3 种资产），避免前端/运营复杂度失控。
7. **手续费货币选择（首版推荐）：diamond（0预算成本、不可兑实物）**
   - **背景**：
     - `diamond`：抽奖内部可设 `prize_value_points = 0`（预算占用 0）；且**不可兑换任何水晶、不可兑换任何有实际成本的奖品**。
     - `red_shard`：抽奖内部成本可设为 10（预算占用 10），且可作为“实物兑换凭证”使用（会影响平台真实成本兑现）。
   - **首版推荐**：交易市场“结算资产白名单”优先仅开放 `diamond`（或至少将 `diamond` 作为主结算资产），手续费随结算资产从卖家侧扣除并进入平台账户的 **diamond 资产余额**。
   - **原因**：
     - 避免手续费侵蚀红/橙水晶凭证（否则用户会出现“交易越多越兑不了实物”的强负反馈）。
     - 平台收取 diamond 不会引入新的实物成本负债（钻石不可提现到实物）。
   - **可选增强（后续二期）**：若希望手续费同时具备“回收真实成本”的效果，再考虑用 `red_shard` 作为手续费货币，但必须配套兑换池限额/动态定价/转换频率限制与明确提示。
8. **最终决策确认（✅ 已定）：交易市场“定价/结算/手续费”统一使用 diamond**
   - 首版将 `diamond` 作为交易市场的**唯一结算资产**：
     - `selling_asset_code` 固定为 `diamond`
     - `fee`（平台手续费）也以 `diamond` 计价与扣减
   - 目的：让“交易摩擦”沉淀为可被平台消耗的钻石（手续费/广告/活动），同时不侵蚀红/橙水晶的实物兑换凭证能力。
9. **钻石消耗闭环（规划项，但影响首版口径）**
   - 钻石未来会作为“企业广告投放”的消耗货币：
     - 企业支付 diamond → 获得广告曝光/推广权益（消耗钻石）
   - 为促进钻石回收与交易活跃：允许（可选二期）**红碎片 → 钻石**的单向兑换：
     - `red_shard -> diamond` ✅ 允许
     - `diamond -> red_shard` ❌ 禁止（防止形成循环套利/把广告币反向提现为实物凭证）
   - 经济含义：企业/大户可用多余红碎片换钻石打广告；平台通过控制兑换汇率与处理策略（销毁/沉淀）来管理“实物负债能力”的回收强度。

---

## 三、当前代码状态（事实对齐）

### 3.1 已经存在且可复用的能力

- **手续费规则与计算**
  - 规则配置：`config/fee_rules.js`（包含 `enabled`、档位 `tiers`、`min_fee`、`fee_strategy` 等）
  - 计算器：`services/FeeCalculator.js`
    - 支持：全局开关、按 `value` 分档、按 `selling_points` 计费、最小手续费、返回 `fee/rate/net_amount/tier`

- **最新积分账本架构（用于“积分域”，不用于交易市场结算）**
  - 积分服务：`services/PointsService.js`
    - 核心写账：`consumePoints()`（扣积分）与 `addPoints()`（加积分）
    - 支持：事务传入、幂等（`business_id`）、交易描述字段（`business_type/reference_*`/title/description）

- **可参考的“非积分支付”先例（仅参考，不等于已有资产账本）**
  - 兑换市场路由已实现：**强制幂等键**（Body `business_id` 或 Header `Idempotency-Key`，缺失直接 400）。
  - 但当前仓库并不存在一套可复用的“资产余额 + 资产流水”账本实现（即：没有现成的 `AssetService/MaterialService`、也没有 `diamond` 余额模型），因此交易市场要改“可交易余额资产”需新增实现。

### 3.2 交易市场购买流程的现状（需要对齐的点）

在 `InventoryService.purchaseMarketProduct` 里，目前逻辑是：

- 买家扣：`selling_points`（走可见积分）
- 卖家加：`selling_points`（全额，走可见积分）
- `TradeRecord` 里写死：`fee_points_amount = 0`、`net_points_amount = selling_points`

这意味着：**手续费在交易市场购买链路里没有生效**（平台没有截留/销毁/回流任何手续费）。

此外也意味着：**交易市场仍在使用可见积分结算**（与“市场结算采用可交易余额资产（✅ 已拍板）”不一致），需要整体迁移到“资产余额账本结算”。

此外还有两个“实现前必须先统一”的风险点：

- **PointsService方法名不一致风险**
  - 购买流程里调用 `PointsService.deductPoints`，而 `PointsService.js` 当前主方法是 `consumePoints/addPoints`。
  - ✅ 本方案采用：**A. 统一“调用方”只用新方法**（把调用方改成 `consumePoints/addPoints`，不在 `PointsService` 增加旧名别名）。
- **TradeRecord枚举一致性风险**
  - 购买流程里写 `trade_type: 'market_purchase'`，但 `models/TradeRecord.js` 当前 `ENUM` 是否包含该值需要先对齐（否则会写入失败或触发运行时错误）。
  - ✅ 本方案采用：**B. 正式扩展枚举**（模型枚举 + 数据库枚举/约束同步迁移），让 `TradeRecord` 原生支持 `market_purchase`（必要时补 `market_sale`）。

### 3.3 真实业务数据快照（用于“实用主义”决策）

为避免过度设计，本方案参考仓库内备份快照做轻量统计（以 `backups/backup_2025-11-11/full_backup_2025-11-11_00-13-27-425+.json` 为主）：

- **市场规模（当时的真实数据量级）**
  - `user_inventory` 共 3 条，其中 **2 条 `market_status='on_sale'`**
  - on_sale 示例：
    - 售价（selling_points）：50、500
    - 价值（value）：均为 100
- **积分账本（当时的真实数据量级）**
  - `points_transactions` 共 4 条，且 `business_type` 均为空（未出现 `market_purchase/market_sale/market_fee_income`）
  - `user_points_accounts` 共 1 条，属于用户 `user_id=31（管理员用户）`（仅用于说明当时数据规模；生产不复用该账号作为平台账户）

> 结论（面向实现）：市场与手续费链路属于“刚启用/数据很少”的阶段，第一版以“能对账、能审计、能灰度”为优先；费率档位暂按现有 `fee_rules.js` 上线，等累计有足够成交（例如 100+ 单）再用真实成交分布调整。

---

## 四、方案原则（在“最新架构”里怎么做才对）

1. **账本权威口径：市场走“资产账本”，积分账本只管积分域**
   - 交易市场（本方案）：买家支付/卖家实收/平台手续费 **全部走资产余额 + 资产流水**（不得动 `available_points` 与 `remaining_budget_points`）。
   - 积分域（非本方案）：才使用 `PointsService` 写入 `PointsTransaction`（如消费奖励、抽奖门票扣分等）。
2. **手续费计算与规则集中**
   - 继续复用 `FeeCalculator + fee_rules.js`，避免把费率散落在业务代码里。
3. **市场结算必须使用“资产账本”**
   - 交易市场禁止使用 `available_points` 与 `remaining_budget_points`。
   - 市场结算使用“资产余额 + 资产流水”（可多资产），支持部分扣减与审计。
4. **展示积分与实际扣账解耦（避免“感知价值”影响控成本）**
   - 对用户展示：`display_points`（参考价值/感知锚点）。
   - 实际扣账：只走资产结算（市场）与资产门槛（兑换），不走 `available_points`，不动 `remaining_budget_points`。
5. **预算控成本守恒口径（防止“凭证兑现”与预算脱钩）**
   - 红/橙水晶（碎片）作为“预算控成本后的兑换凭证”，其后续的合成/拆分/兑换不应让用户获得“超过其内部成本”的实物兑换能力。
   - 最小可落地规则：为每种可用于兑换的资产定义 `internal_cost_points`（内部成本计价单位可复用 `prize_value_points` 的口径），并要求兑换池商品满足：`real_cost <= internal_cost_points` 对应的预算上限（统计口径）。
4. **最小改动集中在一个入口**
   - 只在 `InventoryService.purchaseMarketProduct` 做“计算 + 三方落账 + 交易记录写入”改造，不推倒重来。
   - 但需要补齐：`UserInventory` 上的“售价资产字段”、以及资产账本的 Service/表（见第六节）。

4. **经济与体验目标（首版）**
   - 通过“交易市场资产结算（推荐 diamond）+ 手续费摩擦”，让用户在“预算控奖”场景下仍有稳定的流通资产，同时不侵蚀实物兑换凭证，降低割裂感。
   - 不引入新的“可见积分→实物”兑换口径，避免把手续费/市场交易变成平台真实成本负债。

---

## 四点五、商业模型对齐（把“预算控成本”与“凭证兑现”说清楚）

本节用于统一团队口径：红/橙水晶（碎片）是**预算控成本后的实物兑换凭证**；`diamond` 是**0成本权益券**（用于手续费/活动等，不可兑换任何有成本奖品）。

示例（用户消费 1000 元）：

1) 平台抽佣：100 元  
2) 分配两类账户额度：  
   - 显示积分（显示账户）：`available_points +1000`（用于支付抽奖门票/参与资格）  
   - 预算积分（预算账户）：`remaining_budget_points +240`（用于抽奖控成本：决定能中什么/扣多少成本）  
3) 抽奖消耗：  
   - 显示积分：`available_points -1000`（用于支付抽奖）  
   - 预算成本：`remaining_budget_points -150`（示例：命中 150 成本的奖品组合；若预算只剩 100，则 500 成本奖不会被抽中）  
4) 抽奖产出（示例）：  
   - 红水晶/碎片：累计“兑换门槛等值”约 150（作为可兑实物凭证，进入用户库存/资产余额）  
5) 兑换消耗：  
   - 凭证消耗：`red_* -150`（用于兑换商品）  
6) 最终状态（示例）：  
   - 显示积分：0（已抽奖）  
   - 预算积分：90（240-150）  
   - 凭证：0（已兑换）  
   - 实物商品：精美水杯 ✅  

交易市场手续费（本方案）在这个模型里应满足：
- **不得影响预算账户**：不扣 `remaining_budget_points`  
- **首版推荐不得侵蚀实物凭证**：手续费用 `diamond` 结算并沉淀到平台账户（system user）  
- 从而保证“兑现实物能力”只由抽奖成本与兑换门槛决定，不被交易频率额外削弱（避免用户挫败）

---

## 五、目标实现：购买一次产生三笔账（推荐结构）

### 5.1 交易流程（高层）

1. 查询并锁定 `marketProduct`（当前代码已做行级锁）。
2. **计算手续费**（复用 `FeeCalculator.calculateItemFee(value, selling_amount)`；档位仍按 `value`）。
3. **买家扣全额**（资产流水：consume，单位 `selling_asset_code`）。
4. **卖家加实收**（资产流水：earn，单位 `selling_asset_code`）。
5. **平台入账手续费**（资产流水：earn，单位 `selling_asset_code`，入平台账户；第一版 monetize）。
6. 写入 `TradeRecord`（用于“交易视角”的汇总记录）。
7. 更新 `UserInventory` 的归属与状态（当前代码已做）。

### 5.2 手续费去向（第一版方案：monetize 平台收入）

第一版上线**固定采用 monetize（✅ 已决策）**：手续费进入“平台资产账户（system user_id + asset_code 余额）”，便于对账、统计、审计与后续运营。

- **monetize（平台收入，✅ 第一版采用）**
  - 将 `fee` 记到一个“平台账户（system user）”的资产余额：
    - `AssetService/MaterialService.add(platformUserId, asset_code, fee, { business_type: 'market_fee_income', ... })`
  - 同一笔市场交易建议形成三笔资产流水（同一 business_id 或加后缀）：
    - 买家扣款：`market_purchase`（consume，amount = selling_amount）
    - 卖家入账：`market_sale`（earn，amount = net_amount）
    - 平台手续费：`market_fee_income`（earn，amount = fee，入 platformUserId）

> 平台账户（platformUserId）首版要求作为**环境变量**配置项（✅ 已决策），保证生产可调整且可审计（项目入口 `app.js` 已使用 `dotenv` 加载 `process.env`，且部署类配置普遍走环境变量）。
>
> **生产环境要求（✅ 已决策）**：
> - 必须新建一个“平台账户”专用 user（system user）承接手续费，避免与真实管理员/玩家账户混用
> - 生产的 `PLATFORM_USER_ID` 必须填写该专用用户的 `user_id`

> 说明：当前仓库里“奖池”服务 `PrizePoolService` 管理的是抽奖活动的奖品池，不等同于“积分奖池账户”。因此第一版不建议上 recycle/destroy；等市场跑稳后再评估通胀调节或活动回流策略。

---

## 六、需要补齐/调整的具体点（不写代码，只列方案落点）

### 6.1 在 `InventoryService.purchaseMarketProduct` 集成 FeeCalculator（结算单位迁移为资产）

- 新增：调用 `FeeCalculator.calculateItemFee(marketProduct.value, marketProduct.selling_amount)`
- 得到：`fee / rate / net_amount / tier`
- 规则开关：由 `fee_rules.enabled` 决定 fee 是否为 0（计算器已支持）

### 6.2 市场结算改为“资产账本”落账（多资产）

将购买流程的资产变动统一为（交易市场禁止使用可见积分）：

- 买家：`consume(buyerId, asset_code, selling_amount, {...})`
- 卖家：`add(sellerId, asset_code, net_amount, {...})`
- 平台手续费（第一版 monetize）：`add(platformUserId, asset_code, fee, {...})`（`business_type: 'market_fee_income'`）

> ⚠️ 与当前代码对齐的重要备注：上述 `consume/add` 对应的“资产账本 Service + 表结构”在当前仓库中**尚不存在**，需要新增实现（余额表 + 流水表 + Service）。

同时建议填写以下字段，便于对账/统计：

- `business_id`：用于幂等（见 6.4）
- `business_type`（建议命名）：
  - 买家扣款：`market_purchase`
  - 卖家入账：`market_sale`
  - 平台手续费（第一版 monetize）：`market_fee_income`
- `reference_type/reference_id`：建议 `market_product` + `productId`（统一关联同一件商品交易）
- `title/description`：建议在卖家/平台入账 description 里写清：售价/手续费/费率/档位/实收

### 6.2.1 平台手续费账户（生产配置：环境变量 ✅）

第一版 monetize 需要一个“平台收款账户 user_id”，首版确定用环境变量注入（✅ 已决策）：

- **环境变量名（建议）**：`PLATFORM_USER_ID`
- **类型**：整数（对应 `users.user_id`）
- **用途**：手续费入账目标账户（`AssetService/MaterialService.add(PLATFORM_USER_ID, selling_asset_code, fee, business_type='market_fee_income', ...)`）
  - 与当前代码对齐：当前仓库里还没有 `AssetService/MaterialService`，这里需要新增“资产账本服务”并在其中使用 `PLATFORM_USER_ID` 作为平台手续费入账目标用户。

生产配置示例（在部署平台配置环境变量，或写入 `.env` 并随部署注入）：

```bash
PLATFORM_USER_ID=12345
```

实用主义约束（不做配置中心/不过度设计）：
- 生产环境 **必须配置** `PLATFORM_USER_ID`（避免手续费入账到未知用户或误用管理员账号）
- ✅ **生产环境要求（✅ 已决策）**：必须新建一个昵称明确的 system user（如“平台账户”）专门承接手续费；不要复用管理员或普通用户账号

上线前检查清单（建议写入发布 SOP）：
- 在生产数据库确认存在该“平台账户”用户，且 `user_id == PLATFORM_USER_ID`
- 确认该用户有/可初始化积分账户（能被 `PointsService.addPoints` 正常入账）
- 确认后台/统计口径使用 `PointsTransaction.business_type='market_fee_income'` 聚合平台手续费收入

### 6.3 TradeRecord 的类型与字段一致性

为了让 `TradeRecord.fee_points_amount/net_points_amount` 真正有意义，需要做两件事：

1. **把手续费与实收写入 TradeRecord**
   - ✅ 方案A（最小改动，首版推荐）：`TradeRecord` 继续作为“成交摘要”，金额字段保持不变但语义升级：
     - `points_amount = selling_amount`
     - `fee_points_amount = fee`
     - `net_points_amount = net_amount`
     - 同时在 `TradeRecord` 增加 `meta`（JSON）或新增字段记录：`asset_code=selling_asset_code`（用于区分货币）
   - ✅ 方案B（更规范，二期可做）：`TradeRecord` 增加明确字段：`asset_code`、`gross_amount`、`fee_amount`、`net_amount`，避免“points_amount语义漂移”。

2. **统一 trade_type（最终决策：只扩展 `market_purchase`）**
   - **模型层**：`models/TradeRecord.js` 的 `DataTypes.ENUM(...)` 增加 `'market_purchase'`
   - **数据库层**：如果底层列是 MySQL `ENUM` 或存在约束，需要配套迁移脚本把枚举值/约束同步更新（否则 ORM 改了也写不进去）

> 该选择的收益是：后续做“市场专属统计/筛选”更直接；代价是：需要一次数据库迁移与回归验证。

补充说明（平台手续费是否需要在 TradeRecord 单独记一条）：
- **最终决策：不需要**。平台手续费以 `PointsTransaction.business_type='market_fee_income'` 为权威口径做统计与审计；
- `TradeRecord` 保持“一笔成交一条摘要记录”，通过 `fee_points_amount/net_points_amount` 表达手续费与卖家实收即可。

### 6.4 幂等性：确保“重试不会重复扣款/重复入账”

当前路由层生成 `business_id` 使用 `Date.now()`，会导致每次请求都不同，幂等效果接近于无。

推荐落地方式：

- **首选：前端通过 header 传幂等键（✅ 已决策）**
  - header 名（推荐）：`Idempotency-Key`
  - 值：UUID（重试时保持不变）
- **兼容：body 传 `business_id`（✅ 已决策）**
  - 用途：旧客户端/联调兜底
  - 迁移建议：逐步改为统一走 header `Idempotency-Key`
- **生产环境强制要求（✅ 已决策）**
  - 若缺少 `Idempotency-Key` 且 body 也无 `business_id`：直接返回 **400**（拒绝不可幂等请求）

同时，三笔账建议共享同一个 `business_id`（或在其后追加后缀），确保跨多笔落账可聚合追踪。

---

### 6.5 多资产定价的表结构/接口补齐（首版必须）

为支持“市场多资产结算”，需要把“售价”从单一 `selling_points` 升级为：

- `UserInventory.selling_asset_code`（VARCHAR(32)）：本商品上架时使用的结算资产代码
- `UserInventory.selling_amount`（INT/BIGINT）：售价金额（整数）

兼容策略（实用主义）：
- 首版可保留 `selling_points` 作为历史字段或展示字段，但**结算必须只用 `selling_asset_code + selling_amount`**。
- 市场列表/详情接口对外返回 `price: { asset_code, amount }`，前端以此展示与购买。

首版进一步约束（✅ 已决策）：
- `selling_asset_code` **固定为 `diamond`**（市场唯一结算资产），避免多币种定价带来的用户理解成本与套利面。

> 资产余额建议走“余额表 + 流水表”（参考 `docs/材料系统（碎片-水晶）方案.md` 的方案B），避免背包 SUM value 的不可部分扣减问题。

---

## 七、接口返回与前端展示（建议）

购买成功响应建议增加字段（不破坏现有结构）：

- `fee_info.buyer_paid`：买家支付（selling_points）
- `fee_info.seller_received`：卖家实收（net_amount）
- `fee_info.platform_fee`：平台手续费（fee）
- `fee_info.rate`：费率（rate）
- `fee_info.tier`：档位（tier）
- `fee_info.asset_code`：结算资产（selling_asset_code）

价值：降低用户/客服解释成本，且能与积分流水、交易记录一致对账。

> ✅ 首版口径：`fee_info.asset_code` 恒为 `diamond`。

---

## 八、验收用例（上线前必测）

### 8.1 基础正确性

- **用例A：手续费开启**
  - 给定：`fee_rules.enabled=true`
  - 预期：
    - 买家资产账本 `consume` 金额 = 售价（单位：asset_code，对齐你最终选定的市场结算资产）
    - 卖家资产账本 `add` 金额 = 售价 - 手续费（同一 asset_code）
    - 平台手续费写入 `platformUserId` 的资产流水（`business_type='market_fee_income'`，同一 asset_code）
    - `TradeRecord.fee_points_amount > 0` 且 `fee + net = selling_points`

- **用例B：手续费关闭**
  - 给定：`fee_rules.enabled=false`
  - 预期：
    - 手续费=0
    - 卖家入账=售价
    - 平台无 `market_fee_income` 入账
    - 市场全流程不产生 `PointsTransaction`（可见积分无变动）

### 8.2 幂等性

- 同一 `business_id` 重复请求：
  - 预期：买家不会重复扣款，卖家/平台不会重复入账，返回相同交易结果（或明确标记 `is_duplicate`）

### 8.3 异常与回滚

- 余额不足：
  - 预期：整体失败且不产生部分入账（依赖事务原子性）
- 并发购买同一商品：
  - 预期：行级锁 + 状态校验保证只有一单成功

---

## 九、上线策略（降低风险）

- **先加开关**：用 `fee_rules.enabled` 控制灰度（你已具备该开关）
- **灰度建议**：
  - 先在测试环境跑通验收用例
  - ✅ **已决策：上线即开**（生产发布后直接启用手续费；不做“先关后开”的两步发布）
  - 如后续需要逐步按用户/渠道灰度，需要额外开关设计

> 多资产结算上线建议：
> - ✅ 首版已决策：市场唯一结算资产为 `diamond`（不开放 `red_shard` 等实物凭证资产用于市场定价/结算）。
> - 暂不做“自动换汇/自动拆分”以免争议；需要时参考材料系统的 conversion rules 做“用户显式转换”。
>
> 与“虚拟价值货币合成/拆分系统”的联动建议（重要）：
> - **白名单影响**：如果某资产允许通过合成/拆分在用户侧自由转换，那么把它纳入“市场可用资产白名单”会放大套利/争抢空间（尤其是限量供应品）。
> - **推荐护栏**：
>   - 只允许 **同一组（同色）内部拆分/合成**（例如 `red_crystal <-> red_shard`、`orange_crystal <-> orange_shard`），避免跨组转换把高档凭证转成大量低档凭证。
>   - 拆分存在损耗（例如 10%），并限制每日/每周转换次数（防止短期灌入某个兑换池/市场币种）。
>   - 对“限量供应”的兑换品：建议设置“仅允许原生资产兑换”（或单独池子），避免通过换零/拆分把更多用户引入同一限量抢购队列，导致体验大幅变差。
>
> 钻石广告消耗与“红碎片→钻石”单向兑换（规划项）：
> - 由于兑换池为无限供应，允许用户/企业将 `red_shard` 单向换成 `diamond` 会带来“回收红碎片（实物凭证能力）+ 回收钻石（广告/手续费消耗）”的双回收效果。
> - 关键参数为兑换汇率与平台收到 `red_shard` 的处理策略（建议默认销毁或严格节奏化投放），以控制回收强度与长期供需。

---

## 十、后续可选优化（不影响首版上线）

- 在管理员后台增加“手续费收入统计”页面：
  - 直接按 `PointsTransaction.business_type` 聚合即可（不需要依赖旧表/旧逻辑）
- 对 `fee_strategy` 增加“平台账号/奖池账号”的可配置项：
  - 例如在配置文件或环境变量中提供 `platform_user_id` / `pool_user_id`
  - 第一版若只启用 monetize，则至少提供 `platform_user_id`

---

## 十点五、仍需你拍板的决策清单（与当前代码对齐）

> 你已拍板：市场结算采用“可交易的余额资产”（见 2.5 #0）。下面这些仍需要你确认，才能把实现方案落到当前仓库代码里。

1. **市场结算资产代码（asset_code）首版用哪一个？**
   - 选项A：固定 `diamond`
   - 选项B：允许多币种（需要白名单与前端展示/运营配置）
   - 说明（与当前代码对齐）：当前仓库里尚未实现 `diamond` 余额资产，选 A/B 都需要新增“资产账本模型 + Service”，差别在于是否要做“资产白名单/定价币种字段”。

2. **TradeRecord.trade_type 的落库策略**
   - 选项A：新增 `market_purchase` 枚举值（模型 + 数据库迁移）
   - 选项B：复用现有 `inventory_transfer`（不做迁移，但语义混用）

3. **幂等键策略（市场购买接口）**
   - 选项A：对齐兑换市场：强制 Body `business_id` 或 Header `Idempotency-Key`，缺失直接 400
   - 选项B：允许后端自动生成（维持现状），但重试无法幂等

4. **平台手续费入账目标账户（monetize 方案）**
   - 选项A：新增环境变量 `PLATFORM_USER_ID` 并强制生产配置（平台账户为专用 system user）
   - 选项B：暂时写死到某个管理员/系统账号（不推荐，易混淆）

5. **手续费规则是否对“市场购买”单独开关/单独费率**
   - 选项A：市场购买复用现有 `tiers + min_fee + enabled`
   - 选项B：在 `config/fee_rules.js` 增加 `market_purchase` 的独立配置（enabled/use_tiers/fixed_rate）


