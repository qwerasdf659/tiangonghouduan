# 核销码系统设计分析与多模型升级方案

> **项目**: 天工小程序（餐厅积分抽奖系统 V4.2）  
> **创建时间**: 2026-02-20  
> **数据来源**: 后端代码实际分析 + 真实数据库查询（restaurant_points_dev，查询时间 2026-02-20）  
> **状态**: ✅ 全部 11 项决策已拍板，待实施

---

## 决策速查表（已拍板）

| 编号 | 决策项 | 最终决定 |
|------|--------|---------|
| 1 | 多模型 vs 统一模型 | **A：采用多模型**（不同业务用不同核销方式） |
| 2 | 实物核销双方确认 | **不需要用户确认**（商家扫码即核销，事后通知） |
| 3 | 虚拟/积分是否进背包 | **A：不进背包**，中奖直接到账 |
| 4 | 积分商城确认收货 | **A：加确认收货**，7天未操作自动确认 |
| 5 | C2C交易担保码 | **A：仅实物交易用** |
| 6 | CDKey批量分发 | **B：仅设计不实施**，等业务需要时启动 |
| 7 | QR 码核销 | **B + B-2：QR码 + 文本码并存 + 动态HMAC签名** |
| 8 | 核销门店关联 | **A：强制关联**（通过 store_staff 自动确定） |
| 9 | 核销码有效期 | **C：运营可配置**（system_configs 全局默认 + 奖品级别覆盖） |
| 10 | SHA-256 不可逆 | **A：维持不可逆**（丢失码就取消重生成） |
| 11 | 用户确认环节 | **不需要**（所有到店核销均为商家单方扫码即完成） |

---

## 一、项目技术框架全景（真实代码确认）

### 1.1 后端技术栈

| 层级 | 技术选型 | 版本 |
|------|---------|------|
| 运行时 | Node.js | ≥20.18.0 |
| Web框架 | Express | ^4.18.2 |
| ORM | Sequelize | ^6.35.2 |
| 数据库 | MySQL（mysql2驱动） | ^3.6.5 |
| 缓存 | Redis（ioredis） | ^5.7.0 |
| 认证 | JWT（jsonwebtoken） | ^9.0.2 |
| 实时通信 | Socket.IO | ^4.8.1 |
| 日志 | Winston | ^3.11.0 |
| 定时任务 | node-cron | ^3.0.3 |
| 参数校验 | Joi | ^17.11.0 |
| 对象存储 | Sealos + AWS SDK | ^2.1691.0 |
| 时区 | 全链路北京时间 | TZ=Asia/Shanghai |

**API 架构**：RESTful，路径规范 `/api/v4/{resource}`，扁平化资源导向设计。

### 1.2 Web管理后台前端技术栈

| 层级 | 技术选型 |
|------|---------|
| UI框架 | **Alpine.js**（轻量级响应式） |
| 模板引擎 | **EJS**（服务端渲染 HTML） |
| CSS | **Tailwind CSS** |
| JS模块 | ES Module（import/export），vanilla JS composable 模式 |
| 图表 | ECharts（懒加载） |
| 页面组织 | 每个功能一个 HTML 页面 + 对应 composable JS |

**关键点**：admin 前端不是 SPA（Vue/React），是 MPA（Multi-Page Application），每个页面独立加载 Alpine.js 组件。API 调用封装在 `admin/src/api/` 下，使用 `admin/src/api/base.js` 统一封装的 `request()` 函数。

### 1.3 微信小程序前端

（不在本仓库内，属于独立项目，通过 `/api/v4/` 接口与后端通信）

### 1.4 数据库概览（真实数据 96 张表）

| 业务域 | 核心表 | 真实数据量 |
|--------|-------|-----------|
| 核销码 | `redemption_orders` | 1,211 条 |
| 物品实例 | `item_instances` | 6,559 条 |
| 抽奖奖品 | `lottery_prizes` | 15 条 |
| 积分商城 | `exchange_records` / `exchange_items` | 4 / 多条 |
| 交易市场 | `market_listings` / `trade_orders` | 294 / 133 |
| 门店 | `stores` / `store_staff` | 5 / 3 |
| 角色权限 | `roles` / `user_roles` | 11 / 57 |
| 资产账本 | `account_asset_balances` | 多条（7种资产） |
| 系统配置 | `system_configs` | 11 条 |

---

## 二、项目商业模式概述

餐厅积分抽奖营销系统的商业闭环：

```
用户到店消费 → 获得积分 → 花积分抽奖 → 中奖得到物品（优惠券/实物） → 生成核销码 → 到店出示核销码 → 商家核销 → 物品消耗
```

核销码的定位：**线上奖品 → 线下兑换的桥梁凭证**。

---

## 三、当前核销码设计详解（基于代码和真实数据库）

### 3.1 核心文件清单

| 层级 | 文件路径 | 职责 |
|------|----------|------|
| 生成器 | `utils/RedemptionCodeGenerator.js` | 核销码生成、哈希计算、格式验证 |
| 服务层 | `services/RedemptionService.js` | 订单全生命周期管理（创建/核销/取消/过期） |
| 数据模型 | `models/RedemptionOrder.js` | 数据库表定义和关联关系 |
| 用户路由 | `routes/v4/backpack/index.js` | 用户生成核销码 `/items/:item_instance_id/redeem` |
| 商家路由 | `routes/v4/shop/redemption/fulfill.js` | 商家扫码/输码核销 `POST /fulfill` |
| 管理路由 | `routes/v4/console/business-records.js` | 管理员后台核销管理（列表/批量/统计/导出） |
| 前端API | `admin/src/api/redemption.js` | 管理后台核销接口封装（Alpine.js 调用） |
| 前端页面 | `admin/redemption-management.html` + `admin/src/modules/operations/pages/redemption-management.js` | 核销码管理页面 |

### 3.2 核销码的"身份证"体系

每个核销码有三层唯一标识：

| 身份层 | 字段 | 格式 | 用途 |
|--------|------|------|------|
| 用户看到的凭证 | 明文码 | `EWB3-WE4G-F625`（12位Base32） | 给商家出示 |
| 数据库存储标识 | `code_hash` | SHA-256（64位hex），唯一约束 | 查找和验证 |
| 系统内部标识 | `redemption_order_id` | UUID v4 | 后台管理操作 |

关键安全设计：**系统只存哈希值，不存明文码**（决策10：维持 SHA-256 不可逆）。明文码在生成时返回给用户一次，之后系统无法还原。用户丢失码时，取消旧订单重新生成。

### 3.3 核销码格式规范

```
字符集: 23456789ABCDEFGHJKMNPQRSTUVWXYZ（30个字符）
去除了: 0(零)/O(字母)/I(字母)/L(字母)/1(数字) —— 防止用户看混
长度:   12位，分3组
格式:   XXXX-YYYY-ZZZZ
示例:   3K7J-2MQP-WXYZ
```

生成算法：`crypto.randomInt()` 逐字符从字符集中随机选取，生成后算 SHA-256 查库确认唯一性，最多重试 3 次。

### 3.4 数据库表结构（redemption_orders）— 真实 DESCRIBE 查询

| 字段 | 类型 | 约束 | 说明 |
|------|------|------|------|
| `redemption_order_id` | CHAR(36) | PRI | 订单ID（UUID） |
| `code_hash` | VARCHAR(64) | UNI | 核销码SHA-256哈希 |
| `item_instance_id` | BIGINT | FK → item_instances | 关联物品实例 |
| `redeemer_user_id` | INT | FK → users, 可NULL | 核销人（核销前为NULL） |
| `status` | ENUM | 索引 | pending/fulfilled/cancelled/expired |
| `expires_at` | DATETIME | NOT NULL | 过期时间（创建后30天） |
| `fulfilled_at` | DATETIME | 可NULL | 实际核销时间 |
| `created_at` | DATETIME | DEFAULT NOW | 创建时间 |
| `updated_at` | DATETIME | ON UPDATE NOW | 更新时间 |

**⚠️ 当前缺失字段（升级需新增）**：无 `fulfilled_store_id`、无 `fulfilled_by_staff_id`，无法追踪核销门店和操作员工。

### 3.5 真实数据统计（2026-02-20 查询）

| 状态 | 数量 | 占比 |
|------|------|------|
| pending（待核销） | 641 | 52.9% |
| expired（已过期） | 564 | 46.6% |
| fulfilled（已核销） | 5 | 0.4% |
| cancelled（已取消） | 1 | 0.1% |
| **总计** | **1,211** | 100% |

核销物品类型分布（通过 JOIN item_instances 查询确认）：

| 物品类型(item_type) | 已核销数 |
|----------|----------|
| voucher | 4 |
| product | 1 |

物品实例总规模（真实统计）：

| item_type | available | locked | transferred | used | expired | 合计 |
|-----------|-----------|--------|-------------|------|---------|------|
| voucher | 1,868 | 949 | 266 | 1,419 | 3 | 4,505 |
| product | 1,665 | 6 | 0 | 2 | 0 | 1,673 |
| tradable_item | 34 | 0 | 102 | 0 | 0 | 136 |
| prize | 1 | 47 | 0 | 0 | 0 | 48 |
| null（历史数据） | 2 | 126 | 69 | 0 | 0 | 197 |

### 3.6 订单状态流转

```
物品状态: available ──→ locked(redemption锁,30天) ──→ used（核销成功）
                                                    ↗
订单状态: pending ──→ fulfilled（商家/管理员核销成功）
                   ├→ expired（超30天自动过期 → 物品解锁恢复available）
                   └→ cancelled（取消 → 物品解锁恢复available）
```

### 3.7 权限体系（真实 roles 表数据）

| 角色 | role_name | role_level | 用户数 | 核销码相关权限 |
|------|-----------|-----------|--------|---------------|
| 系统任务 | system_job | -1 | 1 | 后台定时任务执行 |
| 普通用户 | user | 0 | 46 | 为自己的物品生成核销码 |
| 活动角色 | campaign_2 | 10 | 2 | 活动参与 |
| 商家员工 | merchant_staff | 20 | 0 | 输入核销码完成核销 |
| 运营 | ops | 30 | 1 | 后台查看核销订单（只读） |
| 业务员 | sales_staff | 40 | 0 | 消费录入 |
| 商家店长 | merchant_manager | 40 | 1 | 核销 + 管理本店员工 |
| 业务经理 | business_manager | 60 | 2 | 管理业务员 |
| 区域负责人 | regional_manager | 80 | 0 | 查看所有核销数据 |
| 管理员 | admin | 100 | 4 | 所有权限 |

### 3.8 安全特性

| 安全机制 | 实现方式 |
|----------|---------|
| 码不可逆 | 只存 SHA-256 哈希，不存明文（决策10 确认维持） |
| 防并发核销 | SELECT ... FOR UPDATE 行锁 |
| 防重复生成 | 同一物品只能有一个 pending 订单 |
| 防越权 | 服务层兜底：所有权 + role_level 双校验 |
| 物品防双花 | 生成码后立即锁定物品（redemption 锁，30天TTL） |
| 事务完整性 | 强制外部事务传入（`assertAndGetTransaction`），所有写操作在事务边界内 |
| 数据脱敏 | 普通用户看不到核销码字段，管理员可见 |

---

## 四、文档与实际代码/数据库差异核查（关键发现）

> 以下是本次对真实代码 + 真实数据库查询后发现的问题，按归属方分类。

### 4.1 后端数据库项目的问题

| # | 问题 | 现状 | 影响 | 所需操作 |
|---|------|------|------|---------|
| B1 | `redemption_orders` 缺少门店关联字段 | 表中无 `fulfilled_store_id`、`fulfilled_by_staff_id` | 无法追踪核销发生在哪个门店、哪个员工操作 | 新增迁移文件添加字段 |
| B2 | `lottery_prizes` 无 `item_type` 列 | 只有 `prize_type`（physical/coupon/points/virtual），路由映射逻辑需要 `prize_type` → `item_type` 的明确规则 | 文档中用 `item_type` 做路由判断不准确 | **路由调度层应基于 `prize_type` 字段**，非 `item_type` |
| B3 | `exchange_records` 缺少 `received`/`rated` 状态 | 当前 ENUM 只有 `pending/completed/shipped/cancelled` | 模型C"确认收货"功能无法实现 | 新增迁移文件扩展 ENUM |
| B4 | `system_configs` 无核销有效期配置项 | 仅有 `batch_rate_limit_redemption`，无默认有效期配置 | 决策9"运营可配置有效期"无法实现 | 插入配置项 + RedemptionService 读取配置逻辑 |
| B5 | `store_staff` 全部 inactive | 3 条记录均为 `status=inactive`，无活跃商家员工 | 门店关联核销功能缺乏测试数据 | 开发阶段需补充测试数据 |
| B6 | `CONSUMPTION_QR_SECRET` 已配置但未使用 | .env 已有该密钥，但 `system_configs` 中无 QR 相关配置 | QR 码动态签名功能尚未实现 | Phase 1 实现 HMAC 签名逻辑时使用 |
| B7 | CDKey 表不存在 | 数据库中无 `cdkey_batches`、`cdkey_codes` 表 | 模型E 暂不影响（决策6：仅设计不实施） | 未来需要时创建 |
| B8 | 核销码过期清理依赖定时任务 | `RedemptionService.expireOrders()` 存在但未见 cron 调度入口 | 过期订单需手动/定时触发 | 确认 cron 配置或添加 |

### 4.2 Web管理后台前端项目的问题

| # | 问题 | 现状 | 影响 |
|---|------|------|------|
| W1 | 核销管理页面已存在 | `admin/redemption-management.html` + `admin/src/modules/operations/pages/redemption-management.js` + `admin/src/modules/lottery/composables/redemption.js` | 已有列表/统计/批量操作/导出功能，可复用 |
| W2 | 核销 API 封装完整 | `admin/src/api/redemption.js` 覆盖 LIST/STATISTICS/EXPORT/BATCH 操作 | 可复用，后续新增接口只需扩展 |
| W3 | 缺少有效期配置面板 | `admin/src/modules/system/composables/config.js` 管理 system_configs，但无核销有效期配置 UI | Phase 1 需新增配置面板 |
| W4 | 缺少门店关联核销数据展示 | 当前核销订单列表不展示门店信息 | 后端加字段后前端需适配展示 |

### 4.3 微信小程序前端项目的问题

| # | 问题 | 现状 | 影响 |
|---|------|------|------|
| M1 | 缺少 QR 码展示页 | 当前仅展示文本核销码 | Phase 1 核心交付项 |
| M2 | 缺少动态 QR 码刷新逻辑 | 无 5 分钟自动刷新机制 | 需新增 HMAC 签名 + 定时刷新 |
| M3 | 背包页面缺少物品类型区分按钮 | "到店领取"和"到店使用"按钮文案未按 item_type 区分 | 前端适配后端 `item_type` 字段 |
| M4 | 积分/虚拟奖品仍进入背包 | 如果当前实现将虚拟/积分奖品放入背包 | 需改为中奖直接到账（决策3） |
| M5 | 商家端缺少扫码核销页面 | 商家只能手动输入码 | Phase 1 核心交付项 |
| M6 | 积分商城无"确认收货"功能 | 当前无此交互 | Phase 3 交付项 |
| M7 | C2C 交易无担保码功能 | 当前实物交易无担保码环节 | Phase 4 交付项 |

---

## 五、当前设计优缺点分析

### 5.1 做得好的地方

| 优点 | 说明 |
|------|------|
| SHA-256 哈希存储 | 明文码不落库，即使数据库泄露也无法还原核销码 |
| 事务边界治理 | 强制外部事务传入 + SELECT FOR UPDATE 行锁 + `assertAndGetTransaction` |
| 幂等性保证 | 同一物品只能有一个 pending 订单 + code_hash 唯一约束 |
| 物品多级锁定 | `item_instances.locks` JSON 字段支持 trade/redemption/security 三级锁，优先级清晰 |
| Base32 去混淆字符 | 去掉 0/O/I/L/1，降低用户读错率 |
| 服务层兜底校验 | 所有权 + role_level 双重校验，不信任路由层 |

### 5.2 当前不足

| 不足 | 影响 |
|------|------|
| 没有 QR 码 | 用户只能口头报读 12 位码，效率低易出错 |
| 没有动态码 | 静态码 30 天不变，截图可被他人盗用 |
| 门店关联弱 | 核销时不强制关联门店，无法追踪核销发生在哪个店（DB 层面缺字段） |
| 所有业务共用一套 | 实物/优惠券/虚拟奖品/积分全用同一种核销码 |
| 有效期硬编码 | RedemptionService 中写死 30 天，运营无法配置 |

---

## 六、升级方案：多模型核销架构（决策1 ✅ 已拍板）

### 6.1 项目真实业务场景全盘梳理

项目存在 **7 条不同的业务链路**，每条链路的核销/交付性质完全不同：

```
┌──────────────────────────────────────────────────────────────────┐
│                        天工系统全业务地图                           │
├──────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ① 抽奖 → 实物奖品 → 到店兑换     （甜品1份、青菜、首饰…）         │
│  ② 抽奖 → 优惠券   → 到店使用     （八八折、九八折券…）            │
│  ③ 抽奖 → 虚拟奖品 → 自动到账     （好运加持、厨师祝福…）          │
│  ④ 抽奖 → 积分奖品 → 自动到账     （100积分、500积分券…）          │
│  ⑤ 积分商城 → 材料兑换商品 → 发货  （红水晶碎片换商品…）           │
│  ⑥ 交易市场 → C2C买卖 → 资产转移  （用户之间买卖物品/材料…）       │
│  ⑦ 运营活动 → 批量发码 → 渠道分发  （未来场景：推广合作…）         │
│                                                                  │
└──────────────────────────────────────────────────────────────────┘
```

### 6.2 各场景真实数据规模（2026-02-20 查询确认）

| 编号 | 业务场景 | 数据库表 | 真实数据量 | 当前核销方式 |
|------|---------|---------|-----------|-------------|
| ① | 实物奖品到店兑换 | redemption_orders + item_instances(product) | 1 fulfilled / 1,673 product 实例 | 12位Base32核销码 |
| ② | 优惠券到店使用 | redemption_orders + item_instances(voucher) | 4 fulfilled / 4,505 voucher 实例 | 12位Base32核销码（与①共用） |
| ③ | 虚拟奖品自动到账 | lottery_prizes(virtual) | 6 种虚拟奖品 | 无需核销，自动到账 |
| ④ | 积分奖品自动到账 | lottery_prizes(points) | 3 种积分奖品 | 无需核销，自动到账 |
| ⑤ | 积分商城兑换发货 | exchange_records | 4 条记录（3 pending + 1 shipped） | 订单号追踪（pending→shipped） |
| ⑥ | C2C交易市场 | market_listings + trade_orders | 294 挂单 / 133 交易 | 冻结→转移（自动） |
| ⑦ | 运营批量发码 | 暂无独立表 | 0（未来场景） | 不存在 |

### 6.3 统一调度层路由规则（基于后端真实字段）

**关键纠正**：`lottery_prizes` 表中没有 `item_type` 列，只有 `prize_type`。而 `item_instances` 有 `item_type`。调度层应基于以下真实字段：

| 判断条件（基于后端真实字段） | 选择模型 | 用户看到的按钮 |
|------|---------|------|
| `item_instances.item_type = 'product'` | 模型A | "到店领取" |
| `item_instances.item_type = 'voucher'` | 模型A | "到店使用" |
| `lottery_prizes.prize_type = 'virtual'` | 模型B | （无按钮，中奖自动到账） |
| `lottery_prizes.prize_type = 'points'` | 模型B | （无按钮，中奖自动到账） |
| 来源=`exchange_records` | 模型C | "查看物流" |
| 来源=`trade_orders` 且 `listing_kind = 'item_instance'` | 模型D | "确认收货" |
| 来源=`trade_orders` 且 `listing_kind = 'fungible_asset'` | 无需核销 | 自动完成 |
| 来源=cdkey_batch（未来） | 模型E | "输入兑换码" |

**`prize_type` → `item_type` 映射关系（后端权威）**：

| lottery_prizes.prize_type | 中奖后创建的 item_instances.item_type | 核销模型 |
|---|---|---|
| `physical` | `product` | 模型A |
| `coupon` | `voucher` | 模型A |
| `virtual` | 不创建 item_instance（直接到账） | 模型B |
| `points` | 不创建 item_instance（直接到账） | 模型B |

### 6.4 统一调度层架构

```
                    ┌────────────────────┐
                    │   统一核销调度层     │
                    │  RedemptionRouter   │
                    └─────────┬──────────┘
                              │ 根据 item_type / 来源表 自动分发
              ┌───────────────┼───────────────┐
              │               │               │
              ▼               ▼               ▼
      ┌──────────────┐ ┌──────────┐ ┌──────────────┐
      │ 模型A: O2O码 │ │模型B: 自动│ │ 模型C: 发货单│
      │  到店核销     │ │ 核销      │ │  物流追踪    │
      └──────────────┘ └──────────┘ └──────────────┘
              │                              │
              ▼                              ▼
      ┌──────────────┐              ┌──────────────┐
      │ 模型D: 担保码 │              │ 模型E: CDKey  │
      │  C2C交易     │              │  批量分发     │
      └──────────────┘              └──────────────┘
```

### 6.5 业务场景 → 核销模型映射

| 业务场景 | 核销模型 | 灵感来源 | 用户看到的按钮 |
|----------|---------|---------|--------------|
| ① 实物奖品到店兑换 | **模型A：O2O动态码** | 美团到店核销 | "到店领取" |
| ② 优惠券到店使用 | **模型A：O2O动态码** | 美团优惠券 | "到店使用" |
| ③ 虚拟奖品自动到账 | **模型B：自动核销** | 游戏道具发放 | （无按钮，自动到账） |
| ④ 积分奖品自动到账 | **模型B：自动核销** | 同上 | （无按钮，自动到账） |
| ⑤ 积分商城兑换 | **模型C：发货单追踪** | 淘宝/电商 | "查看物流" |
| ⑥ C2C交易市场（实物） | **模型D：担保交易码** | 闲鱼/5173 | "确认收货" |
| ⑦ 运营批量发码 | **模型E：CDKey批量** | 腾讯CDKey | "输入兑换码" |

---

## 七、各模型详细设计

### 模型A：O2O 动态码 — 到店核销（决策2/7/8/9/10/11 ✅）

**适用对象**：`item_instances.item_type = 'product'`（实物）和 `item_instances.item_type = 'voucher'`（优惠券）

**基于决策结果的最终设计**：

| 维度 | 当前设计 | 升级后（已拍板） | 决策依据 |
|------|---------|-----------------|---------|
| 码格式 | 12位Base32文本 | 12位Base32 + **动态QR码** + 文本码备用 | 决策7：B+B-2 |
| 动态防护 | 无 | QR码 **5分钟有效**，HMAC签名（`CONSUMPTION_QR_SECRET`），过期自动刷新 | 决策7：B-2 |
| 核销方式 | 商家手动输入码 | 商家**扫QR码**（主）+ 手动输入文本码（备） | 决策7：B |
| 确认机制 | 商家单方 | **商家单方扫码即完成**，不需要用户确认 | 决策11 |
| 门店关联 | 弱（DB无字段） | **强制关联**：通过 store_staff 自动确定门店 | 决策8：A |
| 有效期 | 固定30天 | **运营可配置**：system_configs 全局默认 + 奖品级别覆盖 | 决策9：C |
| 码存储 | SHA-256哈希 | **维持 SHA-256 不可逆**，丢码取消重生成 | 决策10：A |

**最终交互流程**（实物和优惠券统一）：

```
用户                              商家
 │                                 │
 │ 1. 背包 → 点击物品               │
 │    → "到店领取"/"到店使用"按钮   │
 │                                 │
 │ 2. 生成核销码                    │
 │    显示动态QR码（5分钟自动刷新）   │
 │    + 底部显示文本码（备用）        │
 │    + 有效期倒计时                │
 │                                 │
 │ 3. 到店，出示QR码屏幕   ────────→│ 4. 商家扫码
 │                                 │    显示：物品名称 / 用户昵称
 │                                 │    门店：自动匹配（store_staff）
 │                                 │    → 扫码即核销完成（无用户确认）
 │                                 │
 │ 5. 收到微信模板消息通知  ←───────│
 │    "您的XX已在XX门店核销"         │
```

---

### 模型B：自动核销 — 虚拟奖品 / 积分到账（决策3 ✅）

**适用对象**：`lottery_prizes.prize_type = 'virtual'`（好运加持等）和 `lottery_prizes.prize_type = 'points'`（100积分等）

**基于决策结果**：中奖直接到账，**不进入背包**，不需要核销码。

| 维度 | 设计 |
|------|------|
| 核销码 | **不需要** |
| 触发方式 | 抽奖命中 → 系统自动执行 |
| 积分类 | 直接 credit 到用户 `account_asset_balances`（asset_code=POINTS） |
| 虚拟类 | 直接标记效果或不创建 item_instance |
| 用户感知 | 抽奖结果页直接显示"XXX已到账"，**不进入背包** |
| 失败处理 | 自动重试 3 次，失败转人工补发队列 |

---

### 模型C：发货单追踪 — 积分商城兑换（决策4 ✅）

**适用对象**：`exchange_records` 表的商品兑换订单

**基于决策结果**：加确认收货，发货后 7 天未操作自动确认。

**状态流转（升级 exchange_records ENUM）**：

```
pending（待审核）
  ├→ approved（审核通过）→ shipped（已发货）→ received（已收货/7天自动）→ rated（已评价）
  ├→ rejected（审核拒绝）→ refunded（已退款）
  └→ cancelled（用户取消）
```

**⚠️ 当前 ENUM 仅有** `pending/completed/shipped/cancelled`，需迁移扩展为 `pending/approved/shipped/received/rated/rejected/refunded/cancelled`。

---

### 模型D：担保交易码 — C2C 交易市场（决策5 ✅）

**适用对象**：`market_listings` + `trade_orders` 中 `listing_kind = 'item_instance'` 的实物交易

| 维度 | 设计 |
|------|------|
| 码格式 | **6位纯数字短码**（如：582917），用完即焚 |
| 存储方式 | Redis 短期存储，**30分钟有效** |
| 触发时机 | 买方付款（资产冻结）→ 系统生成担保码发给**卖方** |
| 核销方式 | 卖方交付物品后，将担保码告知买方 → 买方输入码确认收货 |
| 资金释放 | 买方确认 → 冻结资产转给卖方 → 交易完成 |

`fungible_asset` 交易（材料/货币）：不需要担保码，系统自动冻结→转移→完成。

---

### 模型E：CDKey 批量分发 — 运营推广（决策6 ✅ 仅设计）

本期仅设计方案和表结构，不实施开发。等业务需要时启动。

---

## 八、后端可复用资产和扩展点分析

### 8.1 可直接复用的后端代码

| 资产 | 文件 | 复用场景 | 改动量 |
|------|------|---------|--------|
| 核销码生成器 | `utils/RedemptionCodeGenerator.js` | 模型A 直接复用 | 0（无需改动） |
| 核销服务层 | `services/RedemptionService.js` | 模型A 的创建/核销/取消/过期逻辑直接复用 | 小（扩展门店参数） |
| 核销数据模型 | `models/RedemptionOrder.js` | 模型A 直接复用 | 小（加字段迁移） |
| 物品锁定机制 | `models/ItemInstance.js` 的 `lock()`/`unlock()` | 模型A/D 复用 | 0 |
| 事务管理 | `utils/transactionHelpers.js` | 所有模型复用 | 0 |
| 用户背包路由 | `routes/v4/backpack/index.js` | 模型A 的码生成入口已有 | 小（加 QR 码返回） |
| 商家核销路由 | `routes/v4/shop/redemption/fulfill.js` | 模型A 直接复用 | 小（加门店关联） |
| 资产账本服务 | `services/asset/BalanceService.js` | 模型B 积分到账 / 模型D 冻结释放 | 0 |
| 交易市场服务 | `services/market-listing/CoreService.js` | 模型D 担保码集成点 | 中（加担保码逻辑） |
| 管理后台路由 | `routes/v4/console/business-records.js` | 模型A 管理端已有完整 CRUD | 小（适配新字段） |
| 定时任务框架 | `node-cron` 已安装 | 模型A 过期清理 / 模型C 7天自动确认 | 小 |
| HMAC 密钥 | `.env` 的 `CONSUMPTION_QR_SECRET` | 模型A QR 码签名 | 0（密钥已就绪） |

### 8.2 可扩展的现有机制

| 机制 | 现有实现 | 扩展方式 |
|------|---------|---------|
| `system_configs` 表 | 已有 11 个配置项，管理后台有配置页面 | 插入核销有效期配置项 |
| `item_instances.locks` JSON 多级锁 | 已支持 trade/redemption/security | 无需扩展 |
| `store_staff` 表 | 已有门店-员工绑定关系 | 核销时查询员工所属门店 |
| Admin API 封装模式 | `admin/src/api/redemption.js` 模式清晰 | 新增 endpoint 按同样模式扩展 |
| Composable 模式 | `admin/src/modules/*/composables/*.js` | 新功能按同样模式组织 |

### 8.3 Web管理后台前端复用评估

| 已有资产 | 路径 | 复用性 |
|---------|------|--------|
| 核销管理页面 | `admin/redemption-management.html` | ✅ 高复用，扩展列展示门店信息 |
| 核销 composable | `admin/src/modules/lottery/composables/redemption.js` | ✅ 高复用 |
| 核销 API 封装 | `admin/src/api/redemption.js` | ✅ 高复用，新增 endpoint |
| 系统配置管理 | `admin/src/modules/system/composables/config.js` | ✅ 高复用，加核销配置 tab |
| 数据表组件模式 | `admin/src/templates/components/data-table.ejs` | ✅ 高复用 |
| Alpine.js x-data 组件模式 | 全站统一 | ✅ 所有新页面遵循此模式 |

---

## 九、分阶段实施方案（基于后端技术栈的执行步骤）

### Phase 1：升级到店核销（模型A）

#### 后端执行步骤

**步骤 1.1**：数据库迁移 — `redemption_orders` 添加门店字段

- 新建迁移文件 `migrations/YYYYMMDDHHMMSS-add-store-fields-to-redemption-orders.js`
- 添加字段：`fulfilled_store_id`（INT, FK → stores.store_id, 可 NULL）、`fulfilled_by_staff_id`（BIGINT, FK → store_staff.store_staff_id, 可 NULL）
- `models/RedemptionOrder.js` 新增字段定义和关联

**步骤 1.2**：数据库迁移 — `system_configs` 插入有效期配置

- 插入配置项：`redemption_default_expiry_days`（默认值 `{"product": 7, "voucher": 30}`）
- `RedemptionService.createOrder()` 改为读取配置确定有效期

**步骤 1.3**：QR 码动态签名服务

- 新建 `utils/QRCodeSigner.js`，使用 `CONSUMPTION_QR_SECRET` 做 HMAC-SHA256 签名
- QR 码内容：`JSON.stringify({ order_id, code_hash, timestamp, signature })`
- 有效期 5 分钟，过期需客户端重新请求

**步骤 1.4**：改造核销流程加门店关联

- `RedemptionService.fulfillOrder()` 增加 `store_id` 和 `staff_id` 参数
- 核销时自动查 `store_staff` 确定门店（通过 `redeemer_user_id` → `store_staff.user_id` → `store_staff.store_id`）
- 如查不到活跃 store_staff 记录，管理员可手动指定 store_id

**步骤 1.5**：新增 QR 码核销接口

- `routes/v4/shop/redemption/` 新增 `POST /scan`（扫描 QR 码内容验证签名 + 核销）
- 保留原有 `POST /fulfill`（手动输入文本码核销）作为备用

**步骤 1.6**：背包路由返回 QR 码数据

- `routes/v4/backpack/index.js` 的 `/items/:id/redeem` 返回中增加 `qr_payload` 和 `qr_expires_at`
- 新增 `POST /items/:id/redeem/refresh-qr` 刷新 QR 码

#### Web管理后台执行步骤

**步骤 1.7**：核销管理页面适配

- `admin/src/api/redemption.js` 无需改动（后端响应自动包含新字段）
- `admin/redemption-management.html` 表格增加"核销门店"列
- `admin/src/modules/lottery/composables/redemption.js` 适配新字段展示

**步骤 1.8**：有效期配置面板

- `admin/src/modules/system/composables/config.js` 新增核销配置读写
- 复用现有 `system_configs` 管理模式

#### 微信小程序执行步骤

**步骤 1.9**：QR 码展示页

- 调用 `/items/:id/redeem` 获取核销码和 QR payload
- 使用小程序 canvas 渲染 QR 码
- 5 分钟倒计时 + 自动调用 `/refresh-qr` 刷新

**步骤 1.10**：商家扫码核销页

- 调用小程序扫码 API 扫描 QR 码
- 解析 QR 码 JSON → 调用 `POST /scan` 核销
- 展示核销结果（物品名、用户昵称、门店名）

---

### Phase 2：虚拟/积分自动到账（模型B）

#### 后端执行步骤

**步骤 2.1**：抽奖引擎 SettleStage 改造

- `services/UnifiedLotteryEngine/pipeline/stages/SettleStage.js` 是抽奖结算入口
- `prize_type = 'points'` 时：直接调用 `BalanceService.changeBalance()` 将 `prize_value` 加到用户 POINTS
- `prize_type = 'virtual'` 时：不创建 item_instance，直接返回效果描述

**步骤 2.2**：确认 item_instance 不创建

- 确保 points/virtual 中奖不走 item_instance 创建流程

#### 微信小程序执行步骤

**步骤 2.3**：抽奖结果页适配

- points 类型显示"恭喜获得 XXX 积分！已自动到账"
- virtual 类型显示效果描述（好运加持等）
- 不显示"去背包查看"按钮

---

### Phase 3：积分商城确认收货（模型C）

#### 后端执行步骤

**步骤 3.1**：数据库迁移 — exchange_records ENUM 扩展

- 迁移文件将 status ENUM 从 `pending/completed/shipped/cancelled` 扩展为 `pending/approved/shipped/received/rated/rejected/refunded/cancelled`
- 新增字段：`received_at`（DATETIME）、`auto_confirmed`（BOOLEAN, 标记是否自动确认）

**步骤 3.2**：确认收货接口

- `routes/v4/shop/exchange/` 新增 `POST /:exchange_record_id/confirm-receipt`
- `services/exchange/CoreService.js` 添加确认收货逻辑

**步骤 3.3**：7 天自动确认定时任务

- 使用 `node-cron` 每天凌晨扫描 `status = 'shipped'` 且 `shipped_at + 7天 < NOW()` 的记录
- 自动更新为 `received` + `auto_confirmed = true`

#### 微信小程序执行步骤

**步骤 3.4**：订单详情 + 确认收货按钮

---

### Phase 4：C2C担保码（模型D）

#### 后端执行步骤

**步骤 4.1**：担保码 Redis 服务

- 新建 `services/EscrowCodeService.js`
- 6 位纯数字码生成，Redis 存储 30 分钟（key: `escrow:${trade_order_id}`）

**步骤 4.2**：交易流程集成

- `services/market-listing/CoreService.js` 在 `listing_kind = 'item_instance'` 的交易中：
  - 买方付款后生成担保码 → 通知卖方
  - 买方输入担保码 → 验证通过 → 完成交易

#### 微信小程序执行步骤

**步骤 4.3**：担保码展示 + 输入确认页面

---

### Phase 5：CDKey（仅设计不实施）

设计表结构 `cdkey_batches` + `cdkey_codes`，不建表不开发。

---

## 十、全部决策记录（11 项已拍板）

### 决策1：多模型架构 → ✅ A：采用多模型

不同业务用不同核销方式，统一调度层自动分发。

### 决策2：实物核销双方确认 → ✅ 不需要用户确认

商家扫码即核销完成，核销后发微信模板消息通知用户。

### 决策3：虚拟/积分进背包 → ✅ A：不进背包，直接到账

中奖即到账，抽奖结果页显示"已到账"，不生成核销码。

### 决策4：积分商城确认收货 → ✅ A：加确认收货

发货后用户可确认收货，7天未操作自动确认。

### 决策5：C2C交易担保码 → ✅ A：仅实物交易用

`listing_kind=item_instance` 用 6 位担保码；`fungible_asset` 自动转移。

### 决策6：CDKey批量分发 → ✅ B：仅设计不实施

### 决策7：QR码核销 → ✅ B + B-2

QR码 + 文本码并存；QR码内容为动态HMAC签名JSON，5分钟有效，基于 `CONSUMPTION_QR_SECRET`。

### 决策8：门店强制关联 → ✅ A：强制关联

核销时自动根据商家员工的 `store_staff` 绑定关系确定门店。

### 决策9：有效期策略 → ✅ C：运营可配置

在 `system_configs` 中配置全局默认有效期 + 奖品级别覆盖。

### 决策10：SHA-256 不可逆 → ✅ A：维持不可逆

### 决策11：用户确认环节 → ✅ 不需要

---

## 十一、总投入汇总

| 阶段 | 后端 | Web管理后台 | 微信小程序 | 合计 |
|------|------|------------|-----------|------|
| Phase 1（到店核销升级） | 3.5 天 | 1 天 | 2 天 | 6.5 天 |
| Phase 2（自动到账） | 1 天 | 0 天 | 0.5 天 | 1.5 天 |
| Phase 3（确认收货） | 1.5 天 | 0.5 天 | 0.5 天 | 2.5 天 |
| Phase 4（担保码） | 1.5 天 | 0 天 | 1 天 | 2.5 天 |
| Phase 5（CDKey设计） | 0.5 天 | 0 天 | 0 天 | 0.5 天 |
| **总计** | **8 天** | **1.5 天** | **4 天** | **13.5 天** |

---

## 十二、需要拍板的遗留问题

> 以下问题不影响已有 11 项决策，但实施中需要确认。

| # | 问题 | 选项 | 建议 | 理由 |
|---|------|------|------|------|
| P1 | `exchange_records.status` 扩展 ENUM 方案 | A：一次性加全部新状态（approved/received/rated/rejected/refunded）| B：分步加 | **建议A**，项目未上线，一步到位 |
| P2 | 模型B 虚拟奖品 `prize_type='virtual'` 中奖后是否还创建 item_instance | A：不创建（推荐）| B：创建但 status=used | **建议A**，减少无意义数据 |
| P3 | 担保码（模型D）超时后自动取消交易 vs 转客服仲裁 | A：自动取消退款 | B：转客服 | 取决于业务需求复杂度 |
| P4 | `store_staff` 当前全部 inactive，是否需要先补充测试数据再开发 | A：先补数据 | B：开发时自动创建 | **建议A**，便于联调测试 |
| P5 | 核销过期清理定时任务调度频率 | A：每小时 | B：每天凌晨 | **建议B**，30天粒度无需高频 |
