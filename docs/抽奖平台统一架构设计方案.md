# 抽奖平台统一架构设计方案

> **文档版本**: V1.6  
> **创建时间**: 2026-01-16  
> **最后更新**: 2026-01-18（新增 0.18-0.21 拍板：管理干预独立管线、pool+quota 必须实现、预设无需二次审批、自动补差非法输入直接拒绝）  
> **状态**: 架构设计（可直接进入开发）

---

## 〇、决策拍板记录（2026-01-16）

> 本章节记录产品/技术负责人对关键架构决策的明确拍板，后续实现必须严格遵循。

### 0.1 预设功能核心语义

**拍板结论**：选择 **方案 B**（必须发放；扣不了就记欠账；用户永远看到成功）

| 维度       | 决策内容                                                           |
| ---------- | ------------------------------------------------------------------ |
| 语义定义   | 预设是"承诺交付"（entitlement/发放承诺），扣减只是"尽力而为"       |
| 一致性模型 | 引入负债/欠账概念（库存欠、预算欠）；需要冲销与审计闭环            |
| 用户体验   | 最强——表面永远成功、永远看到中奖                                   |
| 运营成本   | 高——欠账表 + 冲销策略 + 定时任务 + 看板 + 资金/库存风控 + 客服话术 |
| 风险控制   | 必须设置欠账上限 + 审计追责 + 监控告警，否则会变成不可控           |

---

### 0.2 欠账硬规则（不可违反）

| 规则编号  | 规则内容                                                                                                                                                                                                                                                                                           |
| --------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **规则1** | **欠账只能来自"预设管线"**<br>普通抽奖/活动参与/兑换/市场交易/任何非预设写操作：预算或库存不足 → 直接失败（不写欠账表，不做补偿发放）                                                                                                                                                              |
| **规则2** | **欠账只允许两类**<br>• 预算欠账：`pool_budget_remaining` 不够，或用户侧 `BUDGET_POINTS` 不够 → 记 `preset_budget_debt`<br>• 库存欠账：奖品 `stock_quantity` 不够或日限额满 → 记 `preset_inventory_debt`<br>• **不允许 POINTS 欠账**：POINTS 是"用户资产"，欠账等于允许负余额/赊账，风控复杂度暴增 |
| **规则3** | **欠账前必须"先尝试扣减"且扣减要原子化**<br>• 库存扣减必须是 `UPDATE ... SET stock=stock-1 WHERE stock>0`（防并发超卖）<br>• 预算扣减必须是事务内原子扣减（pool 或 BUDGET_POINTS），失败才记录欠账                                                                                                 |
| **规则4** | **发放必须与欠账记录强绑定、可对账、可冲销**<br>每次"欠账发放"都要能回答：欠了什么、欠多少、给了谁、对应哪次预设、对应哪次抽奖记录、后续怎么冲销、冲销状态是什么                                                                                                                                   |
| **规则5** | **POINTS 不足，预设也必须失败**<br>预设仍是"正常抽奖动作"，POINTS 不足就失败（因为明确不允许 POINTS 欠账）                                                                                                                                                                                         |
| **规则6** | **欠账必须审计到责任人**<br>只有管理员/运营角色能创建可欠账预设；每笔欠账记录必须带 `preset_id` + `created_by` + `reason`（否则后面没法追责/治理）                                                                                                                                                 |

---

### 0.3 欠账上限配置（运营可动态调整，不允许硬编码）

| 上限维度               | 配置字段建议             | 说明                                     |
| ---------------------- | ------------------------ | ---------------------------------------- |
| 单活动预算欠账上限     | `max_budget_debt`        | 该活动累计预算欠账不得超过此值           |
| 单奖品库存欠账数量上限 | `max_inventory_debt_qty` | 该奖品累计欠货数量不得超过此值           |
| 单用户每日欠账上限     | `user_daily_debt_limit`  | 防止集中薅                               |
| 单用户总欠账上限       | `user_total_debt_limit`  | 防止无限累积                             |
| 预设功能总闸（活动级） | `preset_debt_enabled`    | `true/false`，控制该活动预设是否允许欠账 |

> **存放位置**：建议放在 `lottery_campaigns.prize_distribution_config` 或 `system_settings`（默认 + 活动覆盖）。

---

### 0.4 预设预算扣减策略（已拍板）

**拍板结论**：默认使用 `follow_campaign`，`pool_first` / `user_first` **功能要实现但默认关闭**。

| 配置项                 | 类型     | 默认值            | 说明                                                              |
| ---------------------- | -------- | ----------------- | ----------------------------------------------------------------- |
| `preset_budget_policy` | `string` | `follow_campaign` | 预设预算扣减策略：`follow_campaign` / `pool_first` / `user_first` |

#### 三种策略选项说明（功能都要实现）

| 策略选项              | 业务含义                                                                                                                                                                             | 默认状态                            |
| --------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ----------------------------------- |
| **`follow_campaign`** | 预设预算扣减**严格遵循活动 `budget_mode`**<br>• `budget_mode=user` → 只扣用户 BUDGET_POINTS<br>• `budget_mode=pool` → 只扣活动池<br>• **不跨预算源兜底**，不存在扣到另一个钱包的情况 | ✅ **默认启用**                     |
| `pool_first`          | 预设预算扣减固定走 **pool → user(BUDGET_POINTS)** 优先级<br>• 先扣活动池 `pool_budget_remaining`<br>• 池不够时，**差额**再扣用户 `BUDGET_POINTS`<br>• 属于"跨预算源兜底"模式         | ⚪ 默认关闭（功能实现，运营可开启） |
| `user_first`          | 预设预算扣减固定走 **user(BUDGET_POINTS) → pool** 优先级<br>• 先扣用户 `BUDGET_POINTS`<br>• 用户预算不够时，**差额**再扣活动池 `pool_budget_remaining`<br>• 属于"跨预算源兜底"模式   | ⚪ 默认关闭（功能实现，运营可开启） |

---

#### follow_campaign 的精确定义（默认策略）

| 活动 budget_mode | 预算扣减行为                                                     |
| ---------------- | ---------------------------------------------------------------- |
| `user`           | 只扣用户侧 `BUDGET_POINTS`（不会去扣 pool）                      |
| `pool`           | 只扣活动池 `pool_budget_remaining`（不会去扣用户 BUDGET_POINTS） |
| `none`           | 不扣预算（仅用于测试）                                           |

> **关键约束**：使用 `follow_campaign` 时，不存在"扣不够就去扣另一个钱包"的情况。

---

#### pool_first / user_first 的精确定义（可选策略）

如果运营开启 `pool_first` 或 `user_first`，必须遵循以下**补差额**逻辑：

**pool_first 扣减流程**（先 pool 后 user）：

```
1. 计算奖品预算成本 = prize_value_points
2. 尝试扣 pool_budget_remaining：
   - 如果 pool >= 成本 → 全部从 pool 扣，结束
   - 如果 pool < 成本 → 把 pool 扣到 0，计算差额 = 成本 - pool
3. 差额部分尝试扣用户 BUDGET_POINTS：
   - 如果 BUDGET_POINTS >= 差额 → 扣差额，结束
   - 如果 BUDGET_POINTS < 差额 → 根据 preset_debt_enabled 决定欠账或失败
```

**user_first 扣减流程**（先 user 后 pool）：

```
1. 计算奖品预算成本 = prize_value_points
2. 尝试扣用户 BUDGET_POINTS：
   - 如果 BUDGET_POINTS >= 成本 → 全部从用户扣，结束
   - 如果 BUDGET_POINTS < 成本 → 把用户扣到 0，计算差额 = 成本 - BUDGET_POINTS
3. 差额部分尝试扣 pool_budget_remaining：
   - 如果 pool >= 差额 → 扣差额，结束
   - 如果 pool < 差额 → 根据 preset_debt_enabled 决定欠账或失败
```

> **注意**：即使开启 `pool_first` / `user_first`，**POINTS 仍永不欠账**，这里扣的是 BUDGET_POINTS（预算积分），不是 POINTS（抽奖成本积分）。

---

#### 当选定钱包/池子不够时的分支

| `preset_debt_enabled` | `preset_budget_policy`      | 处理方式                                                      |
| --------------------- | --------------------------- | ------------------------------------------------------------- |
| `true`                | `follow_campaign`           | 单源不够 → 记预算欠账，仍发放奖品                             |
| `true`                | `pool_first` / `user_first` | 两源都扣完仍不够 → 记预算欠账（欠的是最后一个源），仍发放奖品 |
| `false`               | `follow_campaign`           | 单源不够 → 直接失败，不发放                                   |
| `false`               | `pool_first` / `user_first` | 两源都扣完仍不够 → 直接失败，不发放                           |

---

#### 核心约束（所有策略都必须遵循）

1. **POINTS 永不欠账**：预设仍要先扣 POINTS（抽奖成本）；POINTS 不足就失败。
2. **BUDGET_POINTS 可欠账**：但必须在 `preset_debt_enabled=true` 且未超限时才允许。
3. **欠账必须有上限**：无上限必定滚大。
4. **pool_first/user_first 采用补差额模式**：先把第一预算源扣到 0，差额再从第二预算源扣。

---

### 0.5 预设功能新增配置项汇总

| 配置项                   | 类型      | 默认值               | 说明                                                                     |
| ------------------------ | --------- | -------------------- | ------------------------------------------------------------------------ |
| `preset_debt_enabled`    | `boolean` | `false`              | 该活动预设是否允许欠账（核心开关）                                       |
| `preset_budget_policy`   | `string`  | `follow_campaign`    | 预设预算扣减策略：`follow_campaign`（默认）/ `pool_first` / `user_first` |
| `max_budget_debt`        | `number`  | `0`（不限 = 不推荐） | 单活动预算欠账上限                                                       |
| `max_inventory_debt_qty` | `number`  | `0`（不限 = 不推荐） | 单奖品库存欠账数量上限（需放到奖品级或活动级）                           |
| `user_daily_debt_limit`  | `number`  | `0`（不限 = 不推荐） | 单用户每日欠账上限                                                       |
| `user_total_debt_limit`  | `number`  | `0`（不限 = 不推荐） | 单用户总欠账上限                                                         |

> **欠账范围锁死**：只欠预算（BUDGET_POINTS / pool）/ 库存，不欠 POINTS（POINTS 不足预设直接失败）。

#### preset_budget_policy 三种策略速查

| 策略值            | 扣减优先级                           | 是否跨源兜底 | 默认状态    |
| ----------------- | ------------------------------------ | ------------ | ----------- |
| `follow_campaign` | 严格遵循活动 `budget_mode`（单源）   | ❌ 不跨源    | ✅ 默认启用 |
| `pool_first`      | pool → user(BUDGET_POINTS)（补差额） | ✅ 跨源兜底  | ⚪ 默认关闭 |
| `user_first`      | user(BUDGET_POINTS) → pool（补差额） | ✅ 跨源兜底  | ⚪ 默认关闭 |

---

### 0.6 全局默认预算模型（已拍板 2026-01-17）

**拍板结论**：`budget_mode` **不允许默认值**，活动创建时运营**必须显式指定**。

| 维度     | 决策内容                                                                                      |
| -------- | --------------------------------------------------------------------------------------------- |
| 允许值   | `budget_mode` 仅允许 `user` / `pool` / `none` 三个值                                          |
| 默认策略 | **无默认值**（不允许缺省为 `user` 或 `pool`）；活动创建/上线前必须强制配好，否则校验不通过    |
| 强制配置 | 活动开始前，运营必须在后台显式选择走 `user`（用户 BUDGET_POINTS）还是 `pool`（活动池预算）    |
| 校验规则 | 活动状态从 `draft` → `active` 时，系统必须校验 `budget_mode` 非空且为合法枚举值，否则阻止上线 |

#### 三种 budget_mode 定义

| budget_mode | 预算来源                       | 适用场景                                 |
| ----------- | ------------------------------ | ---------------------------------------- |
| `user`      | 用户侧 `BUDGET_POINTS`         | 用户自己的预算积分，适合用户可感知的抽奖 |
| `pool`      | 活动池 `pool_budget_remaining` | 活动统一预算池，适合平台补贴型活动       |
| `none`      | 不扣预算                       | 仅测试/免费活动使用                      |

> **设计理由**：避免运营漏配导致预算来源不明确，强制显式选择可减少线上事故和对账混乱。

---

### 0.7 pool+quota 归属与变体设计（已拍板 2026-01-17）

**拍板结论**：`pool+quota` 归类为 **`budget_mode=pool` 的增强变体**，而不是与 `pool` 平级的独立 `budget_mode`。

| 维度       | 决策内容                                                                             |
| ---------- | ------------------------------------------------------------------------------------ |
| 配置层设计 | `budget_mode=pool` 时，增加子字段 `pool_variant`：`plain`（默认）/ `quota`           |
| 默认值     | `pool_variant=plain`（即 `pool` 模式默认不启用配额）                                 |
| 业务概念   | 对外只有 3 个主模式（`user` / `pool` / `none`）；`pool+quota` 只是 `pool` 的细化能力 |
| 代码实现   | 内部拆成 `PoolBudgetProvider`（plain）/ `PoolQuotaBudgetProvider`（quota）两个实现类 |
| 长期收益   | 分支扩散更少——判断"是不是 pool"即可，不用处处写"pool 或 pool+quota"                  |

#### 配置结构示例

```json
{
  "budget_mode": "pool",
  "pool_variant": "quota", // plain(默认) | quota
  "pool_budget_remaining": 100000,
  "quota_config": {
    "enabled": true,
    "whitelist_mode": "all",
    "default_quota": 1000,
    "reserve_pool": 5000
  }
}
```

#### pool_variant 两种变体对比

| pool_variant | 扣减逻辑                                                      | 需要新增表                                                       | 默认状态      |
| ------------ | ------------------------------------------------------------- | ---------------------------------------------------------------- | ------------- |
| `plain`      | 仅扣活动池 `pool_budget_remaining`                            | 无                                                               | ✅ 默认       |
| `quota`      | 先扣用户配额 `lottery_campaign_user_quota`，再扣活动池 `pool` | `lottery_campaign_user_quota`<br>`lottery_campaign_quota_grants` | ⚪ 需显式开启 |

> **设计理由**：
>
> 1. **业务概念更少**：产品/运营/文档只需理解 3 个主模式，`pool+quota` 是 `pool` 的增强。
> 2. **分支扩散更少**：业务规则判断只需"是不是 pool"，不会到处写"pool 或 pool+quota"。
> 3. **工程清晰度保留**：代码层仍拆成两个 Provider，测试/灰度/回滚更容易。

---

### 0.8 概率缺口处理策略（已拍板 2026-01-17）

**拍板结论**：以 **C) 档位优先（tier_first）** 为主线，**+ 空档降级链路（high→mid→low）**，**降级尽头再 fallback**，**不采用 B) 归一化**。

| 维度     | 决策内容                                                                                   |
| -------- | ------------------------------------------------------------------------------------------ |
| 主策略   | **档位优先（tier_first）**：先按档位（tier）抽取，再在档位内部按概率抽取具体奖品           |
| 空档降级 | **允许跨档降级**：目标档位无可发奖品时，按 **high→mid→low** 链路自动降级，直到找到可发档位 |
| 降级尽头 | **fallback 兜底**：降级链路走完仍无可发奖品时，命中 `prize_value_points=0` 的兜底奖品      |
| 明确放弃 | **不采用归一化**：不做"剩余奖品概率放大"处理，避免运营配置的概率被隐式改变                 |
| 审计要求 | **降级必须记入决策快照**：记录命中档位、降级次数、最终档位、降级原因（库存/预算/日限额）   |

---

#### 三种策略对比（最终选择 C + A）

| 策略代号 | 策略名称               | 处理方式                                         | 是否采用                    |
| -------- | ---------------------- | ------------------------------------------------ | --------------------------- |
| **A**    | fallback（兜底奖）     | 缺口概率绑定到 `prize_value_points=0` 的兜底奖品 | ✅ **采用**（作为缺口出口） |
| **B**    | 归一化（概率放大）     | 剩余可发奖品的概率按比例放大，使总和=100%        | ❌ **不采用**               |
| **C**    | 档位优先（tier_first） | 先抽档位（low/mid/high），再在档位内部抽具体奖品 | ✅ **采用**（作为主线）     |

---

#### 档位优先 + 空档降级 + fallback 的组合语义（已拍板 2026-01-17）

```
抽奖流程：
1. 根据 lottery_tier_rules 配置的档位概率，先抽出目标档位（如 high/mid/low）
2. 在目标档位内，筛选出当前可发放的奖品（库存>0、预算足够、日限额未满）
3. 如果目标档位有可发奖品：
   → 按档位内奖品的 win_probability 抽取具体奖品，流程结束
4. 如果目标档位无可发奖品（空档）：
   → 执行降级链路：high → mid → low（按固定顺序尝试下一档位）
   → 降级到的档位有可发奖品时，在该档位内抽取，流程结束
5. 如果降级链路走完仍无可发奖品（所有档位都空）：
   → 走 fallback：命中 prize_value_points=0 的兜底奖品
   → 兜底奖品也没有/也耗尽：返回失败
```

#### 降级链路示意图

```
用户命中 high 档
      │
      ▼
┌─────────────────┐
│ high 档有可发？  │──── 是 ───→ 在 high 档内抽奖品 → 结束
└─────────────────┘
      │ 否（空档）
      ▼
┌─────────────────┐
│ mid 档有可发？   │──── 是 ───→ 在 mid 档内抽奖品 → 结束（决策快照记录：降级1次）
└─────────────────┘
      │ 否（空档）
      ▼
┌─────────────────┐
│ low 档有可发？   │──── 是 ───→ 在 low 档内抽奖品 → 结束（决策快照记录：降级2次）
└─────────────────┘
      │ 否（空档）
      ▼
┌─────────────────┐
│ fallback 兜底奖  │──── 有 ───→ 发放兜底奖 → 结束（决策快照记录：降级3次+触发fallback）
└─────────────────┘
      │ 无
      ▼
    返回失败
```

---

#### 落地影响（需要新增的表/字段）

| 需新增/修改                  | 用途                                                                                        |
| ---------------------------- | ------------------------------------------------------------------------------------------- |
| `lottery_tier_rules` 表      | 存储活动级的档位概率配置（tier_name, tier_probability, sort_order）                         |
| `pick_method` 配置字段       | `lottery_campaigns.prize_distribution_config` 中新增，值：`tier_first` / `probability_only` |
| `decision_snapshot` 字段     | `lottery_draws` 或独立表，记录本次抽奖的决策过程（用于审计/排查）                           |
| `lottery_prizes.reward_tier` | 奖品所属档位（low/mid/high），用于档位内筛选                                                |
| fallback 奖品约定            | 每个活动**必须配置至少一个** `prize_value_points=0` 的兜底奖品                              |

---

#### 配置结构示例

```json
// lottery_campaigns.prize_distribution_config
{
  "pick_method": "tier_first", // tier_first(档位优先) | probability_only(纯概率)
  "tier_config": {
    "enabled": true,
    "tiers": [
      { "tier_name": "high", "tier_probability": 0.05 },
      { "tier_name": "mid", "tier_probability": 0.25 },
      { "tier_name": "low", "tier_probability": 0.7 }
    ]
  },
  "fallback_config": {
    "enabled": true,
    "fallback_prize_id": null, // null=自动选取 prize_value_points=0 的奖品
    "require_fallback_prize": true // 强制要求活动必须配置兜底奖品
  }
}
```

---

#### lottery_tier_rules 表结构建议

```sql
CREATE TABLE lottery_tier_rules (
  tier_rule_id       BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  campaign_id        INT UNSIGNED NOT NULL,
  tier_name          VARCHAR(32) NOT NULL COMMENT '档位名称: low/mid/high/special',
  tier_probability   DECIMAL(10,8) NOT NULL COMMENT '档位命中概率(0~1)',
  sort_order         INT DEFAULT 0 COMMENT '优先级排序',
  status             ENUM('active','inactive') DEFAULT 'active',
  created_at         DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at         DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  INDEX idx_campaign_tier (campaign_id, tier_name),
  INDEX idx_campaign_sort (campaign_id, sort_order)
) COMMENT='档位概率规则表';
```

---

#### 核心约束（必须遵循）

1. **不做隐式归一化**：运营配的概率就是真实概率，不会因为某奖品缺货而放大其他奖品概率。
2. **降级链路固定**：空档时按 **high→mid→low** 固定顺序降级，不允许跳跃或自定义链路。
3. **降级必须审计**：每次降级都必须记入决策快照，包含：原始命中档位、降级次数、最终档位、降级原因。
4. **fallback 是最终兜底**：降级链路走完仍无可发时才触发 fallback，兜底奖品必须永远可发。
5. **兜底奖品必配**：`pick_method=tier_first` 时，活动上线校验必须检查存在 `prize_value_points=0` 的奖品。
6. **档位内不归一化**：档位内抽取按原始 `win_probability` 权重，不做概率放大（与"不采用归一化"一致）。

---

### 0.9 档位体系定义（已拍板 2026-01-17）

**拍板结论**：**当前固定 low/mid/high 三档**；未来若扩展，只允许白名单枚举（并定义降级链路与校验）。

---

#### 当前阶段（V1 上线）

| 维度     | 决策内容                                            |
| -------- | --------------------------------------------------- |
| 档位集合 | **固定三档**：`low`、`mid`、`high`                  |
| 不允许   | 任意字符串、自定义档位名称、动态新增档位            |
| 代码约束 | 枚举类型 / CHECK 约束 / 应用层白名单校验            |
| 降级链路 | 固定 `high → mid → low → fallback`（已在 0.8 拍板） |

---

#### 未来扩展规则（V2+ 预留）

| 维度           | 决策内容                                                              |
| -------------- | --------------------------------------------------------------------- |
| 扩展方式       | **只允许白名单枚举**，不允许任意字符串                                |
| 新增档位审批   | 需产品/技术负责人拍板，更新枚举白名单                                 |
| 新档位必须定义 | ① 降级目标（fallback_tier）② 优先级排序（sort_order）③ 是否可被降级到 |
| 降级链路更新   | 新档位加入后，必须同步更新降级链路定义，且有迁移脚本                  |
| 向后兼容       | 新档位不得破坏已有数据，旧活动可不感知新档位                          |

---

#### 白名单枚举建议结构（未来实现参考）

```javascript
// 档位白名单定义（应用层）
const TIER_WHITELIST = {
  low: { sort_order: 1, fallback_tier: null, can_be_fallback_target: true },
  mid: { sort_order: 2, fallback_tier: 'low', can_be_fallback_target: true },
  high: { sort_order: 3, fallback_tier: 'mid', can_be_fallback_target: true }
  // 未来扩展示例（需拍板后添加）
  // ultra:   { sort_order: 4, fallback_tier: 'high',  can_be_fallback_target: false },
  // special: { sort_order: 0, fallback_tier: 'low',   can_be_fallback_target: false },
}

// 降级链路自动推导
function getDegradeChain(tier) {
  const chain = []
  let current = tier
  while (current && TIER_WHITELIST[current]?.fallback_tier) {
    current = TIER_WHITELIST[current].fallback_tier
    chain.push(current)
  }
  return chain // high → ['mid', 'low']
}
```

---

#### 数据库约束建议

```sql
-- lottery_prizes 表：reward_tier 字段约束
ALTER TABLE lottery_prizes
  MODIFY COLUMN reward_tier ENUM('low', 'mid', 'high') NOT NULL DEFAULT 'low'
  COMMENT '奖品档位（固定三档，扩展需更新枚举）';

-- lottery_tier_rules 表：tier_name 字段约束
ALTER TABLE lottery_tier_rules
  MODIFY COLUMN tier_name ENUM('low', 'mid', 'high') NOT NULL
  COMMENT '档位名称（固定三档，扩展需更新枚举）';

-- lottery_draws 表：档位相关字段约束
ALTER TABLE lottery_draws
  MODIFY COLUMN original_tier ENUM('low', 'mid', 'high') NULL
  COMMENT '原始命中档位',
  MODIFY COLUMN final_tier ENUM('low', 'mid', 'high', 'fallback') NULL
  COMMENT '最终发放档位（含 fallback）';
```

---

#### 核心约束（必须遵循）

1. **V1 阶段只用 low/mid/high**：不允许新增任何自定义档位名称。
2. **扩展必须走白名单**：未来需要新档位时，必须更新枚举白名单 + 降级链路 + 数据库约束。
3. **降级链路必须完整**：每个档位必须有明确的降级目标（或显式声明无降级）。
4. **校验前置**：活动上线前必须校验所有奖品的 `reward_tier` 在白名单内。
5. **迁移兼容**：新增档位时，旧数据不受影响，旧活动可不感知新档位。

---

### 0.10 奖品配置与概率校验规则（已拍板 2026-01-17）

> **⚠️ 注意**：本节的"概率和=1"校验已被 **0.16 章节** 更新为 **整数权重制（SCALE=1,000,000）**。具体变更：
>
> - `tier_probability` → `tier_weight`（整数）
> - `win_probability` → `win_weight`（整数）
> - 校验规则：`sum(weight) === 1,000,000`（严格相等，无容差）

**拍板结论**：**reward_tier 必填（兜底奖除外）+ tier 权重和=SCALE + 档内权重和=SCALE + 不归一化 + 漏配=上线失败**。

---

#### 规则1：reward_tier 必填范围

| 维度       | 决策内容                                                                                                     |
| ---------- | ------------------------------------------------------------------------------------------------------------ |
| 必填范围   | 除**兜底奖**（`prize_value_points=0` 且标记为 fallback）外，所有 `lottery_prizes` **必须填写** `reward_tier` |
| 兜底奖例外 | 兜底奖不属于任何档位，可不填 `reward_tier`（或填 `null`/空）                                                 |
| 上线校验   | 活动从 `draft` → `active` 时，若存在未填/非法 `reward_tier` 的**非兜底奖品**：**直接阻止上线**               |
| 错误提示   | 后台必须返回具体违规的 `prize_id` 列表，便于运营定位修复                                                     |

---

#### 规则2：reward_tier 合法值

| 模式                | 合法值                                                             |
| ------------------- | ------------------------------------------------------------------ |
| **固定模式（V1）**  | 仅允许 `low`、`mid`、`high`（已在 0.9 拍板）                       |
| **扩展模式（V2+）** | 只允许白名单枚举中定义的值（需拍板审批 + 更新枚举 + 更新降级链路） |

> **违规处理**：`reward_tier` 值不在合法白名单内 → 视为"非法值" → 阻止上线。

---

#### 规则3：兜底奖必须"永远可发"

| 维度     | 决策内容                                                                   |
| -------- | -------------------------------------------------------------------------- |
| 永远可发 | 兜底奖（`prize_value_points=0`）必须**永远可发**，不得设置库存限制或日限额 |
| 配置约束 | 兜底奖的 `stock_quantity` 必须为 `NULL`（无限）或足够大的值                |
| 配置约束 | 兜底奖的 `max_daily_wins` 必须为 `NULL`（无限）或足够大的值                |
| 上线校验 | 活动上线时，若兜底奖不满足"永远可发"条件：**阻止上线**                     |

---

#### 规则4：概率配置强制校验（核心）

| 维度              | 决策内容                                                                                         |
| ----------------- | ------------------------------------------------------------------------------------------------ |
| **tier 概率和=1** | `lottery_tier_rules` 中所有档位的 `tier_probability` 之和**必须精确等于 1**（强制）              |
| **档内概率和=1**  | 同一档位（`reward_tier`）内所有**非兜底奖品**的 `win_probability` 之和**必须精确等于 1**（强制） |
| **不归一化**      | 系统**绝不**自动调整/放大概率，运营配的概率就是真实概率（已在 0.8 拍板）                         |
| **漏配=上线失败** | 概率配置不满足上述规则 → **活动上线前直接失败**，不允许带着配置错误上线                          |

---

#### 规则5：缺口处理边界（配置问题 vs 运行时问题）

| 问题类型                | 触发时机       | 处理方式                                                   |
| ----------------------- | -------------- | ---------------------------------------------------------- |
| **概率配置问题**        | 上线前校验     | 直接阻止上线，返回错误原因（概率和≠1、reward_tier 非法等） |
| **库存/预算导致不可发** | 运行时（线上） | 走降级链路 + fallback 兜底（已在 0.8 拍板）                |

> **设计理由**：
>
> - **配置即行为**：运营配置什么，系统就执行什么，不偷偷修改。
> - **可审计、可复盘**：所有概率都是显式配置，出问题可追溯。
> - **责任清晰**：配置错误是运营责任（上线前拦截）；资源耗尽是运营+系统共同处理（fallback 兜底）。

---

#### 上线校验清单（活动 draft → active 必须通过）

| 序号 | 校验项                                                | 失败处理                            |
| ---- | ----------------------------------------------------- | ----------------------------------- |
| 1    | 所有**非兜底奖品**的 `reward_tier` 已填写且在白名单内 | 阻止上线，返回违规 `prize_id` 列表  |
| 2    | `lottery_tier_rules` 中 `tier_probability` 之和 = 1   | 阻止上线，返回当前概率和            |
| 3    | 每个档位内**非兜底奖品**的 `win_probability` 之和 = 1 | 阻止上线，返回违规档位 + 当前概率和 |
| 4    | 存在至少一个兜底奖品（`prize_value_points=0`）        | 阻止上线，提示"缺少兜底奖品"        |
| 5    | 兜底奖品满足"永远可发"条件（无库存/日限额限制）       | 阻止上线，提示"兜底奖品配置异常"    |

---

#### 校验伪代码示例

```javascript
async function validateCampaignForActivation(campaign_id) {
  const errors = []

  // 1. 获取所有奖品
  const prizes = await LotteryPrize.findAll({ where: { campaign_id } })
  const fallbackPrizes = prizes.filter(p => p.prize_value_points === 0)
  const normalPrizes = prizes.filter(p => p.prize_value_points > 0)

  // 2. 校验非兜底奖品的 reward_tier
  const TIER_WHITELIST = ['low', 'mid', 'high']
  const invalidTierPrizes = normalPrizes.filter(
    p => !p.reward_tier || !TIER_WHITELIST.includes(p.reward_tier)
  )
  if (invalidTierPrizes.length > 0) {
    errors.push({
      code: 'INVALID_REWARD_TIER',
      message: 'reward_tier 未填写或不在白名单内',
      prize_ids: invalidTierPrizes.map(p => p.prize_id)
    })
  }

  // 3. 校验 tier 概率和 = 1
  const tierRules = await LotteryTierRule.findAll({ where: { campaign_id, status: 'active' } })
  const tierProbSum = tierRules.reduce((sum, r) => sum + parseFloat(r.tier_probability), 0)
  if (Math.abs(tierProbSum - 1) > 0.0001) {
    errors.push({
      code: 'TIER_PROBABILITY_SUM_NOT_1',
      message: `tier 概率和必须=1，当前=${tierProbSum}`,
      current_sum: tierProbSum
    })
  }

  // 4. 校验每个档位内概率和 = 1
  for (const tier of TIER_WHITELIST) {
    const tierPrizes = normalPrizes.filter(p => p.reward_tier === tier)
    if (tierPrizes.length === 0) continue // 该档位无奖品，跳过

    const probSum = tierPrizes.reduce((sum, p) => sum + parseFloat(p.win_probability), 0)
    if (Math.abs(probSum - 1) > 0.0001) {
      errors.push({
        code: 'TIER_INTERNAL_PROBABILITY_SUM_NOT_1',
        message: `档位 ${tier} 内概率和必须=1，当前=${probSum}`,
        tier: tier,
        current_sum: probSum,
        prize_ids: tierPrizes.map(p => p.prize_id)
      })
    }
  }

  // 5. 校验兜底奖品存在且永远可发
  if (fallbackPrizes.length === 0) {
    errors.push({
      code: 'NO_FALLBACK_PRIZE',
      message: '缺少兜底奖品（prize_value_points=0）'
    })
  } else {
    const invalidFallbacks = fallbackPrizes.filter(
      p =>
        (p.stock_quantity !== null && p.stock_quantity <= 0) ||
        (p.max_daily_wins !== null && p.max_daily_wins <= 0)
    )
    if (invalidFallbacks.length > 0) {
      errors.push({
        code: 'FALLBACK_NOT_ALWAYS_AVAILABLE',
        message: '兜底奖品必须永远可发（不能有库存/日限额限制）',
        prize_ids: invalidFallbacks.map(p => p.prize_id)
      })
    }
  }

  return {
    valid: errors.length === 0,
    errors: errors
  }
}
```

---

#### 核心约束（必须遵循）

1. **reward_tier 必填**：非兜底奖品必须填写 `reward_tier`，未填/非法 = 阻止上线。
2. **兜底奖例外**：兜底奖（`prize_value_points=0`）不属于任何档位，可不填 `reward_tier`。
3. **兜底奖永远可发**：兜底奖不得设置库存限制或日限额，必须保证任何时候都能发放。
4. **tier 概率和=1**：所有档位的 `tier_probability` 之和必须精确等于 1。
5. **档内概率和=1**：同一档位内所有非兜底奖品的 `win_probability` 之和必须精确等于 1。
6. **不归一化**：系统绝不自动调整概率，配置错误直接阻止上线。
7. **配置问题上线前拦截**：概率配置问题在 `draft→active` 时拦截，不允许带错上线。
8. **运行时缺口走降级/fallback**：库存/预算导致的不可发，走降级链路 + fallback 兜底。

---

### 0.10.1 空档上线规则（已拍板 2026-01-18）

**拍板结论**：**允许"某档为空"上线**（不把"每档至少 1 个 active 奖品"做成阻止上线的硬门槛）。

---

| 维度         | 决策内容                                                                                            |
| ------------ | --------------------------------------------------------------------------------------------------- |
| 空档上线     | **允许**：某个档位（如 high）没有配置任何奖品，或所有奖品都是 `inactive`，**不阻止活动上线**        |
| 但必须满足   | ① **tier 概率仍必须 sum=1**（已在 0.10 拍板为必过）<br>② **决策快照/监控必须能看到"降级率/空档率"** |
| 不强制的原因 | 运营可能有意让某档暂时为空（如高档奖品临时下架），系统通过降级链路 + fallback 保证体验可控          |
| 风险控制     | 允许空档会导致体验漂移（用户命中空档必降级），必须通过监控看板及时发现和处理                        |

---

#### 强制配套要求（允许空档的前提）

| 序号 | 配套要求                 | 说明                                                                               |
| ---- | ------------------------ | ---------------------------------------------------------------------------------- |
| 1    | **tier 概率 sum=1 必过** | 已在 0.10 校验清单第 2 条，不变                                                    |
| 2    | **决策快照记录空档降级** | `lottery_draw_decisions` 必须记录 `downgrade_count`、`original_tier`、`final_tier` |
| 3    | **运营监控看板必须展示** | 按活动/按档位展示"降级率"和"空档率"，便于及时发现体验漂移                          |
| 4    | **空档率告警**           | 某档位连续 N 次被命中但降级，触发告警通知运营                                      |

---

#### 校验伪代码更新（允许空档）

```javascript
// 原逻辑：某档位无奖品时 continue 跳过（允许空档）
for (const tier of TIER_WHITELIST) {
  const tierPrizes = normalPrizes.filter(p => p.reward_tier === tier)
  if (tierPrizes.length === 0) {
    // ✅ 允许空档：不阻止上线，但记录警告
    console.warn(`[WARN] 档位 ${tier} 无 active 奖品，上线后该档位命中将触发降级`)
    continue
  }
  // ... 校验档内概率和=1
}
```

---

#### 核心约束

1. **允许空档**：某档位无 active 奖品不阻止上线，但必须满足 tier 概率 sum=1。
2. **降级兜底**：空档命中时自动走降级链路（high→mid→low→fallback）。
3. **监控必配**：允许空档的前提是监控看板能看到"降级率/空档率"，否则体验漂移难排查。
4. **告警建议**：空档率过高时建议配置告警，提醒运营及时补充奖品。

---

### 0.10.2 兜底奖自动选择规则（已拍板 2026-01-18）

**拍板结论**：**`fallback_prize_id` 自动默认指向 `prize_value_points=0` 的奖品**，不强制手动配置。

---

| 维度           | 决策内容                                                                                                       |
| -------------- | -------------------------------------------------------------------------------------------------------------- |
| 自动选择       | **`fallback_prize_id` 允许为 `null`**：系统自动选取 `prize_value_points=0` 且 `status=active` 的奖品作为兜底奖 |
| 不强制手动配置 | 运营无需显式填写 `fallback_prize_id`，减少配置负担                                                             |
| 自动选择优先级 | 若存在多个 `prize_value_points=0` 的奖品，按 `sort_order ASC` → `prize_id ASC` 选取第一个                      |
| 上线校验仍必过 | **必须存在至少一个** `prize_value_points=0` 的兜底奖品，且满足"永远可发"条件（已在 0.10 校验清单第 4、5 条）   |

---

#### 配置结构示例（更新）

```json
// lottery_campaigns.prize_distribution_config
{
  "pick_method": "tier_first",
  "fallback_config": {
    "enabled": true,
    "fallback_prize_id": null, // ✅ null = 自动选取 prize_value_points=0 的奖品
    "require_fallback_prize": true, // 强制要求活动必须配置兜底奖品
    "auto_select_rule": "prize_value_points=0, sort_order ASC, prize_id ASC" // 自动选择规则说明
  }
}
```

---

#### 自动选择伪代码

```javascript
function getFallbackPrize(campaign_id, fallback_config) {
  // 1. 如果显式配置了 fallback_prize_id，直接使用
  if (fallback_config.fallback_prize_id) {
    return LotteryPrize.findByPk(fallback_config.fallback_prize_id)
  }

  // 2. 自动选择：prize_value_points=0 的奖品
  return LotteryPrize.findOne({
    where: {
      campaign_id: campaign_id,
      prize_value_points: 0, // 预算积分为0
      status: 'active'
    },
    order: [
      ['sort_order', 'ASC'], // 优先级排序
      ['prize_id', 'ASC'] // 相同优先级取最小 ID
    ]
  })
}
```

---

#### 核心约束

1. **允许 null**：`fallback_prize_id` 可为 `null`，系统自动选取 `prize_value_points=0` 的奖品。
2. **自动选择规则**：`prize_value_points=0` + `status=active`，按 `sort_order ASC` → `prize_id ASC` 排序取第一个。
3. **上线校验不变**：仍必须存在至少一个兜底奖品（`prize_value_points=0`），且满足"永远可发"条件。
4. **显式配置优先**：若运营显式填写了 `fallback_prize_id`，则使用显式配置，不走自动选择。

---

### 0.11 保底/预设/干预与 tier_first 优先级（已拍板 2026-01-18）

**拍板结论**：**保底覆盖 tier_first**；**预设/管理干预完全绕开 tier_first**；**三者都必须写决策快照**。

---

#### 规则1：保底触发时的处理

| 维度                | 决策内容                                                                             |
| ------------------- | ------------------------------------------------------------------------------------ |
| 是否跳过 tier_first | **是**：保底触发时直接指定"保底奖品/保底档位"，不再走 tier_first 的档位概率抽取      |
| 快照要求            | **必须写决策快照**：`guarantee_triggered=true`，记录保底原因（累计次数/pity 计数等） |
| 保底奖品来源        | 由 `GuaranteeStage` 输出 `guarantee_prize_id`，直接进入 `SettleStage` 结算           |

---

#### 规则2：预设/管理干预的处理

| 维度                | 决策内容                                                                                           |
| ------------------- | -------------------------------------------------------------------------------------------------- |
| 是否绕开 tier_first | **完全绕开**：预设/干预是"指定结果"管线，不走概率抽取、不走档位选择                                |
| 管线路由            | 命中预设/干预时，走 `PresetAwardPipeline` 或 `OverridePipeline`，`PickPrizeStage` 直接使用指定奖品 |
| 快照要求            | **必须写决策快照**：`pipeline_type=preset` 或 `pipeline_type=override`，防止审计断链               |
| 审计字段            | 快照中必须包含：`preset_id` / `override_id`、`created_by`（责任人）、`reason`（原因）              |

---

#### 规则3：三种场景的优先级顺序

| 优先级 | 场景                 | 处理方式                                                                      |
| ------ | -------------------- | ----------------------------------------------------------------------------- |
| **1**  | 预设（Preset）       | 最高优先级：有待使用预设时，直接走 `PresetAwardPipeline`，绕开所有概率逻辑    |
| **2**  | 管理干预（Override） | 次高优先级：有 `force_win`/`force_lose` 时，走干预管线，绕开概率逻辑          |
| **3**  | 保底（Guarantee）    | 第三优先级：触发保底条件时，覆盖 tier_first，直接指定保底奖品                 |
| **4**  | 正常抽奖             | 最低优先级：无上述情况时，走 `NormalDrawPipeline`，执行 tier_first + 概率抽取 |

---

#### 管线选择伪代码（更新版）

```javascript
async selectPipeline(context) {
  const { user_id, campaign_id } = context;

  // 优先级1：预设（最高）
  const preset = await LotteryPreset.findOne({
    where: { user_id, campaign_id, status: 'active' },
    order: [['queue_order', 'ASC']]
  });
  if (preset) {
    return { pipeline: PresetAwardPipeline, preset, reason: 'preset_hit' };
  }

  // 优先级2：管理干预
  const override = await LotteryManagementSetting.findOne({
    where: { user_id, campaign_id, setting_type: ['force_win', 'force_lose'], status: 'active' }
  });
  if (override) {
    return { pipeline: OverridePipeline, override, reason: 'override_hit' };
  }

  // 优先级3 & 4：正常管线（内部会判断保底）
  // 保底判断在 GuaranteeStage 内完成，触发时 guarantee_prize_id 非空
  return { pipeline: NormalDrawPipeline, reason: 'normal_draw' };
}
```

---

#### 决策快照必须包含的字段（三种场景通用）

| 字段                  | 说明                                          |
| --------------------- | --------------------------------------------- |
| `pipeline_type`       | 管线类型：`normal` / `preset` / `override`    |
| `guarantee_triggered` | 是否触发保底（仅 normal 管线）                |
| `preset_id`           | 关联预设ID（仅 preset 管线）                  |
| `override_id`         | 关联干预设置ID（仅 override 管线）            |
| `created_by`          | 预设/干预的创建人（责任人追溯）               |
| `reason`              | 预设/干预的创建原因                           |
| `original_tier`       | 原始命中档位（仅 normal + tier_first 时有值） |
| `final_tier`          | 最终发放档位（仅 normal + tier_first 时有值） |
| `downgrade_count`     | 降级次数（仅 normal + tier_first 时有值）     |

---

#### 核心约束（必须遵循）

1. **预设/干预绕开概率**：凡是"指定结果"（预设/干预），一律绕开 `tier_first` 和概率抽取。
2. **保底覆盖 tier_first**：保底触发时，直接指定奖品，不再走档位概率。
3. **三者都必须写快照**：无论走哪条管线，都必须写 `lottery_draw_decisions`，防止审计断链。
4. **快照标记 pipeline_type**：快照中必须明确标记 `pipeline_type`，便于区分和统计。
5. **责任人必须记录**：预设/干预场景，快照必须包含 `created_by` 和 `reason`。
6. **优先级不可逆**：预设 > 干预 > 保底 > 正常抽奖，高优先级命中后不再执行低优先级逻辑。

---

### 0.12 配置落地形态（已拍板 2026-01-18）

**拍板结论**：**tier 规则用 `lottery_tier_rules` 表**；**决策快照用独立 `lottery_draw_decisions` 表**。

---

#### 规则1：tier 档位概率配置存储方式

| 维度          | 决策内容                                                                                                                     |
| ------------- | ---------------------------------------------------------------------------------------------------------------------------- |
| 存储位置      | **`lottery_tier_rules` 表**，不放 JSON                                                                                       |
| 理由          | 可查询、可审计、可版本化、可报表统计、可支持多条件规则（如按用户预算区间差异化）                                             |
| JSON 只放开关 | `lottery_campaigns.prize_distribution_config` 只存 `pick_method`、`tier_config.enabled`、`fallback_config` 等开关/方法类配置 |

#### tier 规则表职责说明

| 存储位置                         | 存放内容                                                                  | 示例                                                     |
| -------------------------------- | ------------------------------------------------------------------------- | -------------------------------------------------------- |
| `lottery_tier_rules` 表          | 档位概率规则（tier_name, tier_probability, sort_order, 可选 budget 区间） | high=0.05, mid=0.25, low=0.70                            |
| `prize_distribution_config` JSON | 开关类/方法类配置                                                         | `pick_method: 'tier_first'`, `tier_config.enabled: true` |

---

#### 规则2：决策快照存储方式

| 维度     | 决策内容                                                                               |
| -------- | -------------------------------------------------------------------------------------- |
| 存储位置 | **独立 `lottery_draw_decisions` 表**，不用 `lottery_draws.decision_snapshot` JSON 字段 |
| 理由     | 可检索、可做运营报表、可支持降级/兜底统计分析、可追溯客诉、可支持对账审计              |
| 关联方式 | `lottery_draws.decision_id` 外键关联 `lottery_draw_decisions.decision_id`              |

#### 两种方案对比（已选独立表）

| 方案                                   | 优点                                   | 缺点                                       | 是否采用      |
| -------------------------------------- | -------------------------------------- | ------------------------------------------ | ------------- |
| `lottery_draws.decision_snapshot` JSON | 开发最快、表结构简单                   | 不可检索、不可聚合统计、后期拆表迁移成本高 | ❌ **不采用** |
| 独立 `lottery_draw_decisions` 表       | 可检索、可报表、可审计、可支持复杂分析 | 多一张表、多一次写入                       | ✅ **采用**   |

> **设计理由**：
>
> 1. 文档已把"上线阻断校验、降级审计、欠账追责、幂等对账"写成主线，这套治理能力在"表结构可查询/可统计"时成本最低、效果最好。
> 2. 后期运营分析（降级率、兜底触发率、档位命中分布）必须依赖结构化数据。
> 3. 客诉举证/风控分析场景需要按 campaign_id/user_id/时间范围检索决策记录。

---

#### 核心约束（必须遵循）

1. **tier 概率规则不放 JSON**：必须走 `lottery_tier_rules` 表，便于多条件规则和版本管理。
2. **决策快照走独立表**：每次抽奖都必须写 `lottery_draw_decisions`，与 `lottery_draws` 通过 `decision_id` 关联。
3. **JSON 只放开关**：`prize_distribution_config` 只存 `pick_method`、`enabled` 等轻量配置，不存概率规则。
4. **独立表必须有索引**：`lottery_draw_decisions` 必须建好 `campaign_id`、`user_id`、`created_at`、`downgrade_count` 等索引，支持运营报表和审计检索。

---

### 0.13 lottery_tier_rules 表结构（已拍板 2026-01-18）

**拍板结论**：采用 **A（行式）** 作为最终方案，**A2（segment_key）** 作为分层落地方案。

---

#### 拍板背景

文档中曾出现两套 `lottery_tier_rules` 表结构设计：

| 方案          | 设计形态                                                              | 特点                                     |
| ------------- | --------------------------------------------------------------------- | ---------------------------------------- |
| **A（行式）** | 每行一个 `tier_name + tier_probability`，扩展新档位不改表             | 可扩展、可审计、可版本化、适合多维度分层 |
| **B（列式）** | 一行里 `low_probability/mid_probability/high_probability`，三列硬编码 | 简单直观但扩展困难，新增档位需改表       |

---

#### 最终决策

| 维度     | 决策内容                                                                        |
| -------- | ------------------------------------------------------------------------------- |
| 主方案   | **A（行式）**：每行一个 `tier_name + tier_probability`，不使用三列硬编码        |
| 分层方案 | **A2（segment_key）**：加 `segment_key` 字段表达分层，区间逻辑放在代码/配置表里 |
| 唯一键   | `UNIQUE(campaign_id, segment_key, tier_name)`                                   |
| 不硬编码 | 档位名称（low/mid/high/未来扩展）走白名单枚举，不写死成表的列                   |

---

#### 选择 A2（segment_key）的理由

| 对比维度     | A1（budget_min/budget_max）      | A2（segment_key）【选定】                 |
| ------------ | -------------------------------- | ----------------------------------------- |
| 分层规则存放 | 直接在 `lottery_tier_rules` 表里 | 在代码/配置表里，表里只存 key             |
| 运营可理解性 | 一张表看明白                     | 需要同时看 segment 映射规则               |
| 灵活性       | 单维度（只按预算分层）           | **多维度**（可按渠道/新客/VIP/预算组合）  |
| 扩展成本     | 新增维度要加字段                 | 新增维度只加 segment_key 值               |
| 适用场景     | 简单预算分层                     | **复杂分层 + 未来扩展**（更契合你的需求） |

---

#### segment_key 设计建议

| segment_key 示例 | 含义                     | 映射规则（代码/配置表定义） |
| ---------------- | ------------------------ | --------------------------- |
| `default`        | 默认规则（无分层时使用） | 所有用户                    |
| `low_budget`     | 低预算用户               | BUDGET_POINTS ∈ [0, 99]     |
| `mid_budget`     | 中预算用户               | BUDGET_POINTS ∈ [100, 499]  |
| `high_budget`    | 高预算用户               | BUDGET_POINTS ∈ [500, +∞)   |
| `new_user`       | 新用户                   | 注册 ≤ 7 天                 |
| `vip`            | VIP 用户                 | VIP 等级 ≥ 1                |
| `channel_a`      | 渠道 A                   | 来源渠道 = 'A'              |

> **segment_key 映射规则**（已拍板 0.17）：**V1 不做 `lottery_segment_rules` 表**，采用版本化配置（`config/segment_rules.js`），通过 `SegmentResolver` 实现分层匹配。V2 可接入统一人群/实验平台。

---

#### 更新后的表结构（替换 7.1 原 SQL）

```sql
CREATE TABLE lottery_tier_rules (
  tier_rule_id       BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  campaign_id        INT UNSIGNED NOT NULL COMMENT '关联活动ID',
  segment_key        VARCHAR(50) NOT NULL DEFAULT 'default' COMMENT '分层标识（default/low_budget/high_budget/new_user/vip等）',
  tier_name          VARCHAR(32) NOT NULL COMMENT '档位名称: low/mid/high（白名单枚举）',
  tier_probability   DECIMAL(10,8) NOT NULL COMMENT '档位命中概率(0~1)',
  sort_order         INT DEFAULT 0 COMMENT '优先级排序',
  status             ENUM('active','inactive') DEFAULT 'active',
  created_at         DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at         DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  -- 唯一约束：同一活动 + 同一分层 + 同一档位 只能有一条规则
  UNIQUE KEY uk_campaign_segment_tier (campaign_id, segment_key, tier_name),
  INDEX idx_campaign_segment (campaign_id, segment_key),
  INDEX idx_campaign_sort (campaign_id, sort_order)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='档位概率规则表（行式 + segment_key 分层）';
```

---

#### segment 映射配置表（❌ V1 不做，见 0.17 拍板）

> **重要**：根据 0.17 拍板决定，**V1 不建 `lottery_segment_rules` 业务库规则表**。分层规则采用**版本化配置**（跟代码走），通过 `SegmentResolver` + 配置文件实现。以下 SQL 仅作 V2+ 参考，V1 **不执行**。

```sql
-- ❌ V1 不建此表，分层规则通过 config/segment_rules.js 配置文件实现
-- 以下仅作 V2+ 参考

CREATE TABLE lottery_segment_rules (
  segment_rule_id    BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  campaign_id        INT UNSIGNED NULL COMMENT '活动ID（NULL表示全局规则）',
  segment_key        VARCHAR(50) NOT NULL COMMENT '分层标识',
  rule_type          ENUM('budget_range', 'user_tag', 'channel', 'custom') NOT NULL COMMENT '规则类型',
  rule_config        JSON NOT NULL COMMENT '规则配置，如 {"min":0,"max":99} 或 {"tag":"vip"}',
  priority           INT DEFAULT 0 COMMENT '匹配优先级（高优先）',
  status             ENUM('active','inactive') DEFAULT 'active',
  created_at         DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at         DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  UNIQUE KEY uk_campaign_segment (campaign_id, segment_key),
  INDEX idx_campaign_priority (campaign_id, priority DESC)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='分层规则映射表（V2+ 使用，V1 用配置文件替代）';
```

---

#### 上线校验清单（新增）

| 序号 | 校验项                                              | 失败处理                                    |
| ---- | --------------------------------------------------- | ------------------------------------------- |
| 1    | 每个 `segment_key` 下的 `tier_probability` 之和 = 1 | 阻止上线，返回违规 segment_key + 当前概率和 |
| 2    | 活动必须至少有一个 `segment_key='default'` 的规则组 | 阻止上线，提示"缺少默认分层规则"            |
| 3    | 所有 `tier_name` 在白名单内（low/mid/high）         | 阻止上线，返回非法 tier_name                |

---

#### 核心约束

1. **行式不硬编码**：`tier_name` 用白名单枚举，不写死成表的列，扩展档位不改表结构。
2. **segment_key 灵活分层**：分层逻辑通过 `segment_key` 表达，支持多维度组合（预算/渠道/新客/VIP）。
3. **default 必配**：每个活动必须有 `segment_key='default'` 的规则组，作为无法匹配其他分层时的兜底。
4. **每个分层内 tier 概率和=1**：校验粒度是 `(campaign_id, segment_key)`，不是整个活动。
5. **V1 用版本化配置**（0.17 拍板）：`segment_key` 的匹配规则放在 `config/segment_rules.js`，不建业务库规则表，通过 `SegmentResolver` 实现。

---

### 0.14 tier_first 档位内不归一化（已拍板 2026-01-18）

**拍板结论**：`pick_method=tier_first` 下，**档位内不做归一化**；坚持"配置即行为"；体验稳定性交给降级链路 + fallback + 监控。

---

#### 拍板背景

文档"5.1 三种做法支持"曾写有"在 tier 内归一化"，与 0.8/0.10 的"不采用归一化"存在冲突。本次拍板消除歧义，明确最终口径。

---

#### 最终决策

| 维度           | 决策内容                                                       |
| -------------- | -------------------------------------------------------------- |
| 档位内抽取方式 | **按原始 `win_probability` 权重抽取**，不做任何缩放/归一化     |
| 不可发处理     | 走 **high→mid→low 降级链路**，降级尽头再 **fallback**          |
| 体验稳定性保障 | **空档降级链路 + fallback 永远可发 + 降级率/空档率监控告警**   |
| 明确放弃       | **绝不缩放概率**，即使某奖品不可发，也不放大其他奖品的中奖概率 |

---

#### 归一化 vs 不归一化 对比（奖品例子）

假设 high 档内有两个奖品：

- **H1**：iPhone（`win_probability=0.2`，库存=0，不可发）
- **H2**：AirPods（`win_probability=0.8`，库存>0，可发）

| 处理方式             | 用户命中 high 档后的行为                          | 实际概率           | 问题                                                     |
| -------------------- | ------------------------------------------------- | ------------------ | -------------------------------------------------------- |
| **归一化（不采用）** | 过滤掉 H1 后，H2 缩放到 1.0，100% 得 AirPods      | H2 从 0.8 变成 1.0 | AirPods 出货被隐式放大，成本失控，审计困难               |
| **不归一化（采用）** | H1 不可发跳过；H2 仍按 0.8 权重抽取；抽不到走降级 | H2 仍是 0.8        | 概率契约清晰，成本可控，审计明确；用户可能降级到 mid/low |

---

#### 体验稳定性如何保障（不依赖归一化）

| 保障机制              | 作用                                                                   |
| --------------------- | ---------------------------------------------------------------------- |
| **空档降级链路**      | 目标档位无可发奖品时，按 high→mid→low 自动降级，不让用户空手           |
| **fallback 永远可发** | 降级链路走完仍无可发时，命中 `prize_value_points=0` 的兜底奖品         |
| **降级率/空档率监控** | 运营看板实时展示降级率，某档空档率过高时触发告警，提醒补货             |
| **决策快照审计**      | 每次降级都记入快照（原始档位、最终档位、降级次数、原因），可追溯可复盘 |

---

#### 核心约束

1. **档位内不归一化**：`tier_first` 下，档位内按原始 `win_probability` 权重抽取，绝不缩放。
2. **不可发走降级**：档位内无可发奖品时，走 high→mid→low 降级链路。
3. **降级尽头走 fallback**：所有档位都空时，命中兜底奖品。
4. **配置即行为**：运营配的概率就是真实概率，系统不做任何隐式调整。
5. **监控是体验保障**：降级率/空档率监控 + 告警 = 用"看得见的治理"替代"看不见的归一化"。

---

### 0.15 lottery_campaigns 配置存储方式（已拍板 2026-01-18）

**拍板结论**：**关键策略字段放列（单一真源）+ JSON 仅作扩展与说明**；**禁止双写两份当真源**。

---

#### 拍板 3.1：关键字段放列，并作为单一真源

| 维度               | 决策内容                                                                                                                                       |
| ------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------- |
| **列（真源）**     | `pick_method`、`fallback_prize_id`（允许 null）、`preset_debt_enabled`、`preset_budget_policy`、`budget_mode`（以及已有的 pool/user 相关字段） |
| **JSON（非真源）** | `fallback_config.auto_select_rule`、说明性字段、未来扩展参数（例如将来引入更多降级策略开关、实验参数）                                         |

---

#### 拍板 3.2：禁止"双写两份当真源"

| 维度       | 决策内容                                                                      |
| ---------- | ----------------------------------------------------------------------------- |
| 写入规则   | **写入只写列**；JSON 只读/补充；读取逻辑以列为准（JSON 仅辅助说明或未来字段） |
| 双真源禁止 | 同一配置项**不允许同时在列和 JSON 中维护**，避免数据不一致和维护混乱          |

---

#### 字段归属明细表

| 字段名                             | 存储位置 | 说明                                                      |
| ---------------------------------- | -------- | --------------------------------------------------------- |
| `pick_method`                      | **列**   | 选奖方法（tier_first/normalize/fallback），上线行为开关   |
| `fallback_prize_id`                | **列**   | 兜底奖品 ID（允许 null，自动选取），关键指针              |
| `preset_debt_enabled`              | **列**   | 预设欠账开关，上线行为开关                                |
| `preset_budget_policy`             | **列**   | 预设预算扣减策略（follow_campaign/pool_first/user_first） |
| `budget_mode`                      | **列**   | 预算模式（user/pool/none），核心业务字段                  |
| `pool_budget_remaining`            | **列**   | 活动池剩余预算，核心业务字段                              |
| `max_budget_debt`                  | **列**   | 活动级预算欠账上限，便于索引和校验                        |
| `max_inventory_debt_qty`           | **列**   | 活动级库存欠账上限，便于索引和校验                        |
| `fallback_config.auto_select_rule` | JSON     | 自动选择规则说明（仅文档性质）                            |
| `tier_config.enabled`              | JSON     | 档位功能开关说明（实际由 pick_method 控制）               |
| 实验参数（未来）                   | JSON     | A/B 测试、灰度策略等未来扩展参数                          |

---

#### 读写规则伪代码

```javascript
// ✅ 正确：写入只写列
async function updateCampaignConfig(campaignId, updates) {
  // 关键字段直接更新列
  await LotteryCampaign.update(
    {
      pick_method: updates.pick_method,
      fallback_prize_id: updates.fallback_prize_id,
      preset_debt_enabled: updates.preset_debt_enabled,
      preset_budget_policy: updates.preset_budget_policy,
      budget_mode: updates.budget_mode
    },
    { where: { campaign_id: campaignId } }
  )

  // JSON 只做补充说明（非关键配置）
  if (updates.json_extras) {
    await LotteryCampaign.update(
      {
        prize_distribution_config: Sequelize.fn(
          'JSON_SET',
          Sequelize.col('prize_distribution_config'),
          '$.auto_select_rule',
          updates.json_extras.auto_select_rule
        )
      },
      { where: { campaign_id: campaignId } }
    )
  }
}

// ✅ 正确：读取以列为准
async function getCampaignConfig(campaignId) {
  const campaign = await LotteryCampaign.findByPk(campaignId)
  return {
    // 关键配置从列读取（真源）
    pick_method: campaign.pick_method,
    fallback_prize_id: campaign.fallback_prize_id,
    preset_debt_enabled: campaign.preset_debt_enabled,
    // JSON 仅作补充说明
    json_extras: campaign.prize_distribution_config
  }
}

// ❌ 错误：双写两份
async function badUpdateConfig(campaignId, updates) {
  await LotteryCampaign.update({
    pick_method: updates.pick_method,
    prize_distribution_config: JSON.stringify({
      pick_method: updates.pick_method // ❌ 重复写入 JSON，双真源
      // ...
    })
  })
}
```

---

#### 核心约束

1. **列为唯一真源**：`pick_method`、`fallback_prize_id`、`preset_debt_enabled`、`preset_budget_policy`、`budget_mode` 等关键字段只从列读写。
2. **JSON 仅作扩展**：`prize_distribution_config` 只存放说明性字段和未来扩展参数，不存放关键策略。
3. **禁止双真源**：同一配置项不允许同时在列和 JSON 中维护，所有代码以列为准。
4. **便于索引和校验**：关键字段放列可直接建索引、做上线校验、排障查询。
5. **扩展不改表**：未来新增实验参数、灰度策略等，走 JSON 扩展，不需要 ALTER TABLE。

---

### 0.16 概率存储采用整数权重制（已拍板 2026-01-18）

**拍板结论**：**采用整数权重制，SCALE=1,000,000，tier 和 prize 都用 weight，保存时自动补差保证 sum=SCALE，校验严格相等，不引入容差**。

---

#### 拍板背景

文档中概率存储曾出现两种口径：

- **小数概率 + 容差校验**：`DECIMAL(10,8)` 存储 0~1 小数，校验用 `abs(sum - 1) <= 0.0001`
- **整数权重 + 严格相等**：存 `weight`（整数），校验 `sum(weight) = SCALE`（严格相等）

本次拍板选择**整数权重制**，原因：

1. **不需要容差**：不会出现 `0.99999999` 或 `1.00000001` 这类边界问题
2. **审计/对账最清晰**：快照记录的就是当时权重，复盘没有小数误差争议
3. **与"不归一化"契合**：既然选了不归一化，概率契约就应该做成确定性的

---

#### 最终决策

| 维度         | 决策内容                                                              |
| ------------ | --------------------------------------------------------------------- |
| **存储口径** | **整数权重（weight）**，不存小数概率（probability）                   |
| **精度常量** | **SCALE = 1,000,000**（百万分之一精度，够用且好算）                   |
| **适用范围** | **tier 和 prize 两层都用 weight**（统一口径）                         |
| **校验规则** | **sum(weight) 必须严格等于 SCALE**，不相等则阻止上线                  |
| **禁止容差** | **不得引入"容差 ε"**，必须精确匹配                                    |
| **自动补差** | 后台保存时自动补差：最后一个权重 = SCALE - 前面合计，补差记入审计字段 |

---

#### 权重示例

| 档位     | 小数概率（旧） | 整数权重（新） | 说明             |
| -------- | -------------- | -------------- | ---------------- |
| high     | 0.05           | 50,000         | 5%               |
| mid      | 0.25           | 250,000        | 25%              |
| low      | 0.70           | 700,000        | 70%              |
| **合计** | **1.00**       | **1,000,000**  | **必须精确相等** |

```
抽奖时转换：
actualProbability = weight / SCALE
例如 high 的实际概率 = 50,000 / 1,000,000 = 0.05 = 5%
```

---

#### 校验逻辑（严格相等，无容差）

```javascript
const SCALE = 1_000_000 // 百万分之一精度

// ✅ 正确：严格相等校验
function validateTierWeights(tierRules) {
  const totalWeight = tierRules.reduce((sum, rule) => sum + rule.tier_weight, 0)

  if (totalWeight !== SCALE) {
    return {
      valid: false,
      code: 'TIER_WEIGHT_SUM_NOT_SCALE',
      message: `tier 权重和必须=${SCALE}，当前=${totalWeight}，差值=${SCALE - totalWeight}`,
      current_sum: totalWeight,
      expected: SCALE,
      diff: SCALE - totalWeight
    }
  }

  return { valid: true }
}

// ❌ 禁止：容差校验
function badValidate(tierRules) {
  const totalWeight = tierRules.reduce((sum, rule) => sum + rule.tier_weight, 0)
  if (Math.abs(totalWeight - SCALE) <= 1000) {
    // ❌ 不得引入容差
    return { valid: true }
  }
}
```

---

#### 自动补差机制（后台保存时）

> **已拍板 2026-01-18**：如果前 N-1 项权重之和已经 > SCALE，最后一个会变成负数 → **直接拒绝保存/阻止上线**，不做任何"归一化"或其他处理。

```javascript
const SCALE = 1_000_000

/**
 * 后台保存时自动补差
 * - 计算前 N-1 个权重的合计
 * - 【已拍板】如果前 N-1 项之和 > SCALE，直接拒绝保存（不允许负数权重）
 * - 最后一个权重 = SCALE - 前面合计
 * - 补差信息记入审计字段
 */
function autoAdjustLastWeight(weights) {
  if (weights.length === 0) return weights

  const lastIndex = weights.length - 1
  const sumExceptLast = weights.slice(0, lastIndex).reduce((sum, w) => sum + w.weight, 0)

  // 【已拍板 2026-01-18】前 N-1 项之和超过 SCALE → 直接拒绝保存
  if (sumExceptLast > SCALE) {
    throw new Error(
      `权重配置非法：前 ${lastIndex} 项权重之和（${sumExceptLast}）已超过 SCALE（${SCALE}），` +
        `无法为最后一项分配有效权重。请调整前面的权重配置。`
    )
  }

  const calculatedLast = SCALE - sumExceptLast
  const originalLast = weights[lastIndex].weight
  const diff = calculatedLast - originalLast

  if (diff !== 0) {
    weights[lastIndex].weight = calculatedLast
    weights[lastIndex]._auto_adjusted = true
    weights[lastIndex]._adjustment_diff = diff
    weights[lastIndex]._adjustment_reason =
      `自动补差：原值=${originalLast}，调整后=${calculatedLast}，差值=${diff}`

    console.log(`[AutoAdjust] 自动补差：${originalLast} → ${calculatedLast}（diff=${diff}）`)
  }

  return weights
}

// 示例：运营输入 [50000, 250000, 699999]，最后一个自动补差为 700001
// 输入：[{ tier: 'high', weight: 50000 }, { tier: 'mid', weight: 250000 }, { tier: 'low', weight: 699999 }]
// 输出：[{ tier: 'high', weight: 50000 }, { tier: 'mid', weight: 250000 }, { tier: 'low', weight: 700001, _auto_adjusted: true, _adjustment_diff: 2 }]
```

---

#### 表结构更新（weight 替代 probability）

**lottery_tier_rules 表**（更新后）：

```sql
CREATE TABLE lottery_tier_rules (
  tier_rule_id       BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  campaign_id        INT UNSIGNED NOT NULL COMMENT '关联活动ID',
  segment_key        VARCHAR(50) NOT NULL DEFAULT 'default' COMMENT '分层标识',
  tier_name          VARCHAR(32) NOT NULL COMMENT '档位名称: low/mid/high',

  -- ========== 整数权重（替代 DECIMAL 概率） ==========
  tier_weight        INT UNSIGNED NOT NULL COMMENT '档位权重（整数，sum 必须=1000000）',
  -- 旧字段 tier_probability DECIMAL(10,8) 废弃，迁移后删除

  sort_order         INT DEFAULT 0 COMMENT '优先级排序',
  status             ENUM('active','inactive') DEFAULT 'active',
  created_at         DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at         DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  -- 审计补差记录（可选）
  auto_adjusted      BOOLEAN DEFAULT FALSE COMMENT '是否被自动补差',
  adjustment_diff    INT DEFAULT 0 COMMENT '补差值（正=增加，负=减少）',

  UNIQUE KEY uk_campaign_segment_tier (campaign_id, segment_key, tier_name),
  INDEX idx_campaign_segment (campaign_id, segment_key),
  INDEX idx_campaign_sort (campaign_id, sort_order)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='档位权重规则表（整数权重制，SCALE=1000000）';
```

**lottery_prizes 表**（更新字段）：

```sql
ALTER TABLE lottery_prizes ADD COLUMN (
  -- ========== 整数权重（替代 win_probability） ==========
  win_weight         INT UNSIGNED NOT NULL DEFAULT 0 COMMENT '奖品权重（整数，同档位内 sum 必须=1000000）',
  -- 旧字段 win_probability DECIMAL(10,8) 废弃，迁移后删除

  -- 审计补差记录（可选）
  auto_adjusted      BOOLEAN DEFAULT FALSE COMMENT '是否被自动补差',
  adjustment_diff    INT DEFAULT 0 COMMENT '补差值'
);
```

---

#### 上线校验清单（更新）

| 序号 | 校验项                          | 校验规则                                   | 失败处理                            |
| ---- | ------------------------------- | ------------------------------------------ | ----------------------------------- |
| 1    | tier 权重和 = SCALE             | `sum(tier_weight) === 1000000`（严格相等） | 阻止上线，返回当前权重和与差值      |
| 2    | 每个档位内 prize 权重和 = SCALE | `sum(win_weight) === 1000000`（严格相等）  | 阻止上线，返回违规档位 + 当前权重和 |
| 3    | 权重值范围                      | `0 <= weight <= 1000000`                   | 阻止上线，返回非法权重              |
| 4    | 权重必须为整数                  | `Number.isInteger(weight)`                 | 阻止上线，返回非整数权重            |

---

#### 迁移方案（DECIMAL → INT）

```sql
-- 1. 新增整数权重字段
ALTER TABLE lottery_tier_rules ADD COLUMN tier_weight INT UNSIGNED DEFAULT 0 COMMENT '档位权重（整数）';
ALTER TABLE lottery_prizes ADD COLUMN win_weight INT UNSIGNED DEFAULT 0 COMMENT '奖品权重（整数）';

-- 2. 数据迁移：小数概率 → 整数权重
UPDATE lottery_tier_rules SET tier_weight = ROUND(tier_probability * 1000000);
UPDATE lottery_prizes SET win_weight = ROUND(win_probability * 1000000);

-- 3. 校验迁移结果（确保 sum = 1000000）
SELECT campaign_id, segment_key, SUM(tier_weight) AS total
FROM lottery_tier_rules
GROUP BY campaign_id, segment_key
HAVING total != 1000000;  -- 应返回空

-- 4. 迁移完成后，旧字段可标记废弃或删除
-- ALTER TABLE lottery_tier_rules DROP COLUMN tier_probability;
-- ALTER TABLE lottery_prizes DROP COLUMN win_probability;
```

---

#### 核心约束

1. **整数权重制**：tier 和 prize 都用 `weight`（INT），不用小数 `probability`（DECIMAL）。
2. **SCALE = 1,000,000**：所有权重和必须精确等于 1,000,000，不多不少。
3. **严格相等校验**：`sum(weight) === SCALE`，**禁止引入容差 ε**。
4. **自动补差**：后台保存时自动把最后一个权重补差为 `SCALE - 前面合计`，并记入审计字段。
5. **审计可追溯**：每次补差都记录 `auto_adjusted`、`adjustment_diff`，便于复盘。
6. **迁移兼容**：旧数据通过 `ROUND(probability * 1000000)` 迁移，迁移后校验 sum。

---

### 0.17 segment_key 分层规则实现方式（已拍板 2026-01-18）

**拍板结论**：**V1 不做 `lottery_segment_rules` 业务库规则表**；采用**游戏公司模式（版本化配置）**；引入 **SegmentResolver** 输出 `segment_key + match_reason`（写入决策快照）；**V2 再接入统一人群/实验平台**。

---

#### 拍板背景

文档中曾出现 `lottery_segment_rules` 表用于存储分层映射规则（segment_key 对应的匹配条件）。本次拍板明确 V1 **不做**该表，原因：

| 对比维度     | A) 业务库规则表（不采用）              | B) 版本化配置（采用）                    |
| ------------ | -------------------------------------- | ---------------------------------------- |
| 规则存放     | 业务库，运营可即时改动                 | 代码仓库配置文件，随版本发布             |
| 长期维护成本 | **高**：后台误配、即时改动、线上难复现 | **低**：有明确版本、可回滚、行为可复现   |
| 灵活性       | 高（运营随时改）但不可控               | 中（需走发布流程）但可控                 |
| 审计能力     | 需额外记录配置变更历史                 | 代码版本即审计，配合 `match_reason` 即可 |
| 大厂实践     | 小公司/活动策划型                      | **游戏公司/大厂平台型**                  |

---

#### 最终决策

| 维度                     | 决策内容                                                                          |
| ------------------------ | --------------------------------------------------------------------------------- |
| **V1 不做业务库规则表**  | 不建 `lottery_segment_rules` 表，避免"后台误配/即时改动/线上难复现"的长期维护成本 |
| **采用版本化配置**       | 分层规则在代码仓库配置文件中定义，随版本发布；有明确版本、可回滚                  |
| **引入 SegmentResolver** | 业务运行时通过 `SegmentResolver` 算出 `segment_key + match_reason`                |
| **审计写入决策快照**     | `match_reason` 包含命中规则详情，写入 `lottery_draw_decisions` 表                 |
| **V2 可替换**            | 未来可替换 `SegmentResolver` 的实现为统一人群/实验平台（规则引擎 + 特征服务）     |

---

#### 拍板 1：配置放哪里

| 维度             | 决策内容                                                 |
| ---------------- | -------------------------------------------------------- |
| **选定方案**     | **A. 跟代码走**（仓库配置文件，随版本发布）              |
| **配置文件位置** | `config/segment_rules.js` 或 `config/segment_rules.json` |
| **版本管理**     | 配置文件与代码同一仓库，Git 版本号即配置版本             |
| **环境隔离**     | 可按 `NODE_ENV` 区分 dev/staging/production 配置         |

---

#### 拍板 2：发布/回滚流程

| 维度                    | 决策内容                                                 |
| ----------------------- | -------------------------------------------------------- |
| **发布流程**            | **发布 → 全量 → 可一键回滚**                             |
| **回滚能力**            | 必须做到：通过 Git revert 或切换版本号即可回滚到上一配置 |
| **灰度能力（V1 可选）** | V1 可不做灰度，V2 可接入实验平台实现灰度                 |
| **审批流程（建议）**    | 分层规则变更建议走 Code Review，作为配置变更的审批机制   |

---

#### 拍板 3：审计字段最小集

**强制要求**：每次抽奖必须在 `lottery_draw_decisions` 表中记录以下分层审计字段：

| 字段              | 类型         | 说明                                                                                |
| ----------------- | ------------ | ----------------------------------------------------------------------------------- |
| `segment_key`     | VARCHAR(50)  | 命中的分层标识（如 `default`/`high_budget`/`new_user`）                             |
| `segment_version` | VARCHAR(50)  | 分层规则配置版本（如 Git commit hash 或语义版本号）                                 |
| `matched_rule_id` | VARCHAR(100) | 命中的规则 ID（配置文件中定义的规则标识）                                           |
| `match_reason`    | JSON / TEXT  | 命中原因详情（如 `{"rule":"budget_range","condition":">=500","actual_value":800}`） |

---

#### SegmentResolver 概念设计

```javascript
// config/segment_rules.js - 分层规则配置文件（随代码版本发布）
module.exports = {
  version: '1.0.0', // 配置版本号（或使用 Git commit hash）
  rules: [
    {
      rule_id: 'high_budget',
      segment_key: 'high_budget',
      priority: 10,
      condition: {
        type: 'budget_range',
        field: 'BUDGET_POINTS',
        min: 500,
        max: null // 无上限
      },
      description: '高预算用户（BUDGET_POINTS >= 500）'
    },
    {
      rule_id: 'mid_budget',
      segment_key: 'mid_budget',
      priority: 20,
      condition: {
        type: 'budget_range',
        field: 'BUDGET_POINTS',
        min: 100,
        max: 499
      },
      description: '中预算用户（100 <= BUDGET_POINTS < 500）'
    },
    {
      rule_id: 'new_user',
      segment_key: 'new_user',
      priority: 5, // 高优先级
      condition: {
        type: 'user_attribute',
        field: 'register_days',
        operator: '<=',
        value: 7
      },
      description: '新用户（注册 <= 7 天）'
    },
    {
      rule_id: 'default',
      segment_key: 'default',
      priority: 100, // 最低优先级（兜底）
      condition: { type: 'always_match' },
      description: '默认规则（无其他规则命中时使用）'
    }
  ]
}

// services/SegmentResolver.js - 分层解析器
class SegmentResolver {
  constructor() {
    this.config = require('../config/segment_rules')
  }

  /**
   * 解析用户的分层
   * @param {object} context - { user_id, campaign_id, budget_points, user_attributes }
   * @returns {{ segment_key, segment_version, matched_rule_id, match_reason }}
   */
  resolve(context) {
    const { rules, version } = this.config

    // 按优先级排序（priority 越小优先级越高）
    const sortedRules = [...rules].sort((a, b) => a.priority - b.priority)

    for (const rule of sortedRules) {
      const matchResult = this._evaluateCondition(rule.condition, context)

      if (matchResult.matched) {
        return {
          segment_key: rule.segment_key,
          segment_version: version,
          matched_rule_id: rule.rule_id,
          match_reason: {
            rule_id: rule.rule_id,
            description: rule.description,
            condition: rule.condition,
            actual_values: matchResult.actual_values
          }
        }
      }
    }

    // 理论上不应走到这里（default 规则兜底）
    return {
      segment_key: 'default',
      segment_version: version,
      matched_rule_id: 'fallback',
      match_reason: { error: 'no_rule_matched' }
    }
  }

  _evaluateCondition(condition, context) {
    switch (condition.type) {
      case 'budget_range':
        const budgetValue = context.budget_points || 0
        const minOk = condition.min === null || budgetValue >= condition.min
        const maxOk = condition.max === null || budgetValue <= condition.max
        return {
          matched: minOk && maxOk,
          actual_values: { [condition.field]: budgetValue }
        }

      case 'user_attribute':
        const attrValue = context.user_attributes?.[condition.field]
        const matched = this._compare(attrValue, condition.operator, condition.value)
        return {
          matched,
          actual_values: { [condition.field]: attrValue }
        }

      case 'always_match':
        return { matched: true, actual_values: {} }

      default:
        return { matched: false, actual_values: {} }
    }
  }

  _compare(actual, operator, expected) {
    switch (operator) {
      case '==':
        return actual == expected
      case '!=':
        return actual != expected
      case '>':
        return actual > expected
      case '>=':
        return actual >= expected
      case '<':
        return actual < expected
      case '<=':
        return actual <= expected
      default:
        return false
    }
  }
}

module.exports = new SegmentResolver()
```

---

#### lottery_draw_decisions 表新增字段

```sql
ALTER TABLE lottery_draw_decisions ADD COLUMN (
  -- ========== 分层审计字段（0.17 拍板：必须记录） ==========
  segment_key        VARCHAR(50) NULL COMMENT '命中的分层标识',
  segment_version    VARCHAR(50) NULL COMMENT '分层规则配置版本',
  matched_rule_id    VARCHAR(100) NULL COMMENT '命中的规则ID',
  match_reason       JSON NULL COMMENT '命中原因详情'
);

-- 添加索引（便于按分层统计分析）
ALTER TABLE lottery_draw_decisions ADD INDEX idx_segment_key (segment_key);
ALTER TABLE lottery_draw_decisions ADD INDEX idx_segment_version (segment_version);
```

---

#### 决策快照示例（包含分层审计）

```json
{
  "decision_id": "dec_20260118_abc123",
  "draw_id": "draw_20260118_xyz789",
  "campaign_id": 1,
  "user_id": 12345,
  "pipeline_type": "normal",
  "pick_method": "tier_first",

  // ========== 分层审计字段（0.17 新增） ==========
  "segment_key": "high_budget",
  "segment_version": "1.0.0",
  "matched_rule_id": "high_budget",
  "match_reason": {
    "rule_id": "high_budget",
    "description": "高预算用户（BUDGET_POINTS >= 500）",
    "condition": { "type": "budget_range", "field": "BUDGET_POINTS", "min": 500, "max": null },
    "actual_values": { "BUDGET_POINTS": 800 }
  },

  // ========== 档位与降级相关 ==========
  "original_tier": "high",
  "final_tier": "high",
  "downgrade_count": 0,
  "fallback_triggered": false,
  "picked_prize_id": 10,
  "guarantee_triggered": false
}
```

---

#### V2 演进路径

| 阶段           | 实现方式                           | 说明                                                                                   |
| -------------- | ---------------------------------- | -------------------------------------------------------------------------------------- |
| **V1（当前）** | `SegmentResolver` + 版本化配置文件 | 低维护成本、可回滚、可审计                                                             |
| **V2（未来）** | 接入统一人群/实验平台              | 替换 `SegmentResolver` 的实现，调用平台 API 获取 `segment_key`                         |
| **过渡兼容**   | 保持输出格式不变                   | 无论 V1/V2，输出都是 `{ segment_key, segment_version, matched_rule_id, match_reason }` |

---

#### 核心约束

1. **V1 不建 `lottery_segment_rules` 表**：分层规则在配置文件中定义，不引入业务库可编辑表。
2. **配置跟代码走**：`config/segment_rules.js` 随代码版本发布，Git 版本即配置版本。
3. **必须可回滚**：通过 Git revert 或切换版本号即可回滚到上一配置。
4. **审计字段必须记录**：每次抽奖必须写入 `segment_key`、`segment_version`、`matched_rule_id`、`match_reason`。
5. **default 规则必配**：配置文件中必须有 `segment_key='default'` 的兜底规则。
6. **V2 可无缝替换**：`SegmentResolver` 的实现可被统一人群/实验平台替换，输出格式不变。

---

### 0.18 管理干预管线选择（已拍板 2026-01-18）

**拍板结论**：管理干预（`force_win`/`force_lose`）使用**独立的 OverridePipeline**，**不复用 PresetAwardPipeline**。

| 维度     | 决策内容                                     |
| -------- | -------------------------------------------- |
| 管线选择 | **OverridePipeline（独立管线）**             |
| 放弃方案 | 不复用 PresetAwardPipeline（虽然实现更省事） |
| 选择理由 | 权限隔离更强、逻辑更清晰、审计更明确         |

#### 管线优先级（更新后）

| 优先级 | 场景                 | 管线                                    |
| ------ | -------------------- | --------------------------------------- |
| **1**  | 预设（Preset）       | `PresetAwardPipeline`                   |
| **2**  | 管理干预（Override） | **`OverridePipeline`**（独立管线）      |
| **3**  | 保底（Guarantee）    | `NormalDrawPipeline` + `GuaranteeStage` |
| **4**  | 正常抽奖             | `NormalDrawPipeline`                    |

---

### 0.19 pool+quota 增强功能（已拍板 2026-01-18）

**拍板结论**：**预留池** 和 **quota_init_mode 两种模式**都必须实现（不是可选）。

| 增强功能            | 决策内容                                                                                   |
| ------------------- | ------------------------------------------------------------------------------------------ |
| **预留池**          | **必须实现**：`public_pool_remaining`（普通用户）+ `reserved_pool_remaining`（白名单专用） |
| **quota_init_mode** | **两种都实现**：`on_demand`（默认，按需初始化）+ `pre_allocated`（预分配模式）             |

---

### 0.20 预设二次审批流程（已拍板 2026-01-18）

**拍板结论**：**不需要二次审批流程**。`approved_by`/`approved_at` 字段保留但不启用。

| 维度     | 决策内容                                                                        |
| -------- | ------------------------------------------------------------------------------- |
| 审批流程 | **不启用**：预设创建后直接生效，无需审批确认                                    |
| 字段处理 | **保留但不启用**：`approved_by`、`approved_at` 字段保留在表结构中，方便未来扩展 |
| 责任追溯 | 通过 `created_by` + `reason` 字段实现审计追责（已在 0.2 规则6 中要求）          |

---

### 0.21 自动补差非法输入处理（已拍板 2026-01-18）

**拍板结论**：如果前 N-1 项权重之和超过 SCALE（1,000,000），**直接拒绝保存/阻止上线**。

| 维度         | 决策内容                                                 |
| ------------ | -------------------------------------------------------- |
| 非法输入判定 | 前 N-1 项权重之和 > SCALE（1,000,000）                   |
| 处理方式     | **直接拒绝保存**，不允许上线                             |
| 放弃方案     | 不做归一化、不做比例缩放、不做任何隐式调整               |
| 错误提示     | 返回明确错误：当前权重和、期望值、差值，要求运营调整配置 |

#### 校验逻辑（更新后）

```javascript
const SCALE = 1_000_000

function autoAdjustLastWeight(weights) {
  if (weights.length === 0) return weights

  const lastIndex = weights.length - 1
  const sumExceptLast = weights.slice(0, lastIndex).reduce((sum, w) => sum + w.weight, 0)

  // 【已拍板】前 N-1 项之和超过 SCALE → 直接拒绝保存
  if (sumExceptLast > SCALE) {
    throw new Error(
      `权重配置非法：前 ${lastIndex} 项权重之和（${sumExceptLast}）已超过 SCALE（${SCALE}），` +
        `无法为最后一项分配有效权重。请调整前面的权重配置。`
    )
  }

  // 正常补差逻辑...
}
```

---

## 一、文档目的

本文档将以下四份需求文档的核心诉求统一到一套 **Pipeline（管线）架构** 中：

| 来源文档                          | 核心需求                                   |
| --------------------------------- | ------------------------------------------ |
| `奖品配置与抽奖关系.md`           | 预算过滤、概率抽取、成本控制、保底机制     |
| `抽奖概率归一化与档位设计方案.md` | 解决概率缺口、归一化/显式缺口/先档位后奖品 |
| `预算模型-总池配额方案.md`        | pool+quota 双层预算、白名单预授权、预留池  |
| `预设强制发放-系统垫付方案.md`    | 预设奖品强制发放、库存/预算欠账记录        |

**最终目标**：用一套统一的架构覆盖所有场景，避免功能割裂、逻辑冲突、维护困难。

---

## 二、架构总览

### 2.1 核心设计原则

| 原则                                 | 说明                                                                  |
| ------------------------------------ | --------------------------------------------------------------------- |
| **管线化（Pipeline）**               | 不同玩法/场景对应不同管线，共享 80% 能力，差异部分通过 Stage 组合实现 |
| **单点写入（Single Writer）**        | 只有 `SettleStage` 允许执行扣减/发放/落库，其它 Stage 只产出"决策"    |
| **强一致事务（Strong Consistency）** | 扣积分/扣预算/扣库存/发奖/写记录 全部在同一 DB 事务内完成             |
| **幂等保障（Idempotency）**          | 每次抽奖有唯一 `idempotency_key`，重复请求返回同一结果                |
| **可审计（Auditable）**              | 每次抽奖的决策过程（过滤/归一化/档位/回退）落库为快照，可回放排查     |

### 2.2 模块架构图

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              API Layer（路由/鉴权/参数校验）                   │
│                     POST /api/v4/lottery/draw                               │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                                      ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                         DrawOrchestrator（抽奖编排器）                        │
│  - 组装上下文（user_id, campaign_id, idempotency_key）                       │
│  - 选择 Pipeline（根据 campaign_type / 是否有预设）                          │
│  - 调用 PipelineRunner                                                      │
│  - 格式化响应                                                                │
└─────────────────────────────────────────────────────────────────────────────┘
                                      │
                    ┌─────────────────┴─────────────────┐
                    ▼                                   ▼
┌───────────────────────────────────┐   ┌───────────────────────────────────┐
│     NormalDrawPipeline            │   │     PresetAwardPipeline           │
│     （正常抽奖管线）               │   │     （预设强制发放管线）           │
├───────────────────────────────────┤   ├───────────────────────────────────┤
│ 1. LoadCampaignStage              │   │ 1. LoadPresetStage                │
│ 2. EligibilityStage               │   │ 2. LoadCampaignStage              │
│ 3. BudgetContextStage             │   │ 3. PickPrizeStage（直接指定）      │
│ 4. BuildPrizePoolStage            │   │ 4. SettleStage（强制变体）         │
│ 5. GuaranteeStage（可选）          │   │ 5. MarkPresetUsedStage            │
│ 6. TierPickStage（可选，方案3）    │   │ 6. DecisionSnapshotStage          │
│ 7. PrizePickStage                 │   └───────────────────────────────────┘
│ 8. SettleStage                    │
│ 9. DecisionSnapshotStage          │
└───────────────────────────────────┘
                    │
                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                           Domain Services（领域服务）                        │
├──────────────────┬──────────────────┬──────────────────┬────────────────────┤
│  BudgetProvider  │  InventoryService│  PrizeService    │  LedgerService     │
│  （预算提供者）   │  （库存服务）     │  （奖品服务）     │  （账本服务）       │
├──────────────────┼──────────────────┼──────────────────┼────────────────────┤
│ • UserBudget     │ • 库存扣减       │ • 奖品配置查询   │ • POINTS 扣减      │
│ • PoolBudget     │ • 日限额计数     │ • 权重计算       │ • BUDGET 扣减      │
│ • PoolQuotaBudget│ • 欠账记录       │ • 档位映射       │ • 奖励发放         │
└──────────────────┴──────────────────┴──────────────────┴────────────────────┘
                    │
                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                              Data Layer（数据层）                            │
├───────────────────────────────────────────────────────────────────────────── ┤
│  lottery_campaigns          lottery_prizes           lottery_draws          │
│  lottery_tier_rules         lottery_presets          asset_transactions     │
│  account_asset_balances     lottery_campaign_user_quota                     │
│  lottery_campaign_quota_grants    preset_inventory_debt    preset_budget_debt│
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 三、核心管线设计

### 3.1 NormalDrawPipeline（正常抽奖管线）

适用于：普通用户随机抽奖、保底触发、档位抽取等"公平随机"场景。

#### Stage 列表与职责

| 序号 | Stage 名称            | 职责                                           | 可写入 | 输入                            | 输出                                 |
| ---- | --------------------- | ---------------------------------------------- | ------ | ------------------------------- | ------------------------------------ |
| 1    | LoadCampaignStage     | 加载活动配置                                   | ❌     | campaign_id                     | campaign 对象                        |
| 2    | EligibilityStage      | 资格校验（次数/时间窗/黑白名单）               | ❌     | user_id, campaign               | eligible: boolean, reason            |
| 3    | BudgetContextStage    | 计算本次可用预算视图                           | ❌     | user_id, campaign               | budget_view: { available, source }   |
| 4    | BuildPrizePoolStage   | 构建候选奖品池（状态/库存/日限额/预算过滤）    | ❌     | campaign, budget_view           | candidate_prizes[], filtered_reasons |
| 5    | GuaranteeStage        | 检查保底/累计触发条件（可选）                  | ❌     | user_id, campaign               | guarantee_prize_id \| null           |
| 6    | TierPickStage         | 先抽档位 reward_tier（可选，方案3）            | ❌     | user_id, campaign, budget_view  | selected_tier, tier_probability      |
| 7    | PrizePickStage        | 在候选池/档位内抽具体奖品                      | ❌     | candidate_prizes, selected_tier | picked_prize, pick_method            |
| 8    | SettleStage           | **唯一写入点**：扣积分/扣预算/扣库存/发奖/落库 | ✅     | picked_prize, budget_view       | draw_record, ledger_entries          |
| 9    | DecisionSnapshotStage | 记录决策快照（审计）                           | ✅     | 全部中间结果                    | decision_snapshot_id                 |

#### 事务边界

```
┌─────────────────────────────────────────────────────────────────┐
│                    SettleStage（单一 DB 事务）                   │
├─────────────────────────────────────────────────────────────────┤
│  BEGIN TRANSACTION                                              │
│    1. 扣用户 POINTS（抽奖成本）                                  │
│    2. 扣预算（按 BudgetProvider：user/pool/pool+quota）          │
│    3. 扣库存（UPDATE ... WHERE stock > 0）                       │
│    4. 更新日限额计数                                             │
│    5. 发放奖品（points/coupon/virtual/physical）                 │
│    6. 写 lottery_draws（含 budget_before/after、tier、幂等键）   │
│    7. 写 asset_transactions（账本流水）                          │
│  COMMIT                                                         │
└─────────────────────────────────────────────────────────────────┘
```

---

### 3.2 PresetAwardPipeline（预设强制发放管线）

适用于：运营预设中奖、管理干预、定向发放等"必须发放"场景。

#### Stage 列表与职责

| 序号 | Stage 名称              | 职责                               | 可写入 | 输入                   | 输出                      |
| ---- | ----------------------- | ---------------------------------- | ------ | ---------------------- | ------------------------- |
| 1    | LoadPresetStage         | 加载用户的待使用预设               | ❌     | user_id, campaign_id   | preset 对象               |
| 2    | LoadCampaignStage       | 加载活动配置                       | ❌     | campaign_id            | campaign 对象             |
| 3    | PickPrizeStage          | 直接使用预设指定的奖品（不走概率） | ❌     | preset                 | picked_prize              |
| 4    | SettleStage（强制变体） | **尽力扣减 + 记债 + 永远发放**     | ✅     | picked_prize, campaign | draw_record, debt_records |
| 5    | MarkPresetUsedStage     | 标记预设为已使用                   | ✅     | preset                 | preset.status = 'used'    |
| 6    | DecisionSnapshotStage   | 记录决策快照（审计）               | ✅     | 全部中间结果           | decision_snapshot_id      |

#### SettleStage（强制变体）的特殊逻辑

> **重要**：必须严格遵循"第〇章 决策拍板记录"中的硬规则。

```
┌─────────────────────────────────────────────────────────────────┐
│              SettleStage（强制变体 - 单一 DB 事务）              │
├─────────────────────────────────────────────────────────────────┤
│  BEGIN TRANSACTION                                              │
│                                                                 │
│  ┌─ 步骤1：扣用户 POINTS（硬约束，不可欠账）                     │
│  │    ├─ 余额充足 → 正常扣减，继续                              │
│  │    └─ 余额不足 → ❌ 直接 ROLLBACK 并返回失败                 │
│  │       （POINTS 是用户资产，不允许欠账）                       │
│  │                                                              │
│  ├─ 步骤2：检查欠账上限                                         │
│  │    ├─ 检查活动级 max_budget_debt                             │
│  │    ├─ 检查奖品级 max_inventory_debt_qty                      │
│  │    ├─ 检查用户级 user_daily/total_debt_limit                 │
│  │    └─ 任一超限 → ❌ 直接 ROLLBACK 并返回"欠账已达上限"        │
│  │                                                              │
│  ├─ 步骤3：尝试扣库存（原子操作）                                │
│  │    UPDATE ... SET stock=stock-1 WHERE stock>0                │
│  │    ├─ 成功 → 正常扣减                                        │
│  │    └─ 失败 + preset_debt_enabled=true → 写 preset_inventory_debt │
│  │    └─ 失败 + preset_debt_enabled=false → ❌ ROLLBACK 返回失败 │
│  │                                                              │
│  ├─ 步骤4：尝试扣预算（严格 follow_campaign，不跨源）            │
│  │    if budget_mode='pool':                                    │
│  │       尝试扣 pool_budget_remaining                           │
│  │    elif budget_mode='user':                                  │
│  │       尝试扣用户 BUDGET_POINTS                               │
│  │    elif budget_mode='none':                                  │
│  │       跳过预算扣减                                           │
│  │                                                              │
│  │    ├─ 成功 → 正常扣减                                        │
│  │    └─ 失败 + preset_debt_enabled=true → 写 preset_budget_debt │
│  │    └─ 失败 + preset_debt_enabled=false → ❌ ROLLBACK 返回失败 │
│  │                                                              │
│  ├─ 步骤5：发放奖品                                             │
│  │    （只有前面步骤都通过或允许欠账时才执行）                    │
│  │                                                              │
│  ├─ 步骤6：写 lottery_draws                                     │
│  │    标记 is_preset=true, has_debt, debt_id 关联               │
│  │                                                              │
│  └─ 步骤7：写 asset_transactions                                │
│                                                                 │
│  COMMIT                                                         │
└─────────────────────────────────────────────────────────────────┘
```

**关键约束再次强调**：

1. **POINTS 永不欠账**：步骤1 POINTS 不足直接失败退出
2. **不跨预算源兜底**：步骤4 严格按 budget_mode 扣减，不会"扣不够就去扣另一个"
3. **欠账必须审计**：每笔欠账记录必须带 preset_id、created_by、reason
4. **欠账必须有上限**：步骤2 检查各维度上限，超限拒绝

---

## 四、统一预算域（BudgetProvider）

### 4.1 抽象接口

```javascript
// 统一预算提供者接口（概念定义）
interface BudgetProvider {
  /**
   * 获取本次可用预算视图（用于过滤候选奖品）
   * @returns { available: number, source: string, details: object }
   */
  getBudgetView(context: DrawContext): Promise<BudgetView>

  /**
   * 事务内扣减预算（强一致）
   * @returns { success: boolean, deducted: number, remaining: number }
   */
  deduct(context: DrawContext, amount: number, tx: Transaction): Promise<DeductResult>

  /**
   * 尝试扣减（不抛异常版，用于预设强制发放）
   * @returns { success: boolean, deducted: number, debt: number }
   */
  tryDeduct(context: DrawContext, amount: number, tx: Transaction): Promise<TryDeductResult>
}
```

### 4.2 三种实现

| 实现类                      | 对应 budget_mode | 预算来源                                                   | 扣减逻辑                          |
| --------------------------- | ---------------- | ---------------------------------------------------------- | --------------------------------- |
| **UserBudgetProvider**      | `user`           | 用户的 `BUDGET_POINTS`（按 `allowed_campaign_ids` 筛选桶） | 扣用户账本                        |
| **PoolBudgetProvider**      | `pool`           | 活动的 `pool_budget_remaining`                             | 扣活动池                          |
| **PoolQuotaBudgetProvider** | `pool` + 配额    | 活动池 + 用户配额（双扣）                                  | 先扣 quota，再扣 pool（同一事务） |

### 4.3 PoolQuotaBudgetProvider 详细设计（对应预算模型文档）

```
┌─────────────────────────────────────────────────────────────────┐
│              PoolQuotaBudgetProvider 扣减流程                    │
├─────────────────────────────────────────────────────────────────┤
│  1. 获取用户配额（按需创建，或命中白名单预授权）                   │
│     └─ getOrCreateUserQuota(campaign_id, user_id)               │
│                                                                 │
│  2. 计算可用预算 = min(quota_remaining, pool_remaining)          │
│                                                                 │
│  3. 扣减（同一事务）                                             │
│     ├─ UPDATE lottery_campaign_user_quota                       │
│     │   SET quota_remaining = quota_remaining - ?               │
│     │   WHERE ... AND quota_remaining >= ?                      │
│     │                                                           │
│     └─ UPDATE lottery_campaigns                                 │
│         SET pool_budget_remaining = pool_budget_remaining - ?   │
│         WHERE ... AND pool_budget_remaining >= ?                │
│                                                                 │
│  4. 如选"预留池"方案                                             │
│     ├─ VIP 用户优先扣 reserved_pool_remaining                   │
│     └─ 普通用户只能扣 public_pool_remaining                      │
└─────────────────────────────────────────────────────────────────┘
```

---

## 五、奖品选择策略（PrizePickStage）

### 5.1 三种做法支持

| 做法                    | 配置标识                    | 实现逻辑                                                     | 适用场景                 |
| ----------------------- | --------------------------- | ------------------------------------------------------------ | ------------------------ |
| **做法1：归一化**       | `pick_method: 'normalize'`  | 过滤后对剩余奖品概率按总和缩放到 1                           | 快速止血、接受"动态放大" |
| **做法2：显式缺口**     | `pick_method: 'fallback'`   | 缺口概率绑定到 `fallback_prize_id`                           | 成本严格可控、规则透明   |
| **做法3：先档位后奖品** | `pick_method: 'tier_first'` | 先抽 tier，再在 tier 内按原始权重抽（**不归一化**，见 0.14） | 长期运营、分层体验       |

### 5.2 做法3（先档位后奖品）详细流程（已与 0.8 拍板对齐）

> **重要**：本节实现必须严格遵循"0.8 概率缺口处理策略"的拍板规则。

```
┌─────────────────────────────────────────────────────────────────┐
│                    TierPickStage（先抽档位）                     │
├─────────────────────────────────────────────────────────────────┤
│  1. 查询 lottery_tier_rules（按活动获取档位概率配置）             │
│     SELECT * FROM lottery_tier_rules                            │
│     WHERE campaign_id = ? AND status = 'active'                 │
│     ORDER BY sort_order ASC                                     │
│                                                                 │
│  2. 获取档位概率（必须总和=1）                                   │
│     例如：high=0.02, mid=0.18, low=0.80                         │
│                                                                 │
│  3. 随机抽取一个 tier                                           │
│     randomValue ∈ [0, 1) → 命中 high/mid/low                    │
│                                                                 │
│  4. 输出 original_tier（原始命中档位，用于审计）                  │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│              PrizePickStage（档位内抽奖品 + 降级链路）            │
├─────────────────────────────────────────────────────────────────┤
│  1. 初始化：current_tier = original_tier, downgrade_count = 0   │
│                                                                 │
│  2. 【循环】在 current_tier 内筛选可发奖品                       │
│     候选条件：reward_tier = current_tier                        │
│              AND stock_quantity > 0                             │
│              AND 预算足够                                       │
│              AND daily_win_count < max_daily_wins               │
│                                                                 │
│  3. 如果 current_tier 有可发奖品：                               │
│     └─ 按 win_probability 权重抽取（不归一化，按原始权重）        │
│     └─ 输出 picked_prize, final_tier = current_tier             │
│     └─ 退出循环                                                 │
│                                                                 │
│  4. 如果 current_tier 无可发奖品（空档）：                        │
│     └─ 执行降级：high → mid → low（固定链路）                    │
│     └─ downgrade_count++                                        │
│     └─ 如果还有下一档位：current_tier = next_tier，回到步骤2     │
│     └─ 如果没有下一档位：进入步骤5                               │
│                                                                 │
│  5. 降级链路走完仍无可发（触发 fallback）：                       │
│     └─ 查找 prize_value_points = 0 的兜底奖品                    │
│     └─ 如果兜底奖品存在且可发：输出 fallback_prize               │
│     └─ 如果兜底奖品不存在/不可发：返回失败                        │
│                                                                 │
│  6. 输出决策快照字段：                                           │
│     {                                                           │
│       original_tier: "high",     // 原始命中档位                 │
│       final_tier: "mid",         // 最终发放档位                 │
│       downgrade_count: 1,        // 降级次数                     │
│       downgrade_reason: "stock_empty", // 降级原因               │
│       fallback_triggered: false  // 是否触发兜底                 │
│     }                                                           │
└─────────────────────────────────────────────────────────────────┘
```

#### 降级链路定义（硬编码，不可配置）

| 原始命中档位 | 降级顺序                    | 说明                      |
| ------------ | --------------------------- | ------------------------- |
| `high`       | high → mid → low → fallback | 最高档位，降级路径最长    |
| `mid`        | mid → low → fallback        | 中档，跳过 high           |
| `low`        | low → fallback              | 最低档位，只能走 fallback |

> **设计理由**：降级链路固定为"从高到低"，不允许"low 升级到 mid"，保证用户体验只会"降级"而不会"意外升级"。

---

## 六、预设强制发放与系统垫付

> **重要**：本章节实现必须严格遵循"第〇章 决策拍板记录"中的硬规则。

### 6.1 核心原则

```
预设发奖 = 强约束（永远要发，前提是 POINTS 足够且开启欠账开关）
扣减     = 尽力而为（能扣就扣，扣不了记债）
POINTS   = 硬约束（不足直接失败，不允许欠账）
```

### 6.2 预设执行前置条件

| 条件                                   | 不满足时的处理                                |
| -------------------------------------- | --------------------------------------------- |
| 用户 POINTS 充足                       | ❌ 失败，返回"积分不足"（不允许 POINTS 欠账） |
| `preset_debt_enabled=false` 且预算不足 | ❌ 失败，返回"预算不足"                       |
| `preset_debt_enabled=false` 且库存不足 | ❌ 失败，返回"库存不足"                       |
| `preset_debt_enabled=true` 且欠账超限  | ❌ 失败，返回"欠账已达上限"                   |

### 6.3 库存欠账处理

| 场景                                             | 处理方式                                              |
| ------------------------------------------------ | ----------------------------------------------------- |
| 库存足够                                         | 正常扣减 `stock_quantity -= 1`                        |
| 库存不足 + `preset_debt_enabled=true`            | 强行发放 + 写 `preset_inventory_debt`（待补货后冲销） |
| 库存不足 + `preset_debt_enabled=false`           | ❌ 直接失败，不发放                                   |
| 库存不足 + 欠货数量已达 `max_inventory_debt_qty` | ❌ 直接失败，返回"该奖品欠货已达上限"                 |

### 6.4 预算欠账处理（严格 follow_campaign，不跨钱包兜底）

| 活动 budget_mode | 场景                                                    | 处理方式                                        |
| ---------------- | ------------------------------------------------------- | ----------------------------------------------- |
| `pool`           | 池够                                                    | 正常扣减 `pool_budget_remaining`                |
| `pool`           | 池不够 + `preset_debt_enabled=true`                     | 强行发放 + 写 `preset_budget_debt`（type=pool） |
| `pool`           | 池不够 + `preset_debt_enabled=false`                    | ❌ 直接失败，不发放                             |
| `pool`           | 池不够 + 欠账已达 `max_budget_debt`                     | ❌ 直接失败，返回"活动预算欠账已达上限"         |
| `user`           | 用户 `BUDGET_POINTS` 够                                 | 正常扣减用户 `BUDGET_POINTS`                    |
| `user`           | 用户 `BUDGET_POINTS` 不够 + `preset_debt_enabled=true`  | 强行发放 + 写 `preset_budget_debt`（type=user） |
| `user`           | 用户 `BUDGET_POINTS` 不够 + `preset_debt_enabled=false` | ❌ 直接失败，不发放                             |
| `user`           | 用户 `BUDGET_POINTS` 不够 + 欠账已达上限                | ❌ 直接失败，返回"用户预算欠账已达上限"         |
| `none`           | 任何情况                                                | 不扣预算，直接发放（仅用于测试）                |

> **关键约束**：`budget_mode=user` 时不会"扣不够就去扣 pool"，反之亦然。

### 6.5 用户侧体验保证

当 `preset_debt_enabled=true` 且未超限时：

- 无论库存/预算是否充足，**用户永远看到"正常中奖"**，不会收到"库存不足"或"预算不足"的错误提示。
- 系统侧会记录欠账，运营需关注欠账看板并及时冲销。

当 `preset_debt_enabled=false` 或欠账已超限时：

- 用户可能看到失败提示（但这是受控的，因为运营关闭了欠账或达到了上限）。

### 6.6 欠账记录必须包含的审计字段

每笔欠账记录必须包含以下字段，用于追责与冲销：

| 字段                  | 说明                                         |
| --------------------- | -------------------------------------------- |
| `debt_id`             | 欠账记录唯一ID                               |
| `preset_id`           | 关联的预设记录ID（追溯到哪个预设触发的欠账） |
| `draw_id`             | 关联的抽奖记录ID（追溯到哪次抽奖）           |
| `created_by`          | 创建该预设的管理员ID（责任人）               |
| `reason`              | 预设创建时填写的原因                         |
| `campaign_id`         | 关联活动ID                                   |
| `user_id`             | 受益用户ID                                   |
| `amount` / `quantity` | 欠账金额/数量                                |
| `status`              | 状态（pending/settled）                      |
| `settled_at`          | 冲销时间                                     |
| `settled_by`          | 冲销操作人                                   |

---

## 七、数据模型设计

### 7.1 需要新增的表

#### 1) lottery_tier_rules（档位规则表）

> **已拍板（0.13）**：采用 **A（行式）+ A2（segment_key 分层）** 方案，不使用三列硬编码。

```sql
CREATE TABLE lottery_tier_rules (
  tier_rule_id       BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  campaign_id        INT UNSIGNED NOT NULL COMMENT '关联活动ID',
  segment_key        VARCHAR(50) NOT NULL DEFAULT 'default' COMMENT '分层标识（default/low_budget/high_budget/new_user/vip等）',
  tier_name          VARCHAR(32) NOT NULL COMMENT '档位名称: low/mid/high（白名单枚举）',
  tier_probability   DECIMAL(10,8) NOT NULL COMMENT '档位命中概率(0~1)',
  sort_order         INT DEFAULT 0 COMMENT '优先级排序',
  status             ENUM('active','inactive') DEFAULT 'active',
  created_at         DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at         DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  -- 唯一约束：同一活动 + 同一分层 + 同一档位 只能有一条规则
  UNIQUE KEY uk_campaign_segment_tier (campaign_id, segment_key, tier_name),
  INDEX idx_campaign_segment (campaign_id, segment_key),
  INDEX idx_campaign_sort (campaign_id, sort_order)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='档位概率规则表（行式 + segment_key 分层）';
```

> **设计说明**：
>
> - `segment_key` 支持多维度分层（预算区间/渠道/新客/VIP 等），映射规则放在代码或 `lottery_segment_rules` 表。
> - `tier_name` 使用白名单枚举（low/mid/high），扩展新档位不需要改表结构。
> - 每个 `(campaign_id, segment_key)` 组合下的 `tier_probability` 之和必须 = 1（上线校验）。

#### 2) lottery_campaign_user_quota（用户配额表）

```sql
CREATE TABLE lottery_campaign_user_quota (
  id INT AUTO_INCREMENT PRIMARY KEY,
  campaign_id INT NOT NULL COMMENT '关联活动ID',
  user_id INT NOT NULL COMMENT '关联用户ID',
  quota_total DECIMAL(12,2) NOT NULL DEFAULT 0 COMMENT '分配的配额总量',
  quota_remaining DECIMAL(12,2) NOT NULL DEFAULT 0 COMMENT '剩余配额',
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  UNIQUE KEY uk_campaign_user (campaign_id, user_id),
  INDEX idx_user_id (user_id),
  INDEX idx_campaign_id (campaign_id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='活动用户配额表';
```

#### 3) lottery_campaign_quota_grants（白名单预授权表）

```sql
CREATE TABLE lottery_campaign_quota_grants (
  id INT AUTO_INCREMENT PRIMARY KEY,
  campaign_id INT NOT NULL COMMENT '关联活动ID',
  identity_type ENUM('mobile', 'openid', 'unionid', 'user_id') NOT NULL COMMENT '身份类型',
  identity_value VARCHAR(100) NOT NULL COMMENT '身份值',
  quota_total DECIMAL(12,2) NOT NULL DEFAULT 0 COMMENT '预授权配额',
  status ENUM('active', 'used', 'expired') NOT NULL DEFAULT 'active' COMMENT '状态',
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  UNIQUE KEY uk_campaign_identity (campaign_id, identity_type, identity_value),
  INDEX idx_campaign_id (campaign_id),
  INDEX idx_identity (identity_type, identity_value)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='活动配额白名单预授权表';
```

#### 4) preset_inventory_debt（库存欠账表）

> **审计要求**：每笔欠账必须能追溯到责任人（created_by）和原因（reason）。

```sql
CREATE TABLE preset_inventory_debt (
  debt_id VARCHAR(50) PRIMARY KEY COMMENT '欠货记录ID',
  preset_id VARCHAR(50) NOT NULL COMMENT '关联预设ID',
  draw_id VARCHAR(100) NOT NULL COMMENT '关联抽奖记录ID',
  prize_id INT NOT NULL COMMENT '欠货奖品ID',
  campaign_id INT NOT NULL COMMENT '关联活动ID',
  user_id INT NOT NULL COMMENT '发给的用户ID',
  quantity INT NOT NULL DEFAULT 1 COMMENT '欠货数量',

  -- 审计追责字段（必填）
  created_by INT NOT NULL COMMENT '创建该预设的管理员ID（责任人）',
  reason VARCHAR(500) NULL COMMENT '预设创建时填写的原因',

  -- 状态与冲销
  status ENUM('pending', 'settled') NOT NULL DEFAULT 'pending' COMMENT '状态：pending-待冲销，settled-已冲销',
  settled_at DATETIME NULL COMMENT '冲销时间',
  settled_by INT NULL COMMENT '冲销操作人ID',
  settle_note VARCHAR(500) NULL COMMENT '冲销备注',

  created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',

  INDEX idx_prize_status (prize_id, status),
  INDEX idx_campaign_status (campaign_id, status),
  INDEX idx_user_status (user_id, status),
  INDEX idx_preset_id (preset_id),
  INDEX idx_draw_id (draw_id),
  INDEX idx_created_by (created_by)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='预设发放库存欠账表（审计增强版）';
```

#### 5) preset_budget_debt（预算欠账表）

> **审计要求**：每笔欠账必须能追溯到责任人（created_by）和原因（reason）。

```sql
CREATE TABLE preset_budget_debt (
  debt_id VARCHAR(50) PRIMARY KEY COMMENT '欠账记录ID',
  preset_id VARCHAR(50) NOT NULL COMMENT '关联预设ID',
  draw_id VARCHAR(100) NOT NULL COMMENT '关联抽奖记录ID',
  campaign_id INT NOT NULL COMMENT '关联活动ID',
  user_id INT NOT NULL COMMENT '关联用户ID',
  debt_type ENUM('pool', 'user') NOT NULL COMMENT '欠账类型：pool-活动池欠账，user-用户预算欠账',
  amount DECIMAL(12,2) NOT NULL COMMENT '欠账金额',
  deduct_campaign_id VARCHAR(50) NULL COMMENT '原应扣的桶（user模式时记录 allowed_campaign_ids 中的桶）',

  -- 审计追责字段（必填）
  created_by INT NOT NULL COMMENT '创建该预设的管理员ID（责任人）',
  reason VARCHAR(500) NULL COMMENT '预设创建时填写的原因',

  -- 状态与冲销
  status ENUM('pending', 'settled') NOT NULL DEFAULT 'pending' COMMENT '状态：pending-待冲销，settled-已冲销',
  settled_at DATETIME NULL COMMENT '冲销时间',
  settled_by INT NULL COMMENT '冲销操作人ID',
  settle_note VARCHAR(500) NULL COMMENT '冲销备注',

  created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',

  INDEX idx_campaign_status (campaign_id, status),
  INDEX idx_user_status (user_id, status),
  INDEX idx_debt_type_status (debt_type, status),
  INDEX idx_preset_id (preset_id),
  INDEX idx_draw_id (draw_id),
  INDEX idx_created_by (created_by)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='预设发放预算欠账表（审计增强版）';
```

#### 6) preset_debt_limits（欠账上限配置表 - 运营可动态调整）

> **设计说明**：欠账上限必须运营可动态调整，不允许硬编码。此表支持活动级、奖品级、用户级的多维度上限配置。

```sql
CREATE TABLE preset_debt_limits (
  limit_id INT AUTO_INCREMENT PRIMARY KEY COMMENT '配置ID',

  -- 维度字段（支持多维度组合）
  campaign_id INT NULL COMMENT '活动ID（NULL表示全局默认）',
  prize_id INT NULL COMMENT '奖品ID（NULL表示活动级）',
  user_id INT NULL COMMENT '用户ID（NULL表示不限特定用户）',

  -- 上限配置
  limit_type ENUM('budget', 'inventory', 'user_daily', 'user_total') NOT NULL COMMENT '上限类型',
  limit_value DECIMAL(12,2) NOT NULL DEFAULT 0 COMMENT '上限值（0表示不限制，但强烈不推荐）',

  -- 状态
  status ENUM('active', 'inactive') NOT NULL DEFAULT 'active' COMMENT '状态',

  -- 审计
  created_by INT NOT NULL COMMENT '创建人',
  updated_by INT NULL COMMENT '最后更新人',
  created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  -- 唯一约束：同一维度组合只能有一条配置
  UNIQUE KEY uk_dimension (campaign_id, prize_id, user_id, limit_type),
  INDEX idx_campaign_id (campaign_id),
  INDEX idx_prize_id (prize_id),
  INDEX idx_user_id (user_id),
  INDEX idx_limit_type (limit_type)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='预设欠账上限配置表（运营可动态调整）';

-- 示例数据：
-- 全局默认预算欠账上限（所有活动）
-- INSERT INTO preset_debt_limits (campaign_id, prize_id, user_id, limit_type, limit_value, created_by)
-- VALUES (NULL, NULL, NULL, 'budget', 10000.00, 1);

-- 特定活动的预算欠账上限
-- INSERT INTO preset_debt_limits (campaign_id, prize_id, user_id, limit_type, limit_value, created_by)
-- VALUES (1, NULL, NULL, 'budget', 5000.00, 1);

-- 特定奖品的库存欠账上限
-- INSERT INTO preset_debt_limits (campaign_id, prize_id, user_id, limit_type, limit_value, created_by)
-- VALUES (1, 5, NULL, 'inventory', 100, 1);

-- 特定用户的每日欠账上限
-- INSERT INTO preset_debt_limits (campaign_id, prize_id, user_id, limit_type, limit_value, created_by)
-- VALUES (NULL, NULL, 123, 'user_daily', 500.00, 1);
```

#### 6) lottery_draw_decisions（决策快照表，可选但推荐）

> **重要**：必须记录降级链路信息，用于审计和对账。

```sql
CREATE TABLE lottery_draw_decisions (
  decision_id VARCHAR(100) PRIMARY KEY COMMENT '决策ID（与 draw_id 关联）',
  draw_id VARCHAR(100) NOT NULL COMMENT '关联抽奖记录ID',
  campaign_id INT NOT NULL COMMENT '活动ID',
  user_id INT NOT NULL COMMENT '用户ID',
  pipeline_type VARCHAR(50) NOT NULL COMMENT '管线类型（normal/preset）',
  budget_view JSON COMMENT '预算视图快照',
  candidate_prizes JSON COMMENT '候选奖品池快照',
  filtered_reasons JSON COMMENT '过滤原因',

  -- ========== 分层审计字段（0.17 拍板：必须记录） ==========
  segment_key        VARCHAR(50) NULL COMMENT '命中的分层标识（default/high_budget/new_user等）',
  segment_version    VARCHAR(50) NULL COMMENT '分层规则配置版本（Git commit hash 或语义版本号）',
  matched_rule_id    VARCHAR(100) NULL COMMENT '命中的规则ID（配置文件中定义的规则标识）',
  match_reason       JSON NULL COMMENT '命中原因详情（包含规则条件和实际值）',

  -- ========== 档位与降级相关（0.8 拍板：必须记录） ==========
  pick_method VARCHAR(50) COMMENT '选奖方法（normalize/fallback/tier_first）',
  original_tier VARCHAR(20) COMMENT '原始命中档位（high/mid/low）',
  final_tier VARCHAR(20) COMMENT '最终发放档位（降级后）',
  downgrade_count INT DEFAULT 0 COMMENT '降级次数（0=未降级）',
  downgrade_path JSON COMMENT '降级路径详情，如 ["high","mid"]',
  downgrade_reason VARCHAR(50) COMMENT '降级原因：stock_empty/budget_insufficient/daily_limit',
  fallback_triggered BOOLEAN DEFAULT FALSE COMMENT '是否触发 fallback 兜底',

  -- ========== 其他决策信息 ==========
  picked_prize_id INT COMMENT '最终选中奖品ID',
  guarantee_triggered BOOLEAN DEFAULT FALSE COMMENT '是否触发保底',
  debt_info JSON COMMENT '欠账信息（预设场景）',

  created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,

  INDEX idx_draw_id (draw_id),
  INDEX idx_campaign_user (campaign_id, user_id),
  INDEX idx_created_at (created_at),
  INDEX idx_downgrade (downgrade_count, fallback_triggered) COMMENT '用于降级/兜底分析',
  INDEX idx_segment_key (segment_key) COMMENT '用于按分层统计分析',
  INDEX idx_segment_version (segment_version) COMMENT '用于按配置版本统计'
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='抽奖决策快照表（含降级审计 + 分层审计）';
```

#### decision 快照示例（降级场景 + 分层审计）

```json
{
  "decision_id": "dec_20260117_abc123",
  "draw_id": "draw_20260117_xyz789",
  "campaign_id": 1,
  "user_id": 12345,
  "pipeline_type": "normal",

  // ========== 分层审计字段（0.17 拍板） ==========
  "segment_key": "high_budget",
  "segment_version": "1.0.0",
  "matched_rule_id": "high_budget",
  "match_reason": {
    "rule_id": "high_budget",
    "description": "高预算用户（BUDGET_POINTS >= 500）",
    "condition": { "type": "budget_range", "field": "BUDGET_POINTS", "min": 500, "max": null },
    "actual_values": { "BUDGET_POINTS": 800 }
  },

  // ========== 档位与降级字段（0.8 拍板） ==========
  "pick_method": "tier_first",
  "original_tier": "high",
  "final_tier": "mid",
  "downgrade_count": 1,
  "downgrade_path": ["high", "mid"],
  "downgrade_reason": "stock_empty",
  "fallback_triggered": false,
  "picked_prize_id": 15,
  "guarantee_triggered": false
}
```

### 7.2 需要调整的现有表

#### lottery_campaigns 新增字段

```sql
ALTER TABLE lottery_campaigns ADD COLUMN (
  -- 档位选择方法
  pick_method VARCHAR(50) DEFAULT 'normalize' COMMENT '选奖方法：normalize/fallback/tier_first',
  fallback_prize_id INT NULL COMMENT '缺口奖品ID（pick_method=fallback时使用）',

  -- 配额相关（pool+quota 模式）
  default_quota DECIMAL(12,2) DEFAULT 0 COMMENT '默认用户配额（按需初始化时使用）',
  quota_init_mode VARCHAR(20) DEFAULT 'on_demand' COMMENT '配额初始化模式：on_demand/pre_allocated（已拍板 2026-01-18：两种都实现）',

  -- 预留池（已拍板 2026-01-18：必须实现）
  public_pool_remaining DECIMAL(12,2) NULL COMMENT '公共池剩余（普通用户可用）',
  reserved_pool_remaining DECIMAL(12,2) NULL COMMENT '预留池剩余（白名单专用）',

  -- ========== 预设欠账配置（2026-01-16 决策拍板） ==========
  -- 核心开关
  preset_debt_enabled BOOLEAN DEFAULT FALSE COMMENT '预设是否允许欠账（核心开关）：TRUE-允许欠账发放，FALSE-资源不足直接失败',

  -- 预算扣减策略（三种策略都要实现，默认 follow_campaign）
  preset_budget_policy VARCHAR(20) DEFAULT 'follow_campaign' COMMENT '预设预算扣减策略：follow_campaign(默认)/pool_first/user_first',
  -- follow_campaign: 严格遵循活动 budget_mode，不跨源兜底
  -- pool_first: 先扣 pool，不够再扣用户 BUDGET_POINTS（补差额模式）
  -- user_first: 先扣用户 BUDGET_POINTS，不够再扣 pool（补差额模式）

  -- 活动级欠账上限（快捷配置，优先级低于 preset_debt_limits 表）
  max_budget_debt DECIMAL(12,2) DEFAULT 0 COMMENT '该活动预算欠账上限（0=不限制，强烈不推荐）',
  max_inventory_debt_qty INT DEFAULT 0 COMMENT '该活动库存欠账总数量上限（0=不限制，强烈不推荐）'
);

-- 添加索引
ALTER TABLE lottery_campaigns ADD INDEX idx_preset_debt_enabled (preset_debt_enabled);
ALTER TABLE lottery_campaigns ADD INDEX idx_preset_budget_policy (preset_budget_policy);
```

> **配置优先级说明**：
>
> 1. `preset_debt_limits` 表中的细粒度配置优先级最高
> 2. `lottery_campaigns` 表中的 `max_budget_debt` / `max_inventory_debt_qty` 作为活动级兜底
> 3. 如果都没配置（值为0），则不限制（但强烈不推荐）

#### lottery_prizes 新增字段

```sql
ALTER TABLE lottery_prizes ADD COLUMN (
  -- 档位标记（方案3使用）
  reward_tier VARCHAR(20) DEFAULT 'low' COMMENT '奖品档位：low/mid/high',

  -- 预留控制（可选）
  reserved_for_vip BOOLEAN DEFAULT FALSE COMMENT '是否仅白名单可抽'
);
```

#### lottery_draws 新增字段

```sql
ALTER TABLE lottery_draws ADD COLUMN (
  -- 管线与策略标记
  pipeline_type VARCHAR(50) DEFAULT 'normal' COMMENT '管线类型：normal/preset',
  pick_method VARCHAR(50) NULL COMMENT '选奖方法',

  -- ========== 档位与降级相关（0.8 拍板：必须记录） ==========
  original_tier VARCHAR(20) NULL COMMENT '原始命中档位（high/mid/low）',
  final_tier VARCHAR(20) NULL COMMENT '最终发放档位（降级后）',
  downgrade_count INT DEFAULT 0 COMMENT '降级次数（0=未降级，便于快速统计）',
  fallback_triggered BOOLEAN DEFAULT FALSE COMMENT '是否触发 fallback 兜底',

  -- 预设相关
  is_preset BOOLEAN DEFAULT FALSE COMMENT '是否为预设发放',
  preset_id VARCHAR(50) NULL COMMENT '关联预设ID',

  -- 欠账标记
  inventory_debt_id VARCHAR(50) NULL COMMENT '关联库存欠账ID',
  budget_debt_id VARCHAR(50) NULL COMMENT '关联预算欠账ID',
  has_debt BOOLEAN DEFAULT FALSE COMMENT '是否产生了欠账（便于快速筛选）',

  -- 决策快照关联
  decision_id VARCHAR(100) NULL COMMENT '关联决策快照ID'
);

-- 添加索引（便于欠账相关查询）
ALTER TABLE lottery_draws ADD INDEX idx_is_preset (is_preset);
ALTER TABLE lottery_draws ADD INDEX idx_has_debt (has_debt);
ALTER TABLE lottery_draws ADD INDEX idx_preset_id (preset_id);
-- 新增：降级相关索引（便于运营监控）
ALTER TABLE lottery_draws ADD INDEX idx_downgrade (downgrade_count, fallback_triggered);
ALTER TABLE lottery_draws ADD INDEX idx_tier (original_tier, final_tier);
```

#### lottery_presets 新增字段（审计追责）

> **重要**：`created_by` 和 `reason` 字段用于欠账追责，必须在创建预设时填写。

```sql
ALTER TABLE lottery_presets ADD COLUMN (
  -- 审计追责字段（必填）
  created_by INT NOT NULL COMMENT '创建该预设的管理员ID（责任人）',
  reason VARCHAR(500) NULL COMMENT '创建预设的原因/备注',

  -- 审核字段（已拍板 2026-01-18：不需要二次审批，字段保留但不启用流程）
  approved_by INT NULL COMMENT '审批人ID（保留字段，当前不启用）',
  approved_at DATETIME NULL COMMENT '审批时间（保留字段，当前不启用）'
);

-- 添加索引
ALTER TABLE lottery_presets ADD INDEX idx_created_by (created_by);
```

---

## 八、现有功能覆盖对照表

| 现有功能                               | 新架构落点                                       | 说明                                  |
| -------------------------------------- | ------------------------------------------------ | ------------------------------------- |
| 预算过滤（budget_mode=user/pool/none） | BudgetContextStage + BuildPrizePoolStage         | 统一由 BudgetProvider 提供可用视图    |
| allowed_campaign_ids 桶限制            | UserBudgetProvider                               | 作为"可用桶范围"规则输入              |
| 概率抽取（win_probability）            | PrizePickStage                                   | 支持归一化/显式缺口/档位内归一化      |
| 库存扣减 / 日限额                      | BuildPrizePoolStage（过滤）+ SettleStage（扣减） | 过滤与扣减分离                        |
| 保底机制（guarantee）                  | GuaranteeStage                                   | 只做决策输出，扣减由 SettleStage 完成 |
| 预设奖品（preset）                     | PresetAwardPipeline                              | 独立管线，结算走强制变体              |
| 管理干预（force_win/force_lose）       | **OverridePipeline（独立管线）**                 | **已拍板**：独立管线，权限隔离更强    |
| 记账与抽奖记录                         | SettleStage                                      | 全部收口在同一事务                    |
| 幂等                                   | idempotency_key 唯一约束                         | 重复请求返回同一结果                  |
| **预设欠账（新增）**                   | preset_inventory_debt + preset_budget_debt       | 审计增强版，必须带 created_by/reason  |
| **欠账上限控制（新增）**               | preset_debt_limits 表 + 活动字段兜底             | 运营可动态调整，多维度上限            |
| **POINTS 硬约束（新增）**              | SettleStage 前置校验                             | POINTS 不足直接失败，不允许欠账       |

---

## 九、管线选择逻辑

```javascript
// DrawOrchestrator 中的管线选择逻辑（伪代码）
async selectPipeline(context) {
  const { user_id, campaign_id } = context

  // 1. 检查是否有待使用的预设
  const preset = await LotteryPreset.findOne({
    where: { user_id, campaign_id, status: 'active' },
    order: [['queue_order', 'ASC']]
  })

  if (preset) {
    return {
      pipeline: PresetAwardPipeline,
      preset: preset
    }
  }

  // 2. 检查是否有管理干预（force_win/force_lose）
  // 【已拍板 2026-01-18】管理干预使用独立的 OverridePipeline，不复用 PresetAwardPipeline
  const override = await LotteryManagementSetting.findOne({
    where: { user_id, campaign_id, setting_type: ['force_win', 'force_lose'], status: 'active' }
  })

  if (override) {
    return {
      pipeline: OverridePipeline,  // 独立管线，权限隔离更强
      override: override,
      reason: 'override_hit'
    }
  }

  // 3. 默认走正常抽奖管线
  return {
    pipeline: NormalDrawPipeline
  }
}
```

---

## 十、实施路线图

### 10.1 Phase 1：核心骨架（建议 1-2 周）

- [ ] 新建 `PipelineRunner` 基础框架
- [ ] 实现 `NormalDrawPipeline` 的核心 Stage：
  - LoadCampaignStage
  - BudgetContextStage
  - BuildPrizePoolStage
  - PrizePickStage（先只支持 normalize）
  - SettleStage
- [ ] 建表：`lottery_draw_decisions`
- [ ] 迁移现有 `BasicGuaranteeStrategy` 逻辑到 Stage

### 10.2 Phase 2：预算域统一（建议 1 周）

- [ ] 实现 `BudgetProvider` 抽象和三种实现
- [ ] 建表：`lottery_campaign_user_quota`、`lottery_campaign_quota_grants`
- [ ] 实现配额按需初始化 + 白名单预授权
- [ ] 实现预留池逻辑（已拍板：必须实现）
- [ ] 实现 quota_init_mode 两种模式（on_demand + pre_allocated，已拍板：两种都实现）

### 10.3 Phase 3：档位与选奖策略（建议 1 周）

- [ ] 建表：`lottery_tier_rules`
- [ ] 实现 `TierPickStage`
- [ ] 扩展 `PrizePickStage` 支持三种做法（normalize/fallback/tier_first）
- [ ] 实现降级策略

### 10.4 Phase 4：预设强制发放与管理干预（建议 2 周）

- [ ] 实现 `PresetAwardPipeline`
- [ ] 实现 `OverridePipeline`（已拍板：管理干预使用独立管线，不复用 PresetAwardPipeline）
- [ ] 建表：`preset_inventory_debt`、`preset_budget_debt`（审计增强版）
- [ ] 建表：`preset_debt_limits`（欠账上限配置表）
- [ ] 新增 `lottery_campaigns` 字段：`preset_debt_enabled`、`preset_budget_policy`、`max_budget_debt`、`max_inventory_debt_qty`
- [ ] 新增 `lottery_presets` 字段：`created_by`、`reason`
- [ ] 实现 SettleStage 强制变体（严格遵循决策拍板规则）：
  - [ ] POINTS 不足直接失败（不允许欠账）
  - [ ] 实现三种预算扣减策略（`preset_budget_policy`）：
    - [ ] `follow_campaign`（默认）：严格遵循 budget_mode，不跨源兜底
    - [ ] `pool_first`（默认关闭）：先 pool 后 user，补差额模式
    - [ ] `user_first`（默认关闭）：先 user 后 pool，补差额模式
  - [ ] 欠账前先尝试原子扣减
  - [ ] 检查多维度欠账上限
- [ ] 实现欠账冲销后台功能
- [ ] 实现 `preset_budget_policy` 配置管理界面

### 10.5 Phase 5：审计与监控（建议 1 周）

- [ ] 完善 `DecisionSnapshotStage`
- [ ] 实现欠账看板：
  - [ ] 按活动汇总欠账
  - [ ] 按奖品汇总欠账
  - [ ] 按责任人（created_by）汇总欠账
  - [ ] 欠账趋势图
- [ ] 实现欠账告警：
  - [ ] 接近上限告警
  - [ ] 连续欠账告警
  - [ ] 冲销超时告警
- [ ] 实现成本/库存/档位命中率监控
- [ ] 实现欠账上限配置管理后台

---

## 十一、总结

### 11.1 这套架构解决的核心问题

| 问题                               | 解决方式                                                                        |
| ---------------------------------- | ------------------------------------------------------------------------------- |
| 多种预算模式难统一                 | BudgetProvider 抽象，统一接口                                                   |
| 概率缺口导致分布失真               | 档位优先 + 空档降级 + fallback，不采用归一化                                    |
| 预设发放绕过扣减导致账目失控       | PresetAwardPipeline + 欠账表，强制发放但账目清楚                                |
| pool+quota 双层扣减复杂            | PoolQuotaBudgetProvider 封装，单事务双扣                                        |
| 多种入口（普通/预设/保底）逻辑分散 | 统一收口到 SettleStage，只有一个写入点                                          |
| 决策过程不可追溯                   | DecisionSnapshotStage，每次抽奖可回放                                           |
| **欠账无限累积风险**               | 多维度上限配置（活动/奖品/用户级）+ 运营动态调整                                |
| **欠账追责困难**                   | 每笔欠账强制带 preset_id + created_by + reason                                  |
| **POINTS 被欠账（高风险）**        | 硬规则禁止：POINTS 不足直接失败，不允许欠账                                     |
| **跨预算源兜底导致账目混乱**       | 默认 follow_campaign 不跨源；pool_first/user_first 可选但默认关闭               |
| **高档缺货用户体验差**             | 空档自动降级 high→mid→low，降级尽头再 fallback                                  |
| **降级行为不可审计**               | 决策快照记录原始档位、最终档位、降级次数、降级原因                              |
| **保底/预设/干预优先级混乱**       | 明确优先级：预设 > 干预 > 保底 > 正常；指定结果绕开概率但强制写快照             |
| **tier 规则表结构硬编码**          | 行式 + segment_key 分层，不写死 low/mid/high 三列，扩展档位不改表               |
| **分层规则扩展困难**               | segment_key 支持多维度（预算/渠道/新客/VIP），映射规则独立维护                  |
| **分层规则后台误配/难回滚**        | V1 不做业务库规则表，采用版本化配置（跟代码走），Git 版本即审计，可一键回滚     |
| **分层规则变更难审计**             | SegmentResolver 输出 `segment_key + match_reason`，写入决策快照，线上行为可复现 |

### 11.2 决策拍板要点回顾

| 决策项                              | 拍板结论                                                                                                          |
| ----------------------------------- | ----------------------------------------------------------------------------------------------------------------- |
| 预设语义                            | 方案 B：必须发放 + 尽力扣减 + 记欠账                                                                              |
| 欠账范围                            | 只允许预算欠账（BUDGET_POINTS/pool）+ 库存欠账，**POINTS 不允许欠账**                                             |
| 预算扣减策略                        | 三种策略都要实现：`follow_campaign`（默认）/ `pool_first` / `user_first`                                          |
| follow_campaign 定义                | 严格遵循 budget_mode，不跨预算源兜底                                                                              |
| pool_first / user_first 定义        | 补差额模式：先把第一预算源扣到 0，差额再从第二预算源扣；功能实现但**默认关闭**                                    |
| 欠账上限                            | 运营可动态调整，不允许硬编码                                                                                      |
| 欠账审计                            | 必须带 preset_id + created_by + reason                                                                            |
| **概率缺口处理（0.8）**             | **档位优先（tier_first）+ 空档降级 + fallback 兜底**，不采用归一化                                                |
| **空档降级链路（0.8）**             | **允许降级：high→mid→low→fallback**，固定链路，不可配置                                                           |
| **降级审计（0.8）**                 | 每次降级必须记入决策快照：原始档位、最终档位、降级次数、降级原因                                                  |
| **档位体系定义（0.9）**             | **当前固定 low/mid/high**；未来扩展只允许白名单枚举 + 必须定义降级链路                                            |
| **档位扩展规则（0.9）**             | 新档位需拍板审批 + 更新枚举白名单 + 更新降级链路 + 数据库约束迁移                                                 |
| **reward_tier 必填（0.10）**        | 非兜底奖品必须填写 `reward_tier`，未填/非法 = 阻止上线，返回违规 `prize_id` 列表                                  |
| **兜底奖永远可发（0.10）**          | 兜底奖（`prize_value_points=0`）不得有库存/日限额限制，必须保证任何时候都能发放                                   |
| **tier 权重和=SCALE（0.10→0.16）**  | 所有档位的 `tier_weight` 之和必须**严格等于 SCALE=1,000,000**，否则阻止上线（已更新为整数权重制）                 |
| **档内权重和=SCALE（0.10→0.16）**   | 同一档位内非兜底奖品的 `win_weight` 之和必须**严格等于 SCALE=1,000,000**，否则阻止上线（已更新为整数权重制）      |
| **概率不归一化（0.10）**            | 系统绝不自动调整概率，配置即行为，可审计可复盘                                                                    |
| **漏配=上线失败（0.10）**           | 概率配置问题在 `draft→active` 时拦截；库存/预算导致不可发走运行时 fallback 兜底                                   |
| **允许空档上线（0.10.1）**          | 某档位无 active 奖品**不阻止上线**；但 tier 概率仍必须 sum=1 + 监控必须能看到"降级率/空档率"                      |
| **fallback 自动选择（0.10.2）**     | `fallback_prize_id` 允许为 `null`，自动选取 `prize_value_points=0` 的奖品作为兜底奖                               |
| **保底覆盖 tier_first（0.11）**     | 保底触发时直接指定奖品，不再走档位概率；快照标记 `guarantee_triggered=true`                                       |
| **预设/干预绕开概率（0.11）**       | 预设/管理干预完全绕开 `tier_first`；走"指定结果"管线；**必须写快照防审计断链**                                    |
| **优先级顺序（0.11）**              | 预设 > 干预 > 保底 > 正常抽奖；高优先级命中后不再执行低优先级逻辑                                                 |
| **tier 规则存储方式（0.12）**       | **用 `lottery_tier_rules` 表**，不放 JSON；可查询、可审计、可版本化、可报表统计                                   |
| **决策快照存储方式（0.12）**        | **用独立 `lottery_draw_decisions` 表**，不用 JSON 字段；可检索、可报表、可审计分析                                |
| **tier_rules 表结构（0.13）**       | **A（行式）+ A2（segment_key）**：每行一个 tier，用 segment_key 分层，不硬编码三列                                |
| **segment_key 分层（0.13）**        | 支持多维度分层（预算/渠道/新客/VIP），映射规则放代码或独立配置表，灵活可扩展                                      |
| **default 分层必配（0.13）**        | 每个活动必须有 `segment_key='default'` 的规则组，作为无法匹配其他分层时的兜底                                     |
| **tier_first 档内不归一化（0.14）** | 档位内按原始 `win_weight` 权重抽取，**绝不缩放**；不可发走降级→fallback                                           |
| **体验稳定性保障（0.14）**          | 用"降级链路 + fallback 永远可发 + 监控告警"替代"隐式归一化"，配置即行为                                           |
| **关键字段放列（0.15）**            | `pick_method`/`fallback_prize_id`/`preset_debt_enabled`/`preset_budget_policy`/`budget_mode` 等放列，作为单一真源 |
| **JSON 仅作扩展（0.15）**           | `prize_distribution_config` 只存说明性字段和未来扩展参数，不存关键策略                                            |
| **禁止双真源（0.15）**              | 写入只写列，读取以列为准；同一配置项不允许同时在列和 JSON 中维护                                                  |
| **整数权重制（0.16）**              | **采用整数 weight，SCALE=1,000,000**，tier 和 prize 两层都用 weight，不用小数 probability                         |
| **严格相等校验（0.16）**            | `sum(weight) === SCALE`（严格相等），**禁止引入容差 ε**，不相等则阻止上线                                         |
| **自动补差机制（0.16）**            | 后台保存时自动补差：最后一个权重 = SCALE - 前面合计，补差记入审计字段                                             |
| **segment_key 分层规则（0.17）**    | **V1 不做 `lottery_segment_rules` 业务库规则表**；采用版本化配置（游戏公司模式）；V2 再接入统一人群/实验平台      |
| **配置跟代码走（0.17）**            | 分层规则在 `config/segment_rules.js` 配置文件中定义，随代码版本发布，Git 版本即配置版本                           |
| **发布/回滚流程（0.17）**           | **发布 → 全量 → 可一键回滚**；通过 Git revert 或切换版本号即可回滚                                                |
| **分层审计字段（0.17）**            | 决策快照必须记录：`segment_key`、`segment_version`、`matched_rule_id`、`match_reason`                             |
| **SegmentResolver（0.17）**         | 业务运行时通过 `SegmentResolver` 算出 `segment_key + match_reason`，输出格式固定，V2 可无缝替换                   |

### 11.3 一句话总结

**Pipeline + BudgetProvider + SettleStage + 档位降级链路 + 欠账上限控制 + 审计追责 = 一套架构覆盖所有场景，扩展灵活、强一致、可审计、风险可控。**

---
