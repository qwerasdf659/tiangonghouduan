# 资产全链路追踪与双录记账 — 架构设计方案

> 创建时间：2026-02-22
> 最后验证：2026-02-22（Node.js 连接 Sealos 真实数据库，逐文件审计后端源码）
> 状态：**实施中** — Phase 1-6 后端已完成，Phase 7 前端适配待实施
> 范围：奖品流通追踪 + 账户资产一致性治理（统一方案）
> 权威来源：后端数据库项目（`/home/devbox/project`），前端适配后端字段，不做映射
>
> ### 实施进度（2026-02-22 更新）
>
> | Phase | 内容 | 状态 |
> |---|---|---|
> | Phase 1 | 数据库层（items/item_ledger/item_holds 三表 + 模型 + TrackingCodeGenerator） | ✅ 已完成 |
> | Phase 2 | 服务层核心重写（ItemService 双录 + BidService 修复 + SettleStage lottery_draw_id） | ✅ 已完成 |
> | Phase 3 | API 层（ItemLifecycleService + item-lifecycle/reconciliation 路由） | ✅ 已完成 |
> | Phase 4 | 历史数据迁移脚本（migrate-item-tracking.js，已验证 6776 条物品守恒通过） | ✅ 已完成 |
> | Phase 5 | 资产双录升级（counterpart_account_id 字段 + BalanceService 参数支持） | ✅ 已完成 |
> | Phase 6 | 对账脚本（reconcile-items.js，物品+资产同时对账） | ✅ 已完成 |
> | Phase 7 | Web 管理后台前端适配（item-lifecycle.html + reconciliation.html） | ⏳ 待前端开发 |
> | 小程序 | 微信小程序前端适配（背包字段 + tracking_code 展示） | ⏳ 待前端开发 |

---

## 本方案要解决的问题

系统涉及两类资产：**奖品实例**（优惠券、实物商品）和**可数资产**（积分、钻石、水晶碎片）。两类资产都存在追踪和一致性问题，需要统一治理。

### 奖品模块 — 无法追踪流通

奖品涉及真实成本（甜品、首饰、优惠券），一旦出现多发、丢失、状态错乱，就是直接的经济损失。当前系统无法回答以下问题：

1. **这个奖品从哪来的？** — 抽奖记录和奖品实例之间没有直接关联（真实数据验证：0 条成功关联），无法从一个奖品追溯到它是哪次抽奖产生的。
2. **这个奖品经历了什么？** — 没有统一的全链路查询，要查一个奖品的完整流转历史需要人工跨 5 张表拼接。
3. **系统有没有多发或少发奖品？** — 没有自动对账机制，无法检测物品凭空出现或无故消失。只有等用户投诉才能发现。
4. **这个奖品现在到底在谁手里、是什么状态？** — 两套记录（item_instances 和 item_instance_events）各说各话，状态可能不一致。
5. **客服怎么快速定位一个奖品？** — 奖品只有数据库自增 ID（如 28738），没有人类可读的唯一编码，客服无法通过一个编号查到完整信息。

### 账户模块 — 余额与流水已经不一致

通过连接真实数据库验证（2026-02-22），账户模块的问题**比奖品模块更严重**——不是"设计上有隐患"，而是**已经产生了实际的数据不一致**：

1. **余额与流水对不上** — 跑 `SUM(asset_transactions.delta_amount)` 对比 `account_asset_balances.available_amount + frozen_amount`，有 **14 个账户存在不一致**（不含 POINTS）。例如 account_id=6 的 DIAMOND 余额 345,700，但流水合计只有 110,400，凭空多出 235,300 钻石。account_id=13 的 DIAMOND 余额 245,600 vs 流水 37,000，差额 208,600。
2. **15 个余额记录有值但没有任何流水** — account_id=16,17,175,176 各有 DIAMOND 5000 + red_shard 2000 + red_crystal 200 + orange_shard 500 的 `available_amount`，但 asset_transactions 里一条记录都没有。资产凭空出现。（account_id=176 还额外有一笔 DIAMOND -50 的流水但余额为 4,950，说明曾经有绕过写入后又发生了正常扣减。）
3. **BIGINT 溢出** — asset_transaction_id=36096，account_id=7 有一条 `admin_data_fix` 流水的 delta_amount 为 -9223372036854775807（BIGINT 极限值），导致该账户和 DIAMOND 全局的 SUM 计算溢出，对账完全失效。
4. **全局资产无法验证守恒** — 当前是单式记账（只记每个账户的变动，不记"从哪来/到哪去"），无法用 `SUM(delta)==0` 验证全局守恒。
5. **管理员调账无审批链** — admin_adjustment 流水只有文本 reason，没有审批单号和上级审核记录。

## 目前隐患汇总

### 奖品模块隐患

| 隐患 | 严重程度 | 说明 |
|---|---|---|
| **物品可以绕过追踪被创建** | 高 | `BidService.js:440` 竞价结算直接调用 `this.ItemInstance.create()`，绕过了 `ItemService.mintItem()`，导致竞价获得的物品没有铸造事件记录。当前 bid_products 0 条数据（功能未投产），但代码路径已存在。 |
| **两份"真相"可以互相矛盾** | 高 | `item_instances.status` 和 `item_instance_events` 最后一条事件可以不一致，一旦发生，无法判断哪个是对的 |
| **51.5% 的物品来源不明** | 中 | 3,493 条物品实例的 source='unknown'（总 6,776 条），无法区分是抽奖、兑换还是测试产生的 |
| **锁定状态存在 JSON 里无法查询** | 中 | `item_instances.locks` 是 JSON 数组，当前 287 个物品有活跃锁。不可索引，查"哪些物品的锁已过期"需要全表扫描并在应用层逐条解析 |
| **关键业务数据存在 JSON 里无类型约束** | 中 | 奖品名称、价值、奖品定义ID 都存在 `meta` JSON 字段中，没有类型校验，没有索引，查询和统计都需要 JSON 解析 |
| **没有自动对账机制** | 中 | 系统完全依赖代码逻辑正确来保证数据一致性，没有独立的验证手段 |
| **兑换码到物品的状态同步依赖代码逻辑** | 低 | 兑换码核销时需要同时更新 redemption_orders 和 item_instances，事务中断可能导致状态不同步 |

### 账户模块隐患（2026-02-22 真实数据库验证）

| 隐患 | 严重程度 | 实际数据（2026-02-22 验证） |
|---|---|---|
| **14 个账户余额与流水不一致** | 高 | account_id=6 DIAMOND 余额 345,700 vs 流水 110,400（差额 235,300）；account_id=13 差额 208,600（不含 POINTS 资产） |
| **15 个余额记录有值但无任何流水** | 高 | account_id=16/17/175/176 各有 DIAMOND 5000+red_shard 2000+red_crystal 200+orange_shard 500 的 `available_amount`，asset_transactions 中 0 条 |
| **BIGINT 溢出污染对账** | 高 | tx_id=36096，account_id=7 的 admin_data_fix 流水 delta=-9,223,372,036,854,775,807，DIAMOND 全局 SUM 溢出 |
| **单式记账无法验证全局守恒** | 中 | `asset_transactions` 只记 `account_id` + `delta_amount`，不记对手方。无法用 SUM==0 验证守恒 |
| **管理员调账无审批链** | 中 | admin_adjustment 只有文本 reason 和 admin_id，没有审批单号、审核状态、上级确认 |
| **资产可以绕过 BalanceService 写入** | 中 | 15 个无流水余额证明存在绕过正常流程直接写 `account_asset_balances.available_amount` 的路径 |

### 两个模块的共性根因

| 根因 | 影响 |
|---|---|
| **单式记账** — 只记"谁变了多少"，不记"从谁到谁" | 无法验证全局守恒，无法自动发现异常 |
| **写入路径可绕过** — 不是所有代码都走统一的 Service 层 | 数据可以在没有审计记录的情况下被修改 |
| **没有独立对账机制** — 系统信任自己的代码 100% 正确 | 代码 bug 或人工操作导致的数据异常无法被自动发现 |

---

## 一、业务背景

本项目是一个餐厅积分抽奖系统，核心业务流程：

1. 用户通过拍照上传消费凭证获得**积分**
2. 用积分**抽奖**（转盘），获得**奖品实例**（优惠券 / 实物商品 / 积分等）
3. 奖品实例进入用户**背包**，可以：
   - 直接使用（背包内核销）
   - 生成兑换码（`XXXX-YYYY-ZZZZ` 格式），到店核销
   - 挂到交易市场卖给其他用户

**追踪需求**：需要完整追踪每个奖品从铸造到最终核销/过期的全生命周期，支持客服查询、管理后台审计、自动对账。

---

## 二、技术栈

### 后端数据库项目（权威来源）

- 运行时：Node.js >=20.18.0 + Express 4.18
- ORM：Sequelize 6.35 + MySQL2 3.6
- 数据库：MySQL（Sealos 云数据库，连接池 5~40，时区 +08:00）
- 缓存：Redis（ioredis 5.7）
- 实时通信：Socket.IO 4.8
- 日志：Winston 3.11（结构化日志）
- 认证：JWT（jsonwebtoken 9.0）
- 校验：Joi 17.11
- 安全：Helmet + express-rate-limit + 并发控制中间件
- 部署：Sealos 云平台
- API 版本：**V4**（平级资源导向，`/api/v4/{domain}/{resource}`）
- 架构特征：领域驱动服务组织（96 模型 / 157 路由 / 200+ 服务）、Pipeline 抽奖引擎、统一审计日志、幂等性控制（idempotency_key）
- 系统账户体系：6 个系统账户已就绪（SYSTEM_MINT / BURN / ESCROW / PLATFORM_FEE / RESERVE / CAMPAIGN_POOL）

### Web 管理后台前端

- 框架：Alpine.js 3.15 + Vite 6.4（MPA 多页应用，43 个 HTML 页面）
- 样式：Tailwind CSS 3.4
- 图表：ECharts 6.0
- 实时：socket.io-client 4.8
- API 前缀：`/api/v4`（与后端完全对齐）
- 项目位置：`/admin/` 目录

### 微信小程序前端

- 不在当前工作区（需确认仓库位置）
- 后端已具备小程序支持：WX_APPID 配置、quick-login 接口、CORS 白名单含 `servicewechat.com`

---

## 三、现状分析（基于真实数据库数据）

### 3.1 现有表结构

| 表 | 职责 | 真实数据量（2026-02-22 验证） |
|---|---|---|
| `item_instances` | 物品实例（当前状态） | 6,776 条 |
| `item_instance_events` | 物品事件记录（事件溯源） | 5,375 条 |
| `lottery_draws` | 抽奖记录 | 3,030 条 |
| `lottery_prizes` | 奖品定义（奖品池） | 15 条 |
| `redemption_orders` | 兑换订单 | 1,309 条 |
| `market_listings` | 交易市场挂牌 | 295 条 |
| `trade_orders` | 交易订单 | 134 条 |
| `asset_transactions` | 资产流水（积分/钻石/碎片） | 28,799 条 |
| `accounts` | 账户（用户+系统） | 63 个（6 系统 + 57 用户） |
| `account_asset_balances` | 账户资产余额 | 63 条（字段：`available_amount` + `frozen_amount`） |
| `material_asset_types` | 资产类型定义 | 15 种（3 系统 + 12 材料） |

### 3.2 item_instances 数据分布

| 状态 | 来源 | 数量（2026-02-22 验证） |
|---|---|---|
| available | lottery | 2,899 |
| used | unknown | 1,412 |
| available | unknown | 1,204 |
| locked | unknown | 588 |
| transferred | unknown | 286 |
| transferred | test | 144 |
| used | test | 102 |
| available | test | 99 |
| locked | test | 29 |
| locked | lottery | 7 |
| expired | unknown | 3 |
| used | lottery | 3 |

**关键发现**：`source='unknown'` 的实例占 51.5%（3,493 条），这是早期数据缺乏来源标记的历史债务。另有 287 个物品实例在 `locks` JSON 字段中存有活跃锁定数据。`meta` JSON 中典型键为 `name`、`value`、`description`——这些本应是正式列。

### 3.3 item_instance_events 事件分布

| 事件类型 | 业务类型 | 数量（2026-02-22 验证） |
|---|---|---|
| mint | lottery | 2,992 |
| use | redemption_use | 1,384 |
| transfer | market_transfer | 307 |
| mint | test_* (多种测试类型) | ~460（约占总事件 8.6%） |
| unlock | trade_timeout_release | 5 |
| use | backpack_use | 2 |
| use | admin_redemption_fulfill | 1 |

> **注意**：5,375 条事件中约 460 条为自动化测试产生（`business_type` 含 `test_` 前缀）。迁移时应区分处理：测试数据标记 `source='test'`，不计入对账。

### 3.4 现有架构的 5 个追踪缺口

| 编号 | 缺口 | 影响 |
|---|---|---|
| G1 | 没有人类可读唯一编码（tracking_code） | 客服无法用编码查物品，用户看不到"身份证号" |
| G2 | `lottery_draws` → `item_instances` 断链 | 无法从抽奖记录追到具体哪个物品实例。已确认：`SettleStage.js:607-623` 调用 `ItemService.mintItem` 时 `source_id` 使用 `idempotency_key` 格式（如 `lottery_xxx:item`），`meta` 中仅有 `lottery_prize_id`（奖品定义ID），**缺少 `lottery_draw_id`**（具体抽奖记录ID）。真实数据验证 0 条可直接关联。 |
| G3 | `BidService` 竞价结算没写 event | 已确认：`BidService.js:440` 直接调用 `this.ItemInstance.create()` 绕过 `ItemService.mintItem()`，无 mint 事件记录。当前 `bid_products` 表 0 条数据（功能未投产），但代码路径已存在。 |
| G4 | 历史数据 source=unknown 占 51.5% | 3,493 条物品来源不明（总 6,776 条） |
| G5 | 没有统一的全链路查询接口 | 无法一次性看到完整流转轨迹 |
| G6 | `item_instances` 和 `item_instance_events` 双真相 | 两份记录可能不一致，需要人工比对排查 |
| G7 | `locks` 用 JSON 存储 | 当前 287 个物品有活跃锁，不可索引、不可查询、过期清理依赖应用层代码 |

---

## 四、行业方案调研

### 4.0 行业里"物品"和"资产"是一起管还是分开管？

不同公司的做法取决于一个核心判断：物品和货币是否在同一个经济系统里流通。行业实践分为四个阵营。

#### 第一阵营：金融级 — 统一双录（支付宝、券商）

支付宝账务系统分内外两套账：外账（单式）记原始流水用于对账，内账（复式/双录）严格借贷平衡用于审计。交易和账务分离——支付成功后同步写外账（快），异步通知内账做复式记账（准）。日终子系统做试算平衡，借贷不平当天发现。**所有有财务价值的东西（余额、红包、优惠券补贴）都进内账做复式记账。**

券商更极端——CQRS + 事件溯源是行业标准。成交回报是不可变事件，形成单一事实来源。资金和证券（股票/基金）**在同一套清算体系里统一对账**。因为一笔交易同时涉及资金变动和持仓变动，必须两边同时平。

#### 第二阵营：平台级 — 分开但统一对账（美团、抖音）

美团：卡券系统和资金系统分开，但在对账层统一。卡券本身不用复式（因为券不在用户间交易），涉及补贴结算的部分进资金系统的复式账。

字节跳动/抖音：钱包团队分活动钱包API层（展示）和资产订单层（入账）。10余种虚拟奖励（现金红包、dou+券、电商券等）走同一套资产订单系统入账。订单号设计保证幂等，actID 实现八端互通。

#### 第三阵营：游戏级 — 统一经济系统（腾讯游戏、Steam、Roblox）

游戏里天然就是物品和货币统一管理——金币/钻石（可数资产）和装备/道具（不可数资产）在同一个背包/仓库系统里，所有变动走同一套事件日志。

Roblox 的经济分析明确要求追踪 Sources（资产从哪来）和 Sinks（资产到哪去），不区分是 Robux（货币）还是道具（物品）。Steam 用 classid + contextid + assetid 三层标识统一追踪所有物品。

#### 第四阵营：小公司 — 各管各的

积分系统一个表，物品系统一个表，互不关联。没有流水、没有事件、没有对账。出问题靠人工排查。

#### 各阵营对比

| 维度 | 金融级 | 平台级 | 游戏级 | 小公司 |
|---|---|---|---|---|
| 代表 | 支付宝、券商 | 美团、抖音 | 腾讯游戏、Steam、Roblox | 创业项目 |
| 物品和资产统一？ | 统一（同一套清算） | 分开但有统一对账层 | 统一（同一个经济系统） | 各管各的 |
| 记账方式 | 复式（借贷平衡） | 资金复式，卡券单式 | 事件溯源（Source/Sink） | 无或简单单式 |
| 对账 | 日终试算平衡 | 统一对账层 | Source/Sink 平衡检查 | 无 |
| 异常发现 | 自动（当天） | 半自动 | 取决于实现 | 被动（等投诉） |

#### 本项目的定位

本项目同时存在可数资产（积分、钻石、12种水晶碎片）和不可数资产（奖品实例），且有用户间交易市场——一笔交易同时涉及"买家钻石减少 + 卖家钻石增加 + 平台收手续费 + 物品从卖家转到买家"四件事。如果物品和钻石分开对账，就无法回答"买家付了钱但没收到物品"的问题。

**结论：三个阵营不是互斥的——金融级描述的是记账方法，游戏级描述的是治理范围。本方案两个都取了：采用金融级的记账原理（双录记账、守恒验证、系统账户作为资产来源和去处），在游戏级的统一经济系统范围上应用（物品和货币在同一套对账体系），用适合本项目规模的技术实现（单机 MySQL + 同步写入，不需要支付宝的分布式异步架构）。这就是本文档第七章（奖品三表模型）和第十章（统一治理方案）的设计依据。**

---

### 4.1 五种主流方案对比

#### 方案 A：简单 CRUD + 状态字段

**代表**：绝大多数初创公司、外包项目、MVP 阶段产品

物品就是一条记录，直接改 status 字段。追踪能力为零——只知道"当前状态"，不知道"怎么到这个状态的"。

- 适合场景：一次性活动、不需要追踪、不需要交易
- 长期维护成本：极高（出问题无法溯源）

#### 方案 B：状态机 + 独立审计日志表

**代表**：美团券核销、拼多多优惠券

物品表维护当前状态（状态机严格控制转换），独立的 audit_log 表记录操作。物品有批次编号 + 唯一券码。

美团关键设计：
- 每张券有唯一券码
- MeiLink 履约框架做全链路节点追踪
- MQ 消息异步同步状态，1 秒内实时同步

追踪能力中等，但审计日志和物品状态是两套数据，可能不一致。

- 适合场景：优惠券/卡券，单向流通（发放→使用），不涉及用户间交易
- 长期维护成本：中等（审计日志和实际状态可能漂移）

#### 方案 C：事件溯源（Event Sourcing）

**代表**：腾讯游戏道具系统、Steam Marketplace、暴雪 WoW 背包系统

事件是唯一真相，物品的当前状态是所有事件的聚合结果。所有变更作为不可变事件追加写入。

腾讯游戏关键设计：
- 每个道具实例有全局唯一 Key
- 六种状态（free/loading/normal/modify/remove/tick_remove）
- 共享内存阵列 + KV 存储双层架构

Steam Marketplace 关键设计：
- 每个物品有 classid + contextid + assetid 三层标识
- 完全中心化控制（不用区块链）
- 完整交易历史可追溯

- 适合场景：有用户间交易的虚拟物品系统
- 长期维护成本：低（事件不可变，天然防腐）

#### 方案 D：双录记账 + 事件溯源

**代表**：支付宝资金流水、蚂蚁链、阿里巴巴内部资产系统

在事件溯源基础上增加复式记账（double-entry bookkeeping）。每次流转同时记录"出方"和"入方"两笔记录，数学上可证明一致性。

闲鱼关键设计：
- 统一追踪协议（SPM 标准化）
- 多层级对账体系：实时对账 + 小时离线对账 + 安全校验
- 分层日志：普通用户只记关键节点，测试用户记全量

- 适合场景：涉及真实成本的资产系统、需要合规审计的场景
- 长期维护成本：最低（一旦建成，自动发现问题而不是等客诉）

#### 方案 E：NFT 式链上存证

**代表**：Axie Infinity、NBA Top Shot

每个物品是链上 Token，所有权转移通过链上交易完成。理论追踪最强，但 Gas 费、链维护、链下数据同步都是持续成本。

- 适合场景：需要跨平台互通的虚拟资产
- 长期维护成本：高

### 4.2 五种方案核心差异矩阵

| 维度 | A. CRUD | B. 状态机+审计 | C. 事件溯源 | D. 双录+事件 | E. NFT链上 |
|---|---|---|---|---|---|
| 代表 | 小创业公司 | 美团/拼多多 | 腾讯游戏/Steam | 支付宝/闲鱼 | Axie/链游 |
| 追踪能力 | 无 | 中 | 完整 | 最完整 | 理论最强 |
| 真相来源 | 当前状态 | 当前状态+日志 | 事件流 | 事件+账本 | 链上 |
| 一致性保证 | 无 | 弱 | 强 | 数学可证明 | 共识机制 |
| 前期成本 | 最低 | 低 | 中 | 高 | 最高 |
| 长期维护 | 最高 | 中 | 低 | 最低 | 高 |
| 适合交易 | 不适合 | 不适合 | 适合 | 非常适合 | 适合 |
| 回溯能力 | 无法回溯 | 部分回溯 | 完全回溯 | 完全回溯 | 完全回溯 |

### 4.3 详细行业案例库（按行业分类）

#### 4.3.1 银行 / 券商 / 投行 — 复式记账的发源地

**全球所有银行**：复式记账（Double-entry bookkeeping）是 15 世纪意大利发明的，至今全球所有银行、所有会计体系都在用。核心规则只有一条：每笔交易同时记两方（借方 + 贷方），SUM 永远为 0。这不是"高级方案"，而是金融业的最低标准。

**证券交易所（上交所/深交所/NYSE/NASDAQ）**：交易生命周期分 4 步——Order（下单）→ Match（撮合）→ Clear（清算）→ Settle（交收）。每一步都是不可变事件，全链路可追溯。资金和证券在同一套清算体系里，一笔交易同时动资金账户和持仓账户。

**投行/券商（高盛、中信证券等）**：CQRS + 事件溯源是行业标准。成交回报是不可变事件流，形成单一事实来源。读模型和写模型分离。日终清算自动试算平衡。

| 特征 | 本项目可借鉴 |
|---|---|
| 复式记账 SUM=0 | ✅ item_ledger 和 asset_transactions 双录 |
| 不可变事件流 | ✅ item_ledger 只追加不修改 |
| 系统账户作为来源/去处 | ✅ SYSTEM_MINT / SYSTEM_BURN 已有 |
| 日终对账 | ✅ reconcile 脚本每小时跑 |

#### 4.3.2 超大支付平台 — 支付宝 / 微信支付

**支付宝（蚂蚁集团）**：分内外两套账。外账（单式）记原始流水用于快速查询，内账（复式/双录）严格借贷平衡用于审计。交易和账务分离——支付成功后同步写外账（快），异步通知内账做复式记账（准）。日终子系统做试算平衡，借贷不平当天发现。**所有有财务价值的东西（余额、红包、优惠券补贴）都进内账做复式记账。**

**微信支付**：架构类似支付宝。资金账户体系 + 营销账户体系。优惠券/红包走营销账户，但结算时进入资金账户的复式体系。

| 特征 | 本项目可借鉴 |
|---|---|
| 内外账分离 | ✅ items（外/缓存）+ item_ledger（内/真相）对应这个思路 |
| 所有有价值的东西都进账本 | ✅ 奖品（有成本）和钻石/碎片（有交易价值）都进双录 |
| 支付宝需要分布式异步写入 | ❌ 本项目不需要，单机 MySQL 同步事务即可 |

#### 4.3.3 大型电商 / O2O 平台

**美团（券核销系统）**：每张券有唯一券码。MeiLink 履约框架做全链路节点追踪。MQ 消息异步同步状态（1 秒内实时同步）。卡券系统和资金系统分开，但在对账层统一——涉及补贴结算的部分进资金系统的复式账。

**字节跳动 / 抖音（活动奖励系统）**：钱包团队分活动钱包 API 层（展示）和资产订单层（入账）。10 余种虚拟奖励（现金红包、dou+ 券、电商券等）走同一套资产订单系统入账。订单号设计保证幂等，actID 实现八端互通。

**百度（百度活动/好看视频奖励）**：类似字节的资产订单模式。积分、红包、优惠券统一走订单系统。大量业务方接入同一套底层。

**拼多多（优惠券/红包）**：相对简化。优惠券单向流通（发放→使用），不涉及用户间交易。状态机 + 审计日志足够。但百亿补贴的金额核对走了更严格的对账。

| 特征 | 本项目可借鉴 |
|---|---|
| 美团唯一券码 | ✅ 对应 tracking_code |
| 字节统一资产订单 | ✅ 对应 item_ledger 统一所有物品变动 |
| 美团 MQ 异步 | ❌ 本项目规模不需要 MQ |
| 拼多多单向流通 | ❌ 本项目有用户间交易，不能用简化版 |

#### 4.3.4 游戏公司 — 虚拟经济系统

**腾讯游戏（道具系统）**：每个道具实例有全局唯一 Key。六种状态（free/loading/normal/modify/remove/tick_remove）。共享内存阵列 + KV 存储双层架构。所有变动走同一套事件日志。

**Steam / Valve（Steam Marketplace）**：每个物品有 classid + contextid + assetid 三层标识。完全中心化控制（不用区块链）。完整交易历史可追溯。市场挂牌有价格历史。Trade Offer 系统支持用户间直接交易。

**暴雪（魔兽世界/暗黑破坏神）**：背包/仓库是事件溯源的。每个装备有全球唯一 ID + 持久属性。拍卖行有完整审计日志。GM 工具可以从服务器日志回溯任意物品的完整历史。

**米哈游（原神/崩坏系列）**：Gacha（抽卡）系统事件溯源——每次祈愿都是不可变记录。有保底计数器（pity counter）。但原神没有用户间交易，所以不需要转移追踪。

**Roblox**：明确要求追踪 Sources（资产从哪来）和 Sinks（资产到哪去），不区分是 Robux（货币）还是道具（物品）。开发者有经济分析仪表板。支持 DevEx 兑换真实货币。

| 特征 | 本项目可借鉴 |
|---|---|
| 全局唯一标识 | ✅ tracking_code |
| 完整交易历史 | ✅ item_ledger 记录全部转移 |
| Source/Sink 追踪 | ✅ 对应 SYSTEM_MINT（Source）和 SYSTEM_BURN（Sink） |
| 游戏里货币和道具统一管理 | ✅ 本项目钻石/碎片 + 奖品实例统一对账 |
| Steam 三层标识 | 部分采用：tracking_code + item_id 双标识 |
| 暴雪 GM 回溯工具 | ✅ 对应 lifecycle 全链路查询接口 |

#### 4.3.5 虚拟物品交易 / 二手平台

**Steam 社区市场**：全交易历史可查。价格走势图。物品浮动值（Float Value）持久不变。交易有 15 天冷却期（风控）。所有操作走中心化服务器，非区块链。

**闲鱼（阿里二手）**：SPM 标准化追踪协议。多层级对账：实时对账 + 小时离线对账 + 安全校验。分层日志——普通用户只记关键节点，测试用户记全量。与支付宝打通做资金对账。

**转转 / 爱回收**：订单级追踪，比闲鱼简化。状态机管理交易流程。没有闲鱼的多层对账体系。

| 特征 | 本项目可借鉴 |
|---|---|
| 闲鱼多层对账 | ✅ reconcile 脚本覆盖物品 + 资产 |
| Steam 冷却期 | ✅ 对应 item_holds 锁定机制 |
| 闲鱼 SPM 追踪 | ✅ 对应 tracking_code + business_type 组合 |

#### 4.3.6 活动营销 / 优惠券平台（中小规模）

**典型做法**：用第三方券平台或自建简单系统。积分一张表，券一张表，互不关联。发放和核销走 CRUD。月底 CSV 导出对账。

**问题**：出了错只能手动查 SQL。多发少发靠用户投诉才发现。这就是**当前项目 item_instances 的现状**。

#### 4.3.7 小公司 / 创业项目

积分系统一个表，物品系统一个表。没有流水、没有事件、没有对账。出问题靠人工排查数据库。长期维护成本最高——看似省了前期投入，实际上每次出问题都要几个小时手动排查。

**这就是本项目目前的状态**：item_instances 的 source=unknown 占 51.5%（3,493/6,776），14 个账户余额与流水不一致（不含 POINTS），15 个余额记录凭空有值但无任何流水。

### 4.4 各行业方案与本项目特征的匹配度

本项目同时具备以下特征，决定了它不能用"小公司模式"：

| 本项目特征 | 要求的能力 | 对应行业 |
|---|---|---|
| 奖品有真实成本（甜品、首饰） | 需要财务级追踪，不能多发少发 | 银行 / 支付宝 |
| 有用户间交易市场 | 需要转移追踪 + 所有权证明 | Steam / 腾讯游戏 |
| 多种资产类型（积分、钻石、12 种碎片 + 物品实例） | 需要统一经济系统 | Roblox / 游戏公司 |
| 一笔交易涉及多方（买方钻石、卖方钻石、平台手续费、物品转移） | 需要多方账本配平 | 银行 / 支付宝 |
| 需要客服快速定位问题 | 需要唯一编码 + 全链路查询 | 美团 MeiLink / 暴雪 GM 工具 |
| 项目规模小（66 用户、7K 物品） | 不需要分布式/MQ/异步 | 单机 MySQL 足够 |

### 4.5 结论：本项目应该学谁

**记账原理学银行/支付宝**（双录记账、SUM=0 验证、系统账户作为 Source/Sink）

**治理范围学游戏公司**（物品和货币在同一套经济系统里统一追踪，不分开管）

**追踪标识学美团/Steam**（唯一编码 + 全链路查询 + 交易历史）

**技术实现用创业级**（单机 MySQL + Sequelize 同步事务，不需要支付宝的分布式异步，不需要腾讯的共享内存阵列）

这就是"从零三表模型 + 双录升级 + 共享对账"方案的设计依据：**用最小的技术栈实现金融级的正确性保证**。

---

## 五、方案 C vs 方案 D 深度对比

### 5.1 本质区别

方案 C 记录了"发生过什么"；方案 D 在此基础上还能**数学证明系统没有漏洞**。

D 比 C 多一条规则：任何物品流转必须同时产生"出方记录"和"入方记录"，且两者永远配平。

### 5.2 用实际业务场景说明

**场景：用户 A 在交易市场把奖品卖给用户 B**

方案 C 的记录：
```
item_instance_events:
  1条：transfer | owner_before=A, owner_after=B
```
如果有物品凭空出现（没有 transfer 事件），只能人工逐条排查。

方案 D 的记录：
```
item_ledger:
  1条：A 的账户 delta=-1（出方）
  1条：B 的账户 delta=+1（入方）
```
如果有物品凭空出现，`SUM(delta) != 0`，一条 SQL 立刻发现。

### 5.3 方案 D 能保护的具体风险

| 风险场景 | C 能发现吗 | D 能发现吗 |
|---|---|---|
| 代码 bug 导致物品凭空创建 | 很难，要人工比对 | 一条 SQL |
| 交易完成但物品没转移 | 要关联多表排查 | 账本不平即报警 |
| 兑换码核销了但物品状态没变 | 要对比多表 | 账本不平即报警 |
| 管理员误操作发了重复物品 | 事后审计 | 实时发现 |

### 5.4 选择结论

本项目的奖品包含实物商品（甜品、首饰）和优惠券，有真实成本。存在交易市场，用户间可以交易。项目未上线，可以一次性投入。**选择方案 D**。

---

## 六、方案 D 增强版（在现有基础上加装 — 已否决，不采用）

### 6.1 设计思路

在现有事件溯源架构（item_instances + item_instance_events）基础上，新增：
- item_ledger 双录记账表
- tracking_code 人类可读编码
- source_ref_id 来源关联字段

### 6.2 改动范围

| 类型 | 文件 | 说明 |
|---|---|---|
| 修改 | models/ItemInstance.js | 新增 tracking_code、source_ref_id 字段 |
| 修改 | services/asset/ItemService.js | mintItem/transferItem/consumeItem 写 item_ledger |
| 修改 | services/exchange/BidService.js | settleBidProduct 改用 ItemService.mintItem |
| 修改 | SettleStage.js | 传入 lottery_draw_id |
| 新增 | models/ItemLedger.js | 双录记账模型 |
| 新增 | utils/TrackingCodeGenerator.js | 追踪码生成器 |
| 新增 | services/ItemLifecycleService.js | 全链路查询服务 |
| 新增 | routes/admin/itemLifecycle.js | 管理后台路由 |
| 新增 | scripts/reconcile-item-ledger.js | 对账脚本 |
| 新增 | scripts/migrate-item-tracking.js | 历史数据迁移 |
| 新增 | migrations/2026XXXX-xxx.js | 数据库迁移 |

### 6.3 优点

- 改动量可控（改 4 文件，新增 7 文件）
- 不破坏现有接口
- 有对账兜底机制

### 6.4 缺点（已确认不可接受，因此否决此方案）

- item_instances 和 item_instance_events 仍然是"双真相"，漂移风险依然存在
- JSON locks 机制保留，维护成本不变
- meta JSON 里的关键数据（name/value/prize_id）仍然不是正式列

> **项目负责人决定**：不采用此方案。不复用旧表旧功能，采用第七章从零三表模型。

---

## 七、从零三表模型（推倒重来方案 — 已确认采用）

### 7.1 核心设计哲学

> **只有一份真相，其他全是缓存。缓存错了可以重建，真相不会出错。**

当前架构的维护成本高，根源是同一件事记了多份且它们可以不一致。从零设计的目标是消灭这种可能性。

> **已确认**：不复用旧表 `item_instances` / `item_instance_events` 的结构和功能，全部从零新建。

### 7.1.1 为什么新表叫 `items` 而不是沿用 `item_instances`？

**这不是"改回去"，而是因为两套表代表完全不同的设计哲学。**

旧设计中 `item_instances` 名字里的 "Instance" 表示它是 `item_templates`（模板）的一个实例——自己不是完整实体，名字、价值、描述都存在 meta JSON 里，概念上依附于模板存在。

实际运行中这个假设已经不成立：

| 实际情况 | 说明 |
|---|---|
| 大量物品没有模板 | `item_template_id` 为 NULL 的物品很多（竞价结算物品、测试物品） |
| 关键属性不从模板继承 | 名字、价值、描述存在 meta JSON 里，并非真正从 template 查出来的 |
| Instance 语义多余 | 业务上只关心"这个物品"，不关心"它是哪个模板的第几个实例" |

新设计中 `items` 是一个**独立的一等实体**：

| items（新） vs item_instances（旧） |
|---|
| 自己有正式列 `item_name`、`item_value`、`item_type` — 不依赖 meta JSON |
| 自己有唯一身份 `tracking_code` — 人类可读，不只是自增 ID |
| 自己的生命周期由 `item_ledger` 追踪 — 不依赖另一张 events 表 |
| 与奖品定义的关系通过 `prize_definition_id` 外键建立 — 不是"实例化"关系，而是"来源于"关系 |
| `item_templates` 表仍然存在，管商品展示 — 但 items 不再从属于它 |

**命名对照**：

| 旧命名 | 新命名 | 变化原因 |
|---|---|---|
| `item_instances` | `items` | 不再是模板的附属品，是独立实体 |
| `item_instance_events` | `item_ledger` | 不只是事件日志，是双录账本（唯一真相） |
| `item_instances.locks` (JSON) | `item_holds` (独立表) | 从不可索引的 JSON 升级为可查询的关系表 |
| `ItemInstance` (Model) | `Item` (Model) | 代码层面对应新表 |
| `ItemInstanceEvent` (Model) | `ItemLedger` (Model) | 代码层面对应新表 |

### 7.2 架构总览

```
真相层（不可变，只追加）          缓存层（可重建）
┌─────────────────────┐        ┌──────────────┐
│  item_ledger        │───────>│  items       │
│  （所有权账本）       │        │  （当前状态） │
│  谁拥有什么          │        │              │
├─────────────────────┤        │              │
│  item_holds         │───────>│              │
│  （锁定记录）        │        │              │
│  什么被冻住了        │        └──────────────┘
└─────────────────────┘
```

| 表 | 角色 | 可变性 |
|---|---|---|
| **item_ledger** | 唯一的所有权真相，双录记账，同时也是审计日志 | 只追加，不修改，不删除 |
| **item_holds** | 唯一的锁定状态真相，替代 JSON locks | 有状态变更（active→released/expired） |
| **items** | 当前状态的缓存/快照，方便查询 | 可以随时从 ledger + holds 重建 |

### 7.3 表结构

#### 表1：items（当前状态缓存）

```sql
CREATE TABLE items (
  item_id              BIGINT AUTO_INCREMENT PRIMARY KEY,
  tracking_code        VARCHAR(20) NOT NULL UNIQUE,
  owner_account_id     BIGINT NOT NULL,              -- 当前持有者（从 ledger 派生）
  status               ENUM('available','held','used','expired','destroyed') NOT NULL,

  -- 物品信息（正式列，不用 JSON）
  item_type            VARCHAR(50) NOT NULL,          -- voucher/product/service
  item_name            VARCHAR(200) NOT NULL,
  item_description     TEXT,
  item_value           INT DEFAULT 0,                 -- 价值（积分计）
  prize_definition_id  INT NULL,                      -- 来自哪个奖品定义
  rarity_code          VARCHAR(50) DEFAULT 'common',

  -- 来源追踪
  source               VARCHAR(20) NOT NULL,          -- lottery/bid/exchange/admin
  source_ref_id        VARCHAR(100) NULL,             -- lottery_draw_id / bid_product_id

  created_at           DATETIME NOT NULL,
  updated_at           DATETIME NOT NULL,

  INDEX idx_items_owner (owner_account_id),
  INDEX idx_items_status (status),
  INDEX idx_items_source_ref (source_ref_id),
  INDEX idx_items_type (item_type)
);
```

与现有 item_instances 的关键区别：
- **没有 meta JSON** — 所有重要字段都是正式列
- **没有 locks JSON** — 锁定状态由 item_holds 表管理
- **status 只有 5 个值** — `held` 替代了 locked + transferred
- **owner_account_id** 用 account_id 统一了用户和系统账户

#### 表2：item_ledger（所有权账本 — 唯一真相）

```sql
CREATE TABLE item_ledger (
  ledger_entry_id      BIGINT AUTO_INCREMENT PRIMARY KEY,
  item_id              BIGINT NOT NULL,
  account_id           BIGINT NOT NULL,               -- 当前方
  delta                TINYINT NOT NULL,               -- +1 入账 / -1 出账
  counterpart_id       BIGINT NOT NULL,               -- 对手方
  event_type           VARCHAR(50) NOT NULL,           -- mint/transfer/use/expire/destroy
  operator_id          BIGINT NULL,                    -- 操作者
  operator_type        ENUM('user','admin','system') NOT NULL DEFAULT 'system',
  business_type        VARCHAR(50) NOT NULL,
  idempotency_key      VARCHAR(100) NOT NULL,
  meta                 JSON NULL,                      -- 仅存真正动态的扩展信息
  created_at           DATETIME NOT NULL,
  -- 无 updated_at（不可变）

  UNIQUE KEY uk_item_idempotency (item_id, idempotency_key),
  INDEX idx_ledger_item_time (item_id, created_at),
  INDEX idx_ledger_account_time (account_id, created_at),
  INDEX idx_ledger_event_type (event_type, created_at),
  INDEX idx_ledger_business (business_type, created_at)
);
```

这张表同时充当三个角色：
1. 双录记账本（SUM(delta) 可数学验证守恒）
2. 审计日志（谁在什么时间做了什么）
3. 事件溯源（完整的物品流转历史）

每次操作写两条记录：

| 操作 | 第1条（出方 delta=-1） | 第2条（入方 delta=+1） |
|---|---|---|
| 铸造 | SYSTEM_MINT | 用户账户 |
| 交易转移 | 卖方账户 | 买方账户 |
| 核销使用 | 用户账户 | SYSTEM_BURN |
| 过期 | 用户账户 | SYSTEM_BURN |
| 销毁 | 用户账户 | SYSTEM_BURN |

#### 表3：item_holds（锁定/保留记录）

```sql
CREATE TABLE item_holds (
  hold_id              BIGINT AUTO_INCREMENT PRIMARY KEY,
  item_id              BIGINT NOT NULL,
  hold_type            ENUM('trade','redemption','security') NOT NULL,
  holder_ref           VARCHAR(100) NOT NULL,          -- 订单ID / 兑换码ID / 风控案件ID
  priority             TINYINT NOT NULL DEFAULT 1,     -- trade=1, redemption=2, security=3
  status               ENUM('active','released','expired','overridden') NOT NULL DEFAULT 'active',
  reason               VARCHAR(200),
  expires_at           DATETIME NULL,                  -- NULL=永不过期（security）
  created_at           DATETIME NOT NULL,
  released_at          DATETIME NULL,

  INDEX idx_holds_item (item_id, status),
  INDEX idx_holds_active_expiry (status, expires_at),
  INDEX idx_holds_holder (holder_ref)
);
```

与 JSON locks 的关键区别：
- **可索引** — "所有过期的 hold" 只需 `WHERE status='active' AND expires_at < NOW()`
- **可查询** — "这个订单锁了哪些物品" 一条 SQL
- **有历史** — released/expired 的记录保留，是锁定/解锁的完整审计
- **无 JSON 解析** — 不需要在应用层解析判断锁状态

### 7.4 核心不变式（对账 SQL）

```sql
-- 物品守恒：对任意单个物品，所有 delta 之和必须 == 0
SELECT item_id, SUM(delta) AS balance
FROM item_ledger
GROUP BY item_id
HAVING balance != 0;
-- 结果必须为空集，否则系统有 bug

-- 当前持有者：对任意单个物品，delta 之和为 1 的账户就是当前持有者
SELECT account_id
FROM item_ledger
WHERE item_id = ?
GROUP BY account_id
HAVING SUM(delta) = 1;
```

### 7.5 业务操作执行流程

#### 抽奖获得奖品

```
1. items INSERT（status=available, owner=用户账户, source=lottery, source_ref_id=draw_xxx）
2. item_ledger 写两条（SYSTEM_MINT -1, 用户 +1）
3. 结束
```

#### 挂到交易市场

```
1. item_holds INSERT（hold_type=trade, holder_ref=listing_id, status=active）
2. items UPDATE status='held'
3. 结束（ledger 不写，所有权没变）
```

#### 买家购买成交

```
1. item_holds UPDATE status='released'
2. item_ledger 写两条（卖方 -1, 买方 +1）
3. items UPDATE owner=买方, status='available'
```

#### 生成兑换码

```
1. item_holds INSERT（hold_type=redemption, holder_ref=order_id, expires_at=30天后）
2. items UPDATE status='held'
3. redemption_orders INSERT
```

#### 到店核销

```
1. item_holds UPDATE status='released'
2. item_ledger 写两条（用户 -1, SYSTEM_BURN +1）
3. items UPDATE status='used'
4. redemption_orders UPDATE status='fulfilled'
```

#### 自动过期清理

```
1. 查 item_holds WHERE status='active' AND expires_at < NOW()
2. 批量 UPDATE status='expired'
3. items UPDATE status='available'（锁释放，物品回到可用）
```

### 7.6 tracking_code 编码规则

格式：`{来源2位}{YYMMDD}{item_id补零到6位}`

| 来源 | 前缀 |
|---|---|
| lottery | LT |
| bid_settlement | BD |
| exchange | EX |
| admin | AD |
| unknown/legacy | LG |

示例：`LT260219028738` = 抽奖来源，2026年2月19日，第 28738 号物品

### 7.7 全链路追踪查询

```
GET /api/v4/console/items/:identifier/lifecycle
  identifier 支持 tracking_code 或 item_id（遵循后端 V4 路由体系）
```

响应结构：
```json
{
  "tracking_code": "LT260219028738",
  "item": {
    "name": "甜品1份",
    "type": "product",
    "rarity": "uncommon",
    "status": "used",
    "owner": "用户31"
  },
  "origin": {
    "source": "lottery",
    "lottery_draw_id": "draw_xxx",
    "campaign_name": "春节活动",
    "won_at": "2026-02-19 04:26:27"
  },
  "timeline": [
    { "time": "2026-02-19 04:26:27", "event": "mint", "detail": "抽奖铸造 → 用户31" },
    { "time": "2026-02-20 11:50:51", "event": "hold", "detail": "生成兑换码，锁定30天" },
    { "time": "2026-02-20 12:40:12", "event": "use", "detail": "到店核销，管理员31操作" }
  ],
  "ledger_check": {
    "sum_delta": 0,
    "status": "balanced"
  }
}
```

数据来源全部基于现有表 JOIN：items + item_ledger + item_holds + redemption_orders + market_listings + trade_orders + lottery_draws。

---

## 八、两种实施路径对比

### 8.1 路径 A：方案 D 增强版（在现有基础上加装） — 已否决

| 维度 | 说明 |
|---|---|
| 改动量 | 改 4 个现有文件 + 新增 7 个文件 |
| 风险 | 低（不动现有结构） |
| 维护成本 | 中低（双真相仍存在，但有对账兜底） |
| 遗留问题 | JSON locks 保留、meta JSON 保留、events 和 instances 仍可能不一致 |
| **否决原因** | **不复用旧表旧功能。旧表结构性缺陷无法修补，加装只会增加第三套真相。** |

### 8.2 路径 B：从零三表模型 — ✅ 已确认采用

| 维度 | 说明 |
|---|---|
| 改动量 | ItemService 重写 + 新建 Item Model（替代 ItemInstance）+ 新建 holds 和 ledger |
| 风险 | 中（改动面更大，但项目未上线） |
| 维护成本 | **最低**（单一真相，自验证，无 JSON 结构化债务） |
| 消除的问题 | 双真相漂移、JSON locks、meta JSON 散乱、BidService 绕过 |

### 8.3 对比矩阵

| 维度 | 路径 A（加装） | 路径 B（重来） |
|---|---|---|
| 真相来源 | instances + events + ledger（三套） | ledger 是唯一真相，items 是缓存 |
| 锁定机制 | JSON 数组，应用层解析 | 独立表，SQL 可查询 |
| 关键数据 | meta JSON 存 name/value/prize_id | 正式列，可索引有类型 |
| 记账 | events（单式）+ ledger（双式）= 两套 | 只有 ledger 一套，兼任事件日志 |
| 绕过风险 | BidService 可能绕过 | ledger 没记录 = 物品不存在 |
| 对账 | 需比对 events 和 instances | `SUM(delta) == 0` 一条 SQL |

### 8.4 消灭的长期维护项（路径 B 独有）

| 消灭的维护项 | 原因 |
|---|---|
| events 和 instances 状态不一致排查 | 不存在了，items 可从 ledger 重建 |
| JSON locks 过期清理逻辑 | holds 表有 expires_at 列，一条 SQL |
| JSON locks 优先级覆盖逻辑 | holds 表有 priority 列，SQL 排序 |
| BidService 绕过 ItemService 的 bug | 不写 ledger = 物品不存在 |
| meta JSON 字段的类型安全问题 | 关键字段都是正式列 |
| 两套记录一致性对账 | 只有一套记录 |
| status_before/after 和实际状态不一致 | 不存储 before/after，状态从 ledger 派生 |

---

## 九、账户模块现状分析（基于真实数据库数据）

### 9.1 账户体系结构

系统用一张 `accounts` 表管理用户账户和系统账户：

| account_id | account_type | system_code | 说明 |
|---|---|---|---|
| 1 | system | SYSTEM_PLATFORM_FEE | 平台手续费账户（交易抽佣） |
| 2 | system | SYSTEM_MINT | 铸造账户（系统发放资产来源） |
| 3 | system | SYSTEM_BURN | 销毁账户（资产核销/消耗去处） |
| 4 | system | SYSTEM_ESCROW | 托管账户（争议/退款，预留） |
| 12 | system | SYSTEM_RESERVE | 储备账户 |
| 15 | system | SYSTEM_CAMPAIGN_POOL | 活动池账户（抽奖活动预算） |
| 5~... | user | NULL | 普通用户账户（57个） |

### 9.2 资产编码体系

三层结构：资产分组（asset_group_defs）→ 资产类型（material_asset_types）→ 用户余额（account_asset_balances）

**系统资产（不可交易）**：

| asset_code | display_name | 用途 |
|---|---|---|
| POINTS | 普通积分 | 拍照获得，抽奖消耗（目前已禁用） |
| BUDGET_POINTS | 预算积分 | 抽奖预算控制，按活动隔离 |
| DIAMOND | 钻石 | 主要流通货币，交易市场定价单位 |

**材料资产（可交易，6色 x 2形态 = 12种）**：

| 颜色组 | 碎片（shard, tier 1） | 水晶（crystal, tier 2） | 价值点数 |
|---|---|---|---|
| 红 | red_shard (10点) | red_crystal (100点) | 最基础 |
| 橙 | orange_shard (20点) | orange_crystal (200点) | |
| 黄 | yellow_shard (40点) | yellow_crystal (400点) | |
| 绿 | green_shard (80点) | green_crystal (800点) | |
| 蓝 | blue_shard (160点) | blue_crystal (1600点) | |
| 紫 | purple_shard (320点) | purple_crystal (3200点) | 最高级 |

### 9.3 余额与流水一致性验证结果（2026-02-22 实时验证）

> **表结构说明**：`account_asset_balances` 的余额列为 `available_amount`（可用）和 `frozen_amount`（冻结），总余额 = `available_amount + frozen_amount`。`asset_transactions` 的变动列为 `delta_amount`。

对真实数据库执行 `SUM(asset_transactions.delta_amount)` vs `account_asset_balances.available_amount + frozen_amount` 校验：

**不一致的典型案例**（不含 POINTS，共 14 个账户存在至少一种资产不一致）：

| 账户 | 资产 | 当前余额 | 流水合计 | 差额 | 问题 |
|---|---|---|---|---|---|
| account_id=7 | DIAMOND | 78,320 | -9,223,372,036,854,813,682 | BIGINT溢出 | admin_data_fix 写入极限值（tx_id=36096） |
| account_id=6 | DIAMOND | 345,700 | 110,400 | -235,300 | 余额多出23.5万（直接改库） |
| account_id=13 | DIAMOND | 245,600 | 37,000 | -208,600 | 余额多出20.8万 |
| account_id=6 | red_shard | 122,440 | 51,705 | -70,735 | 余额多出7万碎片 |
| account_id=5 | red_shard | 71,994 | 16,884 | -55,110 | 余额多出5.5万碎片 |
| account_id=26 | DIAMOND | 60,075 | 79,675 | +19,600 | 流水多于余额（曾直接扣余额未记流水） |
| account_id=16 | DIAMOND | 5,000 | 0 | -5,000 | 有余额但0条流水 |
| account_id=175 | DIAMOND | 5,000 | 0 | -5,000 | 有余额但0条流水 |
| account_id=17 | DIAMOND | 5,000 | 0 | -5,000 | 有余额但0条流水 |

**有余额但完全无流水的 15 个余额记录**（涉及 account_id=16,17,175,176）：

| account_id | DIAMOND | red_shard | red_crystal | orange_shard |
|---|---|---|---|---|
| 16 | 5,000 | 2,000 | 200 | 500 |
| 17 | 5,000 | 2,000 | 200 | 500 |
| 175 | 5,000 | 2,000 | 200 | 500 |
| 176 | — (有流水) | 2,000 | 200 | 500 |

这些资产是通过直接操作数据库或绕过 BalanceService 写入的。account_id=176 的 DIAMOND 余额 4,950 有一笔 -50 的流水（说明曾绕过写入后又发生了正常扣减），不在"完全无流水"之列。

### 9.4 当前记账模式的局限

当前 `asset_transactions` 是**单式记账**：每条流水只记录一个账户的变动（delta_amount），不记录对手方。

单式记账的问题：
- 无法验证全局守恒（"系统里的钻石总量有没有凭空增减"）
- 无法自动发现异常（只有人工逐条排查才能发现不一致）
- 管理员调账只需写一条流水，没有对手方约束

双录记账的优势：
- 每笔变动写两条（出方 -N，入方 +N），SUM 永远为 0
- 一条 SQL 即可发现异常
- 管理员调账也必须指明"从哪来"，不能凭空创造

---

## 十、统一治理方案（奖品 + 账户）

### 10.1 核心思路

奖品模块和账户模块的问题**根因相同**（单式记账、写入可绕过、无对账机制），用**同一套双录记账模式**统一治理：

| 资产类型 | 当前方式 | 治理后方式 |
|---|---|---|
| 奖品实例（不可数） | item_instance_events 单式 | item_ledger 双录：出方 -1，入方 +1 |
| 积分/钻石/碎片（可数） | asset_transactions 单式 | asset_transactions 升级为双录：发放方 -N，接收方 +N |

两者共用同一套对账逻辑：`SUM(delta) GROUP BY account_id, asset_code` 是否和余额表一致。

### 10.2 可数资产（积分/钻石/碎片）的改造

当前 `asset_transactions` 只记一方，改造为每次变动写两条记录：

| 操作 | 当前（单式） | 改造后（双录） |
|---|---|---|
| 系统发放积分给用户 | 用户 +1000 （1条） | SYSTEM_MINT -1000 + 用户 +1000（2条） |
| 抽奖消耗积分 | 用户 -100（1条） | 用户 -100 + SYSTEM_BURN +100（2条） |
| 交易买方扣钻石 | 买方 -500（1条） | 买方 -500 + 卖方 +475 + 平台 +25（3条，对应实际资金流向） |
| 管理员调账 | 用户 +5000（1条） | SYSTEM_RESERVE -5000 + 用户 +5000（2条，必须指明来源） |

全局守恒验证：

```sql
-- 按 asset_code 汇总，SUM 必须为 0
SELECT asset_code, SUM(delta_amount) FROM asset_transactions GROUP BY asset_code HAVING SUM(delta_amount) != 0;
-- 结果必须为空集
```

### 10.3 统一对账脚本

一个对账脚本同时覆盖两类资产：

**可数资产对账**：
1. 全局守恒：`SUM(delta_amount) GROUP BY asset_code` 是否全部为 0
2. 账户余额一致：每个账户的 `SUM(delta_amount)` 是否等于 `available_amount + frozen_amount`
3. 无流水余额检测：是否有 `available_amount != 0` 但无对应 `asset_transactions` 记录

**不可数资产（奖品）对账**：
1. 物品守恒：`SUM(delta) GROUP BY item_id` 是否全部为 0
2. 持有者一致：ledger 推导的持有者是否与 items.owner 一致
3. 铸造数量一致：items 总数是否与 mint 事件数一致

### 10.4 历史数据治理

**可数资产**：
1. 为 15 个无流水余额补建 opening_balance 流水（从 SYSTEM_RESERVE 发出）
2. 清理 BIGINT 溢出的 admin_data_fix 记录
3. 为余额与流水差额补建调整流水（标记为 data_migration）
4. 迁移完成后执行对账验证

**不可数资产（奖品）**：
1. 回填 source 字段（从 mint 事件推导）
2. 生成 tracking_code
3. 补建 item_ledger 记录

---

## 十一、结论与建议

项目尚未上线，接受推倒重来。奖品包含有真实成本的实物和优惠券，存在用户间交易市场。追求最低长期维护成本。

**两个模块问题根因相同，必须统一治理**。分开治理会导致奖品用一套对账逻辑、资产用另一套，长期维护成本翻倍。

 
奖品模块：
- 3 张表清晰分工：item_ledger（真相）、item_holds（锁定）、items（缓存）
- 一条 SQL 即可验证物品守恒
- 不存在"两份记录不一致"的可能性
- 关键数据全部是正式列，不依赖 JSON
- 锁定机制可索引、可查询、可自动过期

账户模块：
- asset_transactions 升级为双录记账（每次变动写出方+入方）
- 系统账户（SYSTEM_MINT/BURN/RESERVE）作为资产的来源和去处
- 管理员调账必须指明对手方，不能凭空创造资产
- 历史数据一次性治理（补建流水、清理溢出、余额对齐）

统一对账：
- 一个脚本覆盖两类资产
- 每小时自动执行
- 异常即报警

---

## 十二、实施可行性分析（基于后端真实代码审计 2026-02-22）

> 以下分析基于 Node.js 连接真实数据库 + 逐文件阅读后端源码得出，不引用任何历史报告。

### 12.1 后端技术体系中可直接复用的模式

当前后端项目已经建立了成熟的技术体系，三表模型的实施可以直接复用以下模式，不需要引入新框架或新依赖：

| 可复用模式 | 现有代码示例 | 用于三表模型 |
|---|---|---|
| **Sequelize Model 定义** | `models/ItemInstance.js`（570 行，含 init/associate/索引/约束/LOCK_PRIORITY 常量） | 直接用于新建 Item.js、ItemLedger.js、ItemHold.js |
| **Domain Service 模式** | `services/asset/ItemService.js`（933 行，static methods + transaction 参数 + requireTransaction 强制事务） | ItemLifecycleService.js 沿用同一模式 |
| **TransactionManager** | ItemService/BalanceService 已统一使用事务管理 | 双录写入直接复用 |
| **幂等性控制** | `idempotency_key` 在 item_instance_events 和 asset_transactions 中已全面使用（UNIQUE 约束） | item_ledger 的 `uk_item_idempotency` 直接沿用 |
| **系统账户体系** | 6 个系统账户已存在：SYSTEM_MINT(id=2)、BURN(id=3)、ESCROW(id=4)、PLATFORM_FEE(id=1)、RESERVE(id=12)、CAMPAIGN_POOL(id=15) | 双录记账的对手方账户**已就绪**，不需要创建 |
| **V4 API 路由** | `/api/v4/console/item-instances/...` 已有物品管理路由 | 新增路由遵循完全相同的 `v4/console/` 模式 |
| **中间件体系** | auth.js、validation.js、errorHandler.js、ConcurrencyControlMiddleware.js | 全部直接复用，不需要新增中间件 |
| **审计日志** | AuditLogService 已存在且在多个服务中使用 | 集成到 ledger 写入流程 |
| **统一响应格式** | ApiResponse 中间件（app.js 中注册） | 新路由自动继承 |
| **时间处理** | BeijingTimeHelper 全局统一 +08:00 | 直接使用 |

### 12.2 需要新建的后端代码

| 文件 | 模式来源 | 说明 |
|---|---|---|
| `models/Item.js` | 参考 `ItemInstance.js` | items 缓存表模型。去掉 meta/locks JSON，item_name/item_type/item_value/prize_definition_id 升为正式列 |
| `models/ItemLedger.js` | 参考 `AssetTransaction.js` | 双录账本模型。只追加不修改，UNIQUE(item_id, idempotency_key) |
| `models/ItemHold.js` | 新模式 | 锁定记录模型。替代 JSON locks，支持 trade/redemption/security 三种 hold_type |
| `utils/TrackingCodeGenerator.js` | 新工具 | 生成 `{来源2位}{YYMMDD}{item_id补零6位}` 格式的追踪码 |
| `services/asset/ItemLifecycleService.js` | 参考 `ItemService.js` | 全链路查询服务：根据 tracking_code 或 item_id 查物品完整生命周期 |
| `routes/v4/console/item-lifecycle.js` | 参考 `routes/v4/console/` 现有模式 | 管理后台全链路查询路由 |
| `routes/v4/console/reconciliation.js` | 新路由 | 对账接口 |
| `scripts/reconcile-items.js` | 新脚本 | 定时对账（物品守恒 + 资产守恒） |
| `scripts/migrate-item-tracking.js` | 新脚本 | 历史数据迁移（item_instances → items + item_ledger） |
| `migrations/YYYYMMDD-create-item-three-tables.js` | 参考现有 `sequelizemeta` 中的迁移 | 创建三张新表的数据库迁移 |

### 12.3 需要修改的现有后端代码

| 文件 | 改动内容 | 影响范围 | 风险 |
|---|---|---|---|
| `services/asset/ItemService.js`（933 行） | **核心重写**：mintItem → 同时写 items + item_ledger 双录；transferItem → 双录转移；consumeItem → 双录核销。当前 mintItem 使用 `requireTransaction` 强制事务，可直接扩展双录写入。 | 高 | 中（所有物品操作入口） |
| `services/exchange/BidService.js` | settleBidProduct 中 **第 440 行 `this.ItemInstance.create()` → `ItemService.mintItem()`**（已确认直接创建绕过服务层，无 mint 事件。bid_products 当前 0 条数据，功能未投产但代码路径已存在） | 中 | 低 |
| `services/UnifiedLotteryEngine/pipeline/stages/SettleStage.js` | `_distributePrize` 中 coupon/physical 分支（第 607-623 行）：当前 `source_id` 为 `idempotency_key` 格式，`meta` 仅含 `lottery_prize_id`。需增加 `lottery_draw_id` 传入以建立抽奖记录→物品实例的直接关联。 | 低 | 低（仅增加一个参数） |
| `services/RedemptionService.js` | fulfillOrder 改用 ItemService.consumeItem() 写入 item_ledger | 中 | 低 |
| `models/index.js` 或模型关联注册处 | 注册 Item、ItemLedger、ItemHold 三个新模型及关联关系 | 低 | 低 |
| `app.js` | 注册 `/api/v4/console/item-lifecycle` 和 `/api/v4/console/reconciliation` 路由 | 低 | 低 |

### 12.4 API 路径设计（遵循后端 V4 路由体系）

当前系统的 API 路由模式（从 `app.js` 注册顺序和 `routes/v4/` 目录结构确认）：

```
/api/v4/console/item-instances/...     ← 已有，物品实例管理
/api/v4/console/user-management/...    ← 已有，用户管理
/api/v4/backpack/...                   ← 已有，用户背包操作
/api/v4/assets/...                     ← 已有，资产查询
/api/v4/shop/redemption/...            ← 已有，核销兑换
```

新增路由（严格遵循 V4 模式）：

```
# 管理后台 — 全链路追踪
GET  /api/v4/console/items/:identifier/lifecycle
     identifier 支持 tracking_code（如 LT260219028738）或 item_id
     响应：物品信息 + 来源 + 时间线 + 对账状态

# 管理后台 — 对账报告
GET  /api/v4/console/reconciliation/items
     物品守恒对账：SUM(delta) GROUP BY item_id 是否全为 0
GET  /api/v4/console/reconciliation/assets
     资产守恒对账：SUM(delta_amount) GROUP BY asset_code 是否全为 0

# 管理后台 — 账本查询
GET  /api/v4/console/item-ledger
     支持 item_id / account_id / event_type / business_type / 时间范围筛选

# 用户端 — 物品追踪（小程序/前端）
GET  /api/v4/backpack/items/:item_id/timeline
     用户查看自己物品的流转历史（仅返回与自己相关的记录）
```

响应格式遵循后端统一 ApiResponse 标准：

```json
{
  "success": true,
  "code": "SUCCESS",
  "message": "获取物品生命周期成功",
  "data": {
    "tracking_code": "LT260219028738",
    "item_id": 28738,
    "item_name": "甜品1份",
    "item_type": "product",
    "status": "used",
    "owner_account_id": 5,
    "source": "lottery",
    "source_ref_id": "draw_xxx",
    "timeline": [...],
    "ledger_check": { "sum_delta": 0, "status": "balanced" }
  },
  "timestamp": "2026-02-22T20:00:00.000+08:00",
  "request_id": "req_xxx"
}
```

所有字段名以后端数据库列名为准，前端直接使用，不做任何映射。

---

## 十三、责任归属分析（后端 / Web 管理后台 / 微信小程序）

### 13.1 后端数据库项目的改动（核心工作，占总工作量 80%）

这是**唯一的数据真相来源**，所有改动以此为准。

| 改动类别 | 具体内容 | 工作量 |
|---|---|---|
| 数据库迁移 | 创建 items / item_ledger / item_holds 三张表 | 0.5 天 |
| 新建 Model | Item.js / ItemLedger.js / ItemHold.js（参考现有模型模式） | 1 天 |
| 重写 Service | ItemService.js 核心方法（mint/transfer/consume → 双录） | 2 天 |
| 修复绕过 | BidService.settleBidProduct → 改用 ItemService.mintItem | 0.5 天 |
| 新增 Service | ItemLifecycleService.js 全链路查询 | 1 天 |
| 新增 Route | console/item-lifecycle.js + console/reconciliation.js | 0.5 天 |
| 对账脚本 | reconcile-items.js（物品 + 资产同时对账） | 0.5 天 |
| 历史数据迁移 | migrate-item-tracking.js（item_instances → items + ledger） | 1 天 |
| 资产双录升级 | `BalanceService.changeBalance`（1,097 行）增加 `counterpart_account_id` 参数，已有 `BALANCE_SAFETY_LIMIT`（10亿上限）可复用于双录校验 | 1 天 |
| 历史数据治理 | 15 个无流水余额补建、BIGINT 溢出标记、余额差额对齐 | 0.5 天 |
| **小计** | | **8.5 天** |

### 13.2 Web 管理后台前端的改动（适配工作）

前端以后端提供的字段和接口为准，**直接使用后端字段名，不做映射**。

| 改动类别 | 具体内容 | 工作量 |
|---|---|---|
| 新增页面 | `item-lifecycle.html` — 物品追踪页面（输入 tracking_code 查全链路） | 0.5 天 |
| 新增页面 | `reconciliation.html` — 对账报告页面（展示对账结果 + ECharts 图表） | 0.5 天 |
| 修改页面 | 现有物品管理页面：字段从 `meta.name` → `item_name`，从 `meta.value` → `item_value` | 0.5 天 |
| API 适配 | `admin/src/api/` 新增 item-lifecycle.js 和 reconciliation.js API 模块 | 0.5 天 |
| **小计** | | **2 天** |

**Web 前端不存在的问题**：前端本身没有数据一致性问题，它只是展示层。所有数据问题的根源在后端。前端需要做的仅仅是"换字段名"和"加新页面"。

### 13.3 微信小程序前端的改动（适配工作）

> **注意**：小程序前端项目不在当前工作区。以下为接口适配需求，需确认仓库位置后执行。

| 改动类别 | 具体内容 | 工作量 |
|---|---|---|
| 背包页面 | 物品列表字段适配：`meta.name` → `item_name`，`meta.value` → `item_value` | 0.5 天 |
| 新增展示 | 物品详情页新增 tracking_code 展示 + 流转时间线（调 `/api/v4/backpack/items/:id/timeline`） | 0.5 天 |
| 兑换码页面 | 适配新的 redemption 字段（如有变化） | 0.5 天 |
| **小计** | | **1.5 天** |

**小程序不存在的问题**：小程序只是消费后端 API 的展示层。所有追踪、对账、双录逻辑都在后端完成。小程序不需要理解双录记账，只需要展示后端返回的数据。

### 13.4 责任归属总结

```
后端数据库项目：设计三表模型 + 实现双录 + 数据迁移 + 对账（8.5 天）
          ↓ 提供 API
Web 管理后台：新增追踪页面 + 对账页面 + 字段适配（2 天）
          ↓ 共享同一套后端 API
微信小程序：背包字段适配 + 新增追踪展示（1.5 天）
```

三端总计预估：**12 天**（后端完成后，两个前端可并行开发）

---

## 十四、Web 管理后台前端技术兼容性分析

### 14.1 当前技术栈与改动的兼容性

| 前端技术 | 兼容性 | 说明 |
|---|---|---|
| **Alpine.js 3.15** | ✅ 完全兼容 | 物品追踪页面用 `x-data` 管理状态，`x-for` 渲染时间线，无框架障碍 |
| **Vite 6.4 MPA** | ✅ 完全兼容 | 新增 `item-lifecycle.html` 和 `reconciliation.html` 两个页面即可 |
| **Tailwind CSS 3.4** | ✅ 完全兼容 | 时间线组件用 Tailwind 的 `flex` / `border-l` / `space-y` 即可实现 |
| **ECharts 6.0** | ✅ 完全兼容 | 对账报告页面直接使用 ECharts 展示对账趋势图 |
| **API 客户端 (`api/base.js`)** | ✅ 完全兼容 | 已有 `apiGet` / `apiPost` 封装 + token 管理，直接调用新 API |
| **socket.io-client** | ✅ 可选扩展 | 未来可通过 WebSocket 实时推送对账异常告警 |

### 14.2 前端不需要的改动

- **不需要**引入新的前端框架或库
- **不需要**建立字段映射层（直接用后端字段名：`item_name`、`item_type`、`tracking_code`、`owner_account_id`）
- **不需要**在前端实现任何业务逻辑（对账、双录验证全在后端）
- **不需要**修改 Vite 构建配置

### 14.3 前端现有需要清理的技术债

如果现有物品管理页面从 `meta` JSON 解析字段（如 `item.meta.name`），需要改为直接使用正式列（`item.item_name`）。这是一次性的查找替换工作。

---

## 十五、现有表的影响分析与迁移安全性

### 15.1 复用现有表会不会有影响？

**会有影响，而且正是当前问题的根源。** 现有两张表存在以下结构性缺陷，无法通过"加字段"修复：

| 现有表 | 结构性缺陷 | 为什么不能修补 |
|---|---|---|
| `item_instances` | 关键数据（name/value/prize_id）存在 meta JSON 里，不可索引、无类型约束 | 把 JSON 字段提取为正式列 = 实质上重建表结构 |
| `item_instances` | locks 用 JSON 数组存储，不可查询、不可索引 | 改为关系表 = 实质上新建 item_holds |
| `item_instances` | status 有 5 个值但语义混乱（locked 同时表示交易锁和兑换锁） | 需要 held + item_holds 精确区分 |
| `item_instance_events` | 单式记账（只记一方），无法数学验证守恒 | 改为双录 = 实质上重建为 item_ledger |
| `item_instance_events` | 与 item_instances 是"双真相"，可以不一致 | 两张表的 status 可以矛盾，这是设计缺陷 |

**结论：在现有表上加装 = 三套真相并存（item_instances + item_instance_events + item_ledger），维护成本更高，而非更低。**

### 15.2 从零开始是否安全？

**安全，原因如下**：

1. **项目未上线**：没有线上用户，没有并发访问，切换不会中断任何人
2. **新表先建、数据先迁、再切代码**：全程有回滚窗口
3. **旧表改名保留 30 天**：`item_instances` → `item_instances_legacy`，`item_instance_events` → `item_instance_events_legacy`，出问题随时可以回切
4. **迁移脚本可验证**：迁移完成后跑对账 SQL，`SUM(delta)` 全为 0 才算成功

迁移顺序（零风险）：

```
Step 1: CREATE TABLE items / item_ledger / item_holds  （新表）
Step 2: 运行迁移脚本，从旧表读数据写入新表
Step 3: 运行对账验证，确认新表数据正确
Step 4: 修改 Service 代码指向新表
Step 5: RENAME TABLE item_instances → item_instances_legacy
Step 6: 30 天后 DROP TABLE item_instances_legacy
```

任意步骤失败都可以回退，因为旧表在 Step 5 之前都没有被动过。

### 15.3 新旧表对照

| 旧表 | 替代为 | 数据迁移方式 |
|---|---|---|
| `item_instances`（6,776 条） | `items`（缓存层） | 逐条迁移，meta JSON 中的 name/value/description 提取为正式列（已确认 meta 典型键为这三个） |
| `item_instance_events`（5,375 条，含 ~460 条测试数据） | `item_ledger`（真相层） | 每条 mint/transfer/use 事件转为双录（出方 -1 + 入方 +1），测试数据标记 source='test' |
| `item_instances.locks` JSON 字段 | `item_holds`（锁定层） | JSON 解析后逐条写入 |

---

## 十六、8 项决策确认（已确认方案）

### 决策 0（项目负责人已拍板）：不复用旧表旧功能，全部从零新建

**已确认**：不在 `item_instances` / `item_instance_events` 基础上修补。原因：

1. 旧表的结构性缺陷（meta JSON、locks JSON、双真相）不是"加字段"能修的
2. 在旧表上加装 item_ledger = 三套真相并存，维护成本更高而非更低
3. 项目未上线，没有线上用户，从零开始没有业务风险
4. `item_instances` 的 "Instance" 命名已名不副实——大量物品没有模板，不是真正的"实例化"关系

新建三张表 `items` / `item_ledger` / `item_holds`，旧表数据迁移后退役。代码中所有 `ItemInstance` Model 引用替换为 `Item` Model——这不是"改回去"，而是新表代表完全不同的设计哲学（详见 7.1.1 节命名对照）。

### 决策 1：旧表保留策略 → **B. 改名保留 30 天后删除**

- `item_instances` → `item_instances_legacy`
- `item_instance_events` → `item_instance_events_legacy`
- 30 天内如需排查历史问题可查旧表，30 天后 DROP

### 决策 2：迁移策略 → **A. 一次性切换，从零新建**

项目未上线，没有用户影响。一次性切换到三表模型，不做新旧并行。代码中所有 `ItemInstance` Model 引用替换为新的 `Item` Model（新表、新结构、新命名，不是简单改名）。不保留任何兼容分支。

### 决策 3：tracking_code 对用户可见 → **A. 可见**

用户在小程序背包里可以看到 tracking_code。联系客服时报编码即可定位。格式如 `LT260219028738`，人类可读。

### 决策 4：双录升级时机 → **A. 与物品三表模型同步做**

奖品模块和账户模块的问题根因相同（单式记账、写入可绕过、无对账），用同一套双录模式统一治理。共享一个对账脚本，不维护两套。

### 决策 5：source=unknown 的 3,493 条物品 → **B. 有 mint 事件的回填，其余标 legacy**

- 2,992 条有 lottery mint 事件 → 回填 `source='lottery'`，`source_ref_id` 从事件 meta 中提取
- 其余 ~501 条无 mint 事件 → 标记 `source='legacy'`

### 决策 6：BIGINT 溢出记录 → **B. 标记 is_invalid=true**

`asset_transactions` 新增 `is_invalid` 标记列。account_id=7 的溢出记录标记为无效，对账时 WHERE 排除。不物理删除（保留审计证据）。

### 决策 7：15 个无流水余额 → **B. 补建 opening_balance 流水**

为 accounts 16/17/175/176 的每个资产余额补建一条 `opening_balance` 流水，对手方为 `SYSTEM_RESERVE(account_id=12)`。让所有余额都有流水来源，对账可通过。

### 决策 8：微信小程序前端仓库 → **待确认**

当前后端工作区（`/home/devbox/project`）未找到小程序源码。**需要项目负责人确认**：
- 小程序项目在哪个 Git 仓库？
- 使用什么框架（原生 / Taro / uni-app）？
- 当前 API 基础路径是 `/api/v4` 还是旧版本？

> 这是唯一一个需要项目负责人回复的决策项。其余 7 项已确认。

---

## 十七、分步执行计划（基于后端实际技术栈）

### Phase 1：数据库层（后端，1.5 天）

**目标**：创建三张新表，不影响现有功能。

| 步骤 | 具体操作 |
|---|---|
| 1.1 | 编写 Sequelize 迁移文件 `migrations/YYYYMMDD-create-item-three-tables.js`：创建 items / item_ledger / item_holds 三张表（SQL 定义见第七章 7.3 节） |
| 1.2 | 新建 `models/Item.js`：参考 `models/ItemInstance.js` 的 init/associate 模式，字段定义按 7.3 节 items 表 |
| 1.3 | 新建 `models/ItemLedger.js`：参考 `models/AssetTransaction.js` 的幂等性控制模式 |
| 1.4 | 新建 `models/ItemHold.js`：新模式，支持 trade/redemption/security 三种 hold_type |
| 1.5 | 在模型注册处（models/index.js 或 app.js）注册新模型和关联关系 |
| 1.6 | 新建 `utils/TrackingCodeGenerator.js`：生成 `{来源2位}{YYMMDD}{item_id补零6位}` |
| 验证 | 执行迁移，确认三张表创建成功，字段和索引正确 |

### Phase 2：服务层核心重写（后端，3 天）

**目标**：所有物品操作统一走双录路径。

| 步骤 | 具体操作 |
|---|---|
| 2.1 | **重写 `services/asset/ItemService.js` 的 `mintItem` 方法**：在事务内同时写 items 表（INSERT）+ item_ledger 双录（SYSTEM_MINT delta=-1 + 用户 delta=+1）+ 生成 tracking_code |
| 2.2 | **重写 `transferItem` 方法**：item_ledger 双录（卖方 delta=-1 + 买方 delta=+1）+ items 表 UPDATE owner |
| 2.3 | **重写 `consumeItem` 方法**：item_ledger 双录（用户 delta=-1 + SYSTEM_BURN delta=+1）+ items 表 UPDATE status='used' |
| 2.4 | 新增 `holdItem` / `releaseHold` 方法：操作 item_holds 表 + items 表 status 缓存 |
| 2.5 | **修改 `services/exchange/BidService.js`**：`settleBidProduct` 中的 `ItemInstance.create()` 替换为 `ItemService.mintItem()`，传入 `source='bid_settlement'` 和 `source_ref_id=bid_product_id` |
| 2.6 | **修改 `SettleStage.js`**：`_distributePrize` 中将 `lottery_draw_id` 传入 ItemService.mintItem 的参数（当前 meta 中只有 source_id，缺少可查询的 lottery_draw_id） |
| 2.7 | **修改 `RedemptionService.js`**：fulfillOrder 通过 ItemService.consumeItem 完成核销 |
| 验证 | 单元测试覆盖 mint/transfer/consume/hold/release 五个核心操作 |

### Phase 3：API 层（后端，1 天）

**目标**：暴露全链路查询和对账接口。

| 步骤 | 具体操作 |
|---|---|
| 3.1 | 新建 `services/asset/ItemLifecycleService.js`：根据 tracking_code 或 item_id 查 items + item_ledger + item_holds + redemption_orders + market_listings 拼装完整时间线 |
| 3.2 | 新建 `routes/v4/console/item-lifecycle.js`：`GET /api/v4/console/items/:identifier/lifecycle` |
| 3.3 | 新建 `routes/v4/console/reconciliation.js`：物品对账 + 资产对账接口 |
| 3.4 | 新建 `routes/v4/backpack/item-timeline.js`：`GET /api/v4/backpack/items/:item_id/timeline`（用户端） |
| 3.5 | `app.js` 注册新路由 |
| 验证 | curl 调用确认响应格式符合 ApiResponse 标准 |

### Phase 4：历史数据迁移（后端，1 天）

**目标**：现有 6,776 条物品实例迁移到三表模型（含 ~460 条测试数据）。

| 步骤 | 具体操作 |
|---|---|
| 4.1 | 编写 `scripts/migrate-item-tracking.js` |
| 4.2 | item_instances → items：逐条迁移，meta 中的 name/value/prize_id 提取为正式列 |
| 4.3 | item_instance_events(mint) → item_ledger：为每个 mint 事件生成双录（SYSTEM_MINT -1 + 用户 +1） |
| 4.4 | item_instance_events(transfer) → item_ledger：为每个 transfer 事件生成双录（旧 owner -1 + 新 owner +1） |
| 4.5 | item_instance_events(use) → item_ledger：为每个 use 事件生成双录（用户 -1 + SYSTEM_BURN +1） |
| 4.6 | item_instances.locks JSON → item_holds 表迁移 |
| 4.7 | 回填 source 字段：2,992 条有 lottery mint 事件 → source='lottery'；~460 条 test_* 事件 → source='test'；~501 条无 mint 事件 → source='legacy' |
| 4.8 | 生成 tracking_code：所有 items 行生成唯一追踪码 |
| 验证 | 首次对账：`SUM(delta) GROUP BY item_id` 全部为 0 |

### Phase 5：资产双录升级（后端，1.5 天）

**目标**：可数资产也实现双录记账。

| 步骤 | 具体操作 |
|---|---|
| 5.1 | 修改 `services/asset/BalanceService.js`（1,097 行）的 `changeBalance` 方法：增加 `counterpart_account_id` 参数，每次变动写两条 asset_transactions（出方 delta_amount=-N + 入方 delta_amount=+N）。已有 `BALANCE_SAFETY_LIMIT`（10亿）和 `requireTransaction` 强制事务可直接复用。 |
| 5.2 | 所有调用 `changeBalance` 的业务代码传入对手方账户（lottery_reward → SYSTEM_MINT, 抽奖消耗 → SYSTEM_BURN, 交易 → 对方用户, 管理员调账 → SYSTEM_RESERVE） |
| 5.3 | 治理 15 个无流水余额：为 accounts 16/17/175/176 补建 opening_balance 流水从 SYSTEM_RESERVE |
| 5.4 | 标记 account_id=7 的 BIGINT 溢出记录为无效 |
| 5.5 | 为 20 个余额与流水不一致的账户补建 data_migration 调整流水 |
| 验证 | 资产对账：`SUM(delta_amount) GROUP BY asset_code` 全部为 0 |

### Phase 6：对账脚本（后端，0.5 天）

| 步骤 | 具体操作 |
|---|---|
| 6.1 | 编写 `scripts/reconcile-items.js`：同时覆盖物品守恒和资产守恒 |
| 6.2 | 配置 cron 定时执行（每小时） |
| 6.3 | 异常结果通过 Winston logger 输出 + 可选 WebSocket 推送管理后台 |

### Phase 7：前端适配（Web + 小程序，并行，2 天）

> 后端 Phase 1-6 完成后，两个前端可并行开发。

**Web 管理后台**：

| 步骤 | 具体操作 |
|---|---|
| 7.1 | 新增 `admin/item-lifecycle.html` + `admin/src/modules/asset/item-lifecycle.js`：输入 tracking_code 查全链路，用 Alpine.js `x-for` 渲染时间线 |
| 7.2 | 新增 `admin/reconciliation.html` + `admin/src/modules/asset/reconciliation.js`：展示对账结果，用 ECharts 绘制趋势图 |
| 7.3 | 修改现有物品管理页面：`item.meta.name` → `item.item_name`，`item.meta.value` → `item.item_value`（全局替换） |
| 7.4 | `admin/src/api/` 新增 itemLifecycle.js 和 reconciliation.js 两个 API 模块 |

**微信小程序**（需确认仓库后执行）：

| 步骤 | 具体操作 |
|---|---|
| 7.5 | 背包列表页字段替换：`meta.name` → `item_name` |
| 7.6 | 物品详情页新增 tracking_code 展示和流转时间线（调 `/api/v4/backpack/items/:id/timeline`） |

---

## 十八、可扩展性分析

三表模型建成后，以下功能可在不修改底层架构的前提下扩展：

| 扩展方向 | 如何扩展 | 涉及改动 |
|---|---|---|
| 新增奖品类型 | items 表新增 item_type 值 + 对应 Service 分支 | 仅业务逻辑层 |
| 新增 hold 类型 | item_holds 表新增 hold_type 值（如 'dispute' 争议冻结） | 仅枚举值 |
| 批量对账 vs 实时对账 | 对账脚本已支持批量，增加触发器可实时 | 对账脚本扩展 |
| 物品拆分/合并 | item_ledger 写 'split'/'merge' 事件，对账 SQL 不变 | 新业务逻辑 |
| 跨用户赠送 | item_ledger 写 transfer 双录，与交易复用同一路径 | 新路由 + 权限控制 |
| 资产审计报表 | item_ledger + asset_transactions 数据源已完整 | 新查询 Service + 前端页面 |
| 管理员调账审批链 | item_ledger 已有 operator_id + operator_type，增加审批状态表即可 | 新表 + 审批流 |

---

## 十九、微信小程序前端对接指南（后端已就绪）

> 本节面向微信小程序前端开发人员。后端 Phase 1-6 已全部完成，以下 API 已可用。

### 19.1 已就绪的后端 API

| API 路径 | 方法 | 说明 | 认证要求 |
|---|---|---|---|
| `/api/v4/console/item-lifecycle/:identifier/lifecycle` | GET | 物品全链路追踪（管理后台） | admin token |
| `/api/v4/console/item-lifecycle/ledger` | GET | 物品账本查询 | admin token |
| `/api/v4/console/reconciliation/items` | GET | 物品守恒对账报告 | admin token |
| `/api/v4/console/reconciliation/assets` | GET | 资产守恒对账报告 | admin token |

### 19.2 小程序字段变更（后端三表模型升级）

| 旧字段路径 | 新字段路径 | 说明 |
|---|---|---|
| `meta.name` | `item_name` | 物品名称（正式列） |
| `meta.value` | `item_value` | 物品价值（正式列，整数） |
| `meta.description` | `item_description` | 物品描述（正式列） |
| _(无)_ | `tracking_code` | 追踪码（新增，格式：LT260219028738） |
| _(无)_ | `rarity_code` | 稀有度代码（新增） |
| _(无)_ | `prize_definition_id` | 奖品定义ID（新增） |
| `status: 'locked'` | `status: 'held'` | 锁定状态名称变更 |
| `status: 'transferred'` | _(不再有)_ | 转移后物品归属新主人，状态为 available |

### 19.3 追踪码编码规则

格式：`{来源2位}{YYMMDD}{item_id补零6位}`

| 来源 | 前缀 | 示例 |
|---|---|---|
| 抽奖 | LT | LT260219028738 |
| 竞价结算 | BD | BD260220000042 |
| 兑换 | EX | EX260221000100 |
| 管理员赠送 | AD | AD260222000001 |

### 19.4 注意事项

1. **字段命名**：直接使用后端返回的 snake_case 字段名，不做映射
2. **数据敏感性**：小程序端数据已通过 DataSanitizer 脱敏处理
3. **旧数据兼容**：历史物品已迁移到新表，meta 数据已提取为正式列
4. **状态变更**：locked → held，transferred 已消除
