## 路由层 / 模型层 / 服务层 / 数据一致性规范（V4）

> **版本**: v5.0（规则统一版）  
> **最后更新**: 2025-12-11  
> **适用范围**: `app.js` / `routes/*` / `models/*` / `services/*` 当前代码  
> **目标**: 给所有新增 / 重构代码提供统一的设计指南、强制规范和审查清单，避免过早 DDD 过度设计。

---

## 一、整体分层与技术路线（强制）

### 1.1 分层结构（与当前代码对齐）

```text
HTTP Layer / 路由层（routes/*）
  - Express Router + 中间件（auth、限流、asyncHandler）
  - 只负责参数解析、权限入口、调用 Service、统一返回

Service Layer / 服务层（services/*）
  - 静态方法为主的领域服务（PointsService、InventoryService 等）
  - 负责业务规则、事务、一致性、跨模型协作

Model Layer / 模型层（models/*）
  - Sequelize 模型定义与关联
  - 不包含跨表业务流程
```

- **必须**通过 `ServiceManager` 获取服务：`req.app.locals.services.getService('points')` 等（见 `services/index.js`）。  
- **必须**通过 `utils/ApiResponse` 中间件返回：`res.apiSuccess / res.apiError / res.apiInternalError`。  
- **必须**在服务层处理事务与幂等，路由层不得直接使用 `sequelize.transaction()`。  
- **禁止**引入新的通用 Repository / BaseService / DI 框架，保持与现有静态 Service 模式一致。

### 1.2 本系统架构定位与资产模型（强制）

- **技术形态（当前阶段的唯一标准形态）**：
  - **必须**保持**单体 Node.js + 单库 MySQL** 形态，Redis 仅作为缓存/辅助存储（可选），**不得**在当前项目中拆微服务或引入跨库分布式事务。  
  - **禁止**在现有代码基础上引入 MQ + Saga 补偿式事务等复杂分布式模式；如未来确有拆分需求，应在**单独的架构文档**中重新论证，而不是在本规范中预留。
  - 每个 HTTP 请求内的资产变更（积分/库存/订单/权限）**要么全部成功，要么全部失败**，不接受“先部分落库、再异步补偿”的弱一致模式。

- **资产模型（账户 / 库存 / 订单三件套）**：
  - **积分**：
    - **必须**使用"账户 + 交易明细"模型：`UserPointsAccount` 作为账户，`PointsTransaction` 作为交易明细。  
    - 任何改变积分余额的逻辑（发放、扣减、退款、管理员调整）**必须**通过 `PointsService` 入口，并在事务内写入 `PointsTransaction`。
  - **虚拟物品 / 库存**：
    - **必须**使用"库存 + 交易流水"模型：`UserInventory` 作为背包/库存表，`TradeRecord` 作为物品交易流水。  
    - 获取/使用/转让物品等操作**必须**通过 `InventoryService` 入口完成，并在需要时记录 `TradeRecord`。
  - **兑换市场订单（Exchange Market）**：
    - **必须**以独立订单表建模：`ExchangeMarketRecord`（或等价命名），作为"下单/支付/发货/完成/取消"等状态机的载体。  
    - **业务语义强制约束**（兑换市场 vs 旧兑换链路的边界隔离）：
      - 兑换市场（`ExchangeMarketService` + `ExchangeMarketRecord`）**只处理虚拟价值兑换**（如虚拟货币、代币等非积分形式的支付），**不得支持积分支付**。
      - 旧积分兑换系统（`ExchangeRecords` + 旧运营审核链路）如仍保留，**只作为历史系统冻结使用**（只读或仅后台处理历史订单），不得在新功能中继续扩展。
      - 任何新增"用虚拟价值购买商品"的需求，**必须**通过 `ExchangeMarketService` 完成，不得混入积分扣减逻辑。
    - **支付类型强制校验**（防呆机制）：
      - 兑换市场订单的 `price_type` / `payment_type` **只能**为 `virtual`（虚拟价值）或其他非积分类型，**禁止**出现 `points` 枚举值。
      - 订单记录中 `points_paid` 字段（如存在）**必须**强制为 `0` 或 `NULL`，不得记录任何积分支付金额。
      - Service 层在处理兑换市场订单时，**必须**在事务开始前校验支付类型，如检测到 `points` 支付尝试，立即抛出错误并回滚事务。
    - **数据模型防呆约束**（推荐但非强制，作为防御纵深）：
      - 在 `ExchangeMarketRecord` 模型上增加字段约束（如 `CHECK (points_paid = 0)`）或移除 `points_paid` 字段的业务语义使用。
      - 在 `payment_type` / `price_type` 字段上增加枚举约束，只允许 `virtual` 及其他虚拟价值类型，排除 `points`。
      - 所有兑换市场订单的创建/更新操作**必须**记录 `business_id` 幂等键（已有实现）+ 审计日志（便于追溯"谁触发了这笔兑换"）。

- **事务与幂等的统一基线（资产安全内核）**：
  - 所有“**扣积分 / 改库存 / 下兑换订单**”的写操作，**必须同时满足**：
    - **单库事务**：使用 Sequelize 事务在同一 MySQL 实例内完成整条链路；
    - **行级悲观锁**：对关键账户/库存记录使用 `FOR UPDATE`（`transaction.LOCK.UPDATE`）；
    - **business_id 幂等**：以业务单号/操作唯一键防重复（积分/库存已落地，兑换市场必须对齐）。
  - 只读查询、统计报表等**不得**为了“对齐资产模型”而强行加入事务/悲观锁，但如查询路径会被用作后续写入决策的前置检查，应在 Service 内整体评估并设计合适的锁粒度。

- **权限与配置变更的统一入口**：
  - 所有“修改角色/权限/敏感配置”的操作，**必须**通过对应领域 Service 的**唯一入口方法**完成，例如：`UserRoleService.updateUserRole(...)`、`AdminSystemService.updateConfig(...)`。  
  - 在该入口方法内**同时**完成：权限合法性校验 + 事务内落库 + 审计日志（`AuditLogService`）+ 必要的缓存失效，不得将这些步骤拆散到多个 Controller 或 Model 层调用中。
  - **禁止**在路由/Model 层直接 `update roles/config` 而绕过 Service 入口；发现此类路径视为 P0 级一致性风险。

---

## 二、路由层规范（routes/*）

### 2.1 路由职责边界

- **必须**：
  - 只做这 4 件事：
    - **认证 / 鉴权**：如 `authenticateToken`、`adminAuthMiddleware`。
    - **参数解析与校验**：从 `req.params` / `req.query` / `req.body` 取值并做基础校验。
    - **调用 Service**：通过 `req.app.locals.services.getService(name)` 调用 1–2 个 Service 方法。
    - **统一响应**：使用 `res.apiSuccess / res.apiError / res.apiInternalError`。
  - 复用现有中间件：
    - 异步路由要包在 `asyncHandler(...)` 中（参考 `routes/v4/unified-engine/admin/system.js`）。
    - 需要限流的接口使用 `RateLimiterMiddleware` 创建专用 limiter（参考 `routes/v4/unified-engine/points.js`）。

- **禁止**：
  - 直接引用 `require('../models')` 或 `models.Xxx.findAll/create/update`。
  - 在路由内开启事务：`sequelize.transaction()`。  
  - 在路由内实现跨表业务流程（例如积分扣减 + 库存创建）。  
  - 自己拼装复杂 JSON 结构而绕过 Service 已有封装（例如订单/管理状态聚合应交给 Service）。

### 2.2 路由命名与文件划分

- **路径风格**：保持现有 REST 风格 `/api/v4/*`，同一领域共用一个 Router 文件（如 `points.js`）。  
- **文件内容**：
  - 领域说明 + API 列表置于文件顶部注释（参照当前 `points.js` 注释风格）。  
  - 路由内不写与业务无关的大段文档；领域说明写在对应 Service 或 docs，而不是每个路由重复。
- **文件长度约束**：
  - 单个路由文件建议 **< 800 行**（含注释）。  
  - 超过 800 行时，优先考虑按子领域拆分（例如 `inventory.js` 拆为 `inventory-core.js` + `inventory-market.js`）或将业务逻辑下沉到 Service。

> **说明（避免为了数字而重构）**  
> - 上面的「800 行」「50 行」是**经验阈值**，目的是帮你快速识别**明显已经过胖、需要拆分**的文件/函数，而不是“必须压到这个数字以下”的硬性 KPI。  
> - Code Review 时，更看重的是：**职责是否单一、逻辑是否清晰、是否出现跨层直连 models/事务**，而不是机械地拆成很多小文件/小函数。  
> - 如果一个路由文件略多于 800 行，但结构清晰、职责单一、业务已经下沉到 Service 层，可以暂时保留；相反，即使不到 800 行，但职责严重混杂、直连 models，也应按胖路由规范优先重构。

### 2.3 胖路由（Fat Route）反模式

#### 胖路由定义（命中任一条即需拆分）

- 在路由函数中直接调用 `models.Xxx.*` 或执行 SQL。  
- 单个路由函数里同时完成多步业务流程（例如：查积分 + 改库存 + 写审计日志 + 发通知）。  
- 单个路由函数超过 **50 行**（不含注释）且包含大量业务分支 `if/else`。  
- 在路由中开启事务：`sequelize.transaction()` 或等价代码。  
- 在路由里构建复杂聚合数据结构，而非调用 Service 提供的聚合方法。

#### 胖路由硬性指标（基于实际代码分析）

| 指标 | 阈值 | 说明 |
|------|------|------|
| 单个路由文件总行数 | > 800 行 | 需拆分文件或下沉业务逻辑 |
| 单个路由函数行数 | > 50 行（不含注释） | 需拆分到 Service |
| 直接操作 models 次数 | > 0 次 | 必须通过 Service |
| 单个路由函数业务分支 | > 3 层 if/else | 需抽取到 Service 方法 |
| 单个路由函数操作表数 | > 1 张表 | 需使用 Service 事务 |

> **这些指标的使用方式**  
> - 把它们当作**“报警线”而不是“及格线”**：命中指标说明“这里已经明显偏胖，应考虑下沉到 Service 或拆分”，而不是为达成指标去把本来还算清晰的代码拆碎。  
> - 优先处理那些“跨表写 + 直连 models + 多层分支”的高风险端点，其次再考虑一般性的代码美化；不要为了追求 50 行，把简单直观的逻辑拆得支离破碎，反而降低可读性。

**实际案例（作为反面教材）**：
- `inventory.js`：2933 行 / 20 个端点 / 平均每端点 146 行 / 28 次直接 models 调用 → **严重胖路由**。
- `points.js`：1361 行 / 约 10 个端点 / 3 次直接 models 调用 → **中度胖路由**。

#### 处理方式

- 将流程拆分到对应 Service（如 `PointsService`、`InventoryService`、`AdminLotteryService`），路由只保留参数和返回。  
- 涉及多表写操作的一律下沉到 Service，由 Service 负责事务和幂等。  
- 老代码短期内无法完全重构时，**新逻辑禁止再加在胖路由内部**，必须放在新 Service 方法中。

### 2.4 路由层审查清单

- **路由 PR 必须检查**：
  - 是否只通过 `ServiceManager` 访问业务（没有 `models.*` 调用）。  
  - 是否使用统一响应方法（不出现 `res.json({ success: ... })` 手写结构），**包括顶层接口**（如 `/health`、`/api`、`/api/v4`、`/api/v4/docs` 等，可通过适配函数将现有结构包装为 ApiResponse 规范）。  
  - 是否参数校验完整（id 范围、枚举值校验等，参考 `admin/lottery_management.js` 的校验方式）。  
  - 是否将任何"需要事务"的逻辑下沉到 Service。
  - 单个路由函数是否超过 50 行或含多层业务分支。
  - 是否有直接操作多张表的代码（跨表操作必须在 Service 内用事务保护）。

---

## 三、服务层规范（services/*）

### 3.1 服务形态与依赖注入

- **领域服务**（如 `PointsService`、`InventoryService`、`ExchangeOperationService`）：
  - **必须**使用静态方法模式：`class XxxService { static async method() {} }`。
  - 直接 `require('../models')` 获取所需模型，不通过额外 Repository 抽象。
  - 如果需要其他 Service，**优先**通过 `ServiceManager` 注入（见 `services/index.js` 已有的 `initialize` 调用）。

- **基础设施 / 引擎类服务**（如 `UnifiedLotteryEngine`、`ChatWebSocketService`）：
  - 可以由 `ServiceManager` 以实例方式注册；保持当前模式，不再新建此类复杂组件，除非确有需求。

### 3.2 事务与幂等（数据一致性核心）

#### 事务处理标准模式（强制遵守）

**参考 `PointsService` 的实际实现**：

```javascript
static async consumePoints(userId, amount, options = {}) {
  const { transaction: externalTransaction } = options
  
  // 支持外部事务传入
  const transaction = externalTransaction || await sequelize.transaction()
  const shouldCommit = !externalTransaction
  
  try {
    // 使用悲观锁查询
    const account = await UserPointsAccount.findOne({
      where: { user_id: userId },
      lock: transaction.LOCK.UPDATE,
      transaction
    })
    
    // 业务逻辑...
    
    if (shouldCommit) {
      await transaction.commit()
    }
    return result
  } catch (error) {
    if (shouldCommit) {
      await transaction.rollback()
    }
    throw error
  }
}
```

**关键设计**：
- ✅ 支持外部事务传入（跨 Service 调用时共享事务）
- ✅ 只有自己创建的事务才 commit/rollback
- ✅ 使用悲观锁（FOR UPDATE）防止并发问题

**强制约束**：
- 写操作涉及多表时，**必须**在服务层开启事务：`const tx = await sequelize.transaction()`；  
  对“扣积分 / 改库存 / 下兑换订单”这三类资产写操作，**一律不得**拆成多个事务分步提交。
- 被复用的底层方法（如 `PointsService.consumePoints`、`InventoryService.transferItem`、`ExchangeMarketService.createOrderWithPoints` 等）  
  **必须**支持外部传入事务：`options.transaction`。
  - Exchange 相关链路（用积分购买/兑换商品）**必须**在同一事务中完成：扣积分账户 + 写积分交易明细 + 创建/更新兑换订单记录。

#### 幂等控制标准模式（强制遵守）

**参考 `PointsService` 的实际实现**：

```javascript
// 通过 business_id 防止重复提交
if (business_id) {
  const existingTx = await PointsTransaction.findOne({
    where: { business_id },
    transaction
  })
  
  if (existingTx) {
    // 已存在，返回原结果（幂等）
    return { success: true, transaction_id: existingTx.transaction_id }
  }
}
```

**强制约束**：
- 涉及积分、兑换、退款等**可被重复触发**的业务，**必须**使用 `business_id` 做幂等。
- 新增类似流程时沿用现有模式，不再新增第二套幂等实现方式。

**适用场景**：
- ✅ 兑换扣积分（business_id: `exchange_${exchangeId}`）
- ✅ 退款操作（business_id: `refund_${orderId}`）
- ✅ 消费奖励（business_id: `consumption_${recordId}`）
- ✅ 转让物品（business_id: `transfer_${itemId}_${timestamp}`）
- ✅ 使用物品（business_id: `use_${itemId}_${timestamp}`）

#### 批量运营工具例外

- 像 `ExchangeOperationService.batchApproveOrders` 这类"批量运营工具"，  
  可以按当前实现逐条处理、非整体事务，但：
  - 每个订单的状态流转必须由领域对象 / 领域服务保证一致性（如 `exchange.approve()` 内部负责事务与写入）。
  - 批量接口必须记录详细失败原因，不得"吞掉异常"。

### 3.3 领域边界

- **服务可以做**：
  - 操作自己负责领域的表（`PointsService` 操作 `UserPointsAccount` / `PointsTransaction`）。  
  - 调用其他 Service 的公开方法进行跨领域协作（如兑换成功后调用库存 Service 创建 `UserInventory`）。

- **服务禁止做**：
  - 直接操作其他领域的核心表而绕过对应 Service（例如库存相关表直接在积分服务里更新）。  
  - 在同一个方法里堆过多职责：一个方法同时做查询、统计、导出、通知。

**领域与模型映射（当前实际状态）**：

| 领域 | 负责表 | Service | 核心方法示例 | 业务边界强制约束 |
|------|--------|---------|-------------|---------------|
| 积分 | user_points_accounts<br>points_transactions | PointsService | addPoints()<br>consumePoints()<br>refundPoints() | 只负责积分账户变动，不得直接操作兑换市场订单表 |
| 库存 | user_inventory<br>trade_records | InventoryService | getUserInventory()<br>useItem()<br>transferItem() | 只负责物品库存流转，不得直接操作积分/订单表 |
| 兑换市场 | exchange_items<br>exchange_market_records | ExchangeMarketService | getMarketItems()<br>exchangeItemWithVirtual() | **禁止积分支付**：只处理虚拟价值（virtual）支付，不得调用 `PointsService.consumePoints()` 或操作积分相关表 |
| 审核 | content_review_records<br>admin_operation_logs | ContentAuditEngine<br>AuditLogService | createAudit()<br>approve()<br>reject() | 审核流程与资产变动解耦，通过回调触发资产操作 |

**兑换市场特殊约束（强制）**：
- `ExchangeMarketService` 的所有方法**禁止**接受 `points` / `points_amount` / `points_paid` 等参数。
- 路由层调用兑换市场 API 时，如传入任何包含 `points` 关键字的参数，**必须**在路由层校验并立即拒绝（返回 400 错误）。
- Service 层方法签名示例（正确）：
  ```javascript
  // ✅ 正确：只接受虚拟价值参数
  static async exchangeItemWithVirtual(userId, itemId, virtualAmount, options = {})
  
  // ❌ 错误：不得出现 points 相关参数
  static async exchangeItem(userId, itemId, pointsAmount, options = {})
  ```

### 3.4 服务拆分与命名（避免过度设计）

#### Service 创建门槛（强制）

**新建独立 Service 必须满足以下任一条件**：
1. 承载核心域逻辑（积分、库存、抽奖引擎等），且有明显事务边界和复杂状态机。  
2. 被 **≥5 个路由**或 **≥2 个 Service** 调用。  
3. 方法数量 **≥5 个**且逻辑内聚（不是为了"统一"而强行凑在一起）。

**否则**：优先放入现有 Service（如 `AdminSystemService`、`StatisticsService`），避免碎片化。

#### Admin 侧服务合并规则（强制）

**现状问题**：存在多个只有 1–3 个接口的小 Admin Service，导致服务数量膨胀。

**合并规则**：
- **统计/报表类**：`AdminAnalyticsService` + `StatisticsService` + `UserDashboardService` → 合并为 `ReportingService`。
- **系统配置类**：`AdminSystemService` + `SystemSettingsService` + 其他小配置 Service → 合并为统一的 `AdminSystemService`。
- **市场管理类**：`AdminMarketplaceService` → 合并到 `ExchangeMarketService`（增加管理方法）。

**判断标准**：
- Admin 功能优先在对应领域 Service 内增加管理方法（如 `PointsService.adminAdjustPoints()`）。
- 只有当 Admin 功能与 C 端完全不同且复杂度高时，才考虑独立 Admin Service。

#### Service 命名规范

- **领域服务**：`XxxService`（如 `PointsService`、`InventoryService`）。
- **引擎/基础设施**：`XxxEngine` / `XxxManager`（如 `UnifiedLotteryEngine`、`ServiceManager`）。
- **禁止**：为简单功能使用"引擎""平台""子域"等重量级术语（除非真是核心域复杂组件）。

### 3.5 服务层审查清单

- 新增 / 修改的 Service 是否遵守静态方法 + 领域边界。  
- 是否正确处理事务与幂等；有无遗漏的回滚或重复提交风险。  
- 是否滥建新 Service，而不是合并进现有合适的 Service。
- 是否跨领域直接操作其他领域的表（必须通过对应 Service）。
- Service 头部注释是否与代码复杂度匹配（简单 Service < 50 行注释，复杂 Service < 150 行注释）。

---

## 四、模型层规范（models/*）

### 4.1 模型注册与命名

- 所有模型**必须**在 `models/index.js` 中统一注册，并附简短注释说明用途（参考现有内容）。  
- 表命名保持当前风格：`snake_case_plural`（如 `user_points_accounts`、`points_transactions`）。  
- 一个业务概念只保留一套模型（旧模型已在 `index.js` 注释为"已删除"的不再复活）。

### 4.2 业务含义与边界

- 每个模型注释里已经约定了业务含义，例如：
  - `UserPointsAccount` / `PointsTransaction`：积分账户 + 交易日志。  
  - `ExchangeRecords`（旧系统，冻结状态）：历史积分兑换订单，仅用于查询历史数据或后台处理存量订单。  
  - `ExchangeMarketRecord`（新系统）：兑换市场虚拟价值订单，**只支持非积分支付**（`price_type = 'virtual'`）。  
  - `UserInventory` + `TradeRecord`：库存 + 转让记录。  
  - `ContentReviewRecord` vs `AdminOperationLog`：业务审核记录 vs 管理员操作审计。  
- **新增模型时必须写清**：
  - 与现有模型的关系（替代 / 互斥 / 关联）。  
  - 是否参与事务与幂等（例如是否需要与积分账户联动）。
- **兑换市场模型特殊约束（强制）**：
  - `ExchangeMarketRecord` 模型定义中，**推荐**增加数据库层面的防呆约束：
    - `CHECK (points_paid = 0 OR points_paid IS NULL)`（如字段存在但不再使用）。
    - `CHECK (payment_type != 'points')`（枚举约束，排除积分支付）。
    - 或直接移除 `points_paid` / `points_amount` 等字段（如无历史兼容需求）。
  - 模型注释中**必须**明确声明："本订单表只用于虚拟价值兑换，禁止积分支付"。

### 4.3 模型层审查要点

- 是否已经在 `index.js` 正确注册，并带有中文注释说明用途。  
- 是否与现有模型边界冲突（例如再造一个"积分交易表"是禁止的）。  
- 是否需要在对应 Service 中增加事务 / 审计 / 幂等配套逻辑。

---

## 五、数据输出与脱敏规范（视图常量）

### 5.1 视图常量模式（当前实现）

- 已在以下服务中落地：
  - `PointsService` 中的 `POINTS_ATTRIBUTES.userView/adminView/transactionView`。  
  - `InventoryService` 中的 `INVENTORY_ATTRIBUTES.ownerView/adminView/...`。

- **强制约束**：
  - Controller / Route **不得**直接写 `attributes: [...]`；只能调用 Service 提供的方法。  
  - 视图常量定义在 Service 顶部，**只包含字段名数组**，不写任何 if/else。  
  - 绝对不应对外暴露的字段（如内部审计字段）**不能**出现在任何视图常量里。

### 5.2 何时需要视图常量

- **推荐使用**：
  - 同一模型存在 **≥3 种输出场景**（用户端、管理端、统计、详情）。  
  - 字段列表在多个方法中重复使用。  
- **不推荐使用**：
  - 某模型只在 1–2 处简单查询，且字段稳定；直接在查询里写 `attributes` 即可。

### 5.3 toView / buildResponse 函数

- 对于复杂聚合返回（如管理端抽奖管理状态、库存详情），**建议**：
  - 在 Service 内提供 `_toXxxView(row)` 或 `buildXxxResponse()`。  
  - 路由层只负责调用并返回，不再自己拼装深层嵌套结构。  
- 对于**导出/下载类接口**（Excel、CSV 等二进制流）：
  - 允许直接 `res.send(buffer)` 返回二进制内容，**不强制使用 ApiResponse 包装**。  
  - 但路由上方必须有明确注释声明：  
    - `// 导出接口：返回二进制文件流（例如 Excel），不使用 ApiResponse 包装，规范允许的特例`。  
  - 其他普通 JSON API 不得以“导出”为由规避统一响应规范。
- 审查时优先看：
  - 是否所有计算字段都集中在 Service，而不是分散在多个路由。

---

## 六、数据一致性与审计规范

### 6.1 一致性保障手段

- **事务**：
  - 涉及积分变动、库存变动、兑换订单状态变更时，必须在 Service 使用事务包裹整条链路。  
    - **尤其是**“扣积分 + 改库存 + 写兑换订单”这类跨多个资产的写操作，**必须在同一 MySQL 事务内一次性完成**，禁止拆成多次 `save()` 或多事务拼接。  
  - 下层服务 / 模型方法如果需要参与事务，必须接受 `options.transaction` 并使用行级锁（当前在积分和库存服务中已实现）。

- **幂等**：
  - 所有"可能被重复调用"的敏感操作必须带 `business_id`（尤其是积分增减、退款）。  
  - 兑换市场订单相关链路（下单/支付/继续支付/重试）**必须**沿用相同的 `business_id` 幂等模式，防止重复扣减积分或生成重复订单。  
  - 审查时如果看到有新的扣分/加分/下兑换订单逻辑，但没有幂等机制，视为 P0 问题。

- **审计与业务审核**：
  - 系统内已有区分：
    - `ContentReviewRecord`：业务审核流程（兑换、内容审核等）。  
    - `AdminOperationLog` / `AuditLogService`：管理员操作日志（敏感操作追溯）。  
  - 新增涉及人工审核或敏感操作的流程时：
    - 必须复用上述两类现有模型 / 服务，不再新建第三套"审核表 / 审计表"。

### 6.2 一致性审查清单

- 是否明确事务边界：谁开启事务、谁接收 `transaction` 参数。  
- 是否有幂等控制（`business_id` 或同等唯一约束）。  
- 是否选用了正确的审计载体（ContentReviewRecord vs AdminOperationLog）。  
- 是否处理了失败场景：事务回滚 / 局部失败记录 / 重试策略。

---

## 七、兑换市场业务隔离规范（强制）

### 7.1 业务语义彻底分离（架构定位）

**背景问题**：
- 历史上存在"积分兑换"（`ExchangeRecords`）和"兑换市场"（`ExchangeMarketRecord`）两条链路，边界模糊。
- 部分代码混用了积分支付和虚拟价值支付，导致资产模型不一致。

**强制规则**：
- **兑换市场（Exchange Market）**：
  - **唯一定位**：只处理"虚拟价值 → 兑换商品（虚拟/实体）"的订单流程。
  - **载体表**：`ExchangeMarketRecord`（或等价命名）。
  - **负责 Service**：`ExchangeMarketService`。
  - **支付类型**：只支持 `virtual`（虚拟价值）或其他非积分形式，**绝对禁止**积分支付。
  
- **旧积分兑换系统（Exchange Records）**：
  - **定位**：历史系统，处于"冻结/逐步下线"状态。
  - **载体表**：`ExchangeRecords`（如仍保留）。
  - **使用限制**：只读或仅后台处理存量历史订单，**不得在新功能中扩展**。
  - **未来方向**：如确定不再使用，应在单独的数据迁移文档中规划下线路径。

**判断标准**：
- 新增任何"用户购买商品"的需求，如支付方式是**虚拟价值**，走 `ExchangeMarketService`。
- 如支付方式是**积分**，则属于历史兑换系统范畴（冻结状态，不再新增）。

---

### 7.2 支付类型强制校验（防呆机制）

**目标**：在代码层面强制阻止"积分支付混入兑换市场"的路径，而不是依赖约定。

**强制约束**：

#### 7.2.1 Service 层入口校验

```javascript
// ✅ 正确：ExchangeMarketService 强制校验支付类型
class ExchangeMarketService {
  static async createExchangeOrder(userId, itemId, paymentInfo, options = {}) {
    const { transaction } = options
    
    // 🔴 强制校验：禁止积分支付
    if (paymentInfo.payment_type === 'points' || paymentInfo.price_type === 'points') {
      throw new Error('兑换市场不支持积分支付，请使用虚拟价值支付')
    }
    
    // 🔴 强制校验：只允许 virtual 支付
    if (paymentInfo.payment_type !== 'virtual') {
      throw new Error(`不支持的支付类型: ${paymentInfo.payment_type}`)
    }
    
    // 业务逻辑...
  }
}

// ❌ 错误：不做任何校验，允许 points 传入
class ExchangeMarketService {
  static async createExchangeOrder(userId, itemId, paymentInfo, options = {}) {
    // 直接使用 paymentInfo，没有校验 payment_type
    // 可能导致 points 混入
  }
}
```

#### 7.2.2 路由层参数校验

```javascript
// ✅ 正确：路由层预先拒绝包含 points 的请求
router.post('/exchange-market/order', authenticateToken, async (req, res) => {
  const { item_id, payment_type, points_amount } = req.body
  
  // 🔴 强制校验：拒绝任何 points 相关参数
  if (payment_type === 'points' || points_amount) {
    return res.apiError(
      '兑换市场不支持积分支付', 
      'BAD_REQUEST', 
      null, 
      400
    )
  }
  
  // 调用 Service...
})

// ❌ 错误：路由层不校验，直接透传给 Service
router.post('/exchange-market/order', authenticateToken, async (req, res) => {
  // 直接 await ExchangeMarketService.createOrder(req.body)
  // 依赖 Service 层校验，但路由层应该更早拦截
})
```

#### 7.2.3 数据写入前最终校验

```javascript
// ✅ 正确：写入数据库前最终防线
class ExchangeMarketService {
  static async _saveOrderRecord(orderData, transaction) {
    // 🔴 最终防线：确保 points_paid 为 0
    if (orderData.points_paid && orderData.points_paid > 0) {
      throw new Error('数据异常：兑换市场订单不得包含积分支付金额')
    }
    
    // 🔴 最终防线：确保 payment_type 不是 points
    if (orderData.payment_type === 'points') {
      throw new Error('数据异常：兑换市场订单支付类型不得为 points')
    }
    
    // 强制覆盖为 0（防御性编程）
    orderData.points_paid = 0
    
    await ExchangeMarketRecord.create(orderData, { transaction })
  }
}
```

**校验层次**：
1. **路由层**：最早拦截，拒绝包含 `points` 关键字的请求参数（400 错误）。
2. **Service 入口**：业务逻辑前校验支付类型，不符合立即抛出错误。
3. **数据写入前**：最终防线，确保落库数据不包含积分支付信息。

---

### 7.3 数据模型防呆约束（推荐纵深防御）

**目标**：在数据库层面增加约束，防止绕过 Service 直接写库。

**推荐约束**（不强制，但作为防御纵深）：

#### 7.3.1 字段约束

```sql
-- ✅ 推荐：在 ExchangeMarketRecord 表上增加 CHECK 约束
ALTER TABLE exchange_market_records
ADD CONSTRAINT chk_no_points_payment 
CHECK (points_paid = 0 OR points_paid IS NULL);

-- ✅ 推荐：枚举约束，排除 points
ALTER TABLE exchange_market_records
ADD CONSTRAINT chk_payment_type_virtual
CHECK (payment_type != 'points');
```

#### 7.3.2 字段移除（最彻底方案）

```sql
-- ✅ 最彻底：如无历史兼容需求，直接移除 points 相关字段
ALTER TABLE exchange_market_records
DROP COLUMN points_paid;

ALTER TABLE exchange_market_records
DROP COLUMN points_amount;
```

**Sequelize 模型定义对应**：

```javascript
// ✅ 正确：模型定义中明确约束
const ExchangeMarketRecord = sequelize.define('ExchangeMarketRecord', {
  payment_type: {
    type: DataTypes.ENUM('virtual', 'coupon'), // 不包含 'points'
    allowNull: false,
    validate: {
      isNotPoints(value) {
        if (value === 'points') {
          throw new Error('兑换市场不支持积分支付')
        }
      }
    }
  },
  points_paid: {
    type: DataTypes.DECIMAL(10, 2),
    defaultValue: 0,
    validate: {
      isZero(value) {
        if (value && value > 0) {
          throw new Error('兑换市场订单不得包含积分支付金额')
        }
      }
    }
  }
}, {
  comment: '兑换市场订单表 - 只支持虚拟价值支付，禁止积分支付'
})
```

**模型注释强制要求**：

```javascript
/**
 * ExchangeMarketRecord - 兑换市场订单表
 * 
 * 业务边界（强制）：
 * - 只处理虚拟价值（virtual）支付的兑换订单
 * - 禁止积分（points）支付：payment_type 不得为 'points'
 * - 所有订单 points_paid 必须为 0 或 NULL
 * 
 * 与旧系统的关系：
 * - ExchangeRecords：历史积分兑换系统（冻结状态）
 * - ExchangeMarketRecord：新兑换市场系统（只支持虚拟价值）
 */
```

---

### 7.4 Service 方法签名规范（强制）

**目标**：从方法签名层面防止 `points` 参数传入。

**强制约束**：

```javascript
// ✅ 正确：ExchangeMarketService 方法不接受 points 参数
class ExchangeMarketService {
  /**
   * 创建兑换市场订单（虚拟价值支付）
   * @param {number} userId - 用户ID
   * @param {number} itemId - 商品ID
   * @param {number} virtualAmount - 虚拟价值金额
   * @param {object} options - 可选参数（transaction、business_id 等）
   */
  static async createExchangeOrder(userId, itemId, virtualAmount, options = {}) {
    // 方法签名中完全不出现 points / pointsAmount / pointsPaid
  }
  
  /**
   * 虚拟价值兑换商品（完整流程）
   * @param {number} userId - 用户ID
   * @param {number} itemId - 商品ID
   * @param {object} paymentInfo - 支付信息 { payment_type: 'virtual', amount: 100 }
   */
  static async exchangeItemWithVirtual(userId, itemId, paymentInfo, options = {}) {
    // paymentInfo 对象内部不包含 points 相关字段
  }
}

// ❌ 错误：方法签名包含 points 参数
class ExchangeMarketService {
  static async exchangeItem(userId, itemId, pointsAmount, options = {}) {
    // 错误：出现 pointsAmount 参数名
  }
  
  static async createOrder(userId, itemId, paymentInfo, options = {}) {
    // 如果 paymentInfo 可能包含 { payment_type: 'points', points_amount: 100 }
    // 则方法设计就是错误的
  }
}
```

**命名规范**：
- ✅ 使用 `virtualAmount` / `virtualValue` / `virtual_price` 等命名（明确非积分）。
- ❌ 禁止使用 `points` / `pointsAmount` / `points_cost` / `points_paid` 等命名。

---

### 7.5 事务与审计日志规范（兑换市场专项）

**强制约束**：

```javascript
// ✅ 正确：兑换市场订单创建的完整流程
class ExchangeMarketService {
  static async createExchangeOrder(userId, itemId, virtualAmount, options = {}) {
    const { transaction: externalTransaction } = options
    const transaction = externalTransaction || await sequelize.transaction()
    const shouldCommit = !externalTransaction
    
    try {
      // 1. 支付类型校验（强制）
      if (!this._isValidVirtualPayment(virtualAmount)) {
        throw new Error('虚拟价值支付参数无效')
      }
      
      // 2. 生成幂等键（强制）
      const business_id = options.business_id || `exchange_market_${itemId}_${Date.now()}`
      
      // 3. 幂等检查（强制）
      const existing = await ExchangeMarketRecord.findOne({
        where: { business_id },
        transaction
      })
      if (existing) {
        return { success: true, order_id: existing.order_id }
      }
      
      // 4. 扣减虚拟价值（调用对应 Service，如 VirtualCurrencyService）
      // 注意：不得调用 PointsService.consumePoints()
      await VirtualCurrencyService.consume(userId, virtualAmount, {
        transaction,
        business_id: `${business_id}_virtual`
      })
      
      // 5. 创建订单记录（强制 points_paid = 0）
      const order = await this._saveOrderRecord({
        user_id: userId,
        item_id: itemId,
        payment_type: 'virtual',
        virtual_amount: virtualAmount,
        points_paid: 0, // 强制为 0
        business_id
      }, transaction)
      
      // 6. 审计日志（强制）
      await AuditLogService.log({
        operator_id: userId,
        operation_type: 'exchange_market_order',
        target_type: 'order',
        target_id: order.order_id,
        operation_detail: {
          item_id: itemId,
          payment_type: 'virtual',
          virtual_amount: virtualAmount,
          business_id
        },
        transaction
      })
      
      if (shouldCommit) {
        await transaction.commit()
      }
      
      return { success: true, order_id: order.order_id }
    } catch (error) {
      if (shouldCommit) {
        await transaction.rollback()
      }
      throw error
    }
  }
}
```

**审计日志必填字段**（兑换市场专项）：
- `operation_type: 'exchange_market_order'`（明确标识为兑换市场订单）
- `operation_detail.payment_type`（必须为 'virtual'）
- `operation_detail.virtual_amount`（虚拟价值金额）
- `operation_detail.business_id`（幂等键）

---

### 7.6 Code Review 兑换市场专项清单（强制）

**任何涉及兑换市场的 PR 必须检查以下各项**：

#### 路由层检查
- [ ] 路由参数是否包含 `points` / `points_amount` / `points_paid`（禁止出现）。
- [ ] 是否在路由层预先校验支付类型（拒绝 `payment_type = 'points'`）。
- [ ] 路由命名是否明确区分兑换市场（如 `/api/v4/exchange-market/*`）与旧兑换链路。

#### Service 层检查
- [ ] `ExchangeMarketService` 方法签名是否包含 `points` 相关参数（禁止出现）。
- [ ] 是否在 Service 入口强制校验 `payment_type = 'virtual'`（必须校验）。
- [ ] 是否调用了 `PointsService.consumePoints()` 或直接操作积分相关表（禁止调用）。
- [ ] 是否在数据写入前最终校验 `points_paid = 0`（必须校验）。
- [ ] 是否记录了 `business_id` 幂等键和审计日志（必须记录）。

#### 模型层检查
- [ ] `ExchangeMarketRecord` 模型注释是否明确声明"禁止积分支付"（必须声明）。
- [ ] 是否增加了 `payment_type` 枚举约束（推荐但非强制）。
- [ ] 是否增加了 `points_paid` 字段约束或移除该字段（推荐但非强制）。

#### 事务与一致性检查
- [ ] 如检测到积分支付尝试，是否立即抛出错误并回滚事务（必须回滚）。
- [ ] 兑换市场订单创建是否在单一事务内完成（虚拟价值扣减 + 订单创建）。
- [ ] 是否有完整的失败处理与日志记录（必须完整）。

---

### 7.7 历史代码兼容与迁移策略（非强制，仅供参考）

**如果现有代码已经混用了积分支付和虚拟价值支付**：

**短期策略（不阻塞新功能开发）**：
1. **新代码严格遵守规范**：所有新增的兑换市场功能必须遵守本章规则。
2. **存量代码打标记**：在旧代码中加注释标记 `// TODO: 迁移到虚拟价值支付模式`。
3. **双轨运行**：兑换市场新链路（虚拟价值）与旧链路（积分）暂时共存，但互不干扰。

**长期策略（可选，需单独立项）**：
1. **数据迁移**：历史订单从 `ExchangeRecords` 迁移到 `ExchangeMarketRecord`（如需要）。
2. **字段清理**：彻底移除 `ExchangeMarketRecord.points_paid` 等字段。
3. **旧表下线**：`ExchangeRecords` 进入只读状态或归档。

**判断标准**：
- 如果历史数据量大、业务影响范围广，**不强制立即迁移**。
- 如果历史数据量小、无历史订单依赖，**推荐直接清理**。

---

## 八、避免过度设计的统一约束

### 7.1 Service 拆分自查（基于行业实践）

**参考行业标准**：
- **大厂**（美团/阿里）：每个领域服务承载几十个 API（C 端 + Admin），不按菜单拆服务。
- **游戏公司**：核心三件套（账号、货币物品、交易日志），GM 后台复用同一套服务。
- **小公司**：模块化单体 + 粗颗粒领域 Service，避免微服务化。

**本项目推荐的 Service 数量**：
- **核心领域 Service**：6–8 个（PointsService、InventoryService、ExchangeMarketService、ConsumptionService、UnifiedLotteryEngine、UserService、ReportingService、AdminSystemService）。
- **禁止**：为每个后台页面/报表单独创建 Service，导致服务数量 > 15 个。

**自查清单**：
- [ ] 这个 Service 至少有 **5 个相关接口**吗？
- [ ] 这个 Service 会被**其他模块/Service 复用**吗？
- [ ] 不拆出独立 Service，现有代码会**难以维护**吗？（>500 行/逻辑混乱）
- [ ] **对比行业**：美团的订单服务有 50+ 接口，我这个只有 2 个接口真的需要独立吗？

### 7.2 抽象层引入门槛

**规则**：引入新的抽象层（Engine、Manager、Factory 等）必须满足：
1. 解决 **当前真实存在** 的痛点（而非理论上可能遇到的问题）。
2. 被 **≥3 个业务模块复用**。
3. 不增加 **≥30%** 的代码复杂度（新增抽象的收益 > 维护成本）。

**反例**（不建议引入）：
```javascript
// ❌ 为"可能未来要扩展"的场景引入策略工厂
class NotificationStrategyFactory {
  static create(type) {
    switch(type) {
      case 'email': return new EmailStrategy()
      case 'sms': return new SmsStrategy()
    }
  }
}

// ✅ 当前只有一种通知方式，直接实现
class NotificationService {
  static async send(userId, message) {
    // 直接发送，未来需要时再抽象
  }
}
```

### 7.3 文档复杂度匹配规则

**Service 文件头注释长度标准**：
- 简单 Service（<200 行，无复杂模式）：注释控制在 **50 行以内**。
- 中等 Service（200-500 行，有事务/状态）：注释控制在 **100 行以内**。
- 复杂 Service（>500 行，多模式/引擎）：注释可达 **150 行**。

**禁止**：为简单功能写 200 行架构注释，提到"策略模式""观察者模式""性能指标"等实际代码中不存在的内容。

### 7.4 当前项目的 Service 评估与建议

**✅ 保留的核心领域 Service**：

| Service | 接口数 | 复杂度 | 评估 |
|---------|-------|-------|------|
| PointsService | 15+ | 高（事务/幂等） | ✅ 优秀样板 |
| InventoryService | 20+ | 高（事务/权限） | ✅ 合理 |
| UnifiedLotteryEngine | 核心域 | 极高（策略/监控） | ✅ 合理抽象 |
| ExchangeMarketService | 10+ | 中高（交易协调） | ✅ 合理 |
| ConsumptionService | 8+ | 中（消费奖励） | ✅ 合理 |
| UserService | 10+ | 中（用户管理） | ✅ 合理 |

**⚠️ 建议合并的 Service**：

| 合并方向 | 原 Service | 理由 |
|---------|-----------|------|
| → ReportingService | AdminAnalyticsService<br>StatisticsService<br>UserDashboardService | 职责重叠（统计/报表），合并后 10+ 方法 |
| → AdminSystemService | AdminCustomerServiceService<br>SystemSettingsService | 接口过少（1–3 个），合并后统一管理 |
| → ExchangeMarketService | AdminMarketplaceService | 市场管理应在领域 Service 内 |

---

## 九、错误处理与日志规范

### 9.1 错误处理标准模式（保持现有简单模式）

**当前实际采用的模式**（基于 PointsService / InventoryService）：

```javascript
// Service 层：直接 throw Error
static async useItem(actorId, itemId, context = {}) {
  if (item.status !== 'available') {
    throw new Error(`物品状态为${item.status}，无法使用`)
  }
}

// Controller 层：捕获并分类
catch (error) {
  logger.error('使用物品失败', { error: error.message, item_id })
  
  if (error.message.includes('无权限')) {
    return res.apiError(error.message, 'FORBIDDEN', null, 403)
  } else if (error.message.includes('状态')) {
    return res.apiError(error.message, 'BAD_REQUEST', null, 400)
  } else {
    return res.apiError('使用物品失败', 'INTERNAL_ERROR', null, 500)
  }
}
```

**强制约束**：
- ✅ Service 层直接 throw Error，Controller 层捕获分类。
- ✅ 保持现有的简单错误处理模式。
- ❌ **禁止**引入复杂的 BusinessError 类体系（当前阶段不需要）。

### 9.2 日志记录规范

**标准日志格式**（基于 BeijingTimeHelper + Logger）：

```javascript
logger.error('操作失败', {
  error: error.message,
  user_id: userId,
  item_id: itemId,
  operation: 'use_item',
  timestamp: BeijingTimeHelper.now()
})
```

**强制约束**：
- 所有错误日志必须包含：`error.message` + 关键业务 ID（user_id / item_id / transaction_id 等）。
- 敏感操作（积分变动、权限变更、审核通过/拒绝）必须记录操作日志（通过 `AuditLogService`）。

---

## 十、PR 审查总清单

### 10.1 路由层检查

- [ ] 是否只做 4 件事：鉴权、解析参数、调用 Service、统一响应。  
- [ ] 有无直接访问 `models` 或手写事务。  
- [ ] 是否使用 `ServiceManager` 和统一响应中间件。  
- [ ] 单个路由函数是否超过 50 行或含多层业务分支。
- [ ] 限流、权限校验是否符合已有类似接口的标准。

### 10.2 服务层检查

- [ ] 新增 / 修改的 Service 是否遵守静态方法 + 领域边界。  
- [ ] 是否正确处理事务与幂等；有无遗漏的回滚或重复提交风险。  
- [ ] 是否滥建新 Service（< 5 个接口且无复用），而不是合并进现有 Service。
- [ ] 是否跨领域直接操作其他领域的表（必须通过对应 Service）。
- [ ] Service 头部注释是否与代码复杂度匹配。

### 10.3 模型层检查

- [ ] 新模型是否在 `models/index.js` 注册并写明用途。  
- [ ] 是否复用了现有业务模型而不是重新造轮子。  
- [ ] 是否考虑到与现有事务 / 审计 / 幂等逻辑的衔接。

### 10.4 数据一致性与安全

- [ ] 每条"会改积分 / 库存 / 抽奖结果 / 权限"的代码路径，是否都经过 Service 层。  
- [ ] 是否有完整的失败处理与日志记录，便于问题追踪。  
- [ ] 是否保持了与当前实现一致的时间 / 时区 / 日志规范（例如统一使用 `BeijingTimeHelper`）。
- [ ] 涉及敏感操作是否记录审计日志（通过 `AuditLogService`）。

### 10.6 兑换市场专项检查（强制）

- [ ] **支付类型校验**：兑换市场相关接口是否强制校验 `payment_type != 'points'` 或 `price_type = 'virtual'`。
- [ ] **参数命名约束**：路由/Service 方法是否出现 `points` / `points_amount` / `points_paid` 等参数名（禁止出现）。
- [ ] **Service 边界隔离**：`ExchangeMarketService` 是否调用了 `PointsService.consumePoints()` 或直接操作积分相关表（禁止调用）。
- [ ] **事务回滚机制**：如检测到积分支付尝试，是否立即抛出错误并回滚整个事务（不得部分提交）。
- [ ] **审计日志完整性**：兑换市场订单创建/更新是否记录了 `business_id` 幂等键和审计日志（必须记录）。
- [ ] **模型约束对齐**：`ExchangeMarketRecord` 模型定义是否添加了防呆约束或在注释中明确声明"禁止积分支付"（推荐但非强制）。

### 10.5 胖路由专项检查

- [ ] 路由文件总行数是否 < 800 行。
- [ ] 单个路由函数是否 < 50 行（不含注释）。
- [ ] 是否有直接操作 models 的代码（`models.Xxx.*`）。
- [ ] 是否有在路由内开启事务的代码（`sequelize.transaction()`）。
- [ ] 是否有在路由内实现多步业务流程的代码。

---

## 附录 A：胖路由重构前后对比（样板）

### A.1 inventory.js 重构对比

**重构前（胖路由 - 反面教材）**：

```javascript
// routes/v4/unified-engine/inventory.js（部分代码）
router.get('/user/:user_id', authenticateToken, async (req, res) => {
  try {
    const { user_id } = req.params
    const { status, type, page = 1, limit = 20 } = req.query
    
    // ❌ 权限检查逻辑在 Controller
    const userRoles = await getUserRoles(req.user.user_id)
    if (requestedUserId !== req.user.user_id && !userRoles.isAdmin) {
      return res.apiError('无权限', 'FORBIDDEN', null, 403)
    }
    
    // ❌ 构建查询条件在 Controller
    const whereConditions = { user_id }
    if (status) whereConditions.status = status
    if (type) whereConditions.type = type
    
    // ❌ 直接操作 Model
    const { count, rows } = await models.UserInventory.findAndCountAll({
      where: whereConditions,
      order: [['acquired_at', 'DESC']],
      limit: finalLimit,
      offset
    })
    
    // ❌ 业务逻辑在 Controller
    const processed = rows.map(item => {
      const data = item.toJSON()
      data.status_description = getStatusDescription(data.status)
      return data
    })
    
    // ❌ 数据脱敏在 Controller
    const sanitized = DataSanitizer.sanitize(processed, dataLevel)
    
    return res.apiSuccess({ inventory: sanitized, ... })
  } catch (error) {
    // 错误处理...
  }
})
```

**重构后（薄路由 - 正确样板）**：

```javascript
// routes/v4/unified-engine/inventory.js（重构后）
router.get('/user/:user_id', authenticateToken, async (req, res) => {
  try {
    const { user_id } = req.params
    const { status, type, page = 1, limit = 20 } = req.query
    
    // ✅ 参数验证
    const userId = parseInt(user_id, 10)
    if (isNaN(userId) || userId <= 0) {
      return res.apiError('无效的用户ID', 'BAD_REQUEST', null, 400)
    }
    
    // ✅ 调用 Service（所有业务逻辑在 Service 内）
    const InventoryService = req.app.locals.services.getService('inventory')
    const result = await InventoryService.getUserInventory(
      userId,
      { status, type, page, limit },
      { viewerId: req.user.user_id }
    )
    
    // ✅ 统一响应
    return res.apiSuccess(result, '获取库存列表成功')
  } catch (error) {
    if (error.message.includes('无权限')) {
      return res.apiError(error.message, 'FORBIDDEN', null, 403)
    }
    return res.apiError('获取库存失败', 'INTERNAL_ERROR', null, 500)
  }
})
```

### A.2 points.js 重构对比

**重构前（中度胖路由）**：

```javascript
router.get('/balance', authenticateToken, async (req, res) => {
  try {
    const user_id = req.user.user_id
    
    // ❌ 直接操作 Model 验证用户
    const { User } = models
    const user = await User.findByPk(user_id)
    if (!user) {
      return res.apiError('用户不存在', 'USER_NOT_FOUND', {}, 404)
    }
    
    // ❌ 直接操作 Model 查询账户
    const account = await UserPointsAccount.findOne({
      where: { user_id }
    })
    if (!account) {
      return res.apiError('积分账户不存在', 'POINTS_ACCOUNT_NOT_FOUND', {}, 404)
    }
    
    // ❌ 业务逻辑在 Controller
    if (!account.is_active) {
      return res.apiError('账户已冻结', 'ACCOUNT_FROZEN', {}, 403)
    }
    
    // ✅ 调用 Service（部分逻辑已下沉）
    const points_overview = await PointsService.getUserPointsOverview(user_id)
    
    return res.apiSuccess({ ...points_overview }, '积分余额查询成功')
  } catch (error) {
    // 错误处理...
  }
})
```

**重构后（薄路由）**：

```javascript
router.get('/balance', authenticateToken, async (req, res) => {
  try {
    const user_id = req.user.user_id
    
    // ✅ 调用 Service（Service 内部完成所有验证和业务逻辑）
    const PointsService = req.app.locals.services.getService('points')
    const { account } = await PointsService.getUserAccount(user_id)
    const overview = await PointsService.getUserPointsOverview(user_id)
    
    // ✅ 统一响应
    return res.apiSuccess({ ...overview }, '积分余额查询成功')
  } catch (error) {
    if (error.message.includes('不存在')) {
      return res.apiError(error.message, 'NOT_FOUND', null, 404)
    }
    if (error.message.includes('冻结')) {
      return res.apiError(error.message, 'FORBIDDEN', null, 403)
    }
    return res.apiError('获取积分失败', 'INTERNAL_ERROR', null, 500)
  }
})
```

---

## 附录 B：关键技术决策

### B.1 为什么 Service 采用静态方法？

**参考现有代码**：
- `PointsService`、`InventoryService`、`ExchangeMarketService` 全部使用静态方法。

**优点**：
- ✅ 无需实例化，直接调用：`PointsService.addPoints()`。
- ✅ 无状态设计，线程安全。
- ✅ 与现有 Service 风格一致。

**结论**：✅ **采用静态方法**，与现有技术路线保持一致。

### B.2 为什么不引入 Repository 层？

**理由**：
- 当前项目规模下，Sequelize Model 已经提供了足够的数据访问能力。
- 引入 Repository 会增加一层抽象，但没有带来明显收益（无复杂查询逻辑需要复用）。
- 与现有代码风格不一致（PointsService / InventoryService 直接使用 models）。

**结论**：✅ **不引入 Repository 层**，Service 直接使用 Sequelize Model。

### B.3 为什么不引入依赖注入框架？

**理由**：
- 当前项目使用 `ServiceManager` 手动管理服务实例，已经满足需求。
- 引入 InversifyJS / Awilix 等 DI 框架会增加学习成本和配置复杂度。
- 与现有代码风格不一致（静态方法 Service 不需要 DI）。

**结论**：✅ **不引入 DI 框架**，保持 ServiceManager 手动管理模式。

### B.4 数据脱敏策略选择

**当前实际采用的方式**：
- 通过 Sequelize `attributes` 控制字段（inventory.js / points.js 实际实现）。
- 管理员查看敏感数据时记录审计日志（已有实现）。

**DataSanitizer 现状**：
- 已引入但实际代码中未使用。

**结论**：
- ✅ 继续使用 Sequelize `attributes` + 视图常量模式。
- ✅ 不强制使用 DataSanitizer（保持简单）。
- ✅ 管理员查看敏感数据时记录审计日志。

---

## 十一、规范执行优先级与适用性说明

### 11.1 规范分级体系

本文档所有规范按照"当前项目规模与业务复杂度"分为三个级别：

#### 🔴 P0 - 核心强制规范（立即生效，所有新代码必须遵守）

**适用场景**：涉及积分、库存、抽奖结果、权限、兑换订单等**核心资产/状态变更**的业务逻辑。

**强制约束**：
- ✅ **系统形态**：在当前项目中，资产相关逻辑**必须**运行在“单体 Node.js + 单库 MySQL”形态下，不得擅自拆分为跨库/跨服务架构，也不得引入 MQ/Saga 型补偿事务来处理本规范已经覆盖的场景。  
- ✅ **资产模型**：  
  - 积分 = `UserPointsAccount` + `PointsTransaction`；  
  - 虚拟物品 = `UserInventory` + `TradeRecord`；  
  - 兑换市场 = `ExchangeMarketRecord`（或等价订单表），并由 `ExchangeMarketService` 统一封装状态流转。  
  - 新增资产类能力时，应优先在这三类模型/Service 基础上扩展，而非旁路新增第二套“积分/库存/订单”体系。
- ❌ **路由层禁止直接操作 models**（`models.Xxx.*` 调用）
- ❌ **路由层禁止开启事务**（`sequelize.transaction()`）
- ❌ **Service 禁止跨领域直接操作其他领域的表**（必须通过对应 Service）
- ✅ **所有敏感操作必须有事务保护 + 幂等控制 + 审计日志**：
  - “扣积分 / 改库存 / 下兑换订单”这三类操作，**必须**满足：单库事务 + 行级锁 + `business_id` 幂等；  
  - “改权限 / 改关键配置”必须通过对应 Service 统一入口（如 `UserRoleService.updateUserRole`），在入口内同时完成校验 + 事务 + 审计（`AuditLogService`）+ 缓存失效。
- ✅ **必须使用 ServiceManager 获取服务**（`req.app.locals.services.getService()`）
- ✅ **必须使用统一响应中间件**（`res.apiSuccess / res.apiError / res.apiInternalError`）

**技术标准**：
- ✅ Service 层采用静态方法（与现有 PointsService / InventoryService 一致）
- ✅ 事务处理支持外部传入（`options.transaction` 参数）
- ✅ 幂等性通过 `business_id` 控制（防止重复提交）
- ✅ 错误处理保持简单直接（Service 层 throw Error，Controller 层分类处理）

**判断标准**：如果你的新功能会"改积分余额 / 改库存状态 / 改抽奖结果 / 改用户权限 / 改订单状态"，必须严格遵守 P0 规范。

---

#### 🟡 P1 - 重要建议规范（新代码推荐遵守，存量代码渐进优化）

**适用场景**：只读查询、后台展示、统计报表、简单 CRUD 等**非核心资产变更**的业务逻辑。

**建议约束**：
- ✅ 路由层保持薄层设计（只做鉴权、参数校验、调用 Service、统一响应）
- ✅ 单个路由函数控制在 **< 50 行**（不含注释）
- ✅ 单个路由文件控制在 **< 800 行**（含注释）
- ✅ 复杂查询逻辑下沉到 Service（避免在路由层拼装复杂条件）
- ✅ 数据脱敏通过 Sequelize `attributes` + 视图常量（当模型有 ≥3 种输出场景时）
 - ✅ 顶层接口（`/health`、`/api`、`/api/v4`、`/api/v4/docs` 等）也应通过统一适配函数遵循 ApiResponse 响应结构
 - ✅ 异步路由统一使用 `asyncHandler` 包裹，而不是在每个 handler 内手写 try/catch
 - ✅ 导出/下载接口如需直接返回二进制流，必须在注释中标明“规范允许的 ApiResponse 特例”

**技术建议**：
- ✅ 使用中间件（`asyncHandler`、`validatePositiveInteger` 等）简化路由代码
- ✅ 使用 Logger 记录关键操作（便于问题追踪）
- ✅ 参数验证使用统一中间件（不在路由内写大量 if/else 校验）

**判断标准**：如果你的新功能是"查询列表 / 查看详情 / 导出报表 / 后台展示"，推荐遵守 P1 规范，但不强制（可以先简单实现，后续优化）。

---

#### 🟢 P2 - 长期优化方向（中长期重构目标，不阻塞当前开发）

**适用场景**：代码整理、架构优化、技术债务清理等**非功能性改进**。

**执行原则**：
- ✅ 结合功能改动"顺手"优化，不做一次性大手术
- ✅ 优先优化高频修改的模块（避免低价值重构）
- ✅ 保持向后兼容，避免引入新风险
- ❌ 不为追求规范而暂停业务功能开发

---

##### P2.1 胖路由重构规范

**目标**：逐步将 `inventory.js`（1447 行）/ `points.js`（1361 行）等胖路由的业务逻辑下沉到 Service。

**重构标准**：
- **路由函数职责收敛**：只保留"参数校验 + 调用 Service + 统一响应"
- **超长文件拆分**：路由文件 > 800 行时，按子领域拆分（如 `inventory-core.js` + `inventory-market.js`）
- **超长函数拆分**：路由函数 > 50 行（不含注释）时，将业务逻辑抽取到 Service 方法

**渐进式重构策略**：
```javascript
// ❌ 禁止：一次性重构整个胖路由文件（风险高）
// ✅ 推荐：修改某个端点时，顺手重构该端点

// 示例：修改 inventory.js 的 /use 端点时
router.post('/use/:item_id', authenticateToken, async (req, res) => {
  try {
    // ✅ 将原本在路由内的业务逻辑下沉到 Service
    const InventoryService = req.app.locals.services.getService('inventory')
    const result = await InventoryService.useItem(
      req.user.user_id,
      req.params.item_id,
      { reason: req.body.reason }
    )
    return res.apiSuccess(result, '使用物品成功')
  } catch (error) {
    return handleServiceError(error, res, '使用物品失败')
  }
})
```

**重构优先级**：
1. **高优先级**：涉及事务/幂等的端点（积分扣减、库存变更、订单状态变更）
2. **中优先级**：高频修改的端点（经常改需求的功能）
3. **低优先级**：稳定且很少改动的端点（如简单查询）

---

##### P2.2 Service 整理与合并规范

**目标**：减少碎片化 Service，将职责接近的小 Service 按领域合并。

**合并标准**（基于当前项目实际 Service）：

| 合并方向 | 原 Service | 合并理由 | 预期方法数 |
|---------|-----------|---------|-----------|
| → ReportingService | AdminAnalyticsService<br>StatisticsService<br>UserDashboardService | 统计/报表职责重叠 | 10–15 个 |
| → AdminSystemService | AdminCustomerServiceService<br>SystemSettingsService | 接口过少（1–3 个） | 8–12 个 |
| → ExchangeMarketService | AdminMarketplaceService | 市场管理应在领域 Service 内 | 15–20 个 |

**合并执行策略**：
```javascript
// ✅ 推荐：新增管理功能时，直接在领域 Service 内增加管理方法
class PointsService {
  // C 端方法
  static async addPoints(userId, amount, options) { /* ... */ }
  static async consumePoints(userId, amount, options) { /* ... */ }
  
  // 管理端方法（直接在同一 Service 内）
  static async adminAdjustPoints(userId, amount, reason, operatorId) {
    // 管理员调整积分逻辑
  }
  
  static async adminFreezeAccount(userId, reason, operatorId) {
    // 管理员冻结账户逻辑
  }
}
```

**新 Service 创建门槛**（避免继续碎片化）：
- ❌ 禁止为 **< 5 个接口**的功能新建独立 Service
- ❌ 禁止为单个后台页面/报表新建 Service
- ✅ 优先在现有领域 Service 中增加方法（如 `PointsService.adminXxx()`）

---

##### P2.3 视图常量 / toView 模式推广规范

**目标**：统一数据输出字段管理，减少各处手写字段列表和拼装 JSON。

**推广标准**（基于 PointsService / InventoryService 已有实现）：

**何时推广视图常量**：
- ✅ 同一模型存在 **≥3 种输出场景**（用户端、管理端、统计、详情）
- ✅ 字段列表在多个方法中重复使用
- ❌ 某模型只在 1–2 处简单查询，且字段稳定（不推广，保持简单）

**标准实现模式**：
```javascript
// ✅ 在 Service 顶部定义视图常量
const EXCHANGE_ATTRIBUTES = {
  // 用户视图：用户查看自己的兑换订单
  userView: [
    'exchange_id',
    'item_name',
    'points_cost',
    'status',
    'created_at',
    'updated_at'
  ],
  
  // 管理员视图：管理员查看所有订单
  adminView: [
    'exchange_id',
    'user_id',
    'item_name',
    'points_cost',
    'status',
    'auditor_id',      // 管理员可见
    'audit_reason',    // 管理员可见
    'created_at',
    'updated_at'
  ]
}

// ✅ Service 方法中使用视图常量
class ExchangeMarketService {
  static async getUserOrders(userId, options = {}) {
    const orders = await ExchangeRecords.findAll({
      where: { user_id: userId },
      attributes: EXCHANGE_ATTRIBUTES.userView,  // 使用视图常量
      order: [['created_at', 'DESC']]
    })
    return orders
  }
}
```

**复杂聚合返回的 toView 模式**：
```javascript
// ✅ 对于需要计算字段/关联数据的复杂返回，提供 toView 方法
class ExchangeMarketService {
  static _toOrderDetailView(order, includeAuditInfo = false) {
    const baseView = {
      exchange_id: order.exchange_id,
      item_name: order.item_name,
      points_cost: order.points_cost,
      status: order.status,
      status_text: this._getStatusText(order.status),  // 计算字段
      created_at: order.created_at
    }
    
    if (includeAuditInfo && order.auditor_id) {
      baseView.audit_info = {
        auditor_id: order.auditor_id,
        audit_reason: order.audit_reason,
        audit_time: order.audit_time
      }
    }
    
    return baseView
  }
}
```

---

##### P2.4 日志与审计规范收敛

**目标**：将敏感操作的日志记录统一到 `AuditLogService`，确保可追踪性。

**审计记录标准**（基于当前项目实际实现）：

**必须记录审计日志的操作**：
- ✅ 积分变动（增加、扣除、退款、管理员调整）
- ✅ 库存变更（使用、转让、管理员操作）
- ✅ 权限变更（角色分配、权限调整）
- ✅ 订单审核（通过、拒绝）
- ✅ 账户冻结/解冻

**标准审计日志格式**：
```javascript
// ✅ 在 Service 敏感操作中调用 AuditLogService
class PointsService {
  static async adminAdjustPoints(userId, amount, reason, operatorId) {
    const transaction = await sequelize.transaction()
    
    try {
      // 执行积分调整业务逻辑
      const result = await this.addPoints(userId, amount, {
        transaction,
        business_type: 'admin_adjust',
        title: `管理员调整积分：${reason}`
      })
      
      // ✅ 记录审计日志
      await AuditLogService.log({
        operator_id: operatorId,
        operation_type: 'points_adjust',
        target_type: 'user',
        target_id: userId,
        operation_detail: {
          amount: amount,
          reason: reason,
          transaction_id: result.transaction_id
        },
        transaction
      })
      
      await transaction.commit()
      return result
    } catch (error) {
      await transaction.rollback()
      throw error
    }
  }
}
```

**渐进式补齐策略**：
- ✅ 新增敏感操作时，必须同步记录审计日志
- ✅ 修改现有敏感操作时，顺手补齐审计日志
- ❌ 不强制一次性为所有历史代码补齐（避免引入风险）

---

##### P2.5 文档与注释瘦身规范

**目标**：让文档/注释篇幅与代码实际复杂度匹配，删除失效内容。

**注释长度标准**（基于当前项目实际代码复杂度）：

| Service 复杂度 | 代码行数 | 注释行数上限 | 判断标准 |
|---------------|---------|------------|---------|
| 简单 Service | < 200 行 | ≤ 50 行 | 无复杂模式、无状态机 |
| 中等 Service | 200–500 行 | ≤ 100 行 | 有事务/状态管理 |
| 复杂 Service | > 500 行 | ≤ 150 行 | 多模式/引擎级组件 |

**注释瘦身标准**：
```javascript
// ❌ 禁止：为简单 Service 写 200 行架构注释
/**
 * 用户服务（UserService）
 * 
 * 【架构设计】
 * - 采用领域驱动设计（DDD）
 * - 实现策略模式、观察者模式
 * - 支持高并发、高可用
 * - 性能指标：QPS 10000+
 * 
 * 【技术栈】
 * - Sequelize ORM
 * - Redis 缓存
 * - 消息队列
 * 
 * ... 共 200 行注释
 */
class UserService {
  // 实际只有 3 个简单方法，共 80 行代码
  static async getUserById(userId) { /* ... */ }
  static async updateUser(userId, data) { /* ... */ }
  static async deleteUser(userId) { /* ... */ }
}

// ✅ 推荐：简洁注释，与代码复杂度匹配
/**
 * 用户服务（UserService）
 * 
 * 核心功能：
 * - 用户信息查询、更新、删除
 * - 用户列表查询（支持分页、筛选）
 * 
 * 数据模型：User
 */
class UserService {
  static async getUserById(userId) { /* ... */ }
  static async updateUser(userId, data) { /* ... */ }
  static async deleteUser(userId) { /* ... */ }
}
```

**注释瘦身执行策略**：
- ✅ 新建 Service 时，按标准控制注释长度
- ✅ 修改现有 Service 时，顺手删除失效注释（如已删除的方法、过时的架构说明）
- ✅ 删除与实际代码不一致的注释（如注释说"支持缓存"但代码没实现）
- ❌ 不强制一次性瘦身所有历史注释（避免影响开发节奏）

---

**P2 规范总结**：
- 🔄 胖路由重构：结合功能改动"顺手"下沉业务逻辑到 Service
- 🔄 Service 合并：将职责接近的小 Service 按领域合并，避免继续碎片化
- 🔄 视图常量推广：对输出场景 ≥3 种的模型，统一使用视图常量管理字段
- 🔄 审计日志收敛：新增/修改敏感操作时，顺手补齐审计日志
- 🔄 文档注释瘦身：让注释篇幅与代码复杂度匹配，删除失效内容

**禁止引入**：
- ❌ 禁止为 **< 5 个接口**的功能新建独立 Service
- ❌ 禁止引入 Repository / BaseService / DI 框架等新抽象层
- ❌ 禁止引入"引擎""平台""子域"等重量级抽象（除非核心域必需）

**判断标准**：这些是"有空就做的改进方向"，不应为了追求规范而暂停业务功能开发。结合每次改动，**顺手往规范靠一点**即可。

---

### 11.2 规范适用性自查清单

**新功能开发前，快速判断应遵守的规范级别**：

| 问题 | 回答 | 应遵守规范 |
|------|------|-----------|
| 是否会修改积分余额？ | 是 | 🔴 P0 |
| 是否会修改库存状态？ | 是 | 🔴 P0 |
| 是否会修改抽奖结果？ | 是 | 🔴 P0 |
| 是否会修改用户权限？ | 是 | 🔴 P0 |
| 是否会修改订单状态？ | 是 | 🔴 P0 |
| 是否涉及兑换市场订单？ | 是 | 🔴 P0（必须遵守第七章兑换市场隔离规范） |
| 是否涉及多表写操作？ | 是 | 🔴 P0（必须用事务） |
| 是否可能被重复调用？ | 是 | 🔴 P0（必须幂等） |
| 是否只是查询展示？ | 是 | 🟡 P1 |
| 是否只是后台统计？ | 是 | 🟡 P1 |
| 是否只是代码整理？ | 是 | 🟢 P2 |

---

### 11.3 与当前项目代码的对齐说明

**本文档基于当前项目实际代码编写，不是历史报告或其他项目的规范**：

- ✅ 所有规范基于 `app.js / routes/* / models/* / services/*` 当前实际代码
- ✅ 所有示例来自真实代码（PointsService / InventoryService / ExchangeMarketService 等）
- ✅ 所有反面教材来自真实问题（inventory.js 2933 行 / points.js 1361 行）
- ✅ 技术路线与现有代码一致（静态 Service + Sequelize Model，不引入新抽象层）

**本文档目标**：
- ✅ 将现有高质量代码的模式（如 PointsService 的事务/幂等实现）固化为规范
- ✅ 防止新代码偏离现有技术路线（避免引入 Repository / DI / 新 Engine）
- ✅ 提供清晰的分层边界和审查标准（便于 Code Review）
- ❌ 不要求一次性重构所有存量代码（渐进优化）
- ❌ 不引入超出当前项目规模的复杂设计（避免过度设计）

---

### 11.4 规范执行建议

**对于新功能开发**：
1. 先用 10.2 自查清单判断规范级别
2. 🔴 P0 规范必须严格遵守（涉及资产变更）
3. 🟡 P1 规范推荐遵守（提升代码质量）
4. 🟢 P2 方向可以延后（不阻塞功能上线）

**对于存量代码维护**：
1. 修改存量代码时，优先让新增逻辑符合规范（不在胖路由里继续堆代码）
2. 如果改动较大，可以顺手重构一部分（如将业务逻辑下沉到 Service）
3. 不强制一次性重构整个文件（避免引入新风险）

**对于 Code Review**：
1. 🔴 P0 规范违反 → 必须修改才能合并
2. 🟡 P1 规范违反 → 建议修改，但不强制阻塞
3. 🟢 P2 方向 → 作为改进建议记录，不要求立即执行

---

## 结语

### 核心设计原则

**技术路线统一**：
- ✅ Service 层采用静态方法（与现有 Service 一致）
- ✅ 事务处理支持外部传入（PointsService 模式）
- ✅ 幂等性通过 business_id 控制
- ✅ 错误处理保持简单直接（throw Error + Controller 分类）
- ✅ 数据脱敏通过 Sequelize attributes + 视图常量

**实用主义原则**：
- ✅ 简单优于复杂：能用 1 个方法解决的，不拆成 3 个
- ✅ 直接优于抽象：能直接操作 Model 的，不绕 Repository 层
- ✅ 渐进优于一步到位：先解决当前问题，不为未来过度预留
- ✅ 学习大厂的原则，而非形式：学"按域拆分"，不学"拆 100 个微服务"

**避免过度设计**：
- ✅ 新 Service 至少承载 ≥5 个接口才独立拆出
- ✅ 新抽象层至少被 ≥3 个模块复用才引入
- ✅ 文档复杂度与代码复杂度匹配
- ✅ 解决当前真实痛点，不为未来过度预留
- ❌ 不引入"引擎""平台""子域"等重量级抽象（除非核心域必需）

**规范分级执行**：
- 🔴 P0（核心强制）：涉及资产变更的业务逻辑，必须严格遵守
- 🟡 P1（重要建议）：非核心业务逻辑，推荐遵守但不强制
- 🟢 P2（长期优化）：代码整理和架构优化，渐进式改进

---

**文档维护**：
- 最后更新：2025-12-12
- 版本：v5.2（新增兑换市场与积分支付隔离规则）

**更新记录**：
- v5.2 (2025-12-12)：
  - 新增"兑换市场与积分支付隔离"强制规则（第1.2节、第3.3节、第4.2节）
  - 新增"支付类型强制校验"防呆机制
  - 新增"数据模型防呆约束"推荐规范
  - 新增"兑换市场专项检查清单"（第9.6节）
- v5.1 (2025-12-11)：新增规范分级与适用性说明
 