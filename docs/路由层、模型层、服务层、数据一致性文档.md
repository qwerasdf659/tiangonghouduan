## 路由层 / 模型层 / 服务层 / 数据一致性规范（V4）

> **版本**: v5.0（规则统一版）  
> **最后更新**: 2025-12-11  
> **适用范围**: `app.js` / `routes/*` / `models/*` / `services/*` 当前代码  
> **目标**: 给所有新增 / 重构代码提供统一的设计指南、强制规范和审查清单，避免过早 DDD 过度设计。

---

## 一、整体分层与技术路线（强制）

### 1.1 分层结构（与当前代码对齐）

```text
HTTP Layer / 路由层（routes/*）
  - Express Router + 中间件（auth、限流、asyncHandler）
  - 只负责参数解析、权限入口、调用 Service、统一返回

Service Layer / 服务层（services/*）
  - 静态方法为主的领域服务（PointsService、InventoryService 等）
  - 负责业务规则、事务、一致性、跨模型协作

Model Layer / 模型层（models/*）
  - Sequelize 模型定义与关联
  - 不包含跨表业务流程
```

- **必须**通过 `ServiceManager` 获取服务：`req.app.locals.services.getService('points')` 等（见 `services/index.js`）。
- **必须**通过 `utils/ApiResponse` 中间件返回：`res.apiSuccess / res.apiError / res.apiInternalError`。
- **必须**在服务层处理事务与幂等，路由层不得直接使用 `sequelize.transaction()`。
- **禁止**引入新的通用 Repository / BaseService / DI 框架，保持与现有静态 Service 模式一致。

### 1.2 本系统架构定位与资产模型（强制）

- **技术形态（当前阶段的唯一标准形态）**：
  - **必须**保持**单体 Node.js + 单库 MySQL** 形态，Redis 仅作为缓存/辅助存储（可选），**不得**在当前项目中拆微服务或引入跨库分布式事务。
  - **禁止**在现有代码基础上引入 MQ + Saga 补偿式事务等复杂分布式模式；如未来确有拆分需求，应在**单独的架构文档**中重新论证，而不是在本规范中预留。
  - 每个 HTTP 请求内的资产变更（积分/库存/订单/权限）**要么全部成功，要么全部失败**，不接受“先部分落库、再异步补偿”的弱一致模式。

- **资产模型（账户 / 库存 / 订单三件套）**：
  - **积分**：
    - **必须**使用"账户 + 交易明细"模型：`UserPointsAccount` 作为账户，`PointsTransaction` 作为交易明细。
    - 任何改变积分余额的逻辑（发放、扣减、退款、管理员调整）**必须**通过 `PointsService` 入口，并在事务内写入 `PointsTransaction`。
  - **物品 / 资产（强制：单一真相，不允许两套真相并存）**：
    - **不可叠加物品（Non-stackable Items）**：
      - **唯一真相表**：`ItemInstance`（所有权与状态机的真相）。
      - 任何“发放 / 锁定 / 过期 / 使用 / 转移 / 上架”等操作**必须**通过对应 Service 入口（如 `InventoryService` / `RedemptionOrderService` / 交易相关 Service）完成，并在事务内保证一致性。
    - **可叠加资产（Stackable Assets）**：
      - **唯一真相账本**：`Account` + `AccountAssetBalance` + `AssetTransaction`（可用余额 + 冻结余额 + 资产流水）。
      - 任何改变资产余额/冻结余额的逻辑**必须**通过 `AssetService`（及其相关 Service）入口，且必须写入 `AssetTransaction` 作为可审计流水。
    - **彻底禁止两套真相**：
      - **禁止**引入/保留任何“第二套背包/库存真相表”的概念（包括文档注释）。
      - 评审标准：一件物品/一笔资产在任何时刻只能在 **一套真相模型** 中被 authoritative 表达。
  - **兑换市场订单（Exchange Market）**：
    - **必须**以独立订单表建模：`ExchangeMarketRecord`（或等价命名），作为"下单/支付/发货/完成/取消"等状态机的载体。
    - **业务语义强制约束**（兑换市场 vs 旧兑换链路的边界隔离）：
      - 兑换市场（`ExchangeMarketService` + `ExchangeMarketRecord`）**只处理虚拟价值兑换**（如虚拟货币、代币等非积分形式的支付），**不得支持积分支付**。
      - 旧积分兑换系统（`ExchangeRecords` + 旧运营审核链路）如仍保留，**只作为历史系统冻结使用**（只读或仅后台处理历史订单），不得在新功能中继续扩展。
      - 任何新增"用虚拟价值购买商品"的需求，**必须**通过 `ExchangeMarketService` 完成，不得混入积分扣减逻辑。
    - **支付类型强制校验（强制：业务逻辑 + 数据结构双重禁止）**：
      - **业务逻辑层**：Service 入口必须校验支付类型；如检测到任何 `points` 支付尝试，立即抛错并回滚事务。
      - **数据结构层（强制）**：
        - `ExchangeMarketRecord.payment_type/price_type` **不得**包含 `points` 枚举值（模型枚举/校验必须排除）。
        - **不得**保留 `points_paid/points_amount/points_*` 等字段的业务语义；如历史原因短期无法删字段，也必须有数据库级硬约束确保其恒为 `0/NULL`，并在 Service 写入前做最终防线校验。
      - 所有兑换市场订单的创建/更新操作**必须**记录 `business_id` 幂等键（已有实现）+ 审计日志（便于追溯"谁触发了这笔兑换"）。

- **事务与幂等的统一基线（资产安全内核）**：
  - 所有“**扣积分 / 改库存 / 下兑换订单**”的写操作，**必须同时满足**：
    - **单库事务**：使用 Sequelize 事务在同一 MySQL 实例内完成整条链路；
    - **行级悲观锁**：对关键账户/库存记录使用 `FOR UPDATE`（`transaction.LOCK.UPDATE`）；
    - **business_id 幂等**：以业务单号/操作唯一键防重复（积分/库存已落地，兑换市场必须对齐）。
  - 只读查询、统计报表等**不得**为了“对齐资产模型”而强行加入事务/悲观锁，但如查询路径会被用作后续写入决策的前置检查，应在 Service 内整体评估并设计合适的锁粒度。

- **权限与配置变更的统一入口**：
  - 所有“修改角色/权限/敏感配置”的操作，**必须**通过对应领域 Service 的**唯一入口方法**完成，例如：`UserRoleService.updateUserRole(...)`、`AdminSystemService.updateConfig(...)`。
  - 在该入口方法内**同时**完成：权限合法性校验 + 事务内落库 + 审计日志（`AuditLogService`）+ 必要的缓存失效，不得将这些步骤拆散到多个 Controller 或 Model 层调用中。
  - **禁止**在路由/Model 层直接 `update roles/config` 而绕过 Service 入口；发现此类路径视为 P0 级一致性风险。

---

## 二、路由层规范（routes/\*）

### 2.1 路由职责边界

- **必须**：
  - 只做这 4 件事：
    - **认证 / 鉴权**：如 `authenticateToken`、`adminAuthMiddleware`。
    - **参数解析与校验**：从 `req.params` / `req.query` / `req.body` 取值并做基础校验。
    - **调用 Service**：通过 `req.app.locals.services.getService(name)` 调用 1–2 个 Service 方法。
    - **统一响应**：使用 `res.apiSuccess / res.apiError / res.apiInternalError`。
  - 复用现有中间件：
    - 异步路由要包在 `asyncHandler(...)` 中（参考 `routes/v4/unified-engine/admin/system.js`）。
    - 需要限流的接口使用 `RateLimiterMiddleware` 创建专用 limiter（参考 `routes/v4/unified-engine/points.js`）。

- **禁止**：
  - 直接引用 `require('../models')` 或 `models.Xxx.findAll/create/update`（**P0 强制**）。
  - **路由层直连 models 做写操作**（create/update/destroy/原生SQL）。（**P0 强制**）
  - **允许的唯一例外（P0 特例，必须极少）**：只读安全校验（例如所有权/管理员权限的最小查询），且必须满足：
    - 仅 `findByPk/findOne` 读取必要字段；不得 join、多表聚合、不得写库；
    - 校验逻辑应优先迁移到对应 Service 或复用中间件，避免胖路由回潮；
    - 任何资产/物品/订单状态变更必须由 Service 入口完成（事务/幂等/审计在 Service 内统一处理）。
  - 在路由内开启事务：`sequelize.transaction()`。
  - 在路由内实现跨表业务流程（例如积分扣减 + 库存创建）。
  - 自己拼装复杂 JSON 结构而绕过 Service 已有封装（例如订单/管理状态聚合应交给 Service）。

### 2.2 路由命名与文件划分

- **路径风格**：保持现有 REST 风格 `/api/v4/*`，同一领域共用一个 Router 文件（如 `points.js`）。
- **文件内容**：
  - 领域说明 + API 列表置于文件顶部注释（参照当前 `points.js` 注释风格）。
  - 路由内不写与业务无关的大段文档；领域说明写在对应 Service 或 docs，而不是每个路由重复。
- **文件长度约束**：
  - 单个路由文件建议 **< 800 行**（含注释）。
  - 超过 800 行时，优先考虑按子领域拆分（例如 `inventory.js` 拆为 `inventory-core.js` + `inventory-market.js`）或将业务逻辑下沉到 Service。

> **说明（避免为了数字而重构）**
>
> - 上面的「800 行」「50 行」是**经验阈值**，目的是帮你快速识别**明显已经过胖、需要拆分**的文件/函数，而不是“必须压到这个数字以下”的硬性 KPI。
> - Code Review 时，更看重的是：**职责是否单一、逻辑是否清晰、是否出现跨层直连 models/事务**，而不是机械地拆成很多小文件/小函数。
> - 如果一个路由文件略多于 800 行，但结构清晰、职责单一、业务已经下沉到 Service 层，可以暂时保留；相反，即使不到 800 行，但职责严重混杂、直连 models，也应按胖路由规范优先重构。

### 2.3 胖路由（Fat Route）反模式

#### 胖路由定义（命中任一条即需拆分）

- 在路由函数中直接调用 `models.Xxx.*` 或执行 SQL。
- 单个路由函数里同时完成多步业务流程（例如：查积分 + 改库存 + 写审计日志 + 发通知）。
- 单个路由函数超过 **50 行**（不含注释）且包含大量业务分支 `if/else`。
- 在路由中开启事务：`sequelize.transaction()` 或等价代码。
- 在路由里构建复杂聚合数据结构，而非调用 Service 提供的聚合方法。

#### 胖路由硬性指标（基于实际代码分析）

| 指标                 | 阈值                | 说明                     |
| -------------------- | ------------------- | ------------------------ |
| 单个路由文件总行数   | > 800 行            | 需拆分文件或下沉业务逻辑 |
| 单个路由函数行数     | > 50 行（不含注释） | 需拆分到 Service         |
| 直接操作 models 次数 | > 0 次              | 必须通过 Service         |
| 单个路由函数业务分支 | > 3 层 if/else      | 需抽取到 Service 方法    |
| 单个路由函数操作表数 | > 1 张表            | 需使用 Service 事务      |

> **这些指标的使用方式**
>
> - 把它们当作**“报警线”而不是“及格线”**：命中指标说明“这里已经明显偏胖，应考虑下沉到 Service 或拆分”，而不是为达成指标去把本来还算清晰的代码拆碎。
> - 优先处理那些“跨表写 + 直连 models + 多层分支”的高风险端点，其次再考虑一般性的代码美化；不要为了追求 50 行，把简单直观的逻辑拆得支离破碎，反而降低可读性。

**实际案例（作为反面教材）**：

- `inventory.js`：2933 行 / 20 个端点 / 平均每端点 146 行 / 28 次直接 models 调用 → **严重胖路由**。
- `points.js`：1361 行 / 约 10 个端点 / 3 次直接 models 调用 → **中度胖路由**。

#### 处理方式

- 将流程拆分到对应 Service（如 `PointsService`、`InventoryService`、`AdminLotteryService`），路由只保留参数和返回。
- 涉及多表写操作的一律下沉到 Service，由 Service 负责事务和幂等。
- 老代码短期内无法完全重构时，**新逻辑禁止再加在胖路由内部**，必须放在新 Service 方法中。

### 2.4 路由层审查清单

- **路由 PR 必须检查**：
  - 是否只通过 `ServiceManager` 访问业务（默认不出现 `models.*`；如有仅限“只读安全校验”特例且满足约束）。
  - 是否使用统一响应方法（不出现 `res.json({ ... })` 手写结构），**包括顶层接口**（如 `/health`、`/api`、`/api/v4`、`/api/v4/docs` 等）。
    - **允许的明确特例**：
      - 导出/下载类接口：返回二进制流（Excel/CSV/图片等）可 `res.send(buffer)`，但必须在路由顶部注释说明“规范允许的 ApiResponse 特例”；
      - 废弃接口（410 Gone）：可直接返回 410 JSON，但应尽量保持字段风格一致，并在注释里写清迁移路径与替代接口。
  - 是否参数校验完整（id 范围、枚举值校验等，参考 `admin/lottery_management.js` 的校验方式）。
  - 是否将任何"需要事务"的逻辑下沉到 Service。
  - 单个路由函数是否超过 50 行或含多层业务分支。
  - 是否有直接操作多张表的代码（跨表操作必须在 Service 内用事务保护）。

---

## 三、服务层规范（services/\*）

### 3.1 服务形态与依赖注入

- **领域服务**（如 `PointsService`、`InventoryService`、`ExchangeOperationService`）：
  - **必须**使用静态方法模式：`class XxxService { static async method() {} }`。
  - 直接 `require('../models')` 获取所需模型，不通过额外 Repository 抽象。
  - 如果需要其他 Service，**优先**通过 `ServiceManager` 注入（见 `services/index.js` 已有的 `initialize` 调用）。

- **基础设施 / 引擎类服务**（如 `UnifiedLotteryEngine`、`ChatWebSocketService`）：
  - 可以由 `ServiceManager` 以实例方式注册；保持当前模式，不再新建此类复杂组件，除非确有需求。

### 3.2 事务与幂等（数据一致性核心）

#### 事务处理标准模式（强制遵守）

**参考 `PointsService` 的实际实现**：

```javascript
static async consumePoints(userId, amount, options = {}) {
  const { transaction: externalTransaction } = options

  // 支持外部事务传入
  const transaction = externalTransaction || await sequelize.transaction()
  const shouldCommit = !externalTransaction

  try {
    // 使用悲观锁查询
    const account = await UserPointsAccount.findOne({
      where: { user_id: userId },
      lock: transaction.LOCK.UPDATE,
      transaction
    })

    // 业务逻辑...

    if (shouldCommit) {
      await transaction.commit()
    }
    return result
  } catch (error) {
    if (shouldCommit) {
      await transaction.rollback()
    }
    throw error
  }
}
```

**关键设计**：

- ✅ 支持外部事务传入（跨 Service 调用时共享事务）
- ✅ 只有自己创建的事务才 commit/rollback
- ✅ 使用悲观锁（FOR UPDATE）防止并发问题

**强制约束**：

- 写操作涉及多表时，**必须**在服务层开启事务：`const tx = await sequelize.transaction()`；  
  对“扣积分 / 改库存 / 下兑换订单”这三类资产写操作，**一律不得**拆成多个事务分步提交。
- 被复用的底层方法（如 `PointsService.consumePoints`、`InventoryService.transferItem`、`ExchangeMarketService.createOrderWithPoints` 等）  
  **必须**支持外部传入事务：`options.transaction`。
  - Exchange 相关链路（用积分购买/兑换商品）**必须**在同一事务中完成：扣积分账户 + 写积分交易明细 + 创建/更新兑换订单记录。

#### 幂等控制标准模式（强制遵守）

**参考 `PointsService` 的实际实现**：

```javascript
// 通过 business_id 防止重复提交
if (business_id) {
  const existingTx = await PointsTransaction.findOne({
    where: { business_id },
    transaction
  })

  if (existingTx) {
    // 已存在，返回原结果（幂等）
    return { success: true, transaction_id: existingTx.transaction_id }
  }
}
```

**强制约束**：

- 涉及积分、兑换、退款等**可被重复触发**的业务，**必须**使用 `business_id` 做幂等。
- 新增类似流程时沿用现有模式，不再新增第二套幂等实现方式。

**适用场景**：

- ✅ 兑换扣积分（business*id: `exchange*${exchangeId}`）
- ✅ 退款操作（business*id: `refund*${orderId}`）
- ✅ 消费奖励（business*id: `consumption*${recordId}`）
- ✅ 转让物品（business*id: `transfer*${itemId}_${timestamp}`）
- ✅ 使用物品（business*id: `use*${itemId}_${timestamp}`）

#### 批量运营工具例外

- 像 `ExchangeOperationService.batchApproveOrders` 这类"批量运营工具"，  
  可以按当前实现逐条处理、非整体事务，但：
  - 每个订单的状态流转必须由领域对象 / 领域服务保证一致性（如 `exchange.approve()` 内部负责事务与写入）。
  - 批量接口必须记录详细失败原因，不得"吞掉异常"。

### 3.3 领域边界

- **服务可以做**：
  - 操作自己负责领域的表（`PointsService` 操作 `UserPointsAccount` / `PointsTransaction`）。
  - 调用其他 Service 的公开方法进行跨领域协作（例如兑换成功后创建/转移 `ItemInstance`，或扣减资产余额/冻结余额）。

- **服务禁止做**：
  - 直接操作其他领域的核心表而绕过对应 Service（例如库存相关表直接在积分服务里更新）。
  - 在同一个方法里堆过多职责：一个方法同时做查询、统计、导出、通知。

**领域与模型映射（当前实际状态）**：

| 领域         | 负责表                                                   | Service                               | 核心方法示例                                                          | 业务边界强制约束                                                                                           |
| ------------ | -------------------------------------------------------- | ------------------------------------- | --------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------- |
| 积分         | user_points_accounts<br>points_transactions              | PointsService                         | addPoints()<br>consumePoints()<br>refundPoints()                      | 只负责积分账户变动，不得直接操作兑换市场订单表                                                             |
| 不可叠加物品 | item_instances<br>trade_records（如存在交易流水）        | InventoryService                      | getItemDetail()<br>getTransferHistory()<br>（其他物品所有权相关方法） | 只负责物品所有权与状态流转；不得直接操作积分/兑换市场订单/资产账本                                         |
| 可叠加资产   | accounts<br>account_asset_balances<br>asset_transactions | AssetService                          | getBalance()<br>changeBalance()<br>freeze()/unfreeze()（如有）        | 只负责资产账本与余额/冻结变动；任何变动必须有幂等与流水                                                    |
| 兑换市场     | exchange_items<br>exchange_market_records                | ExchangeMarketService                 | getMarketItems()<br>exchangeItemWithVirtual()                         | **禁止积分支付**：只处理虚拟价值（virtual）支付，不得调用 `PointsService.consumePoints()` 或操作积分相关表 |
| 审核         | content_review_records<br>admin_operation_logs           | ContentAuditEngine<br>AuditLogService | createAudit()<br>approve()<br>reject()                                | 审核流程与资产变动解耦，通过回调触发资产操作                                                               |

**兑换市场特殊约束（强制）**：

- `ExchangeMarketService` 的所有方法**禁止**接受 `points` / `points_amount` / `points_paid` 等参数。
- 路由层调用兑换市场 API 时，如传入任何包含 `points` 关键字的参数，**必须**在路由层校验并立即拒绝（返回 400 错误）。
- Service 层方法签名示例（正确）：

  ```javascript
  // ✅ 正确：只接受虚拟价值参数
  static async exchangeItemWithVirtual(userId, itemId, virtualAmount, options = {})

  // ❌ 错误：不得出现 points 相关参数
  static async exchangeItem(userId, itemId, pointsAmount, options = {})
  ```

### 3.4 服务拆分与命名（避免过度设计）

#### Service 创建门槛（强制）

**新建独立 Service 必须满足以下任一条件**：

1. 承载核心域逻辑（积分、库存、抽奖引擎等），且有明显事务边界和复杂状态机。
2. 被 **≥5 个路由**或 **≥2 个 Service** 调用。
3. 方法数量 **≥5 个**且逻辑内聚（不是为了"统一"而强行凑在一起）。

**否则**：优先放入现有 Service（如 `AdminSystemService`、`StatisticsService`），避免碎片化。

#### Admin 侧服务合并规则（强制）

**现状问题**：存在多个只有 1–3 个接口的小 Admin Service，导致服务数量膨胀。

**合并规则**：

- **统计/报表类**：`AdminAnalyticsService` + `StatisticsService` + `UserDashboardService` → 合并为 `ReportingService`。
- **系统配置类**：`AdminSystemService` + `SystemSettingsService` + 其他小配置 Service → 合并为统一的 `AdminSystemService`。
- **市场管理类**：`AdminMarketplaceService` → 合并到 `ExchangeMarketService`（增加管理方法）。

**判断标准**：

- Admin 功能优先在对应领域 Service 内增加管理方法（如 `PointsService.adminAdjustPoints()`）。
- 只有当 Admin 功能与 C 端完全不同且复杂度高时，才考虑独立 Admin Service。

#### Service 命名规范

- **领域服务**：`XxxService`（如 `PointsService`、`InventoryService`）。
- **引擎/基础设施**：`XxxEngine` / `XxxManager`（如 `UnifiedLotteryEngine`、`ServiceManager`）。
- **禁止**：为简单功能使用"引擎""平台""子域"等重量级术语（除非真是核心域复杂组件）。

### 3.5 服务层审查清单

- 新增 / 修改的 Service 是否遵守静态方法 + 领域边界。
- 是否正确处理事务与幂等；有无遗漏的回滚或重复提交风险。
- 是否滥建新 Service，而不是合并进现有合适的 Service。
- 是否跨领域直接操作其他领域的表（必须通过对应 Service）。
- Service 头部注释是否与代码复杂度匹配（简单 Service < 50 行注释，复杂 Service < 150 行注释）。

---

## 四、模型层规范（models/\*）

### 4.1 模型注册与命名

- 所有模型**必须**在 `models/index.js` 中统一注册，并附简短注释说明用途（参考现有内容）。
- 表命名保持当前风格：`snake_case_plural`（如 `user_points_accounts`、`points_transactions`）。
- 一个业务概念只保留一套模型（旧模型已在 `index.js` 注释为"已删除"的不再复活）。

### 4.2 业务含义与边界

- 每个模型注释里已经约定了业务含义，例如：
  - `UserPointsAccount` / `PointsTransaction`：积分账户 + 交易日志。
  - `ExchangeRecords`（旧系统，冻结状态）：历史积分兑换订单，仅用于查询历史数据或后台处理存量订单。
  - `ExchangeMarketRecord`（新系统）：兑换市场虚拟价值订单，**只支持非积分支付**（`price_type = 'virtual'`）。
  - `ItemInstance`（不可叠加物品真相） + `TradeRecord`（交易/转让流水，如存在）。
  - `ContentReviewRecord` vs `AdminOperationLog`：业务审核记录 vs 管理员操作审计。
- **新增模型时必须写清**：
  - 与现有模型的关系（替代 / 互斥 / 关联）。
  - 是否参与事务与幂等（例如是否需要与积分账户联动）。
- **兑换市场模型特殊约束（强制）**：
  - `ExchangeMarketRecord` 模型定义中，**推荐**增加数据库层面的防呆约束：
    - `CHECK (points_paid = 0 OR points_paid IS NULL)`（如字段存在但不再使用）。
    - `CHECK (payment_type != 'points')`（枚举约束，排除积分支付）。
    - 或直接移除 `points_paid` / `points_amount` 等字段（如无历史兼容需求）。
  - 模型注释中**必须**明确声明："本订单表只用于虚拟价值兑换，禁止积分支付"。

### 4.3 模型层审查要点

- 是否已经在 `index.js` 正确注册，并带有中文注释说明用途。
- 是否与现有模型边界冲突（例如再造一个"积分交易表"是禁止的）。
- 是否需要在对应 Service 中增加事务 / 审计 / 幂等配套逻辑。

---

## 五、数据输出与脱敏规范（视图常量）

### 5.1 视图常量模式（当前实现）

- 已在以下服务中落地：
  - `PointsService` 中的 `POINTS_ATTRIBUTES.userView/adminView/transactionView`。
  - `InventoryService` 中的 `INVENTORY_ATTRIBUTES.ownerView/adminView/...`。

- **强制约束**：
  - Controller / Route **不得**直接写 `attributes: [...]`；只能调用 Service 提供的方法。
  - 视图常量定义在 Service 顶部，**只包含字段名数组**，不写任何 if/else。
  - 绝对不应对外暴露的字段（如内部审计字段）**不能**出现在任何视图常量里。

### 5.2 何时需要视图常量

- **推荐使用**：
  - 同一模型存在 **≥3 种输出场景**（用户端、管理端、统计、详情）。
  - 字段列表在多个方法中重复使用。
- **不推荐使用**：
  - 某模型只在 1–2 处简单查询，且字段稳定；直接在查询里写 `attributes` 即可。

### 5.3 toView / buildResponse 函数

- 对于复杂聚合返回（如管理端抽奖管理状态、库存详情），**建议**：
  - 在 Service 内提供 `_toXxxView(row)` 或 `buildXxxResponse()`。
  - 路由层只负责调用并返回，不再自己拼装深层嵌套结构。
- 对于**导出/下载类接口**（Excel、CSV 等二进制流）：
  - 允许直接 `res.send(buffer)` 返回二进制内容，**不强制使用 ApiResponse 包装**。
  - 但路由上方必须有明确注释声明：
    - `// 导出接口：返回二进制文件流（例如 Excel），不使用 ApiResponse 包装，规范允许的特例`。
  - 其他普通 JSON API 不得以“导出”为由规避统一响应规范。
- 审查时优先看：
  - 是否所有计算字段都集中在 Service，而不是分散在多个路由。

---

## 六、数据一致性与审计规范

### 6.1 一致性保障手段

- **事务**：
  - 涉及积分变动、库存变动、兑换订单状态变更时，必须在 Service 使用事务包裹整条链路。
    - **尤其是**“扣积分 + 改库存 + 写兑换订单”这类跨多个资产的写操作，**必须在同一 MySQL 事务内一次性完成**，禁止拆成多次 `save()` 或多事务拼接。
  - 下层服务 / 模型方法如果需要参与事务，必须接受 `options.transaction` 并使用行级锁（当前在积分和库存服务中已实现）。

- **幂等**：
  - 所有"可能被重复调用"的敏感操作必须带 `business_id`（尤其是积分增减、退款）。
  - 兑换市场订单相关链路（下单/支付/继续支付/重试）**必须**沿用相同的 `business_id` 幂等模式，防止重复扣减积分或生成重复订单。
  - 审查时如果看到有新的扣分/加分/下兑换订单逻辑，但没有幂等机制，视为 P0 问题。

- **审计与业务审核**：
  - 系统内已有区分：
    - `ContentReviewRecord`：业务审核流程（兑换、内容审核等）。
    - `AdminOperationLog` / `AuditLogService`：管理员操作日志（敏感操作追溯）。
  - 新增涉及人工审核或敏感操作的流程时：
    - 必须复用上述两类现有模型 / 服务，不再新建第三套"审核表 / 审计表"。

### 6.2 一致性审查清单

- 是否明确事务边界：谁开启事务、谁接收 `transaction` 参数。
- 是否有幂等控制（`business_id` 或同等唯一约束）。
- 是否选用了正确的审计载体（ContentReviewRecord vs AdminOperationLog）。
- 是否处理了失败场景：事务回滚 / 局部失败记录 / 重试策略。

---

## 七、兑换市场业务隔离规范（强制）

### 7.1 业务语义彻底分离（架构定位）

**背景问题**：

- 历史上存在"积分兑换"（`ExchangeRecords`）和"兑换市场"（`ExchangeMarketRecord`）两条链路，边界模糊。
- 部分代码混用了积分支付和虚拟价值支付，导致资产模型不一致。

**强制规则**：

- **兑换市场（Exchange Market）**：
  - **唯一定位**：只处理"虚拟价值 → 兑换商品（虚拟/实体）"的订单流程。
  - **载体表**：`ExchangeMarketRecord`（或等价命名）。
  - **负责 Service**：`ExchangeMarketService`。
  - **支付类型**：只支持 `virtual`（虚拟价值）或其他非积分形式，**绝对禁止**积分支付。
- **旧积分兑换系统（Exchange Records）**：
  - **定位**：历史系统，处于"冻结/逐步下线"状态。
  - **载体表**：`ExchangeRecords`（如仍保留）。
  - **使用限制**：只读或仅后台处理存量历史订单，**不得在新功能中扩展**。
  - **未来方向**：如确定不再使用，应在单独的数据迁移文档中规划下线路径。

**判断标准**：

- 新增任何"用户购买商品"的需求，如支付方式是**虚拟价值**，走 `ExchangeMarketService`。
- 如支付方式是**积分**，则属于历史兑换系统范畴（冻结状态，不再新增）。

---

### 7.2 支付类型强制校验（防呆机制）

**目标**：在代码层面强制阻止"积分支付混入兑换市场"的路径，而不是依赖约定。

**强制约束**：

#### 7.2.1 Service 层入口校验

```javascript
// ✅ 正确：ExchangeMarketService 强制校验支付类型
class ExchangeMarketService {
  static async createExchangeOrder(userId, itemId, paymentInfo, options = {}) {
    const { transaction } = options

    // 🔴 强制校验：禁止积分支付
    if (paymentInfo.payment_type === 'points' || paymentInfo.price_type === 'points') {
      throw new Error('兑换市场不支持积分支付，请使用虚拟价值支付')
    }

    // 🔴 强制校验：只允许 virtual 支付
    if (paymentInfo.payment_type !== 'virtual') {
      throw new Error(`不支持的支付类型: ${paymentInfo.payment_type}`)
    }

    // 业务逻辑...
  }
}

// ❌ 错误：不做任何校验，允许 points 传入
class ExchangeMarketService {
  static async createExchangeOrder(userId, itemId, paymentInfo, options = {}) {
    // 直接使用 paymentInfo，没有校验 payment_type
    // 可能导致 points 混入
  }
}
```

#### 7.2.2 路由层参数校验

```javascript
// ✅ 正确：路由层预先拒绝包含 points 的请求
router.post('/exchange-market/order', authenticateToken, async (req, res) => {
  const { item_id, payment_type, points_amount } = req.body

  // 🔴 强制校验：拒绝任何 points 相关参数
  if (payment_type === 'points' || points_amount) {
    return res.apiError('兑换市场不支持积分支付', 'BAD_REQUEST', null, 400)
  }

  // 调用 Service...
})

// ❌ 错误：路由层不校验，直接透传给 Service
router.post('/exchange-market/order', authenticateToken, async (req, res) => {
  // 直接 await ExchangeMarketService.createOrder(req.body)
  // 依赖 Service 层校验，但路由层应该更早拦截
})
```

#### 7.2.3 数据写入前最终校验

```javascript
// ✅ 正确：写入数据库前最终防线
class ExchangeMarketService {
  static async _saveOrderRecord(orderData, transaction) {
    // 🔴 最终防线：确保 points_paid 为 0
    if (orderData.points_paid && orderData.points_paid > 0) {
      throw new Error('数据异常：兑换市场订单不得包含积分支付金额')
    }

    // 🔴 最终防线：确保 payment_type 不是 points
    if (orderData.payment_type === 'points') {
      throw new Error('数据异常：兑换市场订单支付类型不得为 points')
    }

    // 强制覆盖为 0（防御性编程）
    orderData.points_paid = 0

    await ExchangeMarketRecord.create(orderData, { transaction })
  }
}
```

**校验层次**：

1. **路由层**：最早拦截，拒绝包含 `points` 关键字的请求参数（400 错误）。
2. **Service 入口**：业务逻辑前校验支付类型，不符合立即抛出错误。
3. **数据写入前**：最终防线，确保落库数据不包含积分支付信息。

---

### 7.3 数据模型防呆约束（推荐纵深防御）

**目标**：在数据库层面增加约束，防止绕过 Service 直接写库。

**推荐约束**（不强制，但作为防御纵深）：

#### 7.3.1 字段约束

```sql
-- ✅ 推荐：在 ExchangeMarketRecord 表上增加 CHECK 约束
ALTER TABLE exchange_market_records
ADD CONSTRAINT chk_no_points_payment
CHECK (points_paid = 0 OR points_paid IS NULL);

-- ✅ 推荐：枚举约束，排除 points
ALTER TABLE exchange_market_records
ADD CONSTRAINT chk_payment_type_virtual
CHECK (payment_type != 'points');
```

#### 7.3.2 字段移除（最彻底方案）

```sql
-- ✅ 最彻底：如无历史兼容需求，直接移除 points 相关字段
ALTER TABLE exchange_market_records
DROP COLUMN points_paid;

ALTER TABLE exchange_market_records
DROP COLUMN points_amount;
```

**Sequelize 模型定义对应**：

```javascript
// ✅ 正确：模型定义中明确约束
const ExchangeMarketRecord = sequelize.define(
  'ExchangeMarketRecord',
  {
    payment_type: {
      type: DataTypes.ENUM('virtual', 'coupon'), // 不包含 'points'
      allowNull: false,
      validate: {
        isNotPoints(value) {
          if (value === 'points') {
            throw new Error('兑换市场不支持积分支付')
          }
        }
      }
    },
    points_paid: {
      type: DataTypes.DECIMAL(10, 2),
      defaultValue: 0,
      validate: {
        isZero(value) {
          if (value && value > 0) {
            throw new Error('兑换市场订单不得包含积分支付金额')
          }
        }
      }
    }
  },
  {
    comment: '兑换市场订单表 - 只支持虚拟价值支付，禁止积分支付'
  }
)
```

**模型注释强制要求**：

```javascript
/**
 * ExchangeMarketRecord - 兑换市场订单表
 *
 * 业务边界（强制）：
 * - 只处理虚拟价值（virtual）支付的兑换订单
 * - 禁止积分（points）支付：payment_type 不得为 'points'
 * - 所有订单 points_paid 必须为 0 或 NULL
 *
 * 与旧系统的关系：
 * - ExchangeRecords：历史积分兑换系统（冻结状态）
 * - ExchangeMarketRecord：新兑换市场系统（只支持虚拟价值）
 */
```

---

### 7.4 Service 方法签名规范（强制）

**目标**：从方法签名层面防止 `points` 参数传入。

**强制约束**：

```javascript
// ✅ 正确：ExchangeMarketService 方法不接受 points 参数
class ExchangeMarketService {
  /**
   * 创建兑换市场订单（虚拟价值支付）
   * @param {number} userId - 用户ID
   * @param {number} itemId - 商品ID
   * @param {number} virtualAmount - 虚拟价值金额
   * @param {object} options - 可选参数（transaction、business_id 等）
   */
  static async createExchangeOrder(userId, itemId, virtualAmount, options = {}) {
    // 方法签名中完全不出现 points / pointsAmount / pointsPaid
  }

  /**
   * 虚拟价值兑换商品（完整流程）
   * @param {number} userId - 用户ID
   * @param {number} itemId - 商品ID
   * @param {object} paymentInfo - 支付信息 { payment_type: 'virtual', amount: 100 }
   */
  static async exchangeItemWithVirtual(userId, itemId, paymentInfo, options = {}) {
    // paymentInfo 对象内部不包含 points 相关字段
  }
}

// ❌ 错误：方法签名包含 points 参数
class ExchangeMarketService {
  static async exchangeItem(userId, itemId, pointsAmount, options = {}) {
    // 错误：出现 pointsAmount 参数名
  }

  static async createOrder(userId, itemId, paymentInfo, options = {}) {
    // 如果 paymentInfo 可能包含 { payment_type: 'points', points_amount: 100 }
    // 则方法设计就是错误的
  }
}
```

**命名规范**：

- ✅ 使用 `virtualAmount` / `virtualValue` / `virtual_price` 等命名（明确非积分）。
- ❌ 禁止使用 `points` / `pointsAmount` / `points_cost` / `points_paid` 等命名。

---

### 7.5 事务与审计日志规范（兑换市场专项）

**强制约束**：

```javascript
// ✅ 正确：兑换市场订单创建的完整流程
class ExchangeMarketService {
  static async createExchangeOrder(userId, itemId, virtualAmount, options = {}) {
    const { transaction: externalTransaction } = options
    const transaction = externalTransaction || (await sequelize.transaction())
    const shouldCommit = !externalTransaction

    try {
      // 1. 支付类型校验（强制）
      if (!this._isValidVirtualPayment(virtualAmount)) {
        throw new Error('虚拟价值支付参数无效')
      }

      // 2. 生成幂等键（强制）
      const business_id = options.business_id || `exchange_market_${itemId}_${Date.now()}`

      // 3. 幂等检查（强制）
      const existing = await ExchangeMarketRecord.findOne({
        where: { business_id },
        transaction
      })
      if (existing) {
        return { success: true, order_id: existing.order_id }
      }

      // 4. 扣减虚拟价值（调用对应 Service，如 VirtualCurrencyService）
      // 注意：不得调用 PointsService.consumePoints()
      await VirtualCurrencyService.consume(userId, virtualAmount, {
        transaction,
        business_id: `${business_id}_virtual`
      })

      // 5. 创建订单记录（强制 points_paid = 0）
      const order = await this._saveOrderRecord(
        {
          user_id: userId,
          item_id: itemId,
          payment_type: 'virtual',
          virtual_amount: virtualAmount,
          points_paid: 0, // 强制为 0
          business_id
        },
        transaction
      )

      // 6. 审计日志（强制）
      await AuditLogService.log({
        operator_id: userId,
        operation_type: 'exchange_market_order',
        target_type: 'order',
        target_id: order.order_id,
        operation_detail: {
          item_id: itemId,
          payment_type: 'virtual',
          virtual_amount: virtualAmount,
          business_id
        },
        transaction
      })

      if (shouldCommit) {
        await transaction.commit()
      }

      return { success: true, order_id: order.order_id }
    } catch (error) {
      if (shouldCommit) {
        await transaction.rollback()
      }
      throw error
    }
  }
}
```

**审计日志必填字段**（兑换市场专项）：

- `operation_type: 'exchange_market_order'`（明确标识为兑换市场订单）
- `operation_detail.payment_type`（必须为 'virtual'）
- `operation_detail.virtual_amount`（虚拟价值金额）
- `operation_detail.business_id`（幂等键）

---

### 7.6 Code Review 兑换市场专项清单（强制）

**任何涉及兑换市场的 PR 必须检查以下各项**：

#### 路由层检查

- [ ] 路由参数是否包含 `points` / `points_amount` / `points_paid`（禁止出现）。
- [ ] 是否在路由层预先校验支付类型（拒绝 `payment_type = 'points'`）。
- [ ] 路由命名是否明确区分兑换市场（如 `/api/v4/exchange-market/*`）与旧兑换链路。

#### Service 层检查

- [ ] `ExchangeMarketService` 方法签名是否包含 `points` 相关参数（禁止出现）。
- [ ] 是否在 Service 入口强制校验 `payment_type = 'virtual'`（必须校验）。
- [ ] 是否调用了 `PointsService.consumePoints()` 或直接操作积分相关表（禁止调用）。
- [ ] 是否在数据写入前最终校验 `points_paid = 0`（必须校验）。
- [ ] 是否记录了 `business_id` 幂等键和审计日志（必须记录）。

#### 模型层检查

- [ ] `ExchangeMarketRecord` 模型注释是否明确声明"禁止积分支付"（必须声明）。
- [ ] 是否增加了 `payment_type` 枚举约束（推荐但非强制）。
- [ ] 是否增加了 `points_paid` 字段约束或移除该字段（推荐但非强制）。

#### 事务与一致性检查

- [ ] 如检测到积分支付尝试，是否立即抛出错误并回滚事务（必须回滚）。
- [ ] 兑换市场订单创建是否在单一事务内完成（虚拟价值扣减 + 订单创建）。
- [ ] 是否有完整的失败处理与日志记录（必须完整）。

---

### 7.7 历史代码兼容与迁移策略（非强制，仅供参考）

> 为保持本文件“纯规则/标准”性质，本节策略性内容已移出；如需保留请放入独立的实施/迁移文档。

---

## 八、避免过度设计的统一约束（强制）

### 8.1 抽象层引入门槛（强制）

引入新的抽象层（Engine、Manager、Factory 等）必须同时满足：

1. 解决**当前真实存在**的痛点（不是为了“可能未来要扩展”）。
2. 被 **≥3** 个业务模块复用。
3. 不增加 **≥30%** 的代码复杂度（新增抽象的收益 > 维护成本）。

### 8.2 文档与注释复杂度匹配（强制）

- **Service 文件头注释上限**：
  - 简单 Service（<200 行、无复杂模式）：≤ **50 行**
  - 中等 Service（200–500 行、有事务/状态）：≤ **100 行**
  - 复杂 Service（>500 行、多模式/引擎级组件）：≤ **150 行**
- **禁止**：为简单功能写与实际代码不一致的“架构/模式/性能指标”长注释（例如声称使用策略模式/观察者模式，但代码中并不存在）。

---

## 九、错误处理与日志规范

### 9.1 错误处理标准模式（保持现有简单模式）

**当前实际采用的模式**（基于 PointsService / InventoryService）：

```javascript
// Service 层：直接 throw Error
static async useItem(actorId, itemId, context = {}) {
  if (item.status !== 'available') {
    throw new Error(`物品状态为${item.status}，无法使用`)
  }
}

// Controller 层：捕获并分类
catch (error) {
  logger.error('使用物品失败', { error: error.message, item_id })

  if (error.message.includes('无权限')) {
    return res.apiError(error.message, 'FORBIDDEN', null, 403)
  } else if (error.message.includes('状态')) {
    return res.apiError(error.message, 'BAD_REQUEST', null, 400)
  } else {
    return res.apiError('使用物品失败', 'INTERNAL_ERROR', null, 500)
  }
}
```

**强制约束**：

- ✅ Service 层直接 throw Error，Controller 层捕获分类。
- ✅ 保持现有的简单错误处理模式。
- ❌ **禁止**引入复杂的 BusinessError 类体系（当前阶段不需要）。

### 9.2 日志记录规范

**标准日志格式**（基于 BeijingTimeHelper + Logger）：

```javascript
logger.error('操作失败', {
  error: error.message,
  user_id: userId,
  item_id: itemId,
  operation: 'use_item',
  timestamp: BeijingTimeHelper.now()
})
```

**强制约束**：

- 所有错误日志必须包含：`error.message` + 关键业务 ID（user_id / item_id / transaction_id 等）。
- 敏感操作（积分变动、权限变更、审核通过/拒绝）必须记录操作日志（通过 `AuditLogService`）。

---

## 十、PR 审查总清单

### 10.1 路由层检查

- [ ] 是否只做 4 件事：鉴权、解析参数、调用 Service、统一响应。
- [ ] 有无直接访问 `models` 或手写事务。
- [ ] 是否使用 `ServiceManager` 和统一响应中间件。
- [ ] 单个路由函数是否超过 50 行或含多层业务分支。
- [ ] 限流、权限校验是否符合已有类似接口的标准。

### 10.2 服务层检查

- [ ] 新增 / 修改的 Service 是否遵守静态方法 + 领域边界。
- [ ] 是否正确处理事务与幂等；有无遗漏的回滚或重复提交风险。
- [ ] 是否滥建新 Service（< 5 个接口且无复用），而不是合并进现有 Service。
- [ ] 是否跨领域直接操作其他领域的表（必须通过对应 Service）。
- [ ] Service 头部注释是否与代码复杂度匹配。

### 10.3 模型层检查

- [ ] 新模型是否在 `models/index.js` 注册并写明用途。
- [ ] 是否复用了现有业务模型而不是重新造轮子。
- [ ] 是否考虑到与现有事务 / 审计 / 幂等逻辑的衔接。

### 10.4 数据一致性与安全

- [ ] 每条"会改积分 / 库存 / 抽奖结果 / 权限"的代码路径，是否都经过 Service 层。
- [ ] 是否有完整的失败处理与日志记录，便于问题追踪。
- [ ] 是否保持了与当前实现一致的时间 / 时区 / 日志规范（例如统一使用 `BeijingTimeHelper`）。
- [ ] 涉及敏感操作是否记录审计日志（通过 `AuditLogService`）。

### 10.6 兑换市场专项检查（强制）

- [ ] **支付类型校验**：兑换市场相关接口是否强制校验 `payment_type != 'points'` 或 `price_type = 'virtual'`。
- [ ] **参数命名约束**：路由/Service 方法是否出现 `points` / `points_amount` / `points_paid` 等参数名（禁止出现）。
- [ ] **Service 边界隔离**：`ExchangeMarketService` 是否调用了 `PointsService.consumePoints()` 或直接操作积分相关表（禁止调用）。
- [ ] **事务回滚机制**：如检测到积分支付尝试，是否立即抛出错误并回滚整个事务（不得部分提交）。
- [ ] **审计日志完整性**：兑换市场订单创建/更新是否记录了 `business_id` 幂等键和审计日志（必须记录）。
- [ ] **模型约束对齐**：`ExchangeMarketRecord` 模型定义是否添加了防呆约束或在注释中明确声明"禁止积分支付"（推荐但非强制）。

### 10.5 胖路由专项检查

- [ ] 路由文件总行数是否 < 800 行。
- [ ] 单个路由函数是否 < 50 行（不含注释）。
- [ ] 是否有直接操作 models 的代码（`models.Xxx.*`）。
- [ ] 是否有在路由内开启事务的代码（`sequelize.transaction()`）。
- [ ] 是否有在路由内实现多步业务流程的代码。

---

> 附录（示例与背景说明）已移动至 `docs/路由层、模型层、服务层、数据一致性文档-附录与示例.md`，本文件仅保留规则/标准。

---

## 十一、规范执行优先级与适用性说明

### 11.1 规范分级体系

本文档所有规范按照"当前项目规模与业务复杂度"分为三个级别：

#### 🔴 P0 - 核心强制规范（立即生效，所有新代码必须遵守）

**适用场景**：涉及积分、库存、抽奖结果、权限、兑换订单等**核心资产/状态变更**的业务逻辑。

**强制约束**：

- ✅ **系统形态**：在当前项目中，资产相关逻辑**必须**运行在“单体 Node.js + 单库 MySQL”形态下，不得擅自拆分为跨库/跨服务架构，也不得引入 MQ/Saga 型补偿事务来处理本规范已经覆盖的场景。
- ✅ **资产模型**：
  - 积分 = `UserPointsAccount` + `PointsTransaction`；
  - 不可叠加物品 = `ItemInstance`（唯一真相）；
  - 可叠加资产 = `Account` + `AccountAssetBalance` + `AssetTransaction`（唯一账本/余额真相）；
  - 兑换市场 = `ExchangeMarketRecord`（或等价订单表），并由 `ExchangeMarketService` 统一封装状态流转。
  - **禁止**旁路新增第二套“资产/物品真相”体系（包括保留历史真相表的业务语义/文档注释）。
- ❌ **路由层禁止直接操作 models**（`models.Xxx.*` 调用）
- ❌ **路由层禁止开启事务**（`sequelize.transaction()`）
- ❌ **Service 禁止跨领域直接操作其他领域的表**（必须通过对应 Service）
- ✅ **所有敏感操作必须有事务保护 + 幂等控制 + 审计日志**：
  - “扣积分 / 改库存 / 下兑换订单”这三类操作，**必须**满足：单库事务 + 行级锁 + `business_id` 幂等；
  - “改权限 / 改关键配置”必须通过对应 Service 统一入口（如 `UserRoleService.updateUserRole`），在入口内同时完成校验 + 事务 + 审计（`AuditLogService`）+ 缓存失效。
- ✅ **必须使用 ServiceManager 获取服务**（`req.app.locals.services.getService()`）
- ✅ **必须使用统一响应中间件**（`res.apiSuccess / res.apiError / res.apiInternalError`）

**技术标准**：

- ✅ Service 层采用静态方法（与现有 PointsService / InventoryService 一致）
- ✅ 事务处理支持外部传入（`options.transaction` 参数）
- ✅ 幂等性通过 `business_id` 控制（防止重复提交）
- ✅ 错误处理保持简单直接（Service 层 throw Error，Controller 层分类处理）

**判断标准**：如果你的新功能会"改积分余额 / 改库存状态 / 改抽奖结果 / 改用户权限 / 改订单状态"，必须严格遵守 P0 规范。

---

#### 🟡 P1 - 重要建议规范（新代码推荐遵守，存量代码渐进优化）

**适用场景**：只读查询、后台展示、统计报表、简单 CRUD 等**非核心资产变更**的业务逻辑。

**建议约束**：

- ✅ 路由层保持薄层设计（只做鉴权、参数校验、调用 Service、统一响应）
- ✅ 单个路由函数控制在 **< 50 行**（不含注释）
- ✅ 单个路由文件控制在 **< 800 行**（含注释）
- ✅ 复杂查询逻辑下沉到 Service（避免在路由层拼装复杂条件）
- ✅ 数据脱敏通过 Sequelize `attributes` + 视图常量（当模型有 ≥3 种输出场景时）
- ✅ 顶层接口（`/health`、`/api`、`/api/v4`、`/api/v4/docs` 等）也应通过统一适配函数遵循 ApiResponse 响应结构
- ✅ 异步路由统一使用 `asyncHandler` 包裹，而不是在每个 handler 内手写 try/catch
- ✅ 导出/下载接口如需直接返回二进制流，必须在注释中标明“规范允许的 ApiResponse 特例”

**判断标准**：如果你的新功能是"查询列表 / 查看详情 / 导出报表 / 后台展示"，按 P1 规范审查其“分层与职责边界”。

---

#### 🟢 P2 - 可选整理规范（非强制）

**适用场景**：代码整理、架构优化、技术债务清理等**非功能性改进**。

**约束**：

- P2 不得削弱/绕过 P0 资产一致性、事务、幂等、审计等硬性规范。
- P2 不得引入新的抽象层导致维护成本显著上升（尤其是 Repository / BaseService / DI）。
- P2 不得引入新的"第二套资产/物品真相"模型。

**禁止引入**：

- ❌ 禁止为 **< 5 个接口**的功能新建独立 Service
- ❌ 禁止引入 Repository / BaseService / DI 框架等新抽象层
- ❌ 禁止引入"引擎""平台""子域"等重量级抽象（除非核心域必需）

---

### 11.2 规范适用性自查清单

**新功能开发前，快速判断应遵守的规范级别**：

| 问题                   | 回答 | 应遵守规范                              |
| ---------------------- | ---- | --------------------------------------- |
| 是否会修改积分余额？   | 是   | 🔴 P0                                   |
| 是否会修改库存状态？   | 是   | 🔴 P0                                   |
| 是否会修改抽奖结果？   | 是   | 🔴 P0                                   |
| 是否会修改用户权限？   | 是   | 🔴 P0                                   |
| 是否会修改订单状态？   | 是   | 🔴 P0                                   |
| 是否涉及兑换市场订单？ | 是   | 🔴 P0（必须遵守第七章兑换市场隔离规范） |
| 是否涉及多表写操作？   | 是   | 🔴 P0（必须用事务）                     |
| 是否可能被重复调用？   | 是   | 🔴 P0（必须幂等）                       |
| 是否只是查询展示？     | 是   | 🟡 P1                                   |
| 是否只是后台统计？     | 是   | 🟡 P1                                   |
| 是否只是代码整理？     | 是   | 🟢 P2                                   |
