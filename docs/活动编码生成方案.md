# 活动编码（campaign_code）生成方案

> 决策日期：2026-02-22
> **实施状态：已完成** ✅（2026-02-22 后端 + Web管理后台 已全部实施）
> **二次验证：通过** ✅（2026-02-23 全量代码审查 + 真实业务测试 + 质量检查）
> 决策结论：采用"后端自增 + 前缀"方案（前缀 `CAMP`，4 位序号），前端不再生成编码
> 已确认：旧编码保留不动 ｜ 创建表单灰色只读"系统自动生成" ｜ 旧数据不清洗 ｜ 生成器放 `utils/`
> 影响范围：前端创建活动表单、后端活动创建接口
> 验证方式：连接真实数据库 `restaurant_points_dev` 查询验证（非备份文件）
> **验证结果**：创建活动不传 campaign_code → 后端自动生成 `CAMP202602230001` → 格式正确 → 新旧共存正常
> **微信小程序前端**：无需改动（详见第十五节）

---

## 一、要解决的问题

### 1.1 现状（真实数据库验证 2026-02-22）

当前活动编码由**前端浏览器**生成，规则为 `CAMP_{毫秒时间戳}_{6位随机字符}`。

**生成逻辑位于前端**：`admin/src/modules/lottery/composables/campaigns.js` 第 194-198 行

```javascript
generateCampaignCode() {
  const timestamp = Date.now()
  const random = Math.random().toString(36).substring(2, 8).toUpperCase()
  return `CAMP_${timestamp}_${random}`
}
```

**数据库真实数据**（`SELECT lottery_campaign_id, campaign_name, campaign_code, status, created_at FROM lottery_campaigns`）：

| lottery_campaign_id | campaign_name | campaign_code | status | created_at |
|---------------------|--------------|---------------|--------|------------|
| 1 | 餐厅积分抽奖 | `BASIC_LOTTERY` | active | 2025-08-20 |
| 25 | 走走走 | `CAMP_1769298977641_853LKG` | ended | 2026-01-25 |
| 26 | 再找找 | `CAMP_1769299553926_MRXZNB` | paused | 2026-01-25 |
| 27 | 12312 | `CAMP_1769347406486_TUS05A` | ended | 2026-01-25 |

**`campaign_code` 列定义**（`SHOW COLUMNS FROM lottery_campaigns LIKE 'campaign_code'`）：

| Field | Type | Null | Key | Default | Extra |
|-------|------|------|-----|---------|-------|
| campaign_code | varchar(100) | NO | UNI | NULL | |

**campaign_code 在数据库中的使用范围**（`INFORMATION_SCHEMA.COLUMNS` 查询）：

仅 `lottery_campaigns` 表有 `campaign_code` 列。系统中 **19 张表** 通过 `lottery_campaign_id`（整数外键）关联活动，没有任何表用 `campaign_code` 字符串做关联：

> `account_asset_balances`、`lottery_alerts`、`lottery_campaign_pricing_config`、`lottery_campaign_quota_grants`、`lottery_campaign_user_quota`、`lottery_daily_metrics`、`lottery_draws`、`lottery_hourly_metrics`、`lottery_presets`、`lottery_prizes`、`lottery_simulation_records`、`lottery_strategy_config`、`lottery_tier_matrix_config`、`lottery_tier_rules`、`lottery_user_daily_draw_quota`、`lottery_user_experience_state`、`preset_budget_debt`、`preset_inventory_debt`

### 1.2 存在的问题

| 问题 | 说明 |
|------|------|
| 前端生成不安全 | 浏览器时间可能不准，`Math.random()` 非密码学安全，运营可篡改 |
| 编码对运营无意义 | `CAMP_1771783028583_JCGQCD` 是一串乱码，看到也没用 |
| 运营不该填这个字段 | 运营不知道该填什么，大多数时候不会改自动生成的值 |
| 沟通成本高 | 排查问题时说"CAMP下划线1771783028583下划线JCGQCD"很痛苦 |

---

## 二、行业调研

### 2.1 各公司活动编码设计

| 公司/行业 | 编码生成策略 | 生成位置 | 运营是否可见/可改 |
|---|---|---|---|
| 美团 | 后端自增ID + 业务前缀 | 后端 | 只读展示 |
| 阿里（淘宝/天猫） | 后端 Snowflake ID | 后端 | 运营看不到，只看活动名 |
| 腾讯（微信/QQ） | 后端自增 + 前缀 | 后端 | 只读展示 |
| 抖音/巨量引擎 | 后端 Snowflake | 后端 | 运营看不到 |
| 游戏公司（网易/米哈游） | 策划手填有语义的英文ID | 策划填写 | 上线后锁死 |
| 银行/券商 | 监管报备编码，人工制定 | 人工+系统 | 合规部门制定，不可改 |
| Steam/虚拟交易 | 后端自增数字 | 后端 | 完全不可见 |

### 2.2 行业共识

- **编码是给机器看的，锁死；名称是给人看的，随便改**
- **全行业没有人在前端生成业务编码，都是后端生成**
- 小项目用自增+前缀，大厂分布式系统用 Snowflake

### 2.3 ID 生成方案对比

| 方案 | 示例 | 优点 | 缺点 | 适用场景 |
|------|------|------|------|---------|
| 自增数字 | `1, 2, 3` | 最简单，查询最快 | 无语义，分布式不安全 | 内部主键 |
| 自增+前缀 | `CAMP202602230001` | 简单、可读、有时间语义 | 依赖单数据库 | 中小项目业务编码 |
| Snowflake | `7281934850123456789` | 分布式安全，每毫秒400万+ | 19位数字无语义，实现复杂 | 日百万级订单的大厂 |
| UUID v4 | `a3f8c2d1-...` | 全球唯一，无需协调 | 36位太长，索引性能差 | 临时标识、日志追踪 |

### 2.4 为什么选"自增+前缀"

本项目数据规模：66 个用户、4 个活动、6978 个物品。即使发展为中小电商（日均几千单），自增+前缀依然绑绑有余。

| 指标 | Snowflake 设计目标 | 本项目实际情况 |
|------|---|---|
| 服务器数量 | 1024 台 | 1 台 |
| 每秒生成量 | 400 万+/秒 | 一天 1-2 个活动 |
| 数据库数量 | 多个分库分表 | 1 个 MySQL |

用 Snowflake 生成活动编码 = 用火箭送外卖。等日订单突破十万级再考虑也不迟。

---

## 三、决策方案

### 3.1 新编码格式

```
CAMP{YYYYMMDD}{4位自增序号}
```

| 示例 | 含义 |
|------|------|
| `CAMP202602230001` | 2026年2月23日创建的第1个活动 |
| `CAMP202602230002` | 同一天创建的第2个活动 |
| `CAMP202603150001` | 2026年3月15日创建的第1个活动 |

### 3.2 生成规则

- **生成位置**：后端（活动创建 API 内部），前端不参与
- **日期部分**：北京时间 `YYYYMMDD`（复用项目现有 `BeijingTimeHelper`）
- **序号部分**：当天已创建活动数 + 1，补零到 4 位
- **唯一约束**：数据库 UNIQUE 索引保底，若冲突则序号 +1 重试

### 3.3 字段职责明确

| 字段 | 谁生成 | 谁能看 | 谁能改 | 用途 |
|------|--------|--------|--------|------|
| `lottery_campaign_id` | 数据库自增 | 运营不可见 | 不可改 | 内部表关联（外键） |
| `campaign_code` | 后端自动生成 | 运营只读展示 | 创建后不可改 | API 路由、日志、运营沟通 |
| `campaign_name` | 运营填写 | 运营可见 | 随时可改 | 前端展示、活动名称 |

### 3.4 前端界面变更

**创建活动表单**：

- "活动代码"输入框改为**灰色只读**，显示占位文字"系统自动生成"
- 提交时不传 `campaign_code`，由后端生成

**编辑活动表单**：

- "活动代码"显示为只读文本（当前已是 readonly，保持不变）

**活动列表**：

- 活动代码列保留展示（方便运营复制给技术排查问题）

---

## 四、已有数据兼容

已有的 4 条活动编码不需要修改，新旧格式可以共存：

| 活动ID | 现有编码 | 处理方式 |
|--------|---------|---------|
| 1 | `BASIC_LOTTERY` | 保留不动 |
| 25 | `CAMP_1769298977641_853LKG` | 保留不动 |
| 26 | `CAMP_1769299553926_MRXZNB` | 保留不动 |
| 27 | `CAMP_1769347406486_TUS05A` | 保留不动 |
| 新活动 | `CAMP202602230001` | 新格式 |

`campaign_code` 字段是 VARCHAR(100)，两种格式都能存，数据库 UNIQUE 约束保证不冲突。其他 19 张关联表全部通过 `lottery_campaign_id`（整数主键）做外键关联，不受编码格式变化影响。

---

## 五、后端技术栈对齐与可复用资源分析

> 以后端数据库项目实际技术框架为准

### 5.1 后端技术栈现状

| 层级 | 技术 | 说明 |
|------|------|------|
| 运行时 | Node.js v20.18.0 | 单体应用 |
| 框架 | Express | REST API |
| ORM | Sequelize | MySQL 驱动 |
| 数据库 | MySQL（Sealos 托管） | 单库 `restaurant_points_dev` |
| 事务管理 | `TransactionManager.execute()` | 路由层管事务边界 |
| 事务断言 | `assertAndGetTransaction()` | Service 层强制要求事务传入 |
| 服务注册 | `ServiceManager._services.set()` | 静态类注册，路由层通过 `req.app.locals.services.getService()` 获取 |
| API 响应 | `ApiResponse.middleware()` | `res.apiSuccess()` / `res.apiError()` |
| 时间工具 | `BeijingTimeHelper` (`utils/timeHelper.js`) | 全项目统一北京时间处理 |
| 日志 | `logger` (`utils/logger.js`) | 结构化日志 |
| 时区 | `TZ=Asia/Shanghai` (.env) | 服务器级别设置 |

### 5.2 已有可复用模式

| 可复用资源 | 位置 | 复用方式 |
|-----------|------|---------|
| `TrackingCodeGenerator` | `utils/TrackingCodeGenerator.js` | **直接参考其静态类设计模式**：`generate()` / `parse()` / `validate()` 三件套。新建 `CampaignCodeGenerator` 采用相同模式 |
| `BeijingTimeHelper.createBeijingTime()` | `utils/timeHelper.js` | 生成编码日期部分用 `BeijingTimeHelper` 获取北京时间日期 |
| `assertAndGetTransaction()` | `utils/transactionHelpers.js` | CRUDService 内部已在使用，不需要额外改动 |
| `TransactionManager.execute()` | `utils/TransactionManager.js` | 路由层已在使用，不需要额外改动 |
| `LotteryCampaign.findOne()` | `models/LotteryCampaign.js` | 查询当天已有活动数量用 Sequelize 的 `count()` |

### 5.3 可扩展设计

`CampaignCodeGenerator` 作为独立工具类，未来可扩展：

| 扩展点 | 场景 | 说明 |
|--------|------|------|
| 新增 `parse()` 方法 | 日志系统根据编码解析创建日期 | 与 `TrackingCodeGenerator.parse()` 同模式 |
| 前缀可配置 | 未来有非 CAMP 类型的活动 | 构造函数或参数传入前缀 |
| 序号位数可配置 | 日创建活动数超过 9999 | 改 4 位为 6 位 |

---

## 六、问题归属划分

### 6.1 后端数据库项目问题（2 个文件）

| 序号 | 文件 | 具体问题 | 改动类型 |
|------|------|---------|---------|
| B1 | `services/admin-lottery/CRUDService.js` | `createCampaign()` 第 89-101 行要求前端传入 `campaign_code` 且验证非空，应改为后端自动生成 | 逻辑修改 |
| B2 | `routes/v4/console/system-data.js` | `POST /lottery-campaigns` 第 357-359 行校验 `campaign_code` 非空，应删除此校验 | 删除校验 |
| B3 | 新增 `utils/CampaignCodeGenerator.js` | 新建编码生成工具类（参考 `TrackingCodeGenerator` 模式） | 新增文件 |

### 6.2 Web 管理后台前端项目问题（2 个文件）

| 序号 | 文件 | 具体问题 | 改动类型 |
|------|------|---------|---------|
| F1 | `admin/src/modules/lottery/composables/campaigns.js` | 第 194-198 行 `generateCampaignCode()` 方法需删除；第 213 行 `campaign_code: this.generateCampaignCode()` 需移除；第 314-316 行 `campaign_code` 非空校验需删除；第 337 行提交数据中 `campaign_code` 需移除 | 删除代码 |
| F2 | `admin/lottery-management.html` | 创建表单中"活动代码"输入框改为灰色只读，显示占位文字"系统自动生成"；编辑表单保持 readonly 不变 | HTML 修改 |

### 6.3 微信小程序前端项目问题

| 序号 | 说明 |
|------|------|
| W1 | 小程序不涉及活动创建，只调用抽奖 API（通过 `lottery_campaign_id` 或 `campaign_code` 路由参数）。编码格式变化对小程序**无影响**，不需要改动 |

---

## 七、后端实现方案（精确到文件和行号）

### 7.1 步骤一：新建 `utils/CampaignCodeGenerator.js`

> 参考现有 `utils/TrackingCodeGenerator.js` 的静态类模式

```javascript
'use strict'

const BeijingTimeHelper = require('./timeHelper')
const { LotteryCampaign } = require('../models')
const { Op } = require('sequelize')

class CampaignCodeGenerator {
  /**
   * 生成活动编码
   *
   * 格式：CAMP{YYYYMMDD}{4位序号}
   * 示例：CAMP202602230001
   *
   * @param {Object} options
   * @param {Object} options.transaction - Sequelize 事务对象（必填）
   * @returns {Promise<string>} 活动编码
   */
  static async generate({ transaction }) {
    const now = BeijingTimeHelper.createBeijingTime()
    const yyyy = String(now.getFullYear())
    const mm = String(now.getMonth() + 1).padStart(2, '0')
    const dd = String(now.getDate()).padStart(2, '0')
    const dateStr = `${yyyy}${mm}${dd}`
    const prefix = `CAMP${dateStr}`

    // 查询当天已有的同前缀活动数量
    const todayCount = await LotteryCampaign.count({
      where: {
        campaign_code: { [Op.like]: `${prefix}%` }
      },
      transaction
    })

    const seq = String(todayCount + 1).padStart(4, '0')
    return `${prefix}${seq}`
  }

  /**
   * 解析活动编码
   *
   * @param {string} code - 活动编码
   * @returns {{ date_part: string, seq: number } | null}
   */
  static parse(code) {
    if (!code || !code.startsWith('CAMP') || code.length < 16) return null
    const datePart = code.slice(4, 12)
    const seqPart = code.slice(12)
    const seq = parseInt(seqPart, 10)
    if (isNaN(seq)) return null
    return { date_part: datePart, seq }
  }

  /**
   * 验证活动编码格式
   *
   * @param {string} code - 待验证编码
   * @returns {boolean}
   */
  static validate(code) {
    if (!code || typeof code !== 'string') return false
    return /^CAMP\d{12,}$/.test(code)
  }
}

module.exports = CampaignCodeGenerator
```

### 7.2 步骤二：修改 `services/admin-lottery/CRUDService.js`

**当前代码**（第 88-101 行）：

```javascript
const { campaign_name, campaign_code, campaign_type } = campaignData
if (!campaign_name) { ... }
if (!campaign_code) { ... }  // ← 删除这段
if (!campaign_type) { ... }
```

**改为**：

```javascript
const CampaignCodeGenerator = require('../../utils/CampaignCodeGenerator')

const { campaign_name, campaign_type } = campaignData
if (!campaign_name) { ... }
if (!campaign_type) { ... }

// 后端自动生成活动编码（忽略前端传入的值）
const campaign_code = await CampaignCodeGenerator.generate({ transaction })
```

**同时修改第 116-127 行**（去除手动查重，因为生成逻辑内部已保证唯一）：

改为在 `LotteryCampaign.create()` 时用 try/catch 捕获 UNIQUE 冲突，冲突时序号 +1 重试（最多 3 次）。

### 7.3 步骤三：修改 `routes/v4/console/system-data.js`

**当前代码**（第 357-359 行）：

```javascript
if (!campaignData.campaign_code) {
  return res.apiError('活动代码不能为空', 'VALIDATION_ERROR', null, 400)
}
```

**改为**：删除这三行。`campaign_code` 不再是前端传入的必填字段。

### 7.4 步骤四：修改 `admin/src/modules/lottery/composables/campaigns.js`

1. **删除** 第 194-198 行 `generateCampaignCode()` 方法
2. **修改** 第 211-213 行 `openCreateCampaignModal()` 中，移除 `campaign_code: this.generateCampaignCode()`
3. **删除** 第 314-316 行 `submitCampaignForm()` 中的 `campaign_code` 非空校验
4. **删除** 第 337 行 `requestData` 中的 `campaign_code` 属性

### 7.5 步骤五：修改 `admin/lottery-management.html`

创建表单中"活动代码"输入框：
- 创建模式：输入框设为 `readonly`，灰色背景，`placeholder="系统自动生成"`，不绑定 `x-model`
- 编辑模式：保持 readonly 展示（当前已是 readonly，不需改动）

---

## 八、安全性说明

### 8.1 改 campaign_code 会不会打破体系？

**不会。** `campaign_code` 属于配置类数据，不参与任何对账互锁机制。

系统中有两套"互锁"需要小心：

| 互锁组 | 涉及的表 | 与 campaign_code 的关系 |
|--------|---------|----------------------|
| 材料资产互锁 | `account_asset_balances` ↔ `asset_transactions` | 无关，用 `account_id` 关联 |
| 物品三表互锁 | `items` ↔ `item_ledger` ↔ `item_holds` | 无关，用 `item_id` 关联 |

所有流水表、账本表都用 `lottery_campaign_id`（数字主键）做外键关联，没有任何表用 `campaign_code` 字符串做关联。改编码生成规则是安全的。

### 8.2 新旧编码共存会不会有问题？

不会。`campaign_code` 是 VARCHAR(100) + UNIQUE 约束，只要值不重复，任何格式都能共存。

### 8.3 并发冲突处理

极端情况下两个管理员同时创建活动，可能生成相同编码。处理方式：

1. 数据库 `unique_campaign_code` 索引保底
2. `LotteryCampaign.create()` 捕获 `SequelizeUniqueConstraintError`
3. 冲突时序号 +1 重试，最多重试 3 次
4. 当前规模（4 个活动、1-2 个管理员），实际概率为零

---

## 九、为什么需要"双标识"（`lottery_campaign_id` + `campaign_code`）

### 9.1 两个字段各管各的

| | `lottery_campaign_id` | `campaign_code` |
|---|---|---|
| **比喻** | 数据库里的"行号" | 活动的"工号牌" |
| **谁用** | 机器内部用 | 人和 API 用 |
| **长什么样** | `1`、`25`、`26` | `BASIC_LOTTERY`、`CAMP202602230001` |
| **可读性** | 看不出是什么活动 | 一眼知道是什么 |
| **出现在哪** | 数据库表关联（外键） | API URL、日志、技术排查 |

### 9.2 为什么不能只留一个

| 只留哪个 | 问题 |
|---|---|
| 只留 `lottery_campaign_id` | 数字 `1` 在系统里到处都是（用户1、奖品1、订单1、活动1），说"1"没人知道在说哪个东西 |
| 只留 `campaign_code` | 字符串做外键性能差；字符串关联容易拼写错误；数据库 JOIN 比数字慢 |

### 9.3 行业通用设计模式

这个设计模式叫**"自增主键 + 业务编码"双标识**，几乎所有系统都这么做：

| 系统 | 内部数字 ID（机器用） | 业务编码（人用） |
|------|----------------------|-----------------|
| 淘宝 | `item_id`（数字） | `item_code`（编码） |
| 银行 | `account_id`（数字） | `account_number`（卡号） |
| 本项目用户表 | `user_id`（数字） | `mobile`（手机号） |
| 本项目活动表 | `lottery_campaign_id`（数字） | `campaign_code`（活动编码） |
| 本项目物品表 | `item_id`（数字） | `tracking_code`（追踪码） |

### 9.4 对应界面上的哪个位置

| 数据库字段 | 界面位置 | 说明 |
|---|---|---|
| `campaign_name` | 创建/编辑表单的"活动名称"输入框 | 运营填写，随时可改 |
| `campaign_code` | 创建表单灰色只读展示"系统自动生成"；编辑表单只读展示实际编码 | 后端自动生成，运营不用管 |
| `lottery_campaign_id` | 界面上不显示 | 数据库自增，用户完全看不到 |

---

## 十、运营和技术的协作方式

### 10.1 核心原则

运营不需要记编码，直接说**活动名称**就行。技术自己去后台用活动名称找到对应的编码来操作。

### 10.2 实际沟通场景

| 运营说 | 技术做 |
|---|---|
| "**春节大转盘**的库存加一下" | 打开后台 → 找到"春节大转盘" → 看到编码 `CAMP202602230001` → 操作 |
| "昨天那个**新活动**中奖率好像不对" | 在后台活动列表找到 → 拿着编码去查日志 |
| "把**店庆抽奖**暂停一下" | 搜活动名称 → 找到 → 暂停 |

### 10.3 类比

就像去银行：你报手机号或名字，柜员用内部账号帮你操作。你不需要知道银行内部的账户序列号。

活动编码同理：它是技术排查问题时用的工具，运营不需要接触它。运营只管活动名称——"春节抽奖活动"、"店庆大转盘"，这才是运营的工作。

---

## 十一、适用规模评估

| 级别 | 日订单量 | 自增+前缀够不够 | 例子 |
|---|---|---|---|
| 小项目 | 几十~几千单/天 | 完全够用 | 本项目、微店、有赞小商家 |
| 中电商 | 几万~几十万单/天 | 还是够用 | 单体 MySQL 极限约 5000+/秒 |
| 大电商 | 百万单/天以上 | 不够，要上 Snowflake | 淘宝、京东、拼多多 |

本项目当前 66 个用户、4 个活动，即使发展为中小电商也完全适用。等日订单突破十万级、需要分库分表时，只需改 ID 生成那一个函数，不影响其他业务逻辑。

---

## 十二、Web 管理后台前端技术栈兼容性分析

### 12.1 前端技术栈现状

| 层级 | 技术 | 版本 |
|------|------|------|
| UI 框架 | Alpine.js | v3.15.4 |
| 构建工具 | Vite | v6.4.1 |
| CSS 框架 | Tailwind CSS | v3.4.19 |
| 图表 | ECharts | v6.0.0 |
| 实时通信 | Socket.io-client | v4.8.3 |
| 架构模式 | Composables 模式（类 Vue Composition API） | — |
| 应用类型 | 多页面应用（每个功能一个 HTML 文件） | — |

### 12.2 前端字段命名已对齐后端

前端已全局使用后端 snake_case 字段名（如 `campaign_name`、`campaign_code`、`campaign_type`），**不需要做字段映射**。提交数据时直接用后端字段名构建 `requestData`。

### 12.3 前端改动兼容性评估

| 改动项 | 是否兼容当前前端技术栈 | 说明 |
|--------|---------------------|------|
| 删除 `generateCampaignCode()` | 完全兼容 | 纯删除，无副作用 |
| 创建表单隐藏 `campaign_code` 输入框 | 完全兼容 | Alpine.js 的 `x-show` 指令或 `x-if` 即可 |
| 编辑表单 `campaign_code` 只读 | 已经是 | `:readonly="isEditMode"` 已在 HTML 中 |
| `submitCampaignForm()` 不传 `campaign_code` | 完全兼容 | 从 `requestData` 对象中删除该属性即可 |
| 活动列表展示 `campaign_code` | 无需改动 | 后端 API 返回的 `campaign_code` 照常展示 |

**结论：所有前端改动都在 Alpine.js + Composables 模式的能力范围内，不需要引入新依赖或改变架构。**

---

## 十三、已确认的决策（2026-02-22）

| 决策项 | 结论 | 理由 |
|--------|------|------|
| **编码前缀** | `CAMP` | 与现有 4 条旧编码（`CAMP_...`）自然过渡，无割裂感 |
| **序号位数** | 4 位（每日上限 9999） | 远超实际需求（日均 1-2 个活动），预留充足空间 |
| **`CampaignCodeGenerator` 位置** | `utils/CampaignCodeGenerator.js` 独立文件 | 与 `TrackingCodeGenerator` 同级，模式统一，可复用 |
| **创建表单"活动代码"字段** | 灰色只读输入框，显示占位文字"系统自动生成" | 运营知道此字段存在但无需填写 |
| **已有 4 条旧编码** | 保留不动，新旧共存 | 仅 4 条测试数据，`BASIC_LOTTERY` 有语义保留更好，零风险 |
| **旧数据是否清洗** | 不清洗 | 4 条测试数据，新旧共存零风险，无需停机迁移 |

---

## 十四、实施记录（2026-02-22）

### 14.1 后端数据库项目修改

| 文件 | 操作 | 说明 |
|------|------|------|
| `utils/CampaignCodeGenerator.js` | **新增** | 活动编码生成器（静态类 generate/parse/validate 三件套） |
| `services/admin-lottery/CRUDService.js` | **修改** | `createCampaign()` 不再要求前端传 `campaign_code`，改为自动调用 `CampaignCodeGenerator.generateWithRetry()` |
| `routes/v4/console/system-data.js` | **修改** | 删除 `campaign_code` 非空校验（3 行） |

### 14.2 Web 管理后台前端修改

| 文件 | 操作 | 说明 |
|------|------|------|
| `admin/src/modules/lottery/composables/campaigns.js` | **修改** | 删除 `generateCampaignCode()` 方法、删除表单初始化中的 `campaign_code` 赋值、删除提交校验、删除提交数据中的 `campaign_code` |
| `admin/lottery-management.html` | **修改** | 创建表单"活动代码"改为灰色只读，placeholder 显示"系统自动生成" |
| `admin/src/modules/content/composables/index.js` | **修改** | 补充导出 `useUserContextState`、`useUserContextMethods`（构建时发现的预先存在的缺失） |

### 14.3 质量检查结果

| 检查项 | 首次验证（2026-02-22） | 二次验证（2026-02-23） |
|--------|----------------------|----------------------|
| ESLint（后端 3 个文件） | 0 错误，3 个 `no-await-in-loop` 警告（重试逻辑必要） | ✅ 一致 |
| Prettier | 通过 | ✅ 一致 |
| 前端构建 `npm run admin:build` | 构建成功（12.78s） | ✅ 构建成功（10.25s） |
| 健康检查 `/health` | `SYSTEM_HEALTHY` | ✅ `SYSTEM_HEALTHY`（DB + Redis 正常） |
| 创建活动（不传 campaign_code） | `CAMP202602230002` 格式正确 | ✅ `CAMP202602230001` 格式正确 |
| 活动列表查询 | 新旧编码共存正常 | ✅ 一致（4条旧 + 新格式共存） |
| Jest `campaign_lifecycle.test.js` | 10/10 通过 | ✅ 10/10 通过 |

### 14.4 二次验证详情（2026-02-23 全量代码审查）

| 验证项 | 验证方法 | 结果 |
|--------|---------|------|
| `utils/CampaignCodeGenerator.js` 实现正确 | 逐行阅读 generate/generateWithRetry/parse/validate | ✅ 符合方案 |
| `CRUDService.js` 不再要求前端传 campaign_code | 阅读 createCampaign() 第 89-105 行 | ✅ 自动调用 CampaignCodeGenerator |
| `system-data.js` 删除 campaign_code 校验 | grep 搜索验证 | ✅ 校验已删除 |
| `campaigns.js` 删除前端生成逻辑 | 搜索 generateCampaignCode、requestData | ✅ 无生成方法，不提交 campaign_code |
| `lottery-management.html` 创建表单灰色只读 | 搜索 "系统自动生成" | ✅ readonly + bg-gray-100 + placeholder |
| 端到端业务测试 | 登录 → POST 创建活动 → 检查响应 | ✅ 返回 CAMP202602230001 |
| 数据库真实数据 | 查询 lottery_campaigns 全表 | ✅ 新旧编码正常共存 |
| 项目整体运行状态 | /health + Redis PING + PM2 | ✅ 全部正常 |

---

## 十五、微信小程序前端对接说明

### 15.1 对小程序的影响

**无影响。** 小程序不涉及活动创建，只调用抽奖相关 API。

### 15.2 小程序涉及的 campaign_code 场景

| 场景 | API | 说明 | 是否需要改动 |
|------|-----|------|-------------|
| 获取活动列表 | `GET /api/v4/lottery/campaigns` | 返回的 `campaign_code` 字段照常使用 | 不需要 |
| 获取活动详情 | `GET /api/v4/lottery/campaigns/:id` | 返回的 `campaign_code` 字段照常使用 | 不需要 |
| 参与抽奖 | `POST /api/v4/lottery/draw` | 通过 `lottery_campaign_id` 关联活动 | 不需要 |

### 15.3 编码格式变化对小程序的影响

小程序使用 `lottery_campaign_id`（数字主键）做 API 调用参数，不使用 `campaign_code` 做路由参数。编码格式从 `CAMP_1769298977641_853LKG` 变为 `CAMP202602230001` 仅影响展示文本（如果小程序有展示活动编码的地方），不影响任何业务逻辑。

### 15.4 小程序前端需要关注的要点

1. **不要在小程序端生成 campaign_code** — 这是后端的职责
2. **活动列表和详情 API 返回的 `campaign_code` 可直接展示**，无需特殊处理
3. **新旧编码格式共存**，不要对 `campaign_code` 做格式校验（既有 `BASIC_LOTTERY` 也有 `CAMP202602230001`）
4. **所有表关联都通过 `lottery_campaign_id`（整数）**，不通过 `campaign_code`（字符串）
