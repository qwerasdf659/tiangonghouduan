# P0级问题聚焦清单

**生成时间**：2026年01月09日  
**项目版本**：V4.0.0  
**文档目的**：聚焦 P0 级别问题（强一致性/安全/业务风险），优先处理  
**优先级定义**：P0 = 强一致/安全/会导致业务风险，必须立即处理  
**来源文档**：`docs/待处理问题清单-2026-01-09.md`

---

## 概览

| 问题编号 | 问题描述                                   | 预计工时 | 状态   | 依赖关系                     |
| -------- | ------------------------------------------ | -------- | ------ | ---------------------------- |
| P0-1     | 测试代码硬编码真实用户ID/活动ID            | 2小时    | 待处理 | 无                           |
| P0-2     | 测试连接真实库导致"孤儿冻结"仍可能再次出现 | 4小时    | 待处理 | 需创建Service+接口+定时任务  |
| P0-3     | TransactionManager 对业务错误做了重试      | 3小时    | 待处理 | 需修改错误分类逻辑           |
| P0-4     | C2C 禁止 POINTS/BUDGET_POINTS 仅靠 DB 拦截 | 2小时    | 待处理 | 需添加白名单语义检查         |
| P0-5     | 审计日志 target_type 命名不统一            | 3-4小时  | 待处理 | 需要数据库迁移（已拍板方案） |

**总计工时**：14-15 小时  
**建议完成时间**：3 个工作日内

---

## P0-1：测试代码硬编码真实用户ID/活动ID

### 问题位置

- `tests/helpers/test-setup.js` 第285-302行

### 问题现状

```javascript
// ❌ 当前硬编码方式
realData: {
  testUser: {
    mobile: '13612227930',
    user_id: 31  // 硬编码用户ID
  },
  adminUser: {
    mobile: '13612227930',
    user_id: 31  // 硬编码管理员ID
  },
  testCampaign: {
    campaign_id: 2,  // 硬编码活动ID
    campaignName: '餐厅积分抽奖活动'
  }
}
```

### 业务风险

- ❌ 换库/数据变动会导致测试不稳定
- ❌ 不符合"测试数据不硬编码、以真实数据驱动"的要求
- ❌ 如果 `user_id: 31` 在新环境不存在，所有测试会静默失败或出现误导性错误

### 解决方案（已拍板）

**使用数据库中的真实活动数据**

测试启动时用 Node.js + Sequelize 从真实库按手机号 `13612227930` 查询 `user_id`，并从数据库中查找真实存在的活跃活动（不再硬编码 campaign_id=2）。数据库中已有活跃活动，测试将使用这些真实活动数据。

### 实施步骤

1. **在 `tests/helpers/test-setup.js` 中添加 `async function loadRealTestData()`**

2. **使用 Sequelize 查询**：

   ```javascript
   const user = await User.findOne({ where: { mobile: '13612227930' } })
   if (!user) {
     throw new Error('测试用户不存在，请在数据库中创建手机号为 13612227930 的用户')
   }
   ```

3. **查找活跃活动**（已拍板规则）：

   ```javascript
   const activeCampaign = await LotteryCampaign.findOne({
     where: {
       status: 'active',
       start_time: { [Op.lte]: new Date() },
       end_time: { [Op.gte]: new Date() }
     },
     order: [['campaign_id', 'ASC']] // 多条时选最早创建的
   })

   if (!activeCampaign) {
     throw new Error('测试环境缺少活跃活动，请确保数据库中有 status=active 且在时间窗口内的活动')
   }
   ```

4. **在 `jest.setup.js` 中调用 `loadRealTestData()` 并将结果存储到 `global.testData`**

5. **所有测试文件从 `global.testData` 获取测试用户ID和活动ID**

### 预期效果

- ✅ 测试数据完全由真实数据库驱动
- ✅ 换库/迁移环境时，只要数据存在就能正常测试
- ✅ 数据不存在时，明确报错提示需要补数据

---

## P0-2：测试连接真实库导致"孤儿冻结"仍可能再次出现

### 问题位置

- `tests/integration/fungible-asset-listing.test.js` 测试清理逻辑
- 任何直接操作数据库表的脚本/工具

### 问题现状

虽然已修复测试清理逻辑使用 `MarketListingService.withdrawFungibleAssetListing()` 并创建了自动清理迁移，但仍存在风险：

```javascript
// ❌ 任何绕过"撤回解冻"链路的操作都会制造孤儿冻结
await MarketListing.destroy({ where: { listing_id } })  // 直接删除，不解冻
await sequelize.query('DELETE FROM market_listings WHERE ...')  // 直接SQL删除
await AccountAssetBalance.update({ frozen_amount: 0 }, { where: ... })  // 直接改余额
```

### 业务风险

- ❌ 测试/脚本只要绕过"撤回解冻"链路就会制造"冻结>挂牌"的孤儿冻结
- ❌ 真实用户资产被卡死，无法正常使用
- ❌ 需要手动运行迁移脚本修复，影响用户体验
- ❌ 允许"测试连真实库"的前提下，风险更高

### 解决方案（已拍板）

**方案 B：detect + 自动修复（用户体验最好）**

把"孤儿冻结自动解冻"收口成**唯一入口**（运维脚本/管理接口走 Service+事务+审计+分布式锁），禁止再出现直改余额/直删挂牌的路径。自动解冻机制已确认符合业务合规要求。

### 实施步骤

#### 1. 创建统一的孤儿冻结清理服务 `services/OrphanFrozenCleanupService.js`

核心功能：

- 使用分布式锁防止并发执行
- 查找孤儿冻结（frozen_amount > 实际挂牌冻结总额）
- 逐条清理（带事务+审计）
- 支持 dryRun 模式（仅检测不修复）

#### 2. 创建管理员接口 `routes/v4/console/orphan-frozen-cleanup.js`

提供两个接口：

- `POST /orphan-frozen/detect` - 检测孤儿冻结（dryRun=true）
  - **权限要求**：所有管理员（`role='admin'`）
- `POST /orphan-frozen/cleanup` - 清理孤儿冻结（dryRun=false）
  - **权限要求**：仅超级管理员（`is_super_admin=true`）
  - **必需参数**：`reason`（清理原因）、`operator_name`（操作人）
  - **审计日志**：记录完整的操作信息

#### 3. 添加定时任务 `jobs/daily-orphan-frozen-check.js`

- **执行时间**：每天凌晨2点固定执行（已拍板）
- 自动检测和清理孤儿冻结
- 发现问题时发送告警通知给管理员
- 记录执行日志和清理结果

#### 4. 在测试清理中强制使用统一入口

```javascript
// tests/helpers/test-cleanup.js
async function cleanupMarketListings(listingIds) {
  // ✅ 强制使用撤回服务
  for (const listingId of listingIds) {
    await MarketListingService.withdrawFungibleAssetListing(listingId, userId, {
      reason: 'test_cleanup'
    })
  }

  // ❌ 禁止直接删除
  // await MarketListing.destroy({ where: { listing_id: { [Op.in]: listingIds } } })
}
```

#### 5. 数据库触发器（已决策：不启用）

**决策理由**：服务层 + 定时任务 + 审计日志已提供足够防护，保持数据库简洁。

~~不实施数据库触发器~~

### 预期效果

- ✅ 孤儿冻结清理有唯一入口，带完整的事务+审计+分布式锁
- ✅ 定时任务每天凌晨2点自动检测和清理，无需手动干预
- ✅ 管理员可通过接口主动检测（所有管理员）和清理（仅超管）
- ✅ 清理操作强制要求 reason 和 operator_name，完整审计追溯
- ✅ 测试清理强制使用正确的撤回逻辑
- ✅ 不使用数据库触发器，保持数据库简洁

---

## P0-3：TransactionManager 对业务错误做了重试

### 问题位置

- `utils/TransactionManager.js` 错误分类逻辑

### 问题现状

```javascript
// ❌ 当前所有错误都可能被重试
async executeInTransaction(operation, options = {}) {
  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      // ...
    } catch (error) {
      // 所有错误都进入重试逻辑
      if (attempt < maxRetries - 1) {
        await this._delay(retryDelay)
        continue
      }
    }
  }
}
```

### 业务风险

- ❌ 业务异常（如"非所有者撤回"、"余额不足"）被重试3次，浪费时间
- ❌ 测试运行变慢（例如权限测试会重试3次）
- ❌ 日志噪声增加（同一错误重复记录3次）
- ❌ 用户体验变差（API响应延迟）

### 解决方案（已拍板）

**重试策略**：

- **4xx/业务码**：永不重试（立即抛出）
- **未知错误**：最多重试 1 次
- **死锁/超时类**：重试 3 次（指数退避）

统一业务异常标识（`error.code`/`statusCode`）并在事务层识别为 `retryable=false`，避免对业务错误重试

### 实施步骤

#### 1. 定义不可重试的业务错误码 `constants/ErrorCodes.js`

```javascript
// 不可重试的业务错误码（客户端错误 4xx）
const NON_RETRYABLE_ERROR_CODES = [
  'PERMISSION_DENIED', // 权限不足
  'INVALID_PARAMS', // 参数错误
  'RESOURCE_NOT_FOUND', // 资源不存在
  'INSUFFICIENT_BALANCE', // 余额不足
  'DUPLICATE_REQUEST', // 重复请求
  'BUSINESS_RULE_VIOLATION', // 业务规则违反
  'INVALID_STATUS', // 状态不合法
  'OWNERSHIP_REQUIRED', // 需要所有权
  'ASSET_NOT_TRADABLE' // 资产不可交易
]

// 可重试的错误码（服务端错误 5xx 或临时性错误）
const RETRYABLE_ERROR_CODES = [
  'DATABASE_DEADLOCK', // 数据库死锁
  'DATABASE_TIMEOUT', // 数据库超时
  'REDIS_CONNECTION_ERROR', // Redis连接错误
  'EXTERNAL_SERVICE_ERROR', // 外部服务错误
  'TEMPORARY_UNAVAILABLE' // 临时不可用
]
```

#### 2. 修改 `TransactionManager._isRetryableError()` 错误分类逻辑

分类规则：

1. 检查 `error.code`（明确标识）
   - 在 `NON_RETRYABLE_ERROR_CODES` 中 → 不重试
   - 在 `RETRYABLE_ERROR_CODES` 中 → 重试 3 次
2. 检查 `error.statusCode`（4xx 不重试，5xx 可重试）
3. 检查错误消息关键词（业务错误关键词 vs 可重试错误关键词）
4. **默认策略**：未知错误重试 1 次（`maxRetries = 1`，总共执行 2 次）

#### 3. 统一业务错误抛出方式（在 Service 层）

```javascript
// services/MarketListingService.js
static async withdrawFungibleAssetListing(listingId, userId, options = {}) {
  // ✅ 抛出带错误码的业务异常
  if (listing.seller_user_id !== userId) {
    const error = new Error('只有挂牌所有者可以撤回')
    error.code = 'OWNERSHIP_REQUIRED'  // 明确标识为业务错误
    error.statusCode = 403
    throw error
  }

  if (listing.status !== 'on_sale') {
    const error = new Error('只能撤回在售状态的挂牌')
    error.code = 'INVALID_STATUS'
    error.statusCode = 400
    throw error
  }
}
```

#### 4. 添加单元测试验证错误分类

测试场景：

- 业务错误不重试（attemptCount = 1）
- 数据库死锁错误会重试（attemptCount = 3）

### 预期效果

- ✅ 业务错误（4xx）立即抛出，不重试
- ✅ 服务端错误（5xx）和临时性错误才重试
- ✅ 测试运行速度提升（权限测试不再重试3次）
- ✅ 日志更清晰（业务错误只记录1次）
- ✅ API响应更快（减少不必要的重试延迟）

---

## P0-4：C2C 禁止 POINTS/BUDGET_POINTS 仅靠 DB 拦截

### 问题位置

- `services/MarketListingService.js` 挂牌入口
- `material_asset_types` 表 `is_tradable` 字段

### 问题现状

```javascript
// ✅ 当前依赖 DB 配置
const assetType = await MaterialAssetType.findOne({
  where: { asset_code: offerAssetCode }
})

if (!assetType.is_tradable) {
  throw new Error('该资产类型不允许交易')
}
```

### 业务风险

- ❌ 一旦有人把 `is_tradable` 改回 `1`，积分类资产就会进入 C2C
- ❌ 如果走到未校验的入口（如直接调用底层方法），就会绕过限制
- ❌ 错误信息不明确，用户不知道为什么不能交易
- ❌ 缺少审计日志，无法追踪谁尝试交易积分

### 解决方案（已拍板）

**永久禁止 POINTS/BUDGET_POINTS 进入 C2C**（商业语义确认）

在 C2C 挂牌入口增加"材料类白名单语义"的强约束（仍以 DB 为真相，但服务层要有明确错误码/错误信息与审计日志），将 POINTS/BUDGET_POINTS 做成服务层硬规则。

### 实施步骤

#### 1. 在 `constants/AssetTypes.js` 中定义材料类白名单

**维护方式**：保持硬编码（已拍板），材料类资产新增频率低，硬编码可控且安全。

```javascript
// 明确的材料类资产（允许 C2C 交易）
const MATERIAL_ASSET_CODES = [
  'red_shard', // 红碎片
  'DIAMOND' // 钻石
  // 未来新增材料需修改此处并发版
]

// 明确禁止 C2C 的资产类型（积分类）
const NON_TRADABLE_ASSET_CODES = [
  'POINTS', // 积分
  'BUDGET_POINTS' // 预算积分
]

module.exports = {
  MATERIAL_ASSET_CODES,
  NON_TRADABLE_ASSET_CODES
}
```

#### 2. 修改 `MarketListingService.createFungibleAssetListing()` 增加三层防护

**第一层：白名单语义检查**（明确的业务规则）

- 检查是否在 `NON_TRADABLE_ASSET_CODES` 黑名单中
- 记录审计日志（rejection_reason: 'points_not_allowed'）

**第二层：DB 配置检查**（以 DB 为真相源）

- 检查 `MaterialAssetType.is_tradable` 字段
- 记录审计日志（rejection_reason: 'db_config_disabled'）

**第三层：材料类白名单检查**（双重保险）

- 检查是否在 `MATERIAL_ASSET_CODES` 白名单中
- 记录警告日志

#### 3. 添加管理员接口查看 C2C 可交易资产

```javascript
// routes/v4/console/marketplace-config.js
router.get('/tradable-assets', authMiddleware.requireAdmin, async (req, res) => {
  // 查询所有材料类资产及其可交易状态
  const assets = await MaterialAssetType.findAll({
    attributes: ['asset_code', 'display_name', 'is_tradable', 'description'],
    order: [['asset_code', 'ASC']]
  })

  const result = assets.map(asset => ({
    asset_code: asset.asset_code,
    display_name: asset.display_name,
    is_tradable: asset.is_tradable,
    in_whitelist: MATERIAL_ASSET_CODES.includes(asset.asset_code),
    in_blacklist: NON_TRADABLE_ASSET_CODES.includes(asset.asset_code),
    effective_tradable:
      asset.is_tradable &&
      MATERIAL_ASSET_CODES.includes(asset.asset_code) &&
      !NON_TRADABLE_ASSET_CODES.includes(asset.asset_code)
  }))

  return res.apiSuccess(result, 'C2C 可交易资产配置')
})
```

#### 4. 添加单元测试验证多层防护

测试场景：

- 积分类资产被白名单拦截
- DB配置 `is_tradable=false` 被拦截
- 材料类白名单资产可正常交易

### 预期效果

- ✅ 三层防护：白名单语义 + DB配置 + 材料类白名单
- ✅ 明确的错误码和错误信息，用户知道为什么不能交易
- ✅ 完整的审计日志，可追踪谁尝试交易积分
- ✅ 管理员可查看所有资产的可交易状态
- ✅ 即使 DB 配置被误改，白名单仍能拦截

---

## P0-5：审计日志 target_type 命名不统一

### 问题位置

- `services/AuditLogService.js` 多处方法中的 `target_type` 字段

### 问题现状（已验证真实库数据）

#### 代码层混用证据

```javascript
// ❌ PascalCase 模型名风格（大量存在）
target_type: 'AssetTransaction' // services/AuditLogService.js:326
target_type: 'ItemInstance' // services/AuditLogService.js:453
target_type: 'ExchangeRecord' // services/AuditLogService.js:590
target_type: 'ConsumptionRecord' // services/AuditLogService.js:636
target_type: 'AccountAssetBalance' // services/AuditLogService.js:737
target_type: 'UserRoleChangeRecord' // services/UserRoleService.js:277
target_type: 'UserStatusChangeRecord' // services/UserRoleService.js:402

// ❌ snake_case 表名风格（少量存在）
target_type: 'lottery_management_setting' // services/AdminLotteryService.js:157
target_type: 'lottery_clear_setting_record' // services/AdminLotteryService.js:785

// ❌ 历史遗留/拼写/复数混乱
target_type: 'UserPointsAccount' // 旧模型名（已废弃）
target_type: 'PointsTransaction' // 旧模型名（已废弃）
target_type: 'ExchangeRecords' // 复数形式（不一致）
target_type: 'LotteryManagement' // 语义不清
target_type: 'UserInventory' // 旧模型名（已废弃）
```

#### 真实数据库验证结果

**Node.js 直连 `.env` 指向的生产库验证**：

```json
{
  "schema": "restaurant_points_dev",
  "table": "admin_operation_logs",
  "total": 1103,
  "distinct_target_type": 13,
  "naming_style_counts_case_sensitive": {
    "snake_case": 33,
    "pascal_case": 1070,
    "other": 0
  },
  "top_target_types": [
    { "target_type": "UserPointsAccount", "count": 496 },
    { "target_type": "CustomerServiceSession", "count": 349 },
    { "target_type": "User", "count": 99 },
    { "target_type": "ConsumptionRecord", "count": 81 },
    { "target_type": "PointsTransaction", "count": 32 },
    { "target_type": "lottery_management_setting", "count": 26 },
    { "target_type": "lottery_clear_setting_record", "count": 7 },
    { "target_type": "UserRoleChangeRecord", "count": 4 },
    { "target_type": "UserStatusChangeRecord", "count": 3 },
    { "target_type": "AccountAssetBalance", "count": 2 },
    { "target_type": "ExchangeRecords", "count": 2 },
    { "target_type": "LotteryManagement", "count": 1 },
    { "target_type": "UserInventory", "count": 1 }
  ]
}
```

### 业务风险

- ❌ **问题已确认存在**：真实库里 1103 条审计日志中，13 种 target_type 混用 PascalCase/snake_case/历史遗留名
- ❌ 审计查询/统计难统一（需要同时查 `AssetTransaction` 和 `asset_transaction`）
- ❌ 长期会变成"字段看不懂、难做报表"（如 `UserPointsAccount` 已废弃但仍占 45% 的历史记录）
- ❌ 前端展示时需要额外的映射逻辑
- ❌ 每次模型重构/更名都会产生新的 target_type 值，导致历史数据碎片化

### 解决方案（已拍板）

**方案 B：新增 target_type_raw 列（查询更方便，但要做迁移）**

**统一为"稳定业务资源码"（单数 `snake_case`）**，并在 `AuditLogService` 做集中规范化 + 别名兼容 + 一次性数据迁移。新增 `target_type_raw` 字段保留原始值，便于审计追溯和查询。

### 选择理由（长期维护视角）

1. **与代码重构/模型更名解耦**：
   - 真实库里已出现 `UserPointsAccount/PointsTransaction/UserInventory` 等历史遗留名（占 48% 的记录）
   - 这些模型已废弃（现为 `accounts/asset_transactions/item_instances`），但审计记录永久保留
   - 如果继续用模型名，每次重构都会产生新的 target_type 值，导致统计/报表碎片化

2. **跨域可持续**：
   - 系统同时有抽奖、资产账本、道具实例、C2C 挂牌/订单，长期需要"按资源聚合"的审计查询
   - 资源码比模型名更稳定（如 `asset_transaction` 永远指向资产流水，无论底层模型叫什么）

3. **现在改成本最低**：
   - 真实库仅 13 种 target_type，1103 条记录
   - 越早统一越省迁移/兼容成本
   - 符合游戏/交易平台的行业最佳实践（稳定资源码 + 事件溯源）

4. **行业对标**：
   - **大厂（腾讯/阿里）**：审计字段用稳定资源码，不直接写 ORM 模型名
   - **游戏公司**：GM 后台审计用严格枚举的 resource_code，避免改模型名打崩报表
   - **交易平台**：纠纷/风控/对账要求审计字段长期稳定，常用固定资源集合

### 实施步骤

#### 1. 定义标准资源码集合（`constants/AuditTargetTypes.js`）

定义 20+ 种标准资源：

- 用户与权限：`user`、`user_role_change_record`、`user_status_change_record`、`customer_service_session`
- 资产与账本：`account`、`account_asset_balance`、`asset_transaction`
- 物品与库存：`item_instance`、`item_instance_event`、`redemption_order`
- 商品与兑换：`product`、`exchange_item`、`exchange_record`
- 消费与审核：`consumption_record`、`content_review_record`
- 抽奖系统：`lottery_campaign`、`lottery_prize`、`lottery_draw`、`lottery_management_setting`、`lottery_clear_setting_record`
- 市场交易：`market_listing`、`trade_order`
- 系统配置：`system_setting`、`popup_banner`

#### 2. 建立历史遗留值映射表（`TARGET_TYPE_LEGACY_MAPPING`）

映射规则：

- PascalCase → snake_case（如 `AssetTransaction` → `asset_transaction`）
- 历史遗留名 → 新架构标准名（如 `UserPointsAccount` → `account_asset_balance`）
- 复数形式 → 单数（如 `ExchangeRecords` → `exchange_record`）
- 语义不清 → 明确资源（如 `LotteryManagement` → `lottery_management_setting`）

#### 3. 在 `AuditLogService.logOperation()` 中添加强制规范化

```javascript
// ✅ 第1步：规范化 target_type（PascalCase/历史名 → 标准资源码）
const normalizedTargetType = normalizeTargetType(target_type)

// ✅ 第2步：严格校验（已拍板：所有操作都强制校验）
if (!isValidTargetType(normalizedTargetType)) {
  throw new Error(`未知的 target_type: ${target_type}，请在 constants/AuditTargetTypes.js 中定义`)
}

// ✅ 第3步：保留原始值（便于审计追溯）
const logData = {
  ...data,
  target_type: normalizedTargetType,
  target_type_raw: target_type !== normalizedTargetType ? target_type : null
}
```

#### 4. 查询接口兼容旧值

```javascript
static async queryAuditLogs(filters = {}) {
  const { target_type, ...otherFilters } = filters

  // ✅ 查询时也规范化（前端传入 PascalCase 也能查到）
  if (target_type) {
    whereClause.target_type = normalizeTargetType(target_type)
  }
}
```

#### 5. 数据库迁移脚本（一次性更新历史数据）

**迁移策略**：维护窗口迁移（已拍板：直接停机 5-10 分钟）

```javascript
// migrations/YYYYMMDDHHMMSS-normalize-audit-target-type.js

async up(queryInterface, Sequelize) {
  // 1. 添加 target_type_raw 字段保留原始值（VARCHAR(100)）
  await queryInterface.addColumn('admin_operation_logs', 'target_type_raw', {
    type: Sequelize.STRING(100),
    allowNull: true,
    comment: '原始 target_type 值（用于审计追溯）'
  })

  // 2. 备份原始值到 target_type_raw
  await queryInterface.sequelize.query(
    'UPDATE admin_operation_logs SET target_type_raw = target_type WHERE target_type_raw IS NULL'
  )

  // 3. 批量规范化（按映射表逐个更新）
  const mappings = {
    'UserPointsAccount': 'account_asset_balance',
    'PointsTransaction': 'asset_transaction',
    'AssetTransaction': 'asset_transaction',
    'ItemInstance': 'item_instance',
    'ExchangeRecord': 'exchange_record',
    'ExchangeRecords': 'exchange_record',
    'ConsumptionRecord': 'consumption_record',
    'AccountAssetBalance': 'account_asset_balance',
    'UserRoleChangeRecord': 'user_role_change_record',
    'UserStatusChangeRecord': 'user_status_change_record',
    'CustomerServiceSession': 'customer_service_session',
    'User': 'user',
    'LotteryManagement': 'lottery_management_setting',
    'UserInventory': 'item_instance'
  }

  for (const [oldValue, newValue] of Object.entries(mappings)) {
    await queryInterface.sequelize.query(
      `UPDATE admin_operation_logs SET target_type = :newValue WHERE target_type = :oldValue`,
      { replacements: { oldValue, newValue } }
    )
  }

  // 4. 验证迁移结果
  const [unmapped] = await queryInterface.sequelize.query(
    `SELECT DISTINCT target_type FROM admin_operation_logs
     WHERE target_type NOT IN (${Object.values(mappings).map(v => `'${v}'`).join(',')})`
  )

  if (unmapped.length > 0) {
    console.warn('⚠️ 发现未映射的 target_type:', unmapped)
  }
}
```

#### 6. 全局替换代码中的 target_type 值（可选）

```bash
# 查找所有需要修改的位置
grep -rn "target_type:" services/ routes/ middleware/ | \
  grep -E "(AssetTransaction|ItemInstance|ExchangeRecord)"

# 逐个修改为标准资源码
# services/AuditLogService.js:326
#   target_type: 'AssetTransaction' → target_type: 'asset_transaction'
```

#### 7. 添加单元测试验证规范化逻辑

测试场景：

- PascalCase 模型名自动规范化为 snake_case 资源码
- 历史遗留名映射到新架构标准名
- 复数形式规范化为单数
- 关键操作使用未知 target_type 时抛出错误
- 非关键操作使用未知 target_type 时仅警告

#### 8. 添加启动时校验（防止回退）

```javascript
// 在 app.js 启动时添加
async function validateAuditConfiguration() {
  // 1. 校验 operation_type ENUM 一致性
  // 2. 校验 target_type 是否还有未规范化的值
}
```

### 预期效果

- ✅ 审计日志 `target_type` 字段完全统一为 snake_case 资源码
- ✅ 历史数据（1103 条）全部规范化，原始值保留在 `target_type_raw` 字段
- ✅ 查询/统计/报表不再需要处理多种命名风格
- ✅ 新增审计类型时，强制通过标准集合定义，防止随意污染
- ✅ 与模型重构/更名解耦，长期稳定可维护
- ✅ 符合游戏/交易平台的行业最佳实践（稳定资源码 + 事件溯源）

### 迁移成本评估

- **代码修改**：约 30 处 target_type 赋值点（可选，也可依赖自动规范化）
- **数据迁移**：1103 条记录，13 种 target_type → 约 10-15 种标准资源码
- **测试验证**：单元测试 + 集成测试验证规范化逻辑
- **预计工时**：3-4 小时（含测试和验证）

---

## 实施计划

### 优先顺序建议

**第1天（6-7小时）**：

1. **P0-3：TransactionManager 业务错误重试**（3小时）
   - 影响最大：测试速度 + 用户体验
   - 改动范围小：仅 `TransactionManager` + `ErrorCodes`
   - 立即见效：测试速度提升 + API 响应更快

2. **P0-1：测试数据硬编码**（2小时）
   - 依赖关系：无
   - 改动范围小：仅 `test-setup.js` + `jest.setup.js`
   - 立即见效：测试稳定性提升

3. **P0-4：C2C 积分类白名单强约束**（2小时）
   - 业务风险高：防止积分进入 C2C
   - 改动范围小：仅 `MarketListingService` + 常量定义
   - 立即见效：三层防护 + 审计日志

**第2天（4小时）**：

4. **P0-2：孤儿冻结唯一入口化**（4小时）
   - 改动范围大：需创建 Service + 接口 + 定时任务
   - 依赖关系：需要前面的 TransactionManager 修复
   - 长期收益：防止测试/脚本制造孤儿冻结

**第3天（3-4小时）**：

5. **P0-5：target_type 规范化**（3-4小时）
   - 改动范围大：需数据库迁移 + 代码修改
   - 长期收益：审计永久统一 + 与模型重构解耦
   - 可并行实施：与其他问题无依赖

### 质量检查标准

每完成一项问题修复后，必须通过以下检查：

#### 代码质量检查

```bash
npm run lint
# 预期：0 errors，warnings 逐步减少
```

#### 功能测试

```bash
npm test
# 预期：所有测试通过，无新增失败
```

#### 健康检查

```bash
curl -s http://localhost:3000/health | python3 -m json.tool
# 预期：status = healthy，database/redis = connected
```

#### 服务运行检查

```bash
npm run pm:status
# 预期：PM2 显示 online 状态
```

---

## 决策记录

### 2026年01月09日 - 用户拍板决策

#### 1. TransactionManager 重试策略（P0-3）

**决策**：

- **4xx/业务码**：永不重试
- **未知错误**：最多重试 1 次
- **死锁/超时类**：重试 3 次

**理由**：业务错误重试浪费时间，影响测试速度和用户体验；未知错误保守重试 1 次；仅对临时性错误（死锁/超时）重试 3 次。

#### 2. 孤儿冻结治理动作边界（P0-2）

**决策**：方案 B - detect + 自动修复

**理由**：用户体验最好，自动解冻机制已确认符合业务合规要求，无需人工干预。

#### 3. C2C 积分类资产交易策略（P0-4）

**决策**：永久禁止 POINTS/BUDGET_POINTS 进入 C2C

**理由**：商业语义明确，积分类资产不应进入 C2C 市场，做成服务层硬规则。

#### 4. 审计 target_type 原值保留方式（P0-5）

**决策**：方案 B - 新增 target_type_raw 列

**理由**：查询更方便，便于审计追溯，虽需数据库迁移但长期收益大。

#### 5. 测试活动数据策略（P0-1）

**决策**：使用数据库中的真实活动数据

**理由**：数据库中已有活跃活动，测试应使用真实数据而非硬编码，提升测试稳定性和真实性。

---

### 2026年01月09日 - 实施细节拍板决策

#### 6. P0-2 数据库触发器策略

**决策**：不启用触发器

**理由**：服务层 + 定时任务 + 审计日志已提供足够防护，触发器增加数据库运维复杂度，保持数据库简洁。

#### 7. P0-2 定时任务执行频率

**决策**：固定凌晨2点执行

**理由**：简单可控，孤儿冻结不是高频问题，固定时间便于运维监控。

#### 8. P0-2 管理接口权限分级

**决策**：检测所有管理员可用，清理仅超级管理员

**理由**：检测操作无风险，所有管理员可查看；清理操作涉及资产修改，需要更高权限。清理操作需传入 `reason` 和 `operator_name`，记录完整审计日志。

#### 9. P0-5 迁移上线策略

**决策**：维护窗口迁移（直接停机）

**理由**：数据量小（1103 条），维护窗口停服 5-10 分钟完成迁移，简单可靠，避免复杂的分批逻辑和潜在的数据一致性问题。

#### 10. P0-5 未知 target_type 处理策略

**决策**：严格阻断模式

**理由**：所有操作使用未知 target_type 时直接抛错，强制在 `constants/AuditTargetTypes.js` 中定义，确保审计日志长期规范，防止随意污染。

#### 11. P0-1 活跃活动判定规则

**决策**：`status='active'` 且 `NOW() BETWEEN start_time AND end_time`

**理由**：严格符合业务语义，确保测试使用的是真正正在进行中的活动。如果有多条活跃活动，选择最早创建的（`ORDER BY campaign_id ASC LIMIT 1`）。如果没有活跃活动，测试直接报错退出，确保测试环境数据完整。

#### 12. P0-3 未知错误重试次数

**决策**：重试 1 次（总共执行 2 次）

**理由**：符合常规理解，`maxRetries = 1` 表示失败后重试 1 次，总共执行 2 次。

#### 13. P0-4 C2C 白名单维护方式

**决策**：保持硬编码在 `constants/AssetTypes.js`

**理由**：材料类资产新增频率低，硬编码可控且安全。暂不支持临时开放某材料交易，有需求时再评估增加数据库配置表。

---

## 实施记录

### 2026年01月09日 - 文档创建

- ✅ 从 `docs/待处理问题清单-2026-01-09.md` 提取所有 P0 级别问题
- ✅ 补充真实库验证数据（P0-5）
- ✅ 明确实施优先级和时间规划
- ✅ 定义质量检查标准
- ✅ 记录用户拍板决策（5 项关键决策）

**下一步行动**：

1. **立即开始 P0-3**（TransactionManager 业务错误重试）- 影响测试速度和用户体验
2. **紧接着 P0-1**（测试数据硬编码）- 提升测试稳定性
3. **然后 P0-4**（C2C 积分类白名单）- 防止业务风险
4. **第2天 P0-2**（孤儿冻结唯一入口化）- 防止资产卡死
5. **第3天 P0-5**（target_type 规范化）- 长期维护基础设施

---

## 待拍板清单（实施细节）

以下是实施过程中需要明确的边界和策略，请逐条选择：

### 1. P0-2 数据库触发器是否启用（"最后防线"）

**问题**：在 `market_listings` 表上添加 `BEFORE DELETE` 触发器，硬阻断"在售且已冻结的挂牌被直接删除"？

**选项**：

- **A. 启用触发器**（最严格防护，但增加数据库复杂度）
- **B. 不启用触发器**（依赖服务层+定时任务+审计日志，保持数据库简洁）

**当前文档状态**：标记为"可选"

**建议**：选 B（服务层+定时任务已足够，触发器增加运维复杂度）

---

### 2. P0-2 自动修复的执行频率与运行窗口

**问题**：定时任务"每天凌晨2点"自动检测和清理孤儿冻结，是否需要调整？

**选项**：

- **A. 固定凌晨2点**（简单，但可能与其他定时任务冲突）
- **B. 凌晨2-4点随机时间**（分散负载）
- **C. 每6小时一次**（更及时，但增加执行频率）
- **D. 仅检测不自动修复**（保守，需人工确认）

**当前文档状态**：写了"每天凌晨2点"，但未确认是否最终方案

**建议**：选 A（简单可控，孤儿冻结不是高频问题）

**补充问题**：高峰期/维护窗口是否允许跳过？

- **允许跳过**（设置执行开关）
- **不允许跳过**（强制执行）

---

### 3. P0-2 管理员接口权限边界

**问题**：`/orphan-frozen/detect` 与 `/orphan-frozen/cleanup` 的权限控制？

**选项**：

- **A. 仅超级管理员**（最严格，需在用户表增加 `is_super_admin` 字段）
- **B. 所有管理员**（`role='admin'` 即可，简单）
- **C. 检测所有管理员可用，清理仅超管**（分级控制）

**当前文档状态**：仅写"管理员接口"，未定义粒度

**建议**：选 C（检测无风险，清理需要更高权限）

**补充问题**：清理操作是否需要二次确认/审批？

- **需要**（传入 `reason` 和 `operator_name`，记录审计日志）
- **不需要**（直接执行）

**建议**：需要（增强审计追溯）

---

### 4. P0-5 迁移的上线策略（零停机 vs 维护窗口）

**问题**：新增 `target_type_raw` 字段 + 批量回填历史数据（1103 条），是否要求零停机？

**选项**：

- **A. 零停机迁移**（分批小事务，避免锁表，但脚本复杂）
- **B. 维护窗口迁移**（凌晨停服5-10分钟，简单可靠）
- **C. 先加字段，后台异步回填**（最安全，但需要兼容逻辑）

**当前文档状态**：仅写"需要数据库迁移"，未明确策略

**建议**：选 C（先加字段，服务重启后异步回填，对线上无影响）

**补充问题**：回填过程中遇到锁冲突怎么办？

- **重试 3 次后跳过**（记录日志，人工处理）
- **阻塞等待**（可能影响性能）

**建议**：重试 3 次后跳过

---

### 5. P0-5 未映射 target_type 的处理策略

**问题**：迁移或运行时遇到"新/未知 target_type"，如何处理？

**选项**：

- **A. 严格模式**：关键操作直接抛错，强制在 `constants/AuditTargetTypes.js` 中定义
- **B. 宽松模式**：先放行但记录警告日志，定期人工审查
- **C. 混合模式**：关键操作抛错，非关键操作仅警告

**当前文档状态**：写了"关键操作强制校验"，但未定义"非关键操作"的边界

**建议**：选 C（平衡严格性与灵活性）

**补充问题**："关键操作"的定义？

- **资产/权限/交易相关**（涉及资金/权限变更）
- **所有写操作**（最严格）
- **仅超管操作**（最宽松）

**建议**：资产/权限/交易相关

---

### 6. P0-1 "活跃活动"的判定规则

**问题**：测试启动时从数据库查找"活跃活动"，具体规则是什么？

**选项**：

- **A. 仅 `status='active'`**（简单）
- **B. `status='active'` 且 `NOW() BETWEEN start_time AND end_time`**（严格）
- **C. `status IN ('active', 'pending')`**（宽松，包含即将开始的活动）

**当前文档状态**：仅写"活跃活动"，未定义精确规则

**建议**：选 B（严格符合业务语义）

**补充问题**：如果同时有多条活跃活动，选哪条？

- **最早创建的**（`ORDER BY campaign_id ASC LIMIT 1`）
- **最新创建的**（`ORDER BY campaign_id DESC LIMIT 1`）
- **按名称匹配**（优先选择包含"测试"的活动）
- **报错提示**（要求数据库只保留一条活跃活动）

**建议**：最早创建的（稳定可预测）

**补充问题**：如果没有活跃活动，测试如何处理？

- **跳过需要活动的测试**（标记为 `test.skip`）
- **使用任意已结束的活动**（降级方案）
- **直接报错退出**（强制要求有活跃活动）

**建议**：直接报错退出（确保测试环境数据完整）

---

### 7. P0-3 TransactionManager 默认重试次数（未知错误）

**问题**：已拍板"未知错误最多重试 1 次"，但实现时的 `maxRetries` 参数默认值是多少？

**选项**：

- **A. maxRetries = 1**（未知错误重试 1 次，总共执行 2 次）
- **B. maxRetries = 0**（未知错误不重试，仅执行 1 次）

**当前文档状态**：写了"最多重试 1 次"，但未明确是"重试 1 次"还是"总共 1 次"

**建议**：选 A（重试 1 次 = 总共执行 2 次，符合常规理解）

---

### 8. P0-4 C2C 白名单的维护方式

**问题**：`MATERIAL_ASSET_CODES` 白名单目前硬编码在 `constants/AssetTypes.js`，未来如何维护？

**选项**：

- **A. 保持硬编码**（简单，但新增材料需要发版）
- **B. 迁移到数据库配置表**（灵活，但增加复杂度）
- **C. 硬编码 + 数据库配置双重校验**（最严格，但冗余）

**当前文档状态**：仅写了硬编码方案，未考虑长期维护

**建议**：选 A（材料类资产新增频率低，硬编码可控）

**补充问题**：如果未来需要"临时开放某材料交易"（如运营活动），如何支持？

- **修改代码发版**（保持硬编码）
- **增加数据库配置表 `tradable_asset_overrides`**（支持临时开关）

**建议**：暂不支持，有需求时再评估

---

## 拍板建议汇总（快速决策参考）

| 问题                | 建议选项                | 理由                   |
| ------------------- | ----------------------- | ---------------------- |
| 1. 触发器是否启用   | **B. 不启用**           | 服务层+定时任务已足够  |
| 2. 定时任务频率     | **A. 凌晨2点**          | 简单可控               |
| 3. 管理接口权限     | **C. 分级控制**         | 检测无风险，清理需超管 |
| 4. 迁移上线策略     | **C. 异步回填**         | 零停机，最安全         |
| 5. 未知 target_type | **C. 混合模式**         | 平衡严格与灵活         |
| 6. 活跃活动规则     | **B. 严格时间窗口**     | 符合业务语义           |
| 7. 未知错误重试     | **A. 重试1次（总2次）** | 符合常规理解           |
| 8. 白名单维护       | **A. 保持硬编码**       | 新增频率低             |

**你可以直接回复"全部按建议"或逐条修改，我会立即更新到文档的"决策记录"中。**

---

**文档状态**：待实施  
**预计完成时间**：3 个工作日  
**总工时**：14-15 小时
