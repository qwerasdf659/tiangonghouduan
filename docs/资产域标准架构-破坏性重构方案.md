# 资产域标准架构 - 破坏性重构方案

**文档版本**: v1.1  
**创建时间**: 2025-12-29  
**更新时间**: 2025-12-30（新增商家审核冻结业务、冻结归属约束、超时兜底机制）  
**架构原则**: 业界标准、单一真相源、破坏性重构、冻结归属约束

---需要注意的问题

1. 数据库迁移执行：请确保已运行迁移创建 merchant_points_reviews 表：
   npx sequelize-cli db:migrate
2. 文档中提到的"删除清单"未执行：


    - models/UserPointsAccount.js 仍存在
    - models/PointsTransaction.js 仍存在
    - services/PointsService.js 仍被8个文件引用

## 一、业务模式分析（基于真实数据）

### 1.1 核心业务流程

**抽奖系统**（主营收入来源）：

- 用户消耗 `POINTS`（积分）参与抽奖
- 定价：单抽100积分（硬编码在代码中）
- 奖励：100%中奖，发放物品实例（`item_instances`）或材料资产（`red_shard`等）
- 幂等保护：`business_id` 唯一约束

**兑换系统**（积分消耗渠道）：

- 用户消耗材料资产（如 `red_shard`）兑换实物商品
- 当前活跃商品：16个，全部消耗 `red_shard`，总成本1600碎片
- 兑换后生成订单（`redemption_orders`）和核销码

**资产体系**（当前真实数据）：

- `POINTS`（积分）：6个账户，总额43,652
- `red_shard`（碎红水晶）：2个账户，总额23,660
- `DIAMOND`（钻石）：1个账户，总额66,900
- `MATERIAL_001`（材料）：1个账户，总额100

**物品实例**（不可叠加资产）：

- 总量：873个实例
- 状态分布：available(841) / locked(6) / used(26)
- 用途：优惠券、实物商品、装备等

### 1.2 商业模式定位

这是一个**"积分抽奖+材料兑换+商家审核"三循环系统**：

1. 用户通过任务/充值获得 `POINTS`
2. 消耗 `POINTS` 抽奖，获得材料（`red_shard`）或物品实例
3. 积累材料后兑换实物商品
4. 运营通过控制材料产出率和兑换成本控制成本
5. **商家扫码审核**（商业模式核心）：用户提交审核后冻结积分，审核通过后从冻结结算（真正扣款），审核拒绝/超时后积分**不退回**（仍冻结，需客服/管理员手工处理）

**核心商业逻辑（拍板决策）**：

- **"积分冻结=商家审核期冻结"是商业模式核心**
- 只要没审核通过就不可以增加到可用积分中
- 冻结会无限期存在，接受用户资产长期不可用
- 必须有"冻结为什么存在"的可追溯审计逻辑（归属约束）

### 1.3 冻结/预占用业务场景（拍板决策）

**冻结语义适用场景**（两类业务共用冻结机制）：

**场景1：商家扫码审核冻结积分**（商业模式核心 - 拍板决策）

- **触发时机**：商家扫描用户身份二维码提交审核
- **冻结动作**：`AssetService.freeze(POINTS, amount, business_type='merchant_review_freeze')`
- **状态流转**：
  - pending（审核中）：积分冻结（available ↓，frozen ↑）
  - approved（审核通过）：从冻结结算（frozen ↓，真正扣款完成）
  - rejected（审核拒绝）：**积分不退回**（仍冻结，需客服/管理员手工处理）
  - expired（审核超时）：**积分不退回**（仍冻结，需客服/管理员手工处理）
- **业务规则（拍板决策）**：
  - 只要没审核通过就不可以增加到可用积分中
  - 冻结会无限期存在，接受用户资产长期不可用
  - **不做超时自动解冻兜底**（与交易市场不同）
  - 超时兜底仅做告警（通知客服处理），不自动解冻
- **归属约束**：`merchant_review.review_id` + `idempotency_key={review_id}:freeze`
- **客服处理出口**：
  - 解冻退回：`AssetService.unfreeze()` + 审核单改为 `cancelled`
  - 从冻结作废：`AssetService.settleFromFrozen()` + 审核单改为 `cancelled`

**场景2：交易市场物品交易冻结**

- **触发时机**：买家下单购买挂牌物品
- **冻结动作**：
  - 买家资产：`AssetService.freeze(DIAMOND, amount, business_type='order_freeze_buyer')`
  - 标的物品：`ItemInstance.lock(order_id)` → `status='locked'`
- **状态流转**：
  - frozen（交易中）：买家资产冻结 + 物品锁定
  - completed（成交）：从冻结结算（frozen ↓）+ 物品转移所有权
  - cancelled（取消）：解冻资产（frozen → available）+ 物品解锁
  - expired（超时）：自动取消并解冻（与商家审核不同）
- **业务规则（拍板决策）**：
  - 取消/超时：**可以自动解冻**（正常商业行为）
  - 超时兜底：定时任务自动释放超时锁定物品（3分钟）+ 自动解冻买家资产
- **归属约束**：`trade_orders.order_id` + `idempotency_key={business_id}:freeze`

**冻结不会混的三件套约束**（强制规范）：

1. **唯一归属ID**：每笔冻结必须绑定业务单号（`merchant_review.review_id` 或 `trade_orders.order_id`）
2. **业务类型区分**：流水表 `business_type` 明确来源（`merchant_review_freeze` vs `order_freeze_buyer`）
3. **幂等键强约束**：`idempotency_key` 唯一索引防止重复冻结

**反例（当前库存在的问题）**：

- `account_asset_balances` 存在 `POINTS frozen_amount=3648`（user_id=31）
- 但 `asset_transactions` 中**无任何冻结流水记录**（无法追溯冻结来源）
- 属于"没有归属约束的脏冻结"，后续无法对账和解释

---

## 二、目标架构：业界标准资产域

### 2.1 架构设计原则

**单一真相源**：

- 所有余额类资产（积分、材料、钻石）→ `account_asset_balances`
- 所有物品实例（优惠券、装备）→ `item_instances`
- 所有资产变动 → `asset_transactions`（不可变流水）

**账本+实例双轨**：

- **账本轨**：可叠加资产（POINTS/DIAMOND/red*shard/MATERIAL*\*）
- **实例轨**：不可叠加物品（voucher/equipment/product）

**完全破坏性**：

- 删除 `user_points_accounts`、`points_transactions`（旧积分表）
- 删除 `PointsService`（改为 `AssetService` 的语义包装）
- 前端接口全部改为资产域语义（`/assets/*` 替代 `/points/*`）

### 2.2 核心数据模型

#### 账户主表（accounts）

```sql
CREATE TABLE accounts (
  account_id INT PRIMARY KEY AUTO_INCREMENT COMMENT '账户ID',
  user_id INT UNIQUE NOT NULL COMMENT '用户ID（user类型账户）',
  account_type ENUM('user', 'system', 'merchant') DEFAULT 'user' COMMENT '账户类型',
  status ENUM('active', 'frozen', 'closed') DEFAULT 'active' COMMENT '账户状态',
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  INDEX idx_user_id (user_id),
  INDEX idx_account_type (account_type)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='账户主表（所有用户/系统账户）';
```

#### 资产余额表（account_asset_balances）

```sql
CREATE TABLE account_asset_balances (
  balance_id BIGINT PRIMARY KEY AUTO_INCREMENT COMMENT '余额ID',
  account_id INT NOT NULL COMMENT '账户ID',
  asset_code VARCHAR(50) NOT NULL COMMENT '资产代码（POINTS/DIAMOND/red_shard/MATERIAL_*）',
  available_amount DECIMAL(20,4) NOT NULL DEFAULT 0 COMMENT '可用余额',
  frozen_amount DECIMAL(20,4) NOT NULL DEFAULT 0 COMMENT '冻结余额',
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  UNIQUE KEY uk_account_asset (account_id, asset_code),
  INDEX idx_asset_code (asset_code),

  FOREIGN KEY (account_id) REFERENCES accounts(account_id) ON DELETE RESTRICT
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='资产余额表（单一真相源）';
```

**关键设计**：

- `(account_id, asset_code)` 唯一索引：一个账户一种资产只有一条余额记录
- 不需要 `campaign_id` 字段（预算控制改用系统账户 + 独立资产代码）

#### 资产流水表（asset_transactions）

```sql
CREATE TABLE asset_transactions (
  transaction_id BIGINT PRIMARY KEY AUTO_INCREMENT COMMENT '流水ID',
  account_id INT NOT NULL COMMENT '账户ID',
  asset_code VARCHAR(50) NOT NULL COMMENT '资产代码',
  delta_amount BIGINT NOT NULL COMMENT '变动金额（正数=增加，负数=扣减）',
  balance_before BIGINT NOT NULL COMMENT '变动前可用余额',
  balance_after BIGINT NOT NULL COMMENT '变动后可用余额',
  business_type VARCHAR(50) NOT NULL COMMENT '业务类型（lottery_consume/lottery_reward/order_freeze_buyer/merchant_review_freeze等）',
  idempotency_key VARCHAR(100) UNIQUE NOT NULL COMMENT '幂等键（每条流水唯一）',
  lottery_session_id VARCHAR(100) COMMENT '抽奖会话ID（非抽奖业务可为NULL）',
  meta JSON COMMENT '业务元数据（包含freeze_amount/unfreeze_amount/frozen_before/frozen_after等冻结相关字段）',
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间（不可变）',

  INDEX idx_account_asset (account_id, asset_code),
  INDEX idx_idempotency_key (idempotency_key),
  INDEX idx_business_type (business_type),
  INDEX idx_created_at (created_at),
  INDEX idx_lottery_session (lottery_session_id),

  FOREIGN KEY (account_id) REFERENCES accounts(account_id) ON DELETE RESTRICT
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='资产流水表（不可变审计日志）';
```

**关键设计**：

- `idempotency_key` 唯一约束：每条流水独立幂等（抽奖格式 `{request_key}:consume`，冻结格式 `{review_id}:freeze`）
- 无 `updatedAt` 字段：流水表只追加，不更新
- `balance_before` + `balance_after`：完整记录每次变动的前后**可用余额**状态
- `meta.frozen_before/frozen_after`：冻结操作时记录冻结余额变动（freeze/unfreeze/settleFromFrozen 必须写入）

**冻结流水的特殊记录方式**（强制规范）：

- `freeze`：`delta_amount` 为负数（从 available 扣减），`meta.freeze_amount/frozen_before/frozen_after` 记录冻结余额变动
- `unfreeze`：`delta_amount` 为正数（回到 available），`meta.unfreeze_amount/frozen_before/frozen_after` 记录解冻
- `settleFromFrozen`：`delta_amount` 可能为0（仅从 frozen 扣减，不影响 available），`meta` 记录结算金额

#### 物品实例表（item_instances）

```sql
CREATE TABLE item_instances (
  item_instance_id BIGINT PRIMARY KEY AUTO_INCREMENT COMMENT '物品实例ID',
  owner_user_id INT NOT NULL COMMENT '所有者用户ID',
  item_type VARCHAR(50) COMMENT '物品类型（voucher/product/equipment）',
  item_template_id BIGINT COMMENT '物品模板ID（关联奖品表或商品表）',
  status ENUM('available', 'locked', 'transferred', 'used', 'expired') NOT NULL DEFAULT 'available' COMMENT '物品状态',
  meta JSON COMMENT '物品元数据（name/description/icon/value/serial_number）',
  locked_by_order_id VARCHAR(100) COMMENT '锁定订单ID（并发控制）',
  locked_at TIMESTAMP NULL COMMENT '锁定时间（3分钟超时自动解锁）',
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  INDEX idx_owner_status (owner_user_id, status),
  INDEX idx_locked_order (locked_by_order_id),
  INDEX idx_item_type (item_type),

  FOREIGN KEY (owner_user_id) REFERENCES users(user_id) ON DELETE RESTRICT
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='物品实例表（不可叠加资产）';
```

**关键设计**：

- 状态机：`available → locked → transferred/used/expired`
- 锁TTL：3分钟（`locked_at` 超时自动解锁）
- 所有权真相：`owner_user_id` 是唯一所有权来源

#### 物品实例事件表（item_instance_events）

```sql
CREATE TABLE item_instance_events (
  event_id BIGINT PRIMARY KEY AUTO_INCREMENT COMMENT '事件ID',
  item_instance_id BIGINT NOT NULL COMMENT '物品实例ID',
  event_type ENUM('mint', 'lock', 'unlock', 'transfer', 'use', 'expire', 'destroy') NOT NULL COMMENT '事件类型',
  from_user_id INT COMMENT '转出用户ID（transfer事件）',
  to_user_id INT COMMENT '转入用户ID（transfer事件）',
  business_type VARCHAR(50) NOT NULL COMMENT '业务类型（lottery_reward/exchange_order/market_trade）',
  business_id VARCHAR(100) NOT NULL COMMENT '业务ID（幂等键）',
  metadata JSON COMMENT '事件元数据',
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '事件时间',

  UNIQUE KEY uk_business (business_type, business_id),
  INDEX idx_item_instance (item_instance_id),
  INDEX idx_event_type (event_type),
  INDEX idx_created_at (created_at),

  FOREIGN KEY (item_instance_id) REFERENCES item_instances(item_instance_id) ON DELETE RESTRICT
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='物品实例事件表（事件溯源）';
```

**关键设计**：

- `(business_type, business_id)` 唯一约束：业务层幂等（一次抽奖只能铸造一次物品）
- 事件溯源：所有物品变更都有事件记录，支持完整审计

### 2.3 资产类型定义

```javascript
// 系统支持的资产类型（标准化命名）
const ASSET_TYPES = {
  // 基础货币
  POINTS: {
    code: 'POINTS',
    name: '积分',
    category: 'currency',
    stackable: true,
    tradable: false,
    description: '用户通过任务/充值获得，用于抽奖消耗'
  },

  DIAMOND: {
    code: 'DIAMOND',
    name: '钻石',
    category: 'currency',
    stackable: true,
    tradable: false,
    description: '高级货币，可兑换稀有物品'
  },

  // 材料资产（可叠加）
  red_shard: {
    code: 'red_shard',
    name: '碎红水晶',
    category: 'material',
    stackable: true,
    tradable: true,
    description: '抽奖产出，用于兑换商品'
  },

  red_crystal: {
    code: 'red_crystal',
    name: '完整红水晶',
    category: 'material',
    stackable: true,
    tradable: true,
    description: '高级材料，合成或兑换高价值商品'
  },

  // 通用材料（动态扩展）
  MATERIAL_PREFIX: 'MATERIAL_', // 前缀，支持 MATERIAL_001, MATERIAL_002 等

  // 物品实例类型（不可叠加，存储在 item_instances 表）
  ITEM_TYPES: {
    voucher: '优惠券',
    product: '实物商品',
    equipment: '装备',
    card: '卡牌',
    service: '服务'
  }
}
```

### 2.4 背包显示数量的两种实现方式（架构决策）

**核心问题**：当用户拥有"3张同样的优惠券"时，背包显示"优惠券A × 3"，底层数据结构应该怎么设计？

#### 方案1：UI/查询层聚合（底层仍是3个实例）

**适用场景**：需要逐张操作的道具（优惠券、门票、可交易/可锁定/可核销的道具）

**数据存储**：

```javascript
// item_instances 表存储 3 条记录
;[
  {
    item_instance_id: 1001,
    item_template_id: 9001,
    owner_user_id: 123,
    status: 'available',
    meta: { serial_number: 'A001', expire_at: '2025-12-31' }
  },
  {
    item_instance_id: 1002,
    item_template_id: 9001,
    owner_user_id: 123,
    status: 'available',
    meta: { serial_number: 'A002', expire_at: '2025-12-31' }
  },
  {
    item_instance_id: 1003,
    item_template_id: 9001,
    owner_user_id: 123,
    status: 'locked',
    meta: { serial_number: 'A003', expire_at: '2025-12-31' }
  }
]
```

**背包查询层聚合**：

```javascript
// BackpackService 查询时按模板分组
const items = await ItemInstance.findAll({
  where: { owner_user_id: userId, status: ['available', 'locked'] }
})

// 按 item_template_id 分组展示
const grouped = items.reduce((acc, item) => {
  const key = item.item_template_id
  if (!acc[key]) {
    acc[key] = { template_id: key, count: 0, instances: [] }
  }
  acc[key].count++
  acc[key].instances.push(item)
  return acc
}, {})

// 前端展示：优惠券A × 3
// 点击进入明细：能看到 3 张独立的券（每张有独立状态、过期时间、核销码）
```

**核心特点**：

- ✅ 每张券有独立的 `item_instance_id`（可单独锁定/转移/核销）
- ✅ 每张券有独立的状态机（available → locked → used）
- ✅ 每张券有独立的元数据（序列号、过期时间、核销码）
- ✅ 支持"锁定其中一张"（订单并发控制）
- ✅ 支持"转移其中一张"（交易/赠送）
- ✅ 完整的事件溯源（每张券的生命周期可追溯）

**业务场景示例**：

- 用户有 3 张优惠券，使用其中 1 张 → 扣减 1 个实例（状态改为 used）
- 用户有 3 张门票，转赠其中 1 张 → 转移 1 个实例（owner_user_id 变更）
- 用户有 3 张装备，其中 1 张被订单锁定 → 锁定 1 个实例（status 改为 locked）

---

#### 方案2：账本式可叠加资产（底层就是数量=3）

**适用场景**：只关心数量、不关心单体的资产（金币、材料、碎片、药水）

**数据存储**：

```javascript
// account_asset_balances 表存储 1 条记录
{
  balance_id: 5001,
  account_id: 123,
  asset_code: 'COUPON_TPL_9001',  // 或者 'red_shard', 'MATERIAL_001'
  available_amount: 3,             // 数量=3
  frozen_amount: 0
}
```

**背包查询**：

```javascript
// 直接返回数量
const balance = await AccountAssetBalance.findOne({
  where: { account_id: accountId, asset_code: 'COUPON_TPL_9001' }
})

// 前端展示：优惠券A × 3
// 使用/消耗就是扣 1（available_amount: 3 → 2）
```

**核心特点**：

- ✅ 不存在"第1张/第2张"的概念（同质可叠加）
- ✅ 使用/消耗就是 `available_amount -= 1`
- ✅ 无法单独锁定/转移某一张（只能整体冻结/解冻）
- ✅ 无单体属性（无序列号、无独立过期时间）
- ✅ 流水记录数量变动（asset_transactions）

**业务场景示例**：

- 用户有 3 个碎片，合成消耗 2 个 → `available_amount: 3 → 1`
- 用户有 100 金币，购买消耗 50 → `available_amount: 100 → 50`
- 用户有 5 个药水，使用 1 个 → `available_amount: 5 → 4`

---

#### 架构决策：如何选择？

**决策树**：

```
是否需要逐张操作（锁定/转移/核销）？
├─ 是 → 方案1（物品实例）
│   └─ 存储在 item_instances 表
│   └─ 示例：优惠券、门票、装备、可交易道具
│
└─ 否 → 方案2（账本资产）
    └─ 存储在 account_asset_balances 表
    └─ 示例：金币、材料、碎片、药水、积分
```

**混合使用示例**（本系统实际情况）：

| 资产类型              | 实现方式 | 存储位置               | 原因                           |
| --------------------- | -------- | ---------------------- | ------------------------------ |
| 积分（POINTS）        | 方案2    | account_asset_balances | 只关心数量，无单体属性         |
| 钻石（DIAMOND）       | 方案2    | account_asset_balances | 只关心数量，无单体属性         |
| 碎红水晶（red_shard） | 方案2    | account_asset_balances | 可叠加材料，无单体属性         |
| 优惠券（voucher）     | 方案1    | item_instances         | 需要核销码、过期时间、独立状态 |
| 实物商品（product）   | 方案1    | item_instances         | 需要物流信息、核销码           |
| 装备（equipment）     | 方案1    | item_instances         | 需要属性、强化等级、可交易     |

**前端展示统一**：

- 无论底层是方案1还是方案2，前端都显示"资产名称 × 数量"
- 方案1：点击进入明细页，显示每个实例的详细信息
- 方案2：点击进入详情页，显示余额和流水记录

---

## 三、服务层架构（完全重写）

### 3.1 AssetService（资产域核心服务）

```javascript
/**
 * 资产服务 - 统一资产域操作入口
 *
 * 职责：
 * - 账户/余额管理（getOrCreateAccount/getOrCreateBalance）
 * - 余额变更（changeBalance - 核心方法）
 * - 余额查询（getBalance/getAllBalances）
 * - 冻结/解冻/从冻结结算（freeze/unfreeze/settleFromFrozen - 预占用三件套）
 *
 * 设计原则：
 * - 所有余额变更必须通过 changeBalance 或 freeze/unfreeze/settleFromFrozen（强制幂等）
 * - 所有操作必须在事务内执行
 * - 余额不足时抛出异常（不允许负余额）
 * - 所有冻结操作必须有归属约束（business_type + 业务单号 + idempotency_key）
 *
 * 冻结业务场景（拍板决策）：
 * 1. 商家扫码审核：冻结 POINTS，审核通过从冻结结算，拒绝/超时不退回（需客服处理）
 * 2. 交易市场下单：冻结 DIAMOND，成交从冻结结算，取消解冻
 */
class AssetService {
  /**
   * 变更余额（核心方法，强制幂等）
   *
   * @param {Object} params
   * @param {number} params.userId - 用户ID
   * @param {string} params.assetCode - 资产代码（POINTS/DIAMOND/red_shard等）
   * @param {number} params.amount - 变动金额（正数=增加，负数=扣减）
   * @param {string} params.transactionType - 业务类型（lottery_deduct/lottery_reward/exchange_cost等）
   * @param {string} params.businessId - 业务幂等键（必需，全局唯一）
   * @param {string} [params.relatedOrderId] - 关联订单ID
   * @param {Object} [params.metadata] - 业务元数据
   * @param {Transaction} params.transaction - Sequelize事务（必需）
   * @returns {Promise<Object>} { success, transaction, idempotent }
   */
  static async changeBalance({
    userId,
    assetCode,
    amount,
    transactionType,
    businessId,
    relatedOrderId = null,
    metadata = null,
    transaction
  }) {
    if (!transaction) {
      throw new Error('AssetService.changeBalance 必须在事务内执行')
    }

    if (!businessId) {
      throw new Error('AssetService.changeBalance 必须提供 businessId（幂等键）')
    }

    // 1. 幂等性检查（基于 business_id）
    const existingTx = await AssetTransaction.findOne({
      where: { business_id: businessId },
      transaction
    })

    if (existingTx) {
      logger.info('幂等拦截：业务ID已存在', { business_id: businessId })
      return { success: true, transaction: existingTx, idempotent: true }
    }

    // 2. 获取或创建账户
    const account = await this.getOrCreateAccount({ user_id: userId }, { transaction })

    if (account.status !== 'active') {
      throw new Error(`账户状态异常: ${account.status}`)
    }

    // 3. 获取或创建余额记录
    const balance = await this.getOrCreateBalance(account.account_id, assetCode, { transaction })

    // 4. 悲观锁锁定余额行（防止并发问题）
    await balance.reload({
      lock: transaction.LOCK.UPDATE,
      transaction
    })

    // 5. 计算新余额
    const beforeAmount = parseFloat(balance.available_amount)
    const changeAmount = parseFloat(amount)
    const afterAmount = beforeAmount + changeAmount

    if (afterAmount < 0) {
      throw new Error(
        `余额不足: ${assetCode}, 当前=${beforeAmount}, 需要=${Math.abs(changeAmount)}`
      )
    }

    // 6. 更新余额
    await balance.update({ available_amount: afterAmount }, { transaction })

    // 7. 记录流水
    const txRecord = await AssetTransaction.create(
      {
        account_id: account.account_id,
        asset_code: assetCode,
        change_amount: changeAmount,
        before_amount: beforeAmount,
        after_amount: afterAmount,
        transaction_type: transactionType,
        business_id: businessId,
        related_order_id: relatedOrderId,
        metadata: metadata
      },
      { transaction }
    )

    logger.info('资产变更成功', {
      user_id: userId,
      asset_code: assetCode,
      change_amount: changeAmount,
      after_amount: afterAmount,
      business_id: businessId
    })

    return { success: true, transaction: txRecord, idempotent: false }
  }

  /**
   * 获取或创建账户
   */
  static async getOrCreateAccount({ user_id }, { transaction }) {
    const [account] = await Account.findOrCreate({
      where: { user_id, account_type: 'user' },
      defaults: {
        user_id,
        account_type: 'user',
        status: 'active'
      },
      transaction
    })
    return account
  }

  /**
   * 获取或创建余额记录
   */
  static async getOrCreateBalance(accountId, assetCode, { transaction }) {
    const [balance] = await AccountAssetBalance.findOrCreate({
      where: {
        account_id: accountId,
        asset_code: assetCode
      },
      defaults: {
        account_id: accountId,
        asset_code: assetCode,
        available_amount: 0,
        frozen_amount: 0
      },
      transaction
    })
    return balance
  }

  /**
   * 查询余额（不需要事务）
   */
  static async getBalance({ userId, assetCode }) {
    const account = await Account.findOne({
      where: { user_id: userId, account_type: 'user' }
    })

    if (!account) {
      return { available: 0, frozen: 0 }
    }

    const balance = await AccountAssetBalance.findOne({
      where: {
        account_id: account.account_id,
        asset_code: assetCode
      }
    })

    return {
      available: balance ? parseFloat(balance.available_amount) : 0,
      frozen: balance ? parseFloat(balance.frozen_amount) : 0
    }
  }

  /**
   * 查询用户所有资产余额
   */
  static async getAllBalances({ userId }) {
    const account = await Account.findOne({
      where: { user_id: userId, account_type: 'user' }
    })

    if (!account) {
      return []
    }

    const balances = await AccountAssetBalance.findAll({
      where: { account_id: account.account_id },
      order: [['asset_code', 'ASC']]
    })

    return balances.map(b => ({
      asset_code: b.asset_code,
      available: parseFloat(b.available_amount),
      frozen: parseFloat(b.frozen_amount)
    }))
  }

  /**
   * 冻结资产（预扣款场景）
   */
  static async freeze({ userId, assetCode, amount, businessId, transaction }) {
    const account = await this.getOrCreateAccount({ user_id: userId }, { transaction })
    const balance = await this.getOrCreateBalance(account.account_id, assetCode, { transaction })

    await balance.reload({ lock: transaction.LOCK.UPDATE, transaction })

    const available = parseFloat(balance.available_amount)
    const frozen = parseFloat(balance.frozen_amount)

    if (available < amount) {
      throw new Error(`可用余额不足: ${assetCode}, 可用=${available}, 需要=${amount}`)
    }

    await balance.update(
      {
        available_amount: available - amount,
        frozen_amount: frozen + amount
      },
      { transaction }
    )

    logger.info('资产冻结成功', {
      user_id: userId,
      asset_code: assetCode,
      amount,
      business_id: businessId
    })
  }

  /**
   * 解冻资产（取消订单场景）
   */
  static async unfreeze({ userId, assetCode, amount, businessId, transaction }) {
    const account = await this.getOrCreateAccount({ user_id: userId }, { transaction })
    const balance = await this.getOrCreateBalance(account.account_id, assetCode, { transaction })

    await balance.reload({ lock: transaction.LOCK.UPDATE, transaction })

    const available = parseFloat(balance.available_amount)
    const frozen = parseFloat(balance.frozen_amount)

    if (frozen < amount) {
      throw new Error(`冻结余额不足: ${assetCode}, 冻结=${frozen}, 需要=${amount}`)
    }

    await balance.update(
      {
        available_amount: available + amount,
        frozen_amount: frozen - amount
      },
      { transaction }
    )

    logger.info('资产解冻成功', {
      user_id: userId,
      asset_code: assetCode,
      amount,
      business_id: businessId
    })
  }
}

module.exports = AssetService
```

### 3.2 ItemInstanceService（物品实例服务）

```javascript
/**
 * 物品实例服务 - 不可叠加资产管理
 *
 * 职责：
 * - 铸造物品（mint - 抽奖产出）
 * - 锁定/解锁（lock/unlock - 订单并发控制）
 * - 转移所有权（transfer - 交易/赠送）
 * - 使用/核销（use - 优惠券核销）
 * - 过期处理（expire - 定时任务）
 *
 * 设计原则：
 * - 所有操作必须记录事件（item_instance_events）
 * - 所有操作必须幂等（基于 business_id）
 * - 状态机严格校验（available → locked → transferred/used/expired）
 */
class ItemInstanceService {
  /**
   * 铸造物品（抽奖产出）
   *
   * @param {Object} params
   * @param {number} params.userId - 所有者用户ID
   * @param {string} params.itemType - 物品类型（voucher/product/equipment）
   * @param {number} params.itemTemplateId - 物品模板ID（关联奖品表）
   * @param {Object} params.meta - 物品元数据（name/description/icon/value）
   * @param {string} params.businessId - 业务幂等键（必需）
   * @param {Transaction} params.transaction - Sequelize事务（必需）
   * @returns {Promise<ItemInstance>}
   */
  static async mint({ userId, itemType, itemTemplateId, meta, businessId, transaction }) {
    if (!transaction) {
      throw new Error('ItemInstanceService.mint 必须在事务内执行')
    }

    if (!businessId) {
      throw new Error('ItemInstanceService.mint 必须提供 businessId（幂等键）')
    }

    // 1. 幂等性检查（基于事件表）
    const existingEvent = await ItemInstanceEvent.findOne({
      where: {
        business_type: 'lottery_reward',
        business_id: businessId
      },
      transaction
    })

    if (existingEvent) {
      logger.info('幂等拦截：物品已铸造', { business_id: businessId })
      const existingItem = await ItemInstance.findByPk(existingEvent.item_instance_id, {
        transaction
      })
      return existingItem
    }

    // 2. 创建物品实例
    const item = await ItemInstance.create(
      {
        owner_user_id: userId,
        item_type: itemType,
        item_template_id: itemTemplateId,
        status: 'available',
        meta: meta
      },
      { transaction }
    )

    // 3. 记录铸造事件
    await ItemInstanceEvent.create(
      {
        item_instance_id: item.item_instance_id,
        event_type: 'mint',
        to_user_id: userId,
        business_type: 'lottery_reward',
        business_id: businessId,
        metadata: { item_type: itemType, template_id: itemTemplateId }
      },
      { transaction }
    )

    logger.info('物品铸造成功', {
      item_instance_id: item.item_instance_id,
      user_id: userId,
      item_type: itemType,
      business_id: businessId
    })

    return item
  }

  /**
   * 锁定物品（订单并发控制）
   */
  static async lock({ itemInstanceId, orderId, businessId, transaction }) {
    const item = await ItemInstance.findByPk(itemInstanceId, {
      lock: transaction.LOCK.UPDATE,
      transaction
    })

    if (!item) {
      throw new Error(`物品实例不存在: ${itemInstanceId}`)
    }

    if (item.status !== 'available') {
      throw new Error(`物品状态不可锁定: ${item.status}`)
    }

    // 检查是否已被其他订单锁定
    if (item.locked_by_order_id && item.locked_by_order_id !== orderId) {
      const lockTime = new Date(item.locked_at)
      const now = new Date()
      const lockDuration = (now - lockTime) / 1000

      // 锁超时（3分钟）自动解锁
      if (lockDuration < 180) {
        throw new Error(`物品已被订单 ${item.locked_by_order_id} 锁定`)
      }

      logger.warn('检测到锁超时，自动解锁', {
        item_instance_id: itemInstanceId,
        old_order_id: item.locked_by_order_id,
        lock_duration: lockDuration
      })
    }

    await item.update(
      {
        status: 'locked',
        locked_by_order_id: orderId,
        locked_at: new Date()
      },
      { transaction }
    )

    await ItemInstanceEvent.create(
      {
        item_instance_id: itemInstanceId,
        event_type: 'lock',
        business_type: 'order_lock',
        business_id: businessId,
        metadata: { order_id: orderId }
      },
      { transaction }
    )

    logger.info('物品锁定成功', { item_instance_id: itemInstanceId, order_id: orderId })
  }

  /**
   * 解锁物品（订单取消）
   */
  static async unlock({ itemInstanceId, orderId, businessId, transaction }) {
    const item = await ItemInstance.findByPk(itemInstanceId, {
      lock: transaction.LOCK.UPDATE,
      transaction
    })

    if (!item) {
      throw new Error(`物品实例不存在: ${itemInstanceId}`)
    }

    if (item.status !== 'locked') {
      throw new Error(`物品状态不可解锁: ${item.status}`)
    }

    if (item.locked_by_order_id !== orderId) {
      throw new Error(`物品被其他订单锁定: ${item.locked_by_order_id}`)
    }

    await item.update(
      {
        status: 'available',
        locked_by_order_id: null,
        locked_at: null
      },
      { transaction }
    )

    await ItemInstanceEvent.create(
      {
        item_instance_id: itemInstanceId,
        event_type: 'unlock',
        business_type: 'order_cancel',
        business_id: businessId,
        metadata: { order_id: orderId }
      },
      { transaction }
    )

    logger.info('物品解锁成功', { item_instance_id: itemInstanceId, order_id: orderId })
  }

  /**
   * 转移所有权（交易/赠送）
   */
  static async transfer({ itemInstanceId, fromUserId, toUserId, businessId, transaction }) {
    const item = await ItemInstance.findByPk(itemInstanceId, {
      lock: transaction.LOCK.UPDATE,
      transaction
    })

    if (!item) {
      throw new Error(`物品实例不存在: ${itemInstanceId}`)
    }

    if (item.owner_user_id !== fromUserId) {
      throw new Error(
        `物品所有权不匹配: 当前所有者=${item.owner_user_id}, 请求转出者=${fromUserId}`
      )
    }

    if (item.status !== 'available') {
      throw new Error(`物品状态不可转移: ${item.status}`)
    }

    await item.update(
      {
        owner_user_id: toUserId,
        status: 'transferred'
      },
      { transaction }
    )

    await ItemInstanceEvent.create(
      {
        item_instance_id: itemInstanceId,
        event_type: 'transfer',
        from_user_id: fromUserId,
        to_user_id: toUserId,
        business_type: 'market_trade',
        business_id: businessId,
        metadata: { from_user_id: fromUserId, to_user_id: toUserId }
      },
      { transaction }
    )

    logger.info('物品转移成功', {
      item_instance_id: itemInstanceId,
      from_user_id: fromUserId,
      to_user_id: toUserId
    })
  }

  /**
   * 使用/核销物品（优惠券核销）
   */
  static async use({ itemInstanceId, userId, businessId, transaction }) {
    const item = await ItemInstance.findByPk(itemInstanceId, {
      lock: transaction.LOCK.UPDATE,
      transaction
    })

    if (!item) {
      throw new Error(`物品实例不存在: ${itemInstanceId}`)
    }

    if (item.owner_user_id !== userId) {
      throw new Error(`物品所有权不匹配: 当前所有者=${item.owner_user_id}, 请求使用者=${userId}`)
    }

    if (item.status !== 'available') {
      throw new Error(`物品状态不可使用: ${item.status}`)
    }

    await item.update(
      {
        status: 'used'
      },
      { transaction }
    )

    await ItemInstanceEvent.create(
      {
        item_instance_id: itemInstanceId,
        event_type: 'use',
        business_type: 'voucher_redeem',
        business_id: businessId,
        metadata: { user_id: userId }
      },
      { transaction }
    )

    logger.info('物品使用成功', { item_instance_id: itemInstanceId, user_id: userId })
  }

  /**
   * 查询用户物品列表
   */
  static async getUserItems({ userId, status = null }) {
    const where = { owner_user_id: userId }
    if (status) {
      where.status = status
    }

    const items = await ItemInstance.findAll({
      where,
      order: [['created_at', 'DESC']]
    })

    return items
  }
}

module.exports = ItemInstanceService
```

### 3.3 BackpackService（背包查询服务）

```javascript
/**
 * 背包服务 - 统一资产查询入口
 *
 * 职责：
 * - 统一返回用户的所有资产（账本资产 + 物品实例）
 * - 双轨查询：assets[]（可叠加）+ items[]（不可叠加）
 *
 * 返回格式：
 * {
 *   assets: [
 *     { asset_code: 'POINTS', available: 1000, frozen: 0, name: '积分' },
 *     { asset_code: 'red_shard', available: 500, frozen: 0, name: '碎红水晶' }
 *   ],
 *   items: [
 *     { item_instance_id: 123, item_type: 'voucher', status: 'available', meta: {...} }
 *   ]
 * }
 */
class BackpackService {
  static async getUserBackpack({ userId }) {
    // 1. 查询账本资产
    const assets = await AssetService.getAllBalances({ userId })

    // 2. 查询物品实例
    const items = await ItemInstanceService.getUserItems({ userId, status: 'available' })

    // 3. 补充资产元数据（名称、图标等）
    const assetsWithMeta = await Promise.all(
      assets.map(async asset => {
        const assetType = await MaterialAssetType.findOne({
          where: { asset_code: asset.asset_code }
        })

        return {
          ...asset,
          name: assetType?.name || asset.asset_code,
          icon: assetType?.icon_url || null,
          category: assetType?.category || 'unknown'
        }
      })
    )

    return {
      assets: assetsWithMeta,
      items: items.map(item => ({
        item_instance_id: item.item_instance_id,
        item_type: item.item_type,
        status: item.status,
        meta: item.meta,
        created_at: item.created_at
      }))
    }
  }
}

module.exports = BackpackService
```

---

## 四、业务流程重构

### 4.1 商家扫码审核流程（新增 - 拍板决策）

**业务实体**：`merchant_points_reviews`（商家积分审核单）

**表结构**：

```sql
CREATE TABLE merchant_points_reviews (
  review_id VARCHAR(100) PRIMARY KEY COMMENT '审核单ID（UUID）',
  user_id INT NOT NULL COMMENT '用户ID',
  merchant_id INT NOT NULL COMMENT '商家ID',
  points_amount BIGINT NOT NULL COMMENT '审核积分金额',
  status ENUM('pending', 'approved', 'rejected', 'expired', 'cancelled') NOT NULL DEFAULT 'pending' COMMENT '审核状态',
  expires_at TIMESTAMP NOT NULL COMMENT '审核超时时间（超时后需客服处理）',
  idempotency_key VARCHAR(100) UNIQUE NOT NULL COMMENT '幂等键（防止重复提交）',
  qr_code_data VARCHAR(500) COMMENT '二维码数据',
  metadata JSON COMMENT '审核元数据（商家信息、扫码时间等）',
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  INDEX idx_user_status (user_id, status),
  INDEX idx_merchant_status (merchant_id, status),
  INDEX idx_expires_at (expires_at),

  FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE RESTRICT,
  FOREIGN KEY (merchant_id) REFERENCES users(user_id) ON DELETE RESTRICT
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='商家积分审核单（扫码审核冻结积分）';
```

**业务流程**：

```javascript
// 1. 商家扫码提交审核（冻结积分）
async function submitMerchantReview({ user_id, merchant_id, points_amount, qr_code_data }) {
  const transaction = await sequelize.transaction()

  try {
    // 1.1 生成审核单ID和幂等键
    const review_id = generateUUID()
    const idempotency_key = `merchant_review_${user_id}_${merchant_id}_${Date.now()}`

    // 1.2 创建审核单（pending）
    const review = await MerchantPointsReview.create(
      {
        review_id,
        user_id,
        merchant_id,
        points_amount,
        status: 'pending',
        expires_at: new Date(Date.now() + 24 * 60 * 60 * 1000), // 24小时超时
        idempotency_key,
        qr_code_data
      },
      { transaction }
    )

    // 1.3 冻结用户积分（归属约束：review_id）
    await AssetService.freeze({
      user_id,
      asset_code: 'POINTS',
      amount: points_amount,
      business_type: 'merchant_review_freeze',
      idempotency_key: `${review_id}:freeze`,
      meta: {
        review_id,
        merchant_id,
        freeze_reason: '商家扫码审核冻结'
      },
      transaction
    })

    await transaction.commit()
    return { review_id, status: 'pending' }
  } catch (error) {
    await transaction.rollback()
    throw error
  }
}

// 2. 审核通过（从冻结结算，真正扣款）
async function approveMerchantReview({ review_id }) {
  const transaction = await sequelize.transaction()

  try {
    const review = await MerchantPointsReview.findByPk(review_id, {
      lock: transaction.LOCK.UPDATE,
      transaction
    })

    if (review.status !== 'pending') {
      throw new Error(`审核单状态异常: ${review.status}`)
    }

    // 2.1 从冻结结算（frozen ↓，真正扣款完成）
    await AssetService.settleFromFrozen({
      user_id: review.user_id,
      asset_code: 'POINTS',
      amount: review.points_amount,
      business_type: 'merchant_review_settle',
      idempotency_key: `${review_id}:settle`,
      meta: {
        review_id,
        merchant_id: review.merchant_id,
        settle_reason: '审核通过结算'
      },
      transaction
    })

    // 2.2 更新审核单状态
    await review.update({ status: 'approved' }, { transaction })

    await transaction.commit()
    return { review_id, status: 'approved' }
  } catch (error) {
    await transaction.rollback()
    throw error
  }
}

// 3. 审核拒绝（拍板决策：积分不退回，需客服处理）
async function rejectMerchantReview({ review_id, reject_reason }) {
  const transaction = await sequelize.transaction()

  try {
    const review = await MerchantPointsReview.findByPk(review_id, {
      lock: transaction.LOCK.UPDATE,
      transaction
    })

    if (review.status !== 'pending') {
      throw new Error(`审核单状态异常: ${review.status}`)
    }

    // 3.1 更新审核单状态（rejected）
    await review.update(
      {
        status: 'rejected',
        metadata: {
          ...review.metadata,
          reject_reason,
          reject_time: new Date().toISOString()
        }
      },
      { transaction }
    )

    // 3.2 拍板决策：积分不退回（仍冻结）
    // 需要客服/管理员手工处理：要么解冻退回，要么从冻结扣除作废
    logger.warn('审核拒绝，积分仍冻结（需客服处理）', {
      review_id,
      user_id: review.user_id,
      frozen_points: review.points_amount,
      reject_reason
    })

    await transaction.commit()
    return { review_id, status: 'rejected', frozen_points: review.points_amount }
  } catch (error) {
    await transaction.rollback()
    throw error
  }
}

// 4. 超时兜底（拍板决策：仅告警，不自动解冻）
async function alertTimeoutReviews() {
  // 定时任务：每小时扫描一次
  const timeoutReviews = await MerchantPointsReview.findAll({
    where: {
      status: 'pending',
      expires_at: { [Op.lt]: new Date() }
    },
    attributes: ['review_id', 'user_id', 'merchant_id', 'points_amount', 'expires_at', 'created_at']
  })

  if (timeoutReviews.length > 0) {
    // 仅推进状态到 expired，不解冻
    for (const review of timeoutReviews) {
      await review.update({
        status: 'expired',
        metadata: {
          ...review.metadata,
          expire_time: new Date().toISOString(),
          expire_reason: '审核超时未处理'
        }
      })
    }

    // 发送告警通知客服
    logger.error('检测到超时审核单（积分仍冻结，需客服处理）', {
      count: timeoutReviews.length,
      review_ids: timeoutReviews.map(r => r.review_id),
      total_frozen_points: timeoutReviews.reduce((sum, r) => sum + r.points_amount, 0)
    })

    // 可扩展：发送企业微信/钉钉告警
    // await sendAdminAlert({ type: 'merchant_review_timeout', data: timeoutReviews });
  }

  return {
    timeout_count: timeoutReviews.length,
    action: 'alert_only_no_unfreeze' // 拍板决策：仅告警，不解冻
  }
}

// 5. 客服手工处理：解冻或作废（唯一出口）
async function adminHandleFrozenReview({ review_id, action, admin_user_id, handle_reason }) {
  // action: 'unfreeze'（解冻退回）或 'confiscate'（从冻结作废）
  const transaction = await sequelize.transaction()

  try {
    const review = await MerchantPointsReview.findByPk(review_id, { transaction })

    if (!['rejected', 'expired'].includes(review.status)) {
      throw new Error(`只能处理 rejected/expired 状态的审核单（当前状态: ${review.status}）`)
    }

    if (action === 'unfreeze') {
      // 解冻退回（客服判断：用户无责/系统异常）
      await AssetService.unfreeze({
        user_id: review.user_id,
        asset_code: 'POINTS',
        amount: review.points_amount,
        business_type: 'merchant_review_admin_unfreeze',
        idempotency_key: `${review_id}:admin_unfreeze`,
        meta: {
          review_id,
          admin_user_id,
          admin_action: 'unfreeze',
          handle_reason
        },
        transaction
      })

      logger.info('客服解冻审核单积分', {
        review_id,
        user_id: review.user_id,
        points_amount: review.points_amount,
        admin_user_id,
        handle_reason
      })
    } else if (action === 'confiscate') {
      // 从冻结作废（客服判断：用户违约/恶意逃单）
      await AssetService.settleFromFrozen({
        user_id: review.user_id,
        asset_code: 'POINTS',
        amount: review.points_amount,
        business_type: 'merchant_review_admin_confiscate',
        idempotency_key: `${review_id}:admin_confiscate`,
        meta: {
          review_id,
          admin_user_id,
          admin_action: 'confiscate',
          handle_reason
        },
        transaction
      })

      logger.info('客服作废审核单积分', {
        review_id,
        user_id: review.user_id,
        points_amount: review.points_amount,
        admin_user_id,
        handle_reason
      })
    } else {
      throw new Error(`未知的处理动作: ${action}`)
    }

    // 更新审核单状态为 cancelled（已处理）
    await review.update(
      {
        status: 'cancelled',
        metadata: {
          ...review.metadata,
          admin_handled_at: new Date().toISOString(),
          admin_user_id,
          admin_action: action,
          handle_reason
        }
      },
      { transaction }
    )

    await transaction.commit()
    return { review_id, action, status: 'cancelled' }
  } catch (error) {
    await transaction.rollback()
    throw error
  }
}
```

**业务规则拍板**（商业模式核心）：

- ✅ 审核通过：从冻结结算（真正扣款）
- ✅ 审核拒绝：**积分不退回**（仍冻结，需客服手工处理）
- ✅ 审核超时：**积分不退回**（仍冻结，需客服手工处理）
- ✅ 超时兜底：仅推进状态到 `expired` 并告警，**不自动解冻**
- ✅ 客服处理：可选择解冻退回（用户无责）或从冻结作废（用户违约）
- ✅ 所有冻结必须有归属约束：`review_id` + `idempotency_key={review_id}:freeze`
- ✅ 冻结会无限期存在，接受用户资产长期不可用（只要没审核通过就不可以增加到可用积分中）

---

### 4.2 抽奖流程（BasicGuaranteeStrategy）

```javascript
class BasicGuaranteeStrategy {
  async execute(context, transaction) {
    const { user_id, campaign_id, draw_count, idempotency_key } = context

    // 1. 计算消耗积分（单抽100，10连抽900）
    const costPerDraw = 100
    const totalCost = draw_count === 10 ? 900 : draw_count * costPerDraw

    // 2. 扣减用户积分（幂等）
    await AssetService.changeBalance({
      userId: user_id,
      assetCode: 'POINTS',
      amount: -totalCost,
      transactionType: 'lottery_deduct',
      businessId: `lottery_${idempotency_key}_deduct`,
      transaction
    })

    // 3. 执行抽奖逻辑（选择奖品）
    const rewards = await this.drawRewards(user_id, campaign_id, draw_count)

    // 4. 发放奖励
    for (let i = 0; i < rewards.length; i++) {
      const reward = rewards[i]

      if (reward.reward_type === 'material') {
        // 材料资产（可叠加）
        await AssetService.changeBalance({
          userId: user_id,
          assetCode: reward.asset_code, // 如 'red_shard'
          amount: reward.quantity,
          transactionType: 'lottery_reward',
          businessId: `lottery_${idempotency_key}_reward_${i}`,
          relatedOrderId: idempotency_key,
          metadata: { prize_id: reward.prize_id, prize_name: reward.prize_name },
          transaction
        })
      } else if (reward.reward_type === 'item') {
        // 物品实例（不可叠加）
        await ItemInstanceService.mint({
          userId: user_id,
          itemType: reward.item_type, // 如 'voucher'
          itemTemplateId: reward.prize_id,
          meta: {
            name: reward.prize_name,
            description: reward.description,
            icon: reward.icon_url,
            value: reward.prize_value
          },
          businessId: `lottery_${idempotency_key}_item_${i}`,
          transaction
        })
      }
    }

    // 5. 创建抽奖记录
    await LotteryDraw.create(
      {
        draw_id: generateDrawId(),
        business_id: idempotency_key,
        user_id: user_id,
        campaign_id: campaign_id,
        prize_id: rewards[0].prize_id,
        prize_name: rewards[0].prize_name,
        prize_value: rewards[0].prize_value,
        points_cost: totalCost,
        draw_count: draw_count
      },
      { transaction }
    )

    return {
      success: true,
      rewards: rewards,
      points_cost: totalCost
    }
  }
}
```

### 4.3 交易市场流程（TradeOrderService - 双重冻结）

**业务实体**：`trade_orders`（交易订单）+ `market_listings`（挂牌）

**业务流程**：

```javascript
// 1. 创建交易订单（双重冻结：买家资产 + 标的物品）
async function createTradeOrder({ business_id, listing_id, buyer_user_id }) {
  const transaction = await sequelize.transaction()

  try {
    // 1.1 查询挂牌信息
    const listing = await MarketListing.findOne({
      where: { listing_id },
      lock: transaction.LOCK.UPDATE,
      transaction
    })

    if (listing.status !== 'on_sale') {
      throw new Error(`挂牌状态异常: ${listing.status}`)
    }

    // 1.2 锁定挂牌
    await listing.update({ status: 'locked', locked_at: new Date() }, { transaction })

    // 1.3 创建订单记录
    const order = await TradeOrder.create(
      {
        business_id,
        listing_id,
        buyer_user_id,
        seller_user_id: listing.seller_user_id,
        asset_code: listing.price_asset_code, // 强制 DIAMOND
        gross_amount: listing.price_amount,
        status: 'created'
      },
      { transaction }
    )

    // 1.4 绑定订单ID到挂牌
    await listing.update({ locked_by_order_id: order.order_id }, { transaction })

    // 1.5 冻结买家资产（归属约束：order_id）
    await AssetService.freeze({
      user_id: buyer_user_id,
      asset_code: listing.price_asset_code, // DIAMOND
      amount: listing.price_amount,
      business_type: 'order_freeze_buyer',
      idempotency_key: `${business_id}:freeze`, // 使用 business_id 派生
      meta: {
        order_id: order.order_id,
        listing_id,
        freeze_reason: '交易市场下单冻结'
      },
      transaction
    })

    // 1.6 如果是不可叠加物品，锁定物品实例
    if (listing.listing_kind === 'non_fungible_item') {
      const item = await ItemInstance.findByPk(listing.offer_item_instance_id, {
        lock: transaction.LOCK.UPDATE,
        transaction
      })
      await item.lock(order.order_id, { transaction })
    }

    // 1.7 推进订单状态：created → frozen
    await order.update({ status: 'frozen' }, { transaction })

    await transaction.commit()
    return { order, status: 'frozen' }
  } catch (error) {
    await transaction.rollback()
    throw error
  }
}

// 2. 完成订单（从冻结结算 + 转移所有权）
async function completeTradeOrder({ order_id, business_id }) {
  const transaction = await sequelize.transaction()

  try {
    const order = await TradeOrder.findByPk(order_id, {
      lock: transaction.LOCK.UPDATE,
      transaction
    })

    if (order.status !== 'frozen') {
      throw new Error(`订单状态异常: ${order.status}`)
    }

    // 2.1 从冻结结算买家资产（frozen ↓，真正扣款）
    await AssetService.settleFromFrozen({
      user_id: order.buyer_user_id,
      asset_code: order.asset_code,
      amount: order.gross_amount,
      business_type: 'order_settle_buyer_debit',
      idempotency_key: `${business_id}:settle_buyer`,
      meta: { order_id, settle_reason: '交易成交结算' },
      transaction
    })

    // 2.2 卖家入账（如果是不可叠加物品，转移所有权）
    const listing = await MarketListing.findByPk(order.listing_id, { transaction })

    if (listing.listing_kind === 'non_fungible_item') {
      const item = await ItemInstance.findByPk(listing.offer_item_instance_id, {
        lock: transaction.LOCK.UPDATE,
        transaction
      })
      await item.transferOwnership(order.buyer_user_id, { transaction })
    }

    // 2.3 卖家入账（净额）
    await AssetService.changeBalance({
      user_id: order.seller_user_id,
      asset_code: order.asset_code,
      delta_amount: order.net_amount,
      business_type: 'order_settle_seller_credit',
      idempotency_key: `${business_id}:settle_seller`,
      transaction
    })

    // 2.4 更新订单和挂牌状态
    await order.update({ status: 'completed' }, { transaction })
    await listing.update({ status: 'sold' }, { transaction })

    await transaction.commit()
    return { order_id, status: 'completed' }
  } catch (error) {
    await transaction.rollback()
    throw error
  }
}

// 3. 取消订单（解冻资产 + 解锁物品）
async function cancelTradeOrder({ order_id, business_id, cancel_reason }) {
  const transaction = await sequelize.transaction()

  try {
    const order = await TradeOrder.findByPk(order_id, {
      lock: transaction.LOCK.UPDATE,
      transaction
    })

    if (order.status !== 'frozen') {
      throw new Error(`订单状态异常: ${order.status}`)
    }

    // 3.1 解冻买家资产（frozen → available）
    await AssetService.unfreeze({
      user_id: order.buyer_user_id,
      asset_code: order.asset_code,
      amount: order.gross_amount,
      business_type: 'order_unfreeze_buyer',
      idempotency_key: `${business_id}:unfreeze`,
      meta: {
        order_id,
        unfreeze_reason: cancel_reason || '订单取消解冻'
      },
      transaction
    })

    // 3.2 解锁物品实例
    const listing = await MarketListing.findByPk(order.listing_id, { transaction })
    if (listing.listing_kind === 'non_fungible_item') {
      const item = await ItemInstance.findByPk(listing.offer_item_instance_id, {
        lock: transaction.LOCK.UPDATE,
        transaction
      })
      await item.unlock({ transaction })
    }

    // 3.3 更新订单和挂牌状态
    await order.update({ status: 'cancelled' }, { transaction })
    await listing.update(
      {
        status: 'on_sale',
        locked_by_order_id: null,
        locked_at: null
      },
      { transaction }
    )

    await transaction.commit()
    return { order_id, status: 'cancelled' }
  } catch (error) {
    await transaction.rollback()
    throw error
  }
}
```

**归属约束三件套**：

1. **唯一归属ID**：`trade_orders.order_id`
2. **业务类型区分**：`order_freeze_buyer`（下单冻结）/ `order_settle_buyer_debit`（成交结算）/ `order_unfreeze_buyer`（取消解冻）
3. **幂等键派生**：`{business_id}:freeze` / `{business_id}:settle_buyer` / `{business_id}:unfreeze`

---

### 4.4 兑换流程（ExchangeService）

```javascript
class ExchangeService {
  static async exchangeItem(userId, itemId, quantity, options = {}) {
    const transaction = await sequelize.transaction()

    try {
      // 1. 查询兑换商品配置
      const exchangeItem = await ExchangeItem.findByPk(itemId, { transaction })

      if (!exchangeItem || exchangeItem.status !== 'active') {
        throw new Error('商品不存在或已下架')
      }

      // 2. 检查库存
      if (exchangeItem.stock < quantity) {
        throw new Error(`库存不足: 剩余=${exchangeItem.stock}, 需要=${quantity}`)
      }

      // 3. 计算消耗材料
      const totalCost = exchangeItem.cost_amount * quantity
      const costAssetCode = exchangeItem.cost_asset_code // 如 'red_shard'

      // 4. 生成业务幂等键
      const businessId = `exchange_${userId}_${itemId}_${Date.now()}`

      // 5. 扣减材料资产
      await AssetService.changeBalance({
        userId: userId,
        assetCode: costAssetCode,
        amount: -totalCost,
        transactionType: 'exchange_cost',
        businessId: `${businessId}_cost`,
        transaction
      })

      // 6. 扣减库存
      await exchangeItem.decrement('stock', { by: quantity, transaction })
      await exchangeItem.increment('sold_count', { by: quantity, transaction })

      // 7. 创建兑换订单
      const order = await RedemptionOrder.create(
        {
          order_id: generateOrderId(),
          user_id: userId,
          item_id: itemId,
          quantity: quantity,
          cost_asset_code: costAssetCode,
          cost_amount: totalCost,
          status: 'pending',
          redemption_code: generateRedemptionCode()
        },
        { transaction }
      )

      // 8. 如果是虚拟商品，直接发放物品实例
      if (exchangeItem.category === 'virtual') {
        await ItemInstanceService.mint({
          userId: userId,
          itemType: 'product',
          itemTemplateId: itemId,
          meta: {
            name: exchangeItem.name,
            description: exchangeItem.description,
            icon: exchangeItem.image_url,
            redemption_code: order.redemption_code
          },
          businessId: `${businessId}_item`,
          transaction
        })
      }

      await transaction.commit()

      return {
        success: true,
        order_id: order.order_id,
        redemption_code: order.redemption_code
      }
    } catch (error) {
      await transaction.rollback()
      throw error
    }
  }
}
```

---

## 五、破坏性迁移方案

### 5.1 数据库表结构变更

```sql
-- ===== 第一步：删除旧表 =====
DROP TABLE IF EXISTS user_points_accounts;
DROP TABLE IF EXISTS points_transactions;

-- ===== 第二步：确保新表结构正确 =====

-- 账户表（如果不存在则创建）
CREATE TABLE IF NOT EXISTS accounts (
  account_id INT PRIMARY KEY AUTO_INCREMENT,
  user_id INT UNIQUE NOT NULL,
  account_type ENUM('user', 'system', 'merchant') DEFAULT 'user',
  status ENUM('active', 'frozen', 'closed') DEFAULT 'active',
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  INDEX idx_user_id (user_id),
  INDEX idx_account_type (account_type)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- 资产余额表（如果不存在则创建）
CREATE TABLE IF NOT EXISTS account_asset_balances (
  balance_id BIGINT PRIMARY KEY AUTO_INCREMENT,
  account_id INT NOT NULL,
  asset_code VARCHAR(50) NOT NULL,
  available_amount DECIMAL(20,4) NOT NULL DEFAULT 0,
  frozen_amount DECIMAL(20,4) NOT NULL DEFAULT 0,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  UNIQUE KEY uk_account_asset (account_id, asset_code),
  INDEX idx_asset_code (asset_code),
  FOREIGN KEY (account_id) REFERENCES accounts(account_id) ON DELETE RESTRICT
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- 资产流水表（如果不存在则创建）
CREATE TABLE IF NOT EXISTS asset_transactions (
  transaction_id BIGINT PRIMARY KEY AUTO_INCREMENT,
  account_id INT NOT NULL,
  asset_code VARCHAR(50) NOT NULL,
  change_amount DECIMAL(20,4) NOT NULL,
  before_amount DECIMAL(20,4) NOT NULL,
  after_amount DECIMAL(20,4) NOT NULL,
  transaction_type VARCHAR(50) NOT NULL,
  business_id VARCHAR(100) UNIQUE,
  related_order_id VARCHAR(100),
  metadata JSON,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  INDEX idx_account_asset (account_id, asset_code),
  INDEX idx_business_id (business_id),
  INDEX idx_transaction_type (transaction_type),
  INDEX idx_created_at (created_at),
  FOREIGN KEY (account_id) REFERENCES accounts(account_id) ON DELETE RESTRICT
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- 物品实例事件表（如果不存在则创建）
CREATE TABLE IF NOT EXISTS item_instance_events (
  event_id BIGINT PRIMARY KEY AUTO_INCREMENT,
  item_instance_id BIGINT NOT NULL,
  event_type ENUM('mint', 'lock', 'unlock', 'transfer', 'use', 'expire', 'destroy') NOT NULL,
  from_user_id INT,
  to_user_id INT,
  business_type VARCHAR(50) NOT NULL,
  business_id VARCHAR(100) NOT NULL,
  metadata JSON,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  UNIQUE KEY uk_business (business_type, business_id),
  INDEX idx_item_instance (item_instance_id),
  INDEX idx_event_type (event_type),
  INDEX idx_created_at (created_at),
  FOREIGN KEY (item_instance_id) REFERENCES item_instances(item_instance_id) ON DELETE RESTRICT
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- ===== 第三步：验证数据完整性 =====
SELECT
  (SELECT COUNT(*) FROM accounts WHERE account_type='user') AS user_accounts,
  (SELECT COUNT(*) FROM account_asset_balances WHERE asset_code='POINTS') AS points_balances,
  (SELECT SUM(available_amount) FROM account_asset_balances WHERE asset_code='POINTS') AS total_points,
  (SELECT COUNT(*) FROM asset_transactions) AS total_transactions,
  (SELECT COUNT(*) FROM item_instances) AS total_items,
  (SELECT COUNT(*) FROM item_instance_events) AS total_events;
```

### 5.2 代码文件删除清单

```bash
# 删除旧模型
rm -f models/UserPointsAccount.js
rm -f models/PointsTransaction.js

# 删除旧服务
rm -f services/PointsService.js

# 删除旧路由
rm -f routes/v4/lottery/user-points.js

# 删除旧测试
rm -f tests/services/PointsService.test.js
rm -f tests/routes/user-points.test.js
```

### 5.3 新增文件清单

```bash
# 核心服务（必需）
services/AssetService.js          # 资产域核心服务（已存在，需确保 freeze/unfreeze/settleFromFrozen 完整）
services/ItemInstanceService.js   # 物品实例服务（新增）
services/BackpackService.js       # 背包查询服务（已存在，需重写）
services/MerchantReviewService.js # 商家审核服务（新增 - 拍板决策）

# 新增路由
routes/v4/assets/balance.js       # 资产余额查询接口
routes/v4/assets/transactions.js  # 资产流水查询接口
routes/v4/backpack/index.js       # 背包查询接口
routes/v4/merchant/reviews.js     # 商家审核接口（新增 - 拍板决策）

# 新增模型（如果不存在）
models/Account.js                  # 账户主表
models/AccountAssetBalance.js     # 资产余额表
models/AssetTransaction.js        # 资产流水表
models/ItemInstanceEvent.js       # 物品实例事件表
models/MerchantPointsReview.js    # 商家积分审核单（新增 - 拍板决策）

# 新增定时任务（兜底机制 - 拍板决策）
jobs/hourly-unlock-timeout-trade-orders.js   # 每小时释放交易市场超时锁定（3分钟超时，自动解冻+解锁）
jobs/hourly-alert-timeout-reviews.js         # 每小时告警商家审核超时（仅告警，不解冻，需客服处理）
```

### 5.4 前端接口变更清单

**废弃接口**（直接返回404）：

- `GET /api/v4/lottery/user-points/:user_id` → 删除
- `POST /api/v4/points/add` → 删除
- `POST /api/v4/points/consume` → 删除

**新增接口**：

- `GET /api/v4/assets/balance?asset_code=POINTS` → 查询单个资产余额
- `GET /api/v4/assets/balances` → 查询所有资产余额
- `GET /api/v4/assets/transactions?asset_code=POINTS&limit=20` → 查询资产流水
- `GET /api/v4/backpack` → 查询背包（资产+物品）
- `GET /api/v4/items/instances?status=available` → 查询物品实例

---

## 六、实施步骤（单次破坏性变更）

### 6.1 实施前准备（1小时）

```bash
# 1. 停止所有服务
pm2 stop all

# 2. 数据库全量备份（应急恢复用）
mysqldump -u root -p restaurant_lottery > backup_$(date +%Y%m%d_%H%M%S).sql

# 3. 验证当前数据状态
mysql -u root -p restaurant_lottery -e "
SELECT
  (SELECT COUNT(*) FROM accounts) AS accounts,
  (SELECT COUNT(*) FROM account_asset_balances) AS balances,
  (SELECT SUM(available_amount) FROM account_asset_balances WHERE asset_code='POINTS') AS total_points,
  (SELECT COUNT(*) FROM item_instances) AS items;
"
```

### 6.2 数据库变更（30分钟）

```bash
# 执行破坏性变更SQL
mysql -u root -p restaurant_lottery < migrations/破坏性重构.sql

# 验证变更结果
mysql -u root -p restaurant_lottery -e "
SHOW TABLES LIKE '%points%';  -- 应该为空（旧表已删除）
SHOW TABLES LIKE 'asset%';    -- 应该有 asset_transactions
SHOW TABLES LIKE 'item_instance%';  -- 应该有 item_instances, item_instance_events
"
```

### 6.3 代码部署（30分钟）

```bash
# 1. 拉取新代码
git pull origin main

# 2. 安装依赖（如有新增）
npm install

# 3. 删除旧文件
rm -f models/UserPointsAccount.js models/PointsTransaction.js
rm -f services/PointsService.js
rm -f routes/v4/lottery/user-points.js

# 4. 验证新文件存在
ls -la services/AssetService.js
ls -la services/ItemInstanceService.js
ls -la services/BackpackService.js

# 5. 启动服务
pm2 start ecosystem.config.js
pm2 logs --lines 50
```

### 6.4 功能验证（30分钟）

```bash
# 1. 健康检查
curl http://localhost:3000/health

# 2. 查询资产余额
curl -H "Authorization: Bearer <token>" \
  http://localhost:3000/api/v4/assets/balances

# 3. 查询背包
curl -H "Authorization: Bearer <token>" \
  http://localhost:3000/api/v4/backpack

# 4. 执行抽奖（完整流程测试）
curl -X POST http://localhost:3000/api/v4/lottery/draw \
  -H "Authorization: Bearer <token>" \
  -H "Content-Type: application/json" \
  -d '{"campaign_code": "default", "draw_count": 1}'

# 5. 验证资产变动
curl -H "Authorization: Bearer <token>" \
  "http://localhost:3000/api/v4/assets/transactions?asset_code=POINTS&limit=5"
```

### 6.5 回滚方案（应急）

```bash
# 如果出现严重问题，执行回滚：

# 1. 停止服务
pm2 stop all

# 2. 恢复数据库备份
mysql -u root -p restaurant_lottery < backup_20251229_*.sql

# 3. 回滚代码
git reset --hard <上一个稳定版本commit>

# 4. 重启服务
pm2 start ecosystem.config.js
```

---

## 七、验收标准

### 7.1 功能验收

- [ ] 抽奖流程正常（扣分 → 发放奖励 → 记录流水）
- [ ] 兑换流程正常（扣材料 → 扣库存 → 生成订单）
- [ ] 背包查询正常（返回资产+物品）
- [ ] 资产流水查询正常（完整审计日志）
- [ ] 物品实例状态机正常（available → locked → used）
- [ ] **商家审核冻结流程正常**（提交审核 → 冻结积分 → 审核通过从冻结结算 → 审核拒绝积分仍冻结）
- [ ] **交易市场冻结流程正常**（下单冻结资产+锁定物品 → 成交从冻结结算+转移所有权 → 取消解冻+解锁）
- [ ] **冻结归属约束验证**（所有冻结余额都能在 asset_transactions 中追溯到 freeze 流水）
- [ ] **超时兜底机制验证**（物品锁超时自动解锁、审核单超时告警）

### 7.2 数据验收

- [ ] 旧表已删除（`user_points_accounts`、`points_transactions`）
- [ ] 新表数据完整（`accounts`、`account_asset_balances`、`asset_transactions`、`merchant_points_reviews`）
- [ ] 资产余额一致性（`account_asset_balances.available_amount` 总额 = `asset_transactions.delta_amount` 流水累计）
- [ ] 冻结余额可追溯性（所有 `frozen_amount > 0` 的记录都能在 `asset_transactions` 中找到对应的 freeze 流水）
- [ ] 物品实例完整性（`item_instances` 总数 = 事件 mint 次数）
- [ ] 物品锁定可追溯性（所有 `status='locked'` 的物品都能找到对应的 pending 订单）
- [ ] 无孤儿冻结/孤儿锁（`frozen_without_audit_count = 0`、`locked_items_orphan_count = 0`）

### 7.3 性能验收

- [ ] 资产余额查询 P99 < 50ms
- [ ] 抽奖接口 P99 < 500ms
- [ ] 背包查询 P99 < 200ms
- [ ] 数据库慢查询 0 条（> 1s）

---

## 八、监控指标

### 8.1 业务指标

```javascript
// 实时监控指标
const MONITORING_METRICS = {
  // 资产域健康度
  total_accounts: 'SELECT COUNT(*) FROM accounts WHERE account_type="user"',
  total_asset_balances: 'SELECT COUNT(*) FROM account_asset_balances',
  total_transactions: 'SELECT COUNT(*) FROM asset_transactions',

  // 数据一致性
  balance_consistency: `
    SELECT 
      a.user_id,
      b.available_amount AS balance_table,
      COALESCE(SUM(t.delta_amount), 0) AS transaction_sum,
      (b.available_amount - COALESCE(SUM(t.delta_amount), 0)) AS diff
    FROM accounts a
    JOIN account_asset_balances b ON b.account_id = a.account_id
    LEFT JOIN asset_transactions t ON t.account_id = a.account_id AND t.asset_code = b.asset_code
    WHERE b.asset_code = 'POINTS'
    GROUP BY a.user_id, b.available_amount
    HAVING ABS(diff) > 0.01
  `,

  // 冻结余额健康度（拍板决策：新增监控）
  frozen_balances_summary: `
    SELECT 
      asset_code,
      COUNT(*) AS accounts_with_frozen,
      SUM(frozen_amount) AS total_frozen
    FROM account_asset_balances
    WHERE frozen_amount > 0
    GROUP BY asset_code
  `,

  frozen_without_audit: `
    SELECT 
      b.account_id,
      a.user_id,
      b.asset_code,
      b.frozen_amount,
      b.updated_at
    FROM account_asset_balances b
    JOIN accounts a ON a.account_id = b.account_id
    WHERE b.frozen_amount > 0
      AND NOT EXISTS (
        SELECT 1 FROM asset_transactions t
        WHERE t.account_id = b.account_id
          AND t.asset_code = b.asset_code
          AND (t.business_type LIKE '%freeze%' 
               OR JSON_EXTRACT(t.meta, '$.freeze_amount') IS NOT NULL)
      )
  `,

  // 物品实例健康度
  total_items: 'SELECT COUNT(*) FROM item_instances',
  available_items: 'SELECT COUNT(*) FROM item_instances WHERE status="available"',
  locked_items_timeout: `
    SELECT COUNT(*) FROM item_instances 
    WHERE status='locked' AND TIMESTAMPDIFF(SECOND, locked_at, NOW()) > 180
  `,

  locked_items_orphan: `
    SELECT COUNT(*) FROM item_instances i
    WHERE i.status='locked'
      AND i.locked_by_order_id IS NOT NULL
      AND NOT EXISTS (
        SELECT 1 FROM redemption_orders r 
        WHERE r.order_id = i.locked_by_order_id AND r.status = 'pending'
      )
      AND NOT EXISTS (
        SELECT 1 FROM trade_orders t
        WHERE t.order_id = i.locked_by_order_id AND t.status = 'frozen'
      )
  `,

  // 商家审核健康度（拍板决策：新增监控）
  pending_reviews_timeout: `
    SELECT COUNT(*) FROM merchant_points_reviews
    WHERE status='pending' AND expires_at < NOW()
  `,

  frozen_reviews_need_admin: `
    SELECT COUNT(*) FROM merchant_points_reviews
    WHERE status IN ('rejected', 'expired')
  `
}
```

### 8.2 告警规则

```yaml
# Prometheus 告警规则
groups:
  - name: asset_domain_alerts
    rules:
      - alert: BalanceInconsistency
        expr: balance_consistency_diff_count > 0
        for: 5m
        labels:
          severity: critical
        annotations:
          summary: '资产余额不一致'
          description: '检测到 {{ $value }} 个账户余额与流水不一致'

      - alert: FrozenBalanceWithoutAudit
        expr: frozen_without_audit_count > 0
        for: 10m
        labels:
          severity: critical
        annotations:
          summary: '冻结余额无审计流水'
          description: '检测到 {{ $value }} 笔冻结余额无法追溯来源（违反归属约束）'

      - alert: LockedItemsTimeout
        expr: locked_items_timeout_count > 10
        for: 10m
        labels:
          severity: warning
        annotations:
          summary: '锁定物品超时'
          description: '{{ $value }} 个物品锁定超过3分钟未解锁'

      - alert: LockedItemsOrphan
        expr: locked_items_orphan_count > 5
        for: 15m
        labels:
          severity: warning
        annotations:
          summary: '孤儿锁定物品'
          description: '{{ $value }} 个物品锁定但无对应的 pending 订单'

      - alert: MerchantReviewsTimeout
        expr: pending_reviews_timeout_count > 0
        for: 30m
        labels:
          severity: warning
        annotations:
          summary: '商家审核超时'
          description: '{{ $value }} 个审核单超时未处理（积分仍冻结，需客服介入）'

      - alert: FrozenReviewsNeedAdmin
        expr: frozen_reviews_need_admin_count > 20
        for: 1h
        labels:
          severity: info
        annotations:
          summary: '审核拒绝/超时积分待处理'
          description: '{{ $value }} 个审核单需客服处理（解冻或作废）'

      - alert: HighTransactionFailureRate
        expr: rate(asset_transaction_failures[5m]) > 0.05
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: '资产变更失败率过高'
          description: '失败率 {{ $value | humanizePercentage }}'
```

---

## 九、FAQ

**Q1: 为什么不保留旧数据/旧接口？**

A: 保留旧系统会导致：

1. 双真相源永久存在，数据一致性无法保证
2. 维护成本翻倍（两套代码、两套测试、两套监控）
3. 新功能开发时需要同时适配两套系统
4. 技术债务永远无法清零

破坏性重构一次性解决问题，长期收益远大于短期阵痛。

**Q2: 前端怎么办？**

A: 前端必须同步改造：

- 旧接口 `/api/v4/lottery/user-points/:user_id` → 新接口 `/api/v4/assets/balances`
- 旧字段 `available_points` → 新字段 `assets[{asset_code: 'POINTS', available: ...}]`
- 一次性发布，不做兼容

**Q3: 如果线上出问题怎么办？**

A: 回滚方案：

1. 数据库备份（实施前全量备份）
2. 代码回滚（git reset）
3. 服务重启（pm2 restart）
4. 回滚时间 < 10分钟

**Q4: 业界大厂是怎么做的？**

A: 主流方案都是"账本+实例"双轨：

- **支付宝/微信支付**：账本表（余额）+ 流水表（不可变）+ 预授权冻结
- **游戏公司**：背包表（可叠加资产）+ 装备表（不可叠加实例）+ 交易锁定
- **电商平台**：积分账户表 + 积分流水表 + 优惠券实例表 + 订单冻结

你的架构设计完全符合业界标准。

**Q5: 两个业务都用"冻结"会不会搞混？（拍板决策）**

A: **不会混，只要做好归属约束**：

**冻结不是"状态"，而是"有归属的占用记录"**：

- 每笔冻结必须绑定业务单号（`merchant_review.review_id` 或 `trade_orders.order_id`）
- `business_type` 明确区分场景（`merchant_review_freeze` vs `order_freeze_buyer`）
- `idempotency_key` 防止重复冻结（`{review_id}:freeze` vs `{business_id}:freeze`）

**反例（当前库存在的问题）**：

- `account_asset_balances` 存在 `POINTS frozen_amount=3648`（user_id=31）
- 但 `asset_transactions` 中无任何冻结流水记录
- 属于"没有归属约束的脏冻结"，无法追溯来源，后续对账困难

**Q6: 商家审核拒绝/超时，积分为什么不退回？（拍板决策 - 商业模式核心）**

A: **业务规则拍板**：只要没审核通过就不可以增加到可用积分中

**商业逻辑**：

- 商家已经提供服务（扫码验证身份），用户承诺支付
- 审核拒绝/超时可能是恶意逃单或系统异常，不应自动退回
- 需要人工判断：是用户违约（作废）还是系统问题（退回）

**实现方式**：

- 审核拒绝：审核单状态改为 `rejected`，但**不执行解冻操作**
- 审核超时：审核单状态改为 `expired`，但**不执行解冻操作**
- 积分仍保持冻结状态（`frozen_amount` 不变）
- 冻结会无限期存在，接受用户资产长期不可用
- 需要客服/管理员手工决策（唯一出口）：
  - 解冻退回用户：`AssetService.unfreeze()` + 审核单改为 `cancelled`（用户无责/系统异常）
  - 从冻结作废：`AssetService.settleFromFrozen()` + 审核单改为 `cancelled`（用户违约/恶意逃单）

**超时兜底机制（拍板决策：仅告警，不自动解冻）**：

- 定时任务每小时扫描 `status='pending' AND expires_at < NOW()` 的审核单
- 自动推进状态到 `expired`（但**不解冻**）
- 发送告警通知客服处理（避免积分永久冻结无人知晓）
- 与交易市场不同：交易市场超时可以自动解冻（正常商业行为），商家审核超时不能自动解冻（需人工判断）

**Q7: "超时兜底"是什么意思？**

A: **兜底=最后保险，防止卡死状态**

不依赖"正常流程一定会走完"，而是加一个定时任务：

- 扫描超时的业务单（审核单超过24小时、物品锁超过3分钟）
- 自动推进到明确的终态（expired/unlocked）
- 根据业务规则决定是否自动解冻：
  - **商家审核**：仅推进状态 + 告警，**不自动解冻**（拍板决策）
  - **交易市场**：自动取消订单 + 解冻资产 + 解锁物品（可以自动解冻）

**为什么需要兜底**：

- 审核服务异常、网络断开、商家/客服离线 → 审核单永远 pending → 积分永久冻结
- 订单创建后系统崩溃 → 物品永远 locked → 用户无法使用/交易
- 兜底确保：即使正常流程断了，系统也能自愈或告警

---

## 十、总结

### 核心设计原则

1. **单一真相源**：`account_asset_balances`（余额）+ `item_instances`（物品）
2. **不可变流水**：`asset_transactions`（审计日志）+ `item_instance_events`（事件溯源）
3. **强制幂等**：`idempotency_key` 唯一约束（每条流水独立）
4. **事务安全**：所有变更必须在事务内执行
5. **破坏性重构**：不保留旧系统，一次性切换
6. **冻结归属约束**（拍板决策）：
   - 每笔冻结必须绑定业务单号（`review_id` / `order_id`）
   - `business_type` 明确区分场景（`merchant_review_freeze` / `order_freeze_buyer`）
   - `idempotency_key` 防止重复冻结（`{review_id}:freeze` / `{business_id}:freeze`）
   - 商家审核拒绝/超时：积分**不退回**（仍冻结，需客服处理）
   - 交易市场取消：资产**解冻退回**（frozen → available）

### 预期收益

**技术收益**：

- ✅ 消除双真相源，数据一致性100%保证
- ✅ 统一资产模型，代码复杂度降低50%
- ✅ 完整审计流水，满足合规要求
- ✅ 业界标准架构，易于扩展和维护

**业务收益**：

- ✅ 支持多种资产类型（积分/钻石/材料）
- ✅ 支持物品实例管理（优惠券/装备/商品）
- ✅ 幂等性保证，杜绝重复扣款/发奖
- ✅ 实时对账能力，财务风险可控

---

**实施时间**: 预计2小时（准备1h + 变更30min + 部署30min + 验证30min）  
**风险等级**: 中（有完整回滚方案）  
**长期收益**: 极高（彻底解决技术债务）

**核心理念**: 短期阵痛换取长期健康，破坏性重构建立业界标准架构。

---

## 十一、冻结/预占用设计总结（拍板决策）

### 冻结语义统一定义

**冻结 = 预占用 + 归属约束 + 可追溯审计**

- **预占用**：把资产从 `available` 转到 `frozen`（或物品从 `available` 转到 `locked`），防止用户在业务完成前再次使用
- **归属约束**：每笔冻结必须绑定业务单号（`review_id` / `order_id`），通过 `business_type` + `idempotency_key` 明确来源
- **可追溯审计**：所有冻结操作必须在 `asset_transactions` 中留下流水记录（包含 `meta.freeze_amount/frozen_before/frozen_after`）

### 两类冻结业务对比（拍板决策）

| 维度              | 商家审核冻结（商业模式核心）                     | 交易市场冻结                   |
| ----------------- | ------------------------------------------------ | ------------------------------ |
| **冻结对象**      | 用户积分（POINTS）                               | 买家资产（DIAMOND）+ 标的物品  |
| **触发时机**      | 商家扫码提交审核                                 | 买家下单购买挂牌               |
| **归属约束**      | `merchant_review.review_id`                      | `trade_orders.order_id`        |
| **业务类型**      | `merchant_review_freeze`                         | `order_freeze_buyer`           |
| **幂等键格式**    | `{review_id}:freeze`                             | `{business_id}:freeze`         |
| **审核通过/成交** | 从冻结结算（frozen ↓）                           | 从冻结结算（frozen ↓）         |
| **审核拒绝**      | **不退回**（仍冻结，需客服处理）                 | 解冻退回（frozen → available） |
| **超时处理**      | 推进到 `expired`，**不解冻**，告警客服           | 自动取消并解冻                 |
| **兜底任务**      | 每小时扫描超时审核单并告警（**仅告警，不解冻**） | 每日释放超时锁定物品并解冻资产 |
| **客服出口**      | 手工解冻或作废（唯一出口）                       | 无需客服（自动解冻）           |
| **冻结期限**      | 无限期（直到客服处理）                           | 最长3分钟（自动解锁）          |

### 为什么两个业务的"拒绝/超时"处理不同？（拍板决策）

**商家审核**（商业模式核心）：

- **业务语义**：商家已经提供服务（扫码验证身份），用户承诺支付
- **拒绝/超时**：可能是恶意逃单或系统异常，不应自动退回
- **需要人工判断**：是用户违约（作废）还是系统问题（退回）
- **拍板决策**：
  - 审核拒绝：积分不退回（仍冻结）
  - 审核超时：积分不退回（仍冻结）
  - 超时兜底：仅推进状态到 `expired` 并告警，**不自动解冻**
  - 唯一出口：客服手工处理（解冻或作废）
  - 冻结期限：无限期（直到客服处理）
- **核心原则**：只要没审核通过就不可以增加到可用积分中

**交易市场**：

- **业务语义**：买卖双方在线交易，取消是正常商业行为
- **拒绝/超时**：买家改变主意或支付超时，应退回资产
- **自动解冻**：符合电商/交易市场惯例
- **拍板决策**：
  - 订单取消：自动解冻资产 + 解锁物品
  - 订单超时：自动取消并解冻
  - 超时兜底：定时任务自动释放（3分钟超时）
  - 无需客服：系统自动处理

### 强制规范（防止冻结混乱）

**禁止行为**：

- ❌ 直接修改 `account_asset_balances.frozen_amount`（绕过流水审计）
- ❌ 冻结操作不记录 `asset_transactions`（无法追溯）
- ❌ 冻结流水缺少 `meta.freeze_amount/frozen_before/frozen_after`（无法对账）
- ❌ 冻结操作不绑定业务单号（无法判断归属）

**强制要求**：

- ✅ 所有冻结必须通过 `AssetService.freeze()`（统一入口）
- ✅ 所有冻结必须记录流水（`asset_transactions` + `meta` 完整）
- ✅ 所有冻结必须有归属约束（`business_type` + 业务单号 + `idempotency_key`）
- ✅ 所有冻结必须有出口（解冻/结算/客服处理）

**当前库存在的问题（需修复）**：

- `POINTS frozen_amount=3648`（user_id=31）无对应冻结流水 → 违反归属约束，无法追溯来源
- `item_instances` 6条 locked 全部超时（超过3分钟） → 超时兜底未生效
- 其中4条能匹配到 `redemption_orders.status='pending'`，2条是孤儿锁（无对应订单）
- 建议：先清理脏数据（手工解锁孤儿锁 + 确认 POINTS 冻结来源），再上线新流程

**清理脚本（不自动执行，需人工确认）**：

```sql
-- 1. 释放孤儿锁（无对应订单的 locked 物品）
UPDATE item_instances
SET status = 'available', locked_by_order_id = NULL, locked_at = NULL
WHERE status = 'locked'
  AND locked_by_order_id NOT IN (
    SELECT order_id FROM redemption_orders WHERE status = 'pending'
    UNION
    SELECT order_id FROM trade_orders WHERE status = 'frozen'
  );

-- 2. 释放超时锁（locked_at 超过3分钟且订单仍 pending）
UPDATE item_instances
SET status = 'available', locked_by_order_id = NULL, locked_at = NULL
WHERE status = 'locked'
  AND TIMESTAMPDIFF(SECOND, locked_at, NOW()) > 180;

-- 3. 确认 POINTS 冻结来源（需人工判断）
-- 查询：account_id=5, user_id=31, frozen_amount=3648
-- 如果无法追溯来源，需要决定：
--   - 选项1：归零（UPDATE account_asset_balances SET frozen_amount=0 WHERE balance_id=29）
--   - 选项2：转为可用（UPDATE account_asset_balances SET available_amount=available_amount+3648, frozen_amount=0 WHERE balance_id=29）
--   - 选项3：保留冻结，补充审计流水（创建对应的 merchant_review 和 asset_transaction 记录）
```
