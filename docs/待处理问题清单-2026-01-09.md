# 待处理问题清单

**生成时间**：2026年01月09日  
**项目版本**：V4.0.0  
**文档目的**：记录当前代码现状中需要处理的技术债务和优化项  
**优先级定义**：P0（强一致/安全/会导致业务风险）> P1（架构一致性/可维护性）> P2（规范/一致性/长期技术债）

---

## P0级问题（强一致/安全/会导致业务风险）

### 1. 测试代码仍存在"硬编码真实用户ID/活动ID"

**问题位置**：

- `tests/helpers/test-setup.js` 第285-302行

**问题现状**：

```javascript
// ❌ 当前硬编码方式
realData: {
  testUser: {
    mobile: '13612227930',
    user_id: 31  // 硬编码用户ID
  },
  adminUser: {
    mobile: '13612227930',
    user_id: 31  // 硬编码管理员ID
  },
  testCampaign: {
    campaign_id: 2,  // 硬编码活动ID
    campaignName: '餐厅积分抽奖活动'
  }
}
```

**业务风险**：

- 换库/数据变动会导致测试不稳定
- 不符合"测试数据不硬编码、以真实数据驱动"的要求
- 如果 `user_id: 31` 在新环境不存在，所有测试会静默失败或出现误导性错误

**解决方案**：
测试启动时用 Node.js + Sequelize 从真实库按手机号 `13612227930` 查询 `user_id`，并按业务规则查找可用活动/默认活动

**实施步骤**：

1. 在 `tests/helpers/test-setup.js` 中添加 `async function loadRealTestData()`
2. 使用 Sequelize 查询：
   ```javascript
   const user = await User.findOne({ where: { mobile: '13612227930' } })
   if (!user) {
     throw new Error('测试用户不存在，请在数据库中创建手机号为 13612227930 的用户')
   }
   ```
3. 查找默认活动（按业务规则，如状态为 active 的第一个活动）
4. 在 `jest.setup.js` 中调用 `loadRealTestData()` 并将结果存储到 `global.testData`
5. 所有测试文件从 `global.testData` 获取测试用户ID和活动ID

**预期效果**：

- 测试数据完全由真实数据库驱动
- 换库/迁移环境时，只要数据存在就能正常测试
- 数据不存在时，明确报错提示需要补数据

---

### 2. 审计日志"target_type"命名不统一（存在业务表名/模型名混用）

**问题位置**：

- `services/AuditLogService.js` 多处方法中的 `target_type` 字段

**问题现状**：

```javascript
// ❌ 混用模型名（PascalCase）和表名风格
target_type: 'AssetTransaction' // 模型名风格
target_type: 'ExchangeRecord' // 模型名风格
target_type: 'transaction_record' // 表名风格（snake_case）
target_type: 'User' // 模型名风格
```

**业务风险**：

- 审计查询/统计难统一（需要同时查 `AssetTransaction` 和 `asset_transaction`）
- 长期会变成"字段看不懂、难做报表"
- 前端展示时需要额外的映射逻辑

**解决方案**：
统一为**业务表级别 snake_case**（例如 `asset_transaction`、`exchange_record`），并在 `AuditLogService` 内集中映射/校验

**实施步骤**：

1. 在 `constants/AuditOperationTypes.js` 中定义标准 `TARGET_TYPE_MAPPING`：

   ```javascript
   const TARGET_TYPE_MAPPING = {
     User: 'user',
     AssetTransaction: 'asset_transaction',
     ExchangeRecord: 'exchange_record',
     ItemInstance: 'item_instance',
     ConsumptionRecord: 'consumption_record'
     // ... 其他映射
   }
   ```

2. 在 `AuditLogService.logOperation()` 中添加自动转换：

   ```javascript
   const normalizedTargetType = TARGET_TYPE_MAPPING[target_type] || target_type.toLowerCase()
   ```

3. 全局搜索并替换所有 `AuditLogService` 调用中的 `target_type`：

   ```bash
   grep -r "target_type:" services/ routes/ | grep -E "(AssetTransaction|ExchangeRecord|ItemInstance)"
   ```

4. 数据库迁移：更新现有审计日志中的 `target_type` 值：

   ```sql
   UPDATE admin_operation_logs SET target_type = 'asset_transaction' WHERE target_type = 'AssetTransaction';
   UPDATE admin_operation_logs SET target_type = 'exchange_record' WHERE target_type = 'ExchangeRecord';
   -- ... 其他表名
   ```

5. 添加单元测试验证所有 `target_type` 都符合 snake_case 规范

**预期效果**：

- 审计日志 `target_type` 字段完全统一为 snake_case
- 查询/统计/报表不再需要处理多种命名风格
- 新增审计类型时，强制通过映射表规范命名

---

## P1级问题（架构一致性/可维护性）

### 3. ESLint 仍有 87 个 warnings

**问题现状**：

```bash
✖ 87 problems (0 errors, 87 warnings)
```

**警告类型分布**：

- `no-unused-vars`：约10个（测试文件中的未使用变量）
- `no-await-in-loop`：约60个（循环中的 await，部分合理部分可优化）
- `no-restricted-syntax`：约10个（事务边界告警，业务一致性问题）
- 其他：约7个

**业务风险**：

- 噪声过大，真实问题容易被淹没
- 部分规则（事务边界提示）本质是质量门槛，忽略会导致数据不一致

**解决方案**：
分批清理，优先顺序：no-unused-vars → 事务边界告警 → no-await-in-loop

**实施步骤**：

#### 第一批：清理 no-unused-vars（预计减少10个警告）

```bash
# 1. 查找所有未使用变量
npm run lint 2>&1 | grep "no-unused-vars"

# 2. 逐个修复（删除或改为 _variableName）
# 示例：
# - tests/business/asset/phase3_migration.test.js:13 'sequelize' 未使用 → 删除
# - tests/business/auth/api.test.js:25 'test_user_id' 未使用 → 删除或使用
```

#### 第二批：核查事务边界告警（预计修复5-10个真实问题）

```bash
# 1. 查找所有事务边界告警
npm run lint 2>&1 | grep "no-restricted-syntax" | grep "事务边界"

# 2. 逐个核查是否真的缺 transaction
# 示例：routes/v4/console/asset-adjustment.js:2070
# - 检查 AssetService.changeBalance() 调用是否在事务内
# - 如果缺失，补充 { transaction } 参数
# - 如果确认不需要，添加 eslint-disable-next-line 并注释说明原因
```

#### 第三批：优化 no-await-in-loop（仅优化可并行的场景）

```bash
# 1. 查找所有 no-await-in-loop
npm run lint 2>&1 | grep "no-await-in-loop"

# 2. 分类处理：
# - 可并行：改为 Promise.all()
#   例如：批量查询用户信息
#   const users = await Promise.all(userIds.map(id => User.findByPk(id)))
#
# - 必须串行：保留并添加注释 + eslint-disable
#   例如：顺序执行的业务流程（发奖 → 扣库存 → 记录日志）
#   // eslint-disable-next-line no-await-in-loop -- 业务要求顺序执行
```

**预期效果**：

- 第一批完成后：87 → 77 warnings
- 第二批完成后：77 → 67 warnings（并修复潜在的事务一致性问题）
- 第三批完成后：67 → 30-40 warnings（剩余的都是合理的串行逻辑）

---

### 4. 服务获取方式未完全统一（仍有路由/服务直接 require Service 的情况）

**问题位置**：

- `routes/v4/console/marketplace.js` 第455行

**问题现状**：

```javascript
// ❌ 直接 require Service
const MarketListingService = require('../../../services/MarketListingService')

// ✅ 其他地方已统一使用 ServiceManager
const ExchangeService = req.app.locals.services.getService('exchangeMarket')
```

**业务风险**：

- 违背"路由通过 ServiceManager 获取 Service"的架构约束
- 后续依赖会越来越乱，难以追踪服务调用关系
- 无法统一管理服务生命周期（如热重载、依赖注入）

**解决方案**：
把 `MarketListingService` 纳入 `ServiceManager` 注册，并在路由改为 `req.app.locals.services.getService(...)`

**实施步骤**：

1. 检查 `MarketListingService` 是否已在 `ServiceManager` 注册：

   ```bash
   grep -r "MarketListingService" utils/ServiceManager.js app.js
   ```

2. 如果未注册，在 `app.js` 或 `utils/ServiceManager.js` 中添加注册：

   ```javascript
   // app.js 中的服务注册部分
   const MarketListingService = require('./services/MarketListingService')
   serviceManager.registerService('marketListing', MarketListingService)
   ```

3. 修改 `routes/v4/console/marketplace.js`：

   ```javascript
   // 删除直接 require
   - const MarketListingService = require('../../../services/MarketListingService')

   // 改为通过 ServiceManager 获取
   + const MarketListingService = req.app.locals.services.getService('marketListing')
   ```

4. 全局搜索其他直接 require Service 的情况：

   ```bash
   grep -r "require.*Service\.js" routes/ | grep -v "ServiceManager"
   ```

5. 逐个修改为统一的 ServiceManager 获取方式

**预期效果**：

- 所有路由统一通过 `ServiceManager` 获取服务
- 服务依赖关系清晰可追踪
- 为后续服务层优化（如依赖注入、AOP）打下基础

---

## P2级问题（规范/一致性/长期技术债）

### 5. 测试环境配置加载链路需要进一步统一

**问题位置**：

- `jest.setup.js` 第13行：`require('dotenv').config()`
- `tests/helpers/test-setup.js` 第9-11行：备用 dotenv 加载逻辑

**问题现状**：

```javascript
// jest.setup.js
require('dotenv').config() // 主入口

// tests/helpers/test-setup.js
if (!process.env.DB_HOST) {
  require('dotenv').config() // 备用入口
}
```

**业务风险**：

- 未来容易出现"谁覆盖谁"的误解
- 调试时难以确定配置来源
- 可能导致测试环境与开发环境配置不一致

**解决方案**：
明确唯一入口（只在 `jest.setup.js` 加载 dotenv），`tests/helpers/test-setup.js` 只做断言工具与非敏感兜底

**实施步骤**：

1. 修改 `tests/helpers/test-setup.js`，移除 dotenv 加载逻辑：

   ```javascript
   // 删除备用加载逻辑
   - if (!process.env.DB_HOST) {
   -   require('dotenv').config()
   - }

   // 添加明确的注释说明
   + /**
   +  * 注意：环境变量由 jest.setup.js 统一加载
   +  * 此文件仅提供测试工具类和非敏感配置兜底
   +  */
   ```

2. 在 `jest.setup.js` 顶部添加注释说明：

   ```javascript
   /**
    * Jest测试环境设置 - 唯一配置入口
    *
    * 职责：
    * 1. 从 .env 加载所有环境变量（单一真相源）
    * 2. 设置测试专用配置（NODE_ENV、超时时间等）
    * 3. 提供非敏感配置的兜底值
    *
    * ⚠️ 其他测试文件不应再加载 dotenv
    */
   require('dotenv').config()
   ```

3. 添加环境变量加载验证：
   ```javascript
   // jest.setup.js 末尾添加
   if (!process.env.DB_HOST || !process.env.DB_NAME) {
     console.error('❌ 环境变量加载失败，请检查 .env 文件是否存在')
     process.exit(1)
   }
   ```

**预期效果**：

- 配置加载链路清晰：`.env` → `jest.setup.js` → 所有测试
- 避免多处加载导致的配置覆盖问题
- 配置缺失时能立即发现并报错

---

### 6. 健康检查返回字段与解析脚本不一致

**问题位置**：

- `/health` 接口返回的数据结构
- 各处健康检查解析脚本

**问题现状**：

```javascript
// 实际返回结构
{
  "data": {
    "status": "healthy",
    "systems": {
      "database": "connected",
      "redis": "connected"
    }
  }
}

// 脚本尝试解析的结构（错误）
checks.database.status  // 实际不存在
checks.redis.status     // 实际不存在
```

**业务风险**：

- 运维脚本/监控误判（显示 unknown）
- CI/CD 流程中的健康检查可能失效
- 告警系统无法正确识别服务状态

**解决方案**：
统一健康检查响应契约，或同步更新所有解析脚本（只保留一种，不做兼容两套）

**实施步骤**：

#### 方案A：修改解析脚本（推荐，不改接口）

```bash
# 1. 查找所有健康检查解析脚本
grep -r "checks.database" scripts/ docs/ .github/

# 2. 统一修改为正确的解析路径
# 旧：d.get('checks',{}).get('database',{}).get('status','unknown')
# 新：d.get('data',{}).get('systems',{}).get('database','unknown')
```

#### 方案B：修改接口响应（如果团队约定需要 checks 字段）

```javascript
// routes/v4/system.js 中的 /health 接口
return res.apiSuccess({
  status: 'healthy',
  systems: { database: 'connected', redis: 'connected' },
  // 添加 checks 字段以兼容旧脚本
  checks: {
    database: { status: 'connected' },
    redis: { status: 'connected' }
  }
})
```

**实施建议**：

- 优先采用方案A（修改脚本），保持接口简洁
- 如果外部系统依赖旧格式，则采用方案B（同时返回两种格式）
- 无论哪种方案，都要在文档中明确健康检查响应契约

**预期效果**：

- 健康检查解析脚本能正确识别服务状态
- 运维监控/告警系统正常工作
- 响应格式统一，便于对接外部系统

---

## 实施计划

### 优先级与时间估算

| 优先级 | 问题编号 | 问题描述               | 预计工时 | 依赖关系       |
| ------ | -------- | ---------------------- | -------- | -------------- |
| P0     | 1        | 测试数据硬编码         | 2小时    | 无             |
| P0     | 2        | target_type 命名不统一 | 3小时    | 需要数据库迁移 |
| P1     | 3        | ESLint warnings 清理   | 4小时    | 分三批进行     |
| P1     | 4        | 服务获取方式统一       | 1小时    | 无             |
| P2     | 5        | 测试配置加载统一       | 0.5小时  | 无             |
| P2     | 6        | 健康检查响应统一       | 0.5小时  | 无             |

**总计**：约11小时

### 实施顺序建议

**第一阶段（P0问题，2天内完成）**：

1. 问题1：测试数据硬编码 → 测试数据驱动
2. 问题2：target_type 统一 → 审计日志规范化

**第二阶段（P1问题，3天内完成）**：3. 问题4：服务获取统一 → 架构一致性 4. 问题3：ESLint warnings 清理（分批进行）

**第三阶段（P2问题，1天内完成）**：5. 问题5：测试配置统一6. 问题6：健康检查统一

---

## 质量检查标准

每完成一项问题修复后，必须通过以下检查：

### 代码质量检查

```bash
npm run lint
# 预期：0 errors，warnings 逐步减少
```

### 功能测试

```bash
npm test
# 预期：所有测试通过，无新增失败
```

### 健康检查

```bash
curl -s http://localhost:3000/health | python3 -m json.tool
# 预期：status = healthy，database/redis = connected
```

### 服务运行检查

```bash
npm run pm:status
# 预期：PM2 显示 online 状态
```

---

## 附录

### 相关文档

- `docs/审计统一入口整合方案-2026-01-08.md` - 审计日志规范
- `docs/Devbox单环境统一配置方案.md` - 环境配置规范
- `.cursor/rules/` - 项目开发规范

### 联系方式

- 如有疑问，请联系项目负责人
- 问题追踪：在本文档对应位置添加实施记录

---

**文档状态**：待实施  
**下次更新**：完成 P0 问题后更新实施记录
