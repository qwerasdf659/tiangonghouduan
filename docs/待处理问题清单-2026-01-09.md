# 待处理问题清单

**生成时间**：2026年01月09日  
**项目版本**：V4.0.0  
**文档目的**：记录当前代码现状中需要处理的技术债务和优化项  
**优先级定义**：

- **P0**：影响资产安全/数据一致性/用户体验的关键问题
- **P1**：架构一致性/可维护性问题
- **P2**：规范/一致性/长期技术债

---

## P0级问题（资产安全/数据一致性/用户体验）

### 1. 兑换接口幂等跨版本冲突风险（方案B - canonical 化）

**问题位置**：

- `services/IdempotencyService.js` 幂等指纹生成逻辑
- `routes/v4/shop/exchange/exchange.js` 兑换下单接口
- `api_idempotency_requests` 表历史数据

**问题现状**：

当前幂等系统按 `idempotency_key` 唯一查找，但 `request_hash` 指纹里包含 `api_path`，导致同一幂等键跨路径（旧/新版本）会被判定为"参数不同"直接 409：

```javascript
// services/IdempotencyService.js:137-159
static generateRequestFingerprint(context) {
  const { user_id, http_method, api_path, query, body } = context

  // 问题：api_path 包含在指纹中
  const canonical = {
    user_id,
    method: http_method,
    path: normalized_path,  // ❌ 路径变更会导致指纹变化
    query: query || {},
    body: body_filtered
  }

  return crypto.createHash('sha256').update(sortedJson).digest('hex')
}
```

**真实库数据现状**（2026-01-08 直连查询结果）：

```sql
-- 兑换接口跨版本分裂
SELECT api_path, status, COUNT(*) as cnt,
       SUM(CASE WHEN expires_at > NOW() THEN 1 ELSE 0 END) as unexpired_cnt
FROM api_idempotency_requests
WHERE api_path IN ('/api/v4/exchange_market/exchange', '/api/v4/shop/exchange/exchange')
GROUP BY api_path, status;

-- 结果：
-- 旧路径 /api/v4/exchange_market/exchange: 414条（270 completed / 144 failed），全部未过期
-- 新路径 /api/v4/shop/exchange/exchange: 12条（8 completed / 4 failed），全部未过期
-- TTL=7天，跨版本重试 409 风险持续到旧记录过期为止
```

**业务风险**：

- **资产类操作 409 风险**：用户先用旧路径下单、后用新路径重试时，会因 `request_hash` 不匹配而 409，导致"以为失败→重复下单→疑似重复扣款"的投诉
- **移动端弱网 + TTL=7天**：灰度/多端混跑、客户端缓存、代理兼容导致"同一业务动作走不同 URL"是常态，不是偶发
- **未来路径迁移必然复发**：每次路由重构（拆分、重命名、版本迁移）都会触发同样问题

**解决方案（方案B - canonical 化 + alias 映射）**：

把幂等语义从 URL 解耦，使用稳定的 `canonical_operation` 作为幂等作用域，通过白名单 alias 映射保证跨版本兼容。

**核心原则**：

1. **稳定作用域**：幂等指纹里用 `canonical_operation`（如 `SHOP_EXCHANGE_CREATE_ORDER`），而不是 `api_path`
2. **全量覆盖（已拍板）**：把所有写接口都纳入 `canonical_operation` 体系（一次性更彻底）
3. **仍保持严格 409**：同一 `idempotency_key` 如果落到不同 `canonical_operation`，仍然 409

**已拍板决策**（2026-01-09 最终确认）：

- ✅ **技术路线**：上 canonical_operation（幂等语义从 URL 解耦，长期稳定）
- ✅ **兼容策略**：强制不兼容（算法迁移不做兼容窗口，简洁优先）
- ✅ **覆盖范围**：把所有写接口（POST/PUT/DELETE）都纳入 canonical 体系，不仅限于兑换下单
- ✅ **数据写回策略**：不写回（零数据改写风险，只回放结果）
- ✅ **旧路径处理**：确保功能正常后强制删除旧路径（代码 + 数据都删）
- ✅ **落地方式**：显式 operation（所有写接口必须显式提供 canonical_operation，禁止依赖 URL 推导）

**实施步骤**：

**⚠️ 前置条件**（2026-01-09 拍板确认）：

- 确保新路径功能完全正常（测试/验证通过）
- 算法迁移采用强制不兼容策略（不做兼容窗口，简洁优先）
- 旧路径删除策略：代码删除 → 验证功能 → 数据清理（三步走）

1. 在 `services/IdempotencyService.js` 添加 canonical 映射配置（全量覆盖所有写接口，已拍板：显式 operation）：

   ```javascript
   // 业务操作 canonical 映射表（全量覆盖所有写接口）
   // 【已拍板决策】：显式 operation，禁止依赖 URL 推导
   const CANONICAL_OPERATION_MAP = {
     // ===== B2C 兑换下单 =====
     '/api/v4/exchange_market/exchange': 'SHOP_EXCHANGE_CREATE_ORDER',
     '/api/v4/shop/exchange/exchange': 'SHOP_EXCHANGE_CREATE_ORDER',

     // ===== 材料转换 =====
     '/api/v4/assets/convert': 'SHOP_ASSET_CONVERT',
     '/api/v4/shop/assets/convert': 'SHOP_ASSET_CONVERT',

     // ===== 抽奖 =====
     '/api/v4/lottery/draw': 'LOTTERY_DRAW',

     // ===== C2C 市场交易 =====
     '/api/v4/market/listings': 'MARKET_CREATE_LISTING',
     '/api/v4/market/listings/:id/purchase': 'MARKET_PURCHASE_LISTING',
     '/api/v4/market/listings/:id/cancel': 'MARKET_CANCEL_LISTING',

     // ===== 核销系统 =====
     '/api/v4/shop/redemption/orders': 'REDEMPTION_CREATE_ORDER',
     '/api/v4/shop/redemption/fulfill': 'REDEMPTION_FULFILL',

     // ===== 消费记录 =====
     '/api/v4/shop/consumption/submit': 'CONSUMPTION_SUBMIT',

     // ===== 管理员操作 =====
     '/api/v4/console/asset-adjustment/adjust': 'ADMIN_ASSET_ADJUST',
     '/api/v4/console/marketplace/force-withdraw': 'ADMIN_FORCE_WITHDRAW',

     // 未来新增写接口在此添加映射（必须显式定义）
   }

   /**
    * 获取 API 路径的 canonical operation
    *
    * 【已拍板决策】：显式 operation，禁止依赖 URL 推导
    * - 所有写接口必须在 CANONICAL_OPERATION_MAP 中显式定义
    * - 未定义的路径使用原路径（保持严格，避免误放行）
    *
    * @param {string} api_path - API路径
    * @returns {string} canonical operation 或原路径
    */
   static getCanonicalOperation(api_path) {
     const canonical = CANONICAL_OPERATION_MAP[api_path]

     if (!canonical) {
       // 未定义的路径，记录告警（便于发现遗漏）
       logger.warn('未定义 canonical operation 的写接口', {
         api_path,
         hint: '如果这是新增写接口，需要在 CANONICAL_OPERATION_MAP 中显式定义'
       })
     }

     return canonical || api_path
   }
   ```

2. 修改指纹生成逻辑，使用 canonical operation（已拍板：显式 operation + 强制不兼容）：

   ```javascript
   /**
    * 生成请求指纹（用于检测参数冲突）
    * 【已拍板决策 2026-01-09】
    * - 使用 canonical operation 替代 api_path
    * - 强制不兼容策略：不做旧算法兼容，简洁优先
    * - 旧路径记录在迁移前会自然过期（TTL=7天）或手动清理
    *
    * @param {Object} context - 请求上下文
    * @param {number} context.user_id - 用户ID
    * @param {string} context.http_method - HTTP方法
    * @param {string} context.api_path - API路径
    * @param {Object} context.query - 查询参数
    * @param {Object} context.body - 请求体
    * @returns {string} SHA-256哈希值
    */
   static generateRequestFingerprint(context) {
     const { user_id, http_method, api_path, query, body } = context

     // ✅ 使用 canonical operation 替代原始路径（已拍板）
     const canonical_operation = this.getCanonicalOperation(api_path)

     const body_filtered = this.filterBodyForFingerprint(body)

     // 构建规范化的 canonical 对象
     const canonical = {
       user_id,
       method: http_method,
       operation: canonical_operation,  // ✅ 稳定的业务操作标识（替代 path）
       query: query || {},
       body: body_filtered
     }

     const sortedCanonical = this.deepSortObject(canonical)
     const sortedJson = JSON.stringify(sortedCanonical)

     return crypto.createHash('sha256').update(sortedJson).digest('hex')
   }
   ```

   **⚠️ 强制不兼容说明**（2026-01-09 拍板）：
   - 算法改动后，旧幂等记录（使用旧算法写入的 request_hash）会全部失效
   - 不做双算比对/版本字段兼容（简洁优先）
   - 迁移前确保旧路径幂等记录已过期（TTL=7天）或手动清理
   - 迁移后短期可能出现"相同幂等键不同参数"的 409（预期行为，客户端重新生成幂等键即可）

3. 修改 `getOrCreateRequest` 方法，支持跨路径查找（已拍板决策：不写回，只回放）：

   ```javascript
   static async getOrCreateRequest(idempotency_key, request_data) {
     const { ApiIdempotencyRequest } = require('../models')
     const { api_path, http_method = 'POST', request_params, query, user_id } = request_data

     // 生成新指纹（使用 canonical operation）
     const request_hash = this.generateRequestFingerprint({
       user_id, http_method, api_path, query, body: request_params
     })

     const transaction = await sequelize.transaction()

     try {
       // 查找已存在的请求
       const existingRequest = await ApiIdempotencyRequest.findOne({
         where: { idempotency_key },
         lock: transaction.LOCK.UPDATE,
         transaction
       })

       if (existingRequest) {
         // ✅ 检查是否为同类操作（通过 canonical operation）
         const existing_canonical = this.getCanonicalOperation(existingRequest.api_path)
         const current_canonical = this.getCanonicalOperation(api_path)

         // 如果是同类操作但路径不同，允许回放
         if (existing_canonical === current_canonical) {
           logger.info('🔄 检测到同类操作跨路径重试', {
             idempotency_key,
             old_path: existingRequest.api_path,
             new_path: api_path,
             canonical_operation: current_canonical,
             decision: '不写回，只回放结果'  // ✅ 已拍板决策
           })

           // ❌ 不写回更新记录（已拍板决策）
           // 原因：
           // 1. 零数据改写风险
           // 2. 保留审计真实性（记录首次请求的真实路径）
           // 3. 避免线上数据改写争议
           // 4. 旧路径记录会在 TTL 后自然过期

           // 参数一致性检查（使用新指纹）
           if (existingRequest.request_hash !== request_hash) {
             await transaction.rollback()
             const error = new Error(
               '幂等键冲突：相同的 idempotency_key 但参数不同。' +
               '请使用不同的幂等键或确认请求参数正确。'
             )
             error.statusCode = 409
             error.errorCode = 'IDEMPOTENCY_KEY_CONFLICT'
             throw error
           }

           // 状态检查和回放逻辑（与原逻辑相同）
           if (existingRequest.status === 'completed') {
             await transaction.commit()
             logger.info('🔄 入口幂等拦截：请求已完成，返回首次结果', {
               idempotency_key, user_id, api_path
             })
             return {
               is_new: false,
               request: existingRequest,
               should_process: false,
               response: existingRequest.response_snapshot
             }
           }
           // ... 其他状态处理逻辑
         } else {
           // 不同操作，严格 409
           await transaction.rollback()
           const error = new Error(
             `幂等键冲突：该幂等键已用于不同的操作。` +
             `已有操作：${existing_canonical}，当前操作：${current_canonical}`
           )
           error.statusCode = 409
           error.errorCode = 'IDEMPOTENCY_KEY_CONFLICT_DIFFERENT_OPERATION'
           throw error
         }
       }

       // 创建新记录逻辑（保持不变）
       // ...
     } catch (error) {
       if (!transaction.finished) {
         await transaction.rollback()
       }
       throw error
     }
   }
   ```

4. 添加 canonical 映射验证脚本（已拍板：显式 operation，强制检查）：

   ```javascript
   // scripts/validation/check-canonical-operation-mapping.js
   const { IdempotencyService } = require('../../services/IdempotencyService')
   const { sequelize } = require('../../config/database')
   const logger = require('../../utils/logger').logger

   async function checkCanonicalMapping() {
     console.log('🔍 检查 canonical operation 映射一致性...')

     // 1. 查询所有幂等记录的路径
     const [paths] = await sequelize.query(
       `SELECT DISTINCT api_path, COUNT(*) as count
        FROM api_idempotency_requests
        WHERE api_path LIKE '/api/v4/%'
        GROUP BY api_path
        ORDER BY count DESC`
     )

     console.log(`📊 发现 ${paths.length} 个不同的 API 路径`)

     // 2. 【强制检查】所有写操作路径必须有显式映射
     const writePaths = paths.filter(p => {
       const path = p.api_path
       // 排除查询类接口（GET /orders, GET /items 等）
       return !path.includes('/orders') || !path.includes('/items') || !path.includes('/statistics')
     })

     const unmappedPaths = []
     const mappedPaths = []

     writePaths.forEach(({ api_path, count }) => {
       const canonical = IdempotencyService.getCanonicalOperation(api_path)

       if (canonical === api_path) {
         // 未映射（使用原路径）- 违反显式 operation 规范
         unmappedPaths.push({ api_path, count })
       } else {
         // 已映射
         mappedPaths.push({ api_path, canonical, count })
         console.log(`✅ ${api_path} → ${canonical} (${count}条记录)`)
       }
     })

     // 【强制规范】未映射的写操作路径视为违规
     if (unmappedPaths.length > 0) {
       console.error('❌ 发现未映射的写操作路径（违反显式 operation 规范）:')
       unmappedPaths.forEach(({ api_path, count }) => {
         console.error(`   ${api_path}: ${count}条记录`)
       })
       console.error('\n⚠️ 强制规范：所有写接口必须在 CANONICAL_OPERATION_MAP 中显式定义')
       console.error('   请在 services/IdempotencyService.js 中添加映射')
       process.exit(1)
     }

     // 3. 检查同一 canonical 下是否有跨路径记录
     const canonicalGroups = new Map()
     mappedPaths.forEach(({ api_path, canonical, count }) => {
       if (!canonicalGroups.has(canonical)) {
         canonicalGroups.set(canonical, [])
       }
       canonicalGroups.get(canonical).push({ api_path, count })
     })

     console.log('\n📊 Canonical Operation 分组:')
     canonicalGroups.forEach((paths, canonical) => {
       if (paths.length > 1) {
         console.log(`   ${canonical}:`)
         paths.forEach(({ api_path, count }) => {
           console.log(`     - ${api_path}: ${count}条记录`)
         })
       }
     })

     console.log('\n✅ canonical operation 映射检查完成')
     console.log(`   已映射: ${mappedPaths.length}个路径`)
     console.log(`   未映射: ${unmappedPaths.length}个路径`)
   }

   checkCanonicalMapping().catch(console.error)
   ```

5. 添加单元测试验证跨路径幂等（已拍板：显式 operation）：

   ```javascript
   // tests/services/IdempotencyService.canonical.test.js
   describe('IdempotencyService - Canonical Operation（已拍板：显式 operation）', () => {
     test('同一幂等键跨路径（同类操作）应返回首次结果', async () => {
       const idempotency_key = 'test_cross_path_' + Date.now()
       const user_id = 1
       const params = { item_id: 100, quantity: 1 }

       // 1. 首次请求（旧路径）
       const result1 = await IdempotencyService.getOrCreateRequest(idempotency_key, {
         api_path: '/api/v4/exchange_market/exchange',
         http_method: 'POST',
         request_params: params,
         user_id
       })

       expect(result1.should_process).toBe(true)

       // 标记完成
       await IdempotencyService.markAsCompleted(idempotency_key, 'order_123', {
         order_no: 'order_123',
         status: 'completed'
       })

       // 2. 重试请求（新路径，相同参数）
       const result2 = await IdempotencyService.getOrCreateRequest(idempotency_key, {
         api_path: '/api/v4/shop/exchange/exchange', // ✅ 不同路径
         http_method: 'POST',
         request_params: params, // ✅ 相同参数
         user_id
       })

       // 应该返回首次结果，而不是 409
       expect(result2.should_process).toBe(false)
       expect(result2.response.order_no).toBe('order_123')

       // ✅ 验证：不写回更新旧记录（已拍板决策）
       const originalRecord = await ApiIdempotencyRequest.findOne({
         where: { idempotency_key }
       })
       expect(originalRecord.api_path).toBe('/api/v4/exchange_market/exchange') // 保持原路径
     })

     test('同一幂等键不同操作应 409', async () => {
       const idempotency_key = 'test_different_op_' + Date.now()
       const user_id = 1

       // 1. 首次请求（兑换操作）
       await IdempotencyService.getOrCreateRequest(idempotency_key, {
         api_path: '/api/v4/shop/exchange/exchange',
         http_method: 'POST',
         request_params: { item_id: 100 },
         user_id
       })

       // 2. 重试请求（转换操作，不同 canonical）
       await expect(
         IdempotencyService.getOrCreateRequest(idempotency_key, {
           api_path: '/api/v4/shop/assets/convert', // ❌ 不同操作
           http_method: 'POST',
           request_params: { from_asset_code: 'red_shard' },
           user_id
         })
       ).rejects.toThrow('IDEMPOTENCY_KEY_CONFLICT_DIFFERENT_OPERATION')
     })

     test('未定义 canonical 的路径应记录告警', async () => {
       const idempotency_key = 'test_unmapped_' + Date.now()
       const user_id = 1

       // 模拟未定义映射的新接口
       const result = await IdempotencyService.getOrCreateRequest(idempotency_key, {
         api_path: '/api/v4/new/unmapped/endpoint', // 未在 CANONICAL_OPERATION_MAP 中定义
         http_method: 'POST',
         request_params: { test: 'data' },
         user_id
       })

       // 应该能创建，但会记录告警
       expect(result.is_new).toBe(true)

       // 验证日志中有告警（需要 mock logger 或查看日志输出）
       // 预期日志：logger.warn('未定义 canonical operation 的写接口', { api_path: ... })
     })
   })
   ```

**预期效果**：

- ✅ 同一幂等键跨路径（同类操作）重试时，返回首次结果而不是 409
- ✅ 未来路径迁移只需添加 alias 映射，无需 DB 迁移
- ✅ 不同操作仍保持严格 409，避免错用幂等键
- ✅ 降低资产类操作的用户投诉和客服成本
- ✅ 一次性解决长期维护成本（符合大厂主流做法）
- ✅ 全量覆盖所有写接口，一次性彻底解决（已拍板）
- ✅ 显式 operation 强制规范，语义清晰可维护（已拍板）

**风险控制**：

- 显式定义机制：所有写接口都必须在 CANONICAL_OPERATION_MAP 中显式定义（已拍板）
- 零数据改写：不写回更新旧记录，保留审计真实性（已拍板）
- 强制检查：CI/CD 自动检查未映射的写接口，违规则失败
- 可观测性：日志记录跨路径重试事件，便于监控和审计
- 全量覆盖：一次性建立完整 canonical 体系，避免后续反复改动

---

### 2. 同一业务动作两条路径长期并存（强制废弃旧路径，不做兼容）

**问题位置**：

- `routes/v4/shop/exchange/exchange.js` 当前兑换接口
- `api_idempotency_requests` 表历史数据
- 可能存在的旧路由挂载或兼容层

**问题现状**：

真实库数据显示，兑换下单操作存在两条路径的历史记录：

```sql
-- 查询结果（2026-01-08）
SELECT api_path, COUNT(*) as cnt,
       MIN(created_at) as first_at, MAX(created_at) as last_at
FROM api_idempotency_requests
WHERE api_path LIKE '%exchange%'
GROUP BY api_path;

-- 旧路径（历史命名）
/api/v4/exchange_market/exchange: 414条记录
  - 首次：2026-01-02 21:04:37
  - 最新：2026-01-08 21:19:48
  - 状态：270 completed / 144 failed

-- 新路径（当前规范）
/api/v4/shop/exchange/exchange: 12条记录
  - 首次：2026-01-08 22:06:06
  - 最新：2026-01-08 22:09:38
  - 状态：8 completed / 4 failed
```

**业务语义**：

- **两条路径对应同一业务动作**：B2C 官方商城"兑换下单"（用户用材料资产兑换商品，生成订单，扣减资产）
- **历史原因**：早期把"兑换"放在 `exchange_market` 命名下，后来架构重构明确"shop 域负责 B2C 兑换，market 域负责 C2C 交易"，路径迁移到 `/api/v4/shop/exchange/*`
- **当前状态**：用户侧只挂载了 `/api/v4/shop` 路由，旧路径主要是历史幂等记录残留

**业务风险**：

- **语义混乱**：同一业务动作有两个路径名称，审计/排障/统计时需要同时查询两条路径
- **代码维护困惑**：新人不清楚旧路径是否仍在使用，不敢删除相关代码
- **数据统计不准确**：兑换订单量需要合并两条路径的数据才是真实值

**解决方案（激进策略 - 已拍板）**：

**强制废弃旧路径，不做向后兼容，并删除历史数据**。明确只保留新路径 `/api/v4/shop/exchange/exchange`，删除所有旧路径相关代码、引用和数据库记录。

**已拍板决策（问题2）**（2026-01-09 最终确认）：

- ✅ **旧路径策略**：确保功能正常后强制删除旧路径（代码 + 数据都删）
- ✅ **删除执行顺序**：
  1. 先删除代码中的旧路径路由/引用（确保 404）
  2. 全面测试验证新路径功能正常（包括幂等/重试/冲突检测）
  3. 功能确认无误后，删除数据库中旧路径幂等记录
- ✅ **数据备份策略**：不备份，直接删除（最干净，但不可逆）
- ✅ **兼容性**：不做任何兼容层或迁移引导（强制不兼容）
- ✅ **保底机制**：问题1的 canonical 解耦方案作为长期保底，防止未来再次出现路径迁移问题

**策略说明**：

- 彻底删除旧路径痕迹，代码和数据都不保留
- 不做备份，直接删除（已拍板：最干净，不可逆）
- 统计分析只基于新路径数据
- 降低维护成本，新人无需理解历史遗留

**实施步骤**（2026-01-09 三步走强制删除策略）：

**第一阶段：删除旧路径代码（确保 404）**

1. **全局扫描并删除旧路径相关代码**：

   ```bash
   # 1. 查找所有旧路径引用
   grep -r "exchange_market" routes/ app.js services/ public/ tests/

   # 2. 删除旧路径的路由定义（如果存在）
   # 检查 app.js 中是否有类似挂载：
   # app.use('/api/v4/exchange_market', ...)

   # 3. 删除前端/测试中的旧路径调用
   grep -r "/api/v4/exchange_market/exchange" public/ tests/

   # 4. 删除所有旧路径相关代码和注释
   ```

**第二阶段：全面验证新路径功能（确保正常）**

2. **测试新路径完整功能**：

   ```bash
   # 1. 运行完整测试套件
   npm test

   # 2. 重点验证兑换接口幂等性
   # - 正常兑换流程
   # - 重复提交返回首次结果
   # - 参数冲突返回 409
   # - 并发请求处理正确

   # 3. 验证旧路径已返回 404
   curl -X POST http://localhost:3000/api/v4/exchange_market/exchange \
     -H "Authorization: Bearer <token>" \
     -H "Idempotency-Key: test_old_path" \
     -d '{"item_id": 1, "quantity": 1}'

   # 预期：404 Not Found

   # 4. 功能验证通过后，进入第三阶段
   ```

**第三阶段：删除数据库旧路径记录（功能确认无误后执行）**

3. **删除数据库中的旧路径历史记录（已拍板：不备份，直接删除）**：

   ```sql
   -- ⚠️ 警告：此操作不可逆，已拍板不做备份
   -- ⚠️ 前置条件：第二阶段功能验证已完成且正常

   -- 1. 统计待删除记录（最后确认）
   SELECT api_path, COUNT(*) as count,
          SUM(CASE WHEN status = 'completed' THEN 1 ELSE 0 END) as completed,
          SUM(CASE WHEN status = 'failed' THEN 1 ELSE 0 END) as failed
   FROM api_idempotency_requests
   WHERE api_path = '/api/v4/exchange_market/exchange';

   -- 预期：414 条记录（270 completed / 144 failed）

   -- 2. 直接删除旧路径所有记录（已拍板：不备份）
   DELETE FROM api_idempotency_requests
   WHERE api_path = '/api/v4/exchange_market/exchange';

   -- 预期：删除 414 条记录

   -- 3. 验证删除结果
   SELECT api_path, COUNT(*) as count
   FROM api_idempotency_requests
   WHERE api_path LIKE '%exchange%'
   GROUP BY api_path;

   -- 预期结果：只剩 /api/v4/shop/exchange/exchange（12条）
   ```

4. **创建数据清理脚本（已拍板：不备份，直接删除）**：

   ```javascript
   // scripts/cleanup/delete-deprecated-path-records.js

   const { sequelize } = require('../../config/database')
   const logger = require('../../utils/logger').logger

   async function deleteDeprecatedPathRecords() {
     console.log('🗑️ 开始删除废弃路径的幂等记录...')
     console.log('⚠️ 已拍板决策：不备份，直接删除（不可逆）')

     const deprecatedPaths = [
       '/api/v4/exchange_market/exchange',
       '/api/v4/assets/convert' // 如果也需要删除
     ]

     try {
       await sequelize.authenticate()

       // 1. 统计待删除记录
       const [stats] = await sequelize.query(
         `SELECT api_path, COUNT(*) as count,
                 SUM(CASE WHEN status = 'completed' THEN 1 ELSE 0 END) as completed,
                 SUM(CASE WHEN status = 'failed' THEN 1 ELSE 0 END) as failed
          FROM api_idempotency_requests
          WHERE api_path IN (${deprecatedPaths.map(() => '?').join(',')})
          GROUP BY api_path`,
         { replacements: deprecatedPaths }
       )

       if (stats.length === 0) {
         console.log('✅ 无需删除：未发现废弃路径记录')
         return
       }

       console.log('📊 待删除记录统计:')
       let totalCount = 0
       stats.forEach(({ api_path, count, completed, failed }) => {
         console.log(`   ${api_path}: ${count}条（${completed} completed / ${failed} failed）`)
         totalCount += parseInt(count)
       })

       // 2. 【已拍板】不备份，直接删除
       console.log(`\n⚠️ 即将删除 ${totalCount} 条记录，此操作不可逆`)

       // 3. 确认删除（生产环境强制人工确认）
       if (process.env.NODE_ENV === 'production') {
         console.log('\n⚠️ 生产环境删除需要确认')
         console.log('⚠️ 已拍板：不备份，直接删除（不可逆）')
         console.log('请设置环境变量 CONFIRM_DELETE=yes 后重新运行')

         if (process.env.CONFIRM_DELETE !== 'yes') {
           console.log('❌ 未确认，取消删除')
           process.exit(1)
         }
       }

       // 4. 执行删除（不可逆）
       console.log('\n🗑️ 执行删除...')
       const [result] = await sequelize.query(
         `DELETE FROM api_idempotency_requests
          WHERE api_path IN (${deprecatedPaths.map(() => '?').join(',')})`,
         { replacements: deprecatedPaths }
       )

       console.log(`✅ 删除完成：${result.affectedRows || 0} 条记录`)

       // 5. 验证删除结果
       const [remaining] = await sequelize.query(
         `SELECT api_path, COUNT(*) as count
          FROM api_idempotency_requests
          WHERE api_path IN (${deprecatedPaths.map(() => '?').join(',')})
          GROUP BY api_path`,
         { replacements: deprecatedPaths }
       )

       if (remaining.length > 0) {
         console.error('❌ 删除不完全，仍有残留记录')
         process.exit(1)
       }

       console.log('✅ 验证通过：所有废弃路径记录已删除')
       console.log('⚠️ 提醒：此操作不可逆，无备份表')
     } catch (error) {
       console.error('❌ 删除失败:', error.message)
       process.exit(1)
     } finally {
       await sequelize.close()
     }
   }

   deleteDeprecatedPathRecords().catch(console.error)
   ```

5. **确认旧路径已完全不可访问**：

   ```bash
   # 启动服务后测试旧路径
   curl -X POST http://localhost:3000/api/v4/exchange_market/exchange \
     -H "Content-Type: application/json" \
     -H "Authorization: Bearer <token>" \
     -d '{"item_id": 1, "quantity": 1}'

   # 预期结果：404 Not Found（Express 默认 404 处理器）
   ```

6. **更新所有客户端代码（强制升级）**：

   ```javascript
   // 前端 API 调用统一修改

   // ❌ 删除旧代码
   // const response = await fetch('/api/v4/exchange_market/exchange', { ... })

   // ✅ 统一使用新路径
   const response = await fetch('/api/v4/shop/exchange/exchange', {
     method: 'POST',
     headers: { 'Idempotency-Key': idempotencyKey },
     body: JSON.stringify({ item_id, quantity })
   })
   ```

7. **添加路径规范检查脚本（防止未来误用旧路径）**：

   ```javascript
   // scripts/validation/check-deprecated-paths.js

   const { execSync } = require('child_process')

   async function checkDeprecatedPaths() {
     console.log('🔍 检查是否有废弃路径残留...')

     const deprecatedPaths = [
       '/api/v4/exchange_market/exchange',
       '/api/v4/assets/convert' // 如果也有类似问题
     ]

     let hasViolation = false

     // 1. 检查代码中是否有引用（应该为空）
     for (const path of deprecatedPaths) {
       try {
         const result = execSync(
           `grep -r "${path}" routes/ app.js services/ public/ --exclude-dir=node_modules`,
           { encoding: 'utf8' }
         )

         if (result.trim()) {
           console.error(`❌ 代码中仍有废弃路径引用: ${path}`)
           console.error(result)
           hasViolation = true
         }
       } catch (error) {
         // grep 无匹配时会抛出错误，这是预期的
         if (error.status === 1) {
           console.log(`✅ ${path}: 代码中无引用`)
         }
       }
     }

     // 2. 检查数据库中的最近访问（仅统计，不阻止）
     const { sequelize } = require('../../config/database')
     const [recentAccess] = await sequelize.query(
       `SELECT api_path, COUNT(*) as count, MAX(created_at) as last_access
        FROM api_idempotency_requests
        WHERE api_path IN (${deprecatedPaths.map(() => '?').join(',')})
        AND created_at > DATE_SUB(NOW(), INTERVAL 7 DAY)
        GROUP BY api_path`,
       { replacements: deprecatedPaths }
     )

     if (recentAccess.length > 0) {
       console.warn('⚠️ 最近7天仍有废弃路径访问记录:')
       recentAccess.forEach(({ api_path, count, last_access }) => {
         console.warn(`   ${api_path}: ${count}次，最后 ${last_access}`)
       })
       console.warn('   说明：可能是客户端缓存/代理残留，应返回 404')
     } else {
       console.log('✅ 最近7天无废弃路径访问')
     }

     if (hasViolation) {
       console.error('\n❌ 检查失败：代码中仍有废弃路径引用')
       process.exit(1)
     }

     console.log('\n✅ 废弃路径检查通过')
   }

   checkDeprecatedPaths().catch(console.error)
   ```

8. **添加到 CI/CD 检查**：

   ```json
   // package.json
   {
     "scripts": {
       "validate:deprecated-paths": "node scripts/validation/check-deprecated-paths.js",
       "pretest": "npm run validate:deprecated-paths"
     }
   }
   ```

9. **文档更新（明确不兼容策略）**：

   ```markdown
   # API 路径迁移记录

   ## 兑换接口路径变更（Breaking Change）

   **变更时间**：2026年01月02日  
   **兼容策略**：❌ 不做向后兼容

   **旧路径**（已删除）：
   ```

   POST /api/v4/exchange_market/exchange

   ```

   **新路径**（唯一有效）：
   ```

   POST /api/v4/shop/exchange/exchange

   ```

   **变更原因**：
   - 架构重构：明确 shop 域负责 B2C 兑换，market 域负责 C2C 交易
   - 语义清晰：`/shop/exchange` 更明确表达"官方商城兑换"的业务含义

   **Breaking Changes**：
   - ❌ 旧路径已完全删除，返回 404 Not Found
   - ❌ 不提供任何兼容层或迁移引导
   - ✅ 参数无变更，仅路径变更
   - ✅ 客户端必须升级到新路径

   **历史数据说明**：
   - `api_idempotency_requests` 表中的旧路径记录保留用于审计
   - 统计分析时需要合并新旧路径数据
   - 不做数据迁移（保持历史真实性）

   **客户端迁移指南**：
   1. ⚠️ 强制升级：更新所有 API 调用路径为新路径
   2. 保持 Idempotency-Key 生成逻辑不变
   3. 测试验证兑换流程正常
   4. 旧路径将直接返回 404，无迁移提示
   ```

**预期效果**（2026-01-09 三步走强制删除策略）：

- ✅ 彻底删除旧路径，代码和数据都不保留
- ✅ 不备份，直接删除（已拍板：最干净，不可逆）
- ✅ 三步走确保安全：代码删除 → 功能验证 → 数据清理
- ✅ 新人无需理解历史遗留，只需关注当前唯一路径
- ✅ 统计分析只基于新路径数据，口径统一
- ✅ CI/CD 自动检查防止未来误用旧路径
- ✅ 数据库更清晰，无历史包袱
- ⚠️ 强制客户端升级（Breaking Change）
- ⚠️ 不可逆操作（已拍板：不备份）
- ⚠️ 算法迁移采用强制不兼容（不做兼容窗口）

**与问题1的关系（保底机制）**（2026-01-09 最终确认）：

- **问题2（本问题）**：激进策略，彻底删除旧路径（代码+数据，不备份），三步走确保安全
- **问题1（canonical 化）**：长期技术路线，幂等语义从 URL 解耦（canonical_operation），防止未来所有路径迁移的幂等冲突
- **协同效果**：
  - 短期：通过三步走删除旧路径强制统一入口（不可逆，但有验证保障）
  - 长期：通过 canonical 解耦（显式 operation）保证未来路径变更时的幂等稳定性
  - 兼容策略：强制不兼容（算法迁移不做兼容窗口），简洁优先
  - 保底：即使未来再次出现路径迁移，问题1的解耦方案可以兜底（不写回，只回放）

**已拍板决策总结（问题2）**（2026-01-09 最终确认）：

1. ✅ 旧路径策略：确保功能正常后强制删除（代码 + 数据都删）
2. ✅ 删除执行顺序：代码删除 → 功能验证 → 数据清理（三步走）
3. ✅ 历史数据处理：彻底删除旧路径记录（功能验证通过后执行）
4. ✅ 数据备份策略：不备份，直接删除（最干净，不可逆）
5. ✅ 兼容性策略：强制不兼容（算法迁移不做兼容窗口）
6. ✅ 客户端策略：强制升级，不提供迁移引导

---

**两个问题的完整拍板决策汇总**（2026-01-09 最终确认）：

| 决策点     | 问题1（canonical 化）                      | 问题2（旧路径删除）                |
| ---------- | ------------------------------------------ | ---------------------------------- |
| 技术路线   | canonical_operation（幂等语义从 URL 解耦） | 强制删除（代码 + 数据）            |
| 兼容策略   | 强制不兼容（不做兼容窗口）                 | 强制不兼容（不做兼容层）           |
| 旧路径处理 | 直接 404                                   | 三步走：代码删除 → 验证 → 数据清理 |
| 历史数据   | 不写回（只回放）                           | 彻底删除（不备份）                 |
| 覆盖范围   | 全量写接口                                 | 兑换下单路径                       |
| 落地方式   | 显式 operation                             | 强制删除代码+数据                  |
| 客户端策略 | 无感知（幂等兼容）                         | 强制升级                           |
| 可逆性     | 可逆（只改代码）                           | 不可逆（删除数据）                 |

**强制规范（已拍板）**（2026-01-09 最终确认）：

> **显式 operation 强制规范**：所有 POST/PUT/DELETE 接口，只要接入入口幂等，必须在 `CANONICAL_OPERATION_MAP` 中显式定义 `canonical_operation`；禁止依赖 URL 推导作为最终语义。未定义的路径将记录告警并使用原路径（保持严格），CI/CD 检查时视为违规。
>
> **强制不兼容策略**：算法迁移采用强制不兼容（不做兼容窗口、不做双算比对、不做版本字段），简洁优先，迁移前确保旧幂等记录已过期或手动清理。
>
> **三步走删除策略**：代码删除 → 功能验证 → 数据清理（确保每步正常后再进入下一步）。

---

## P1级问题（架构一致性/可维护性）

### 6. ESLint 仍有 87 个 warnings

**问题现状**：

```bash
✖ 87 problems (0 errors, 87 warnings)
```

**警告类型分布**：

- `no-unused-vars`：约10个（测试文件中的未使用变量）
- `no-await-in-loop`：约60个（循环中的 await，部分合理部分可优化）
- `no-restricted-syntax`：约10个（事务边界告警，业务一致性问题）
- 其他：约7个

**业务风险**：

- 噪声过大，真实问题容易被淹没
- 部分规则（事务边界提示）本质是质量门槛，忽略会导致数据不一致

**解决方案**：
分批清理，优先顺序：no-unused-vars → 事务边界告警 → no-await-in-loop

**实施步骤**：

#### 第一批：清理 no-unused-vars（预计减少10个警告）

```bash
# 1. 查找所有未使用变量
npm run lint 2>&1 | grep "no-unused-vars"

# 2. 逐个修复（删除或改为 _variableName）
# 示例：
# - tests/business/asset/phase3_migration.test.js:13 'sequelize' 未使用 → 删除
# - tests/business/auth/api.test.js:25 'test_user_id' 未使用 → 删除或使用
```

#### 第二批：核查事务边界告警（预计修复5-10个真实问题）

```bash
# 1. 查找所有事务边界告警
npm run lint 2>&1 | grep "no-restricted-syntax" | grep "事务边界"

# 2. 逐个核查是否真的缺 transaction
# 示例：routes/v4/console/asset-adjustment.js:2070
# - 检查 AssetService.changeBalance() 调用是否在事务内
# - 如果缺失，补充 { transaction } 参数
# - 如果确认不需要，添加 eslint-disable-next-line 并注释说明原因
```

#### 第三批：优化 no-await-in-loop（仅优化可并行的场景）

```bash
# 1. 查找所有 no-await-in-loop
npm run lint 2>&1 | grep "no-await-in-loop"

# 2. 分类处理：
# - 可并行：改为 Promise.all()
#   例如：批量查询用户信息
#   const users = await Promise.all(userIds.map(id => User.findByPk(id)))
#
# - 必须串行：保留并添加注释 + eslint-disable
#   例如：顺序执行的业务流程（发奖 → 扣库存 → 记录日志）
#   // eslint-disable-next-line no-await-in-loop -- 业务要求顺序执行
```

**预期效果**：

- 第一批完成后：87 → 77 warnings
- 第二批完成后：77 → 67 warnings（并修复潜在的事务一致性问题）
- 第三批完成后：67 → 30-40 warnings（剩余的都是合理的串行逻辑）

---

### 7. listing_expiry_days/监控阈值是否全部以 DB 为真相源

**问题位置**：

- `jobs/hourly-expire-fungible-asset-listings.js` 定时任务
- `jobs/hourly-market-listing-monitor.js` 监控任务
- `scripts/maintenance/scheduled-tasks.js` 调度配置

**问题现状**：

虽然 `MarketListingService` 已改为从 DB 读取 `max_active_listings` 和 `listing_expiry_days`，但定时任务和监控逻辑可能仍存在硬编码：

```javascript
// ❌ 可能存在的硬编码
const EXPIRY_DAYS = 3 // 硬编码过期天数
const MONITOR_THRESHOLD_DAYS = 2 // 硬编码监控阈值
```

**业务风险**：

- 运营调整配置后，定时任务仍按旧值执行
- 监控告警阈值与实际业务规则不一致
- 配置不一致导致用户困惑（为什么3天还没过期？）

**解决方案**：

梳理 `jobs/*market*`、`scripts/maintenance/*` 是否读取 `system_settings(marketplace/*)`；不读的改成读 DB

**实施步骤**：

1. 检查所有定时任务和监控脚本：

   ```bash
   # 查找硬编码的天数/阈值
   grep -r "EXPIRY.*DAY\|THRESHOLD.*DAY\|= 3\|= 2" jobs/ scripts/maintenance/

   # 查找是否使用 AdminSystemService.getSettingValue
   grep -r "getSettingValue\|system_settings" jobs/ scripts/maintenance/
   ```

2. 修改 `jobs/hourly-expire-fungible-asset-listings.js`：

   ```javascript
   // ✅ 从 DB 读取配置
   async function expireFungibleAssetListings() {
     // 读取过期天数配置
     const expiryDays = await AdminSystemService.getSettingValue(
       'marketplace',
       'listing_expiry_days'
     )
     const expiryDaysNum = parseInt(expiryDays, 10) || 3 // 兜底值

     logger.info('开始过期挂牌检查', { expiry_days: expiryDaysNum })

     const expiryDate = new Date()
     expiryDate.setDate(expiryDate.getDate() - expiryDaysNum)

     // 查找过期挂牌
     const expiredListings = await MarketListing.findAll({
       where: {
         status: 'on_sale',
         created_at: { [Op.lt]: expiryDate }
       }
     })

     // ... 处理过期逻辑
   }
   ```

3. 修改 `jobs/hourly-market-listing-monitor.js`：

   ```javascript
   // ✅ 从 DB 读取监控阈值
   async function monitorMarketListings() {
     // 读取监控配置
     const monitorThresholdDays = await AdminSystemService.getSettingValue(
       'marketplace',
       'monitor_threshold_days'
     )
     const thresholdDays = parseInt(monitorThresholdDays, 10) || 2 // 兜底值

     logger.info('开始市场监控', { threshold_days: thresholdDays })

     // 查找长期在售挂牌
     const thresholdDate = new Date()
     thresholdDate.setDate(thresholdDate.getDate() - thresholdDays)

     const longTermListings = await MarketListing.findAll({
       where: {
         status: 'on_sale',
         created_at: { [Op.lt]: thresholdDate }
       }
     })

     if (longTermListings.length > 0) {
       logger.warn('发现长期在售挂牌', {
         count: longTermListings.length,
         threshold_days: thresholdDays
       })

       // 发送告警
       await NotificationService.sendAdminAlert({
         type: 'long_term_listings',
         count: longTermListings.length,
         threshold_days: thresholdDays
       })
     }
   }
   ```

4. 在 `system_settings` 表中添加监控配置（如果缺失）：

   ```sql
   -- 添加监控阈值配置
   INSERT INTO system_settings (setting_key, setting_value, value_type, description, created_at)
   VALUES
     ('marketplace/monitor_threshold_days', '2', 'number', 'C2C市场监控阈值（天）', NOW())
   ON DUPLICATE KEY UPDATE
     setting_value = VALUES(setting_value),
     description = VALUES(description);
   ```

5. 添加配置一致性检查脚本：

   ```javascript
   // scripts/validation/check-marketplace-config-consistency.js
   const { AdminSystemService } = require('../../services/AdminSystemService')
   const { MarketListingService } = require('../../services/MarketListingService')

   async function checkConfigConsistency() {
     console.log('🔍 检查市场配置一致性...')

     // 1. 检查必需配置是否存在
     const requiredConfigs = [
       'marketplace/max_active_listings',
       'marketplace/listing_expiry_days',
       'marketplace/monitor_threshold_days'
     ]

     const missingConfigs = []
     for (const key of requiredConfigs) {
       const [category, configKey] = key.split('/')
       const value = await AdminSystemService.getSettingValue(category, configKey)

       if (!value) {
         missingConfigs.push(key)
       } else {
         console.log(`✅ ${key}: ${value}`)
       }
     }

     if (missingConfigs.length > 0) {
       console.error('❌ 缺失配置:', missingConfigs)
       process.exit(1)
     }

     // 2. 检查配置值是否合理
     const expiryDays = parseInt(
       await AdminSystemService.getSettingValue('marketplace', 'listing_expiry_days'),
       10
     )
     const monitorThresholdDays = parseInt(
       await AdminSystemService.getSettingValue('marketplace', 'monitor_threshold_days'),
       10
     )

     if (monitorThresholdDays >= expiryDays) {
       console.warn('⚠️ 监控阈值应小于过期天数', {
         monitor_threshold_days: monitorThresholdDays,
         listing_expiry_days: expiryDays
       })
     }

     console.log('✅ 市场配置一致性检查通过')
   }

   checkConfigConsistency().catch(console.error)
   ```

**预期效果**：

- 所有定时任务和监控逻辑统一从 DB 读取配置
- 运营调整配置后，定时任务立即生效
- 配置一致性检查脚本可在部署前验证
- 监控告警阈值与实际业务规则一致

---

### 8. 历史幂等记录里 api_path 旧值残留

**问题位置**：

- `api_idempotency_requests` 表历史数据
- `routes/v4/shop/assets/convert.js` 已修正 `api_path`

**问题现状**：

虽然已修正路由代码中的 `api_path` 记录（从 `/api/v4/assets/convert` 改为 `/api/v4/shop/assets/convert`），但数据库中可能已有旧路径的幂等请求记录：

```sql
-- 可能存在的旧数据
SELECT * FROM api_idempotency_requests
WHERE api_path = '/api/v4/assets/convert';  -- 旧路径
```

**业务风险**：

- 审计排障时路径混乱（同一功能有两个路径）
- 幂等性检查可能失效（新旧路径不匹配）
- 统计分析不准确（同一接口被拆成两条记录）

**解决方案**：

确认 `api_idempotency_requests` 表里旧路径数据是否需要迁移/清理（避免审计与排障混乱）

**实施步骤**：

1. 检查历史数据中的旧路径：

   ```sql
   -- 查找所有旧路径的幂等记录
   SELECT
     api_path,
     COUNT(*) as count,
     MIN(created_at) as first_request,
     MAX(created_at) as last_request
   FROM api_idempotency_requests
   WHERE api_path LIKE '/api/v4/assets/%'
   GROUP BY api_path
   ORDER BY api_path;
   ```

2. 创建数据迁移脚本 `migrations/YYYYMMDDHHMMSS-migrate-api-path-history.js`：

   ```javascript
   'use strict'

   module.exports = {
     async up(queryInterface, Sequelize) {
       console.log('🔄 开始迁移历史 api_path 数据...')

       // 路径映射表
       const pathMappings = [
         {
           old: '/api/v4/assets/convert',
           new: '/api/v4/shop/assets/convert',
           reason: '材料转换接口路径修正'
         }
         // 未来发现其他路径变更在此添加
       ]

       for (const mapping of pathMappings) {
         const [result] = await queryInterface.sequelize.query(
           `UPDATE api_idempotency_requests 
            SET api_path = ?,
                meta = JSON_SET(
                  COALESCE(meta, '{}'),
                  '$.path_migrated_from', ?,
                  '$.path_migration_reason', ?,
                  '$.path_migration_at', NOW()
                )
            WHERE api_path = ?`,
           {
             replacements: [mapping.new, mapping.old, mapping.reason, mapping.old]
           }
         )

         console.log(`  ✅ ${mapping.old} → ${mapping.new} (affected: ${result.affectedRows})`)
       }

       // 验证迁移结果
       const [verification] = await queryInterface.sequelize.query(
         `SELECT api_path, COUNT(*) as count
          FROM api_idempotency_requests
          WHERE api_path LIKE '/api/v4/%assets%'
          GROUP BY api_path
          ORDER BY api_path`
       )

       console.log('  📊 迁移后路径分布:')
       verification.forEach(row => {
         console.log(`     ${row.api_path}: ${row.count} 条记录`)
       })

       console.log('✅ api_path 历史数据迁移完成')
     },

     async down(queryInterface, Sequelize) {
       console.log('🔄 开始回滚 api_path 迁移...')

       // 回滚逻辑：从 meta 中读取原始路径
       await queryInterface.sequelize.query(
         `UPDATE api_idempotency_requests
          SET api_path = JSON_UNQUOTE(JSON_EXTRACT(meta, '$.path_migrated_from'))
          WHERE JSON_EXTRACT(meta, '$.path_migrated_from') IS NOT NULL`
       )

       console.log('✅ api_path 迁移已回滚')
     }
   }
   ```

3. 添加路径一致性检查到启动验证：

   ```javascript
   // scripts/validation/check-api-path-consistency.js
   async function checkApiPathConsistency() {
     console.log('🔍 检查 API 路径一致性...')

     // 1. 查找所有幂等记录的路径
     const [paths] = await sequelize.query(
       `SELECT DISTINCT api_path 
        FROM api_idempotency_requests 
        ORDER BY api_path`
     )

     // 2. 检查是否有已知的旧路径
     const knownOldPaths = [
       '/api/v4/assets/convert' // 已废弃
     ]

     const foundOldPaths = paths.filter(row => knownOldPaths.includes(row.api_path))

     if (foundOldPaths.length > 0) {
       console.warn(
         '⚠️ 发现旧路径记录:',
         foundOldPaths.map(p => p.api_path)
       )
       console.warn('   建议运行迁移: npm run migration:run')
     } else {
       console.log('✅ 未发现旧路径记录')
     }

     // 3. 检查路径格式规范
     const invalidPaths = paths.filter(row => {
       const path = row.api_path
       // 路径应该以 /api/v4/ 开头
       return path && !path.startsWith('/api/v4/')
     })

     if (invalidPaths.length > 0) {
       console.warn(
         '⚠️ 发现不规范路径:',
         invalidPaths.map(p => p.api_path)
       )
     }

     console.log(`📊 总计 ${paths.length} 个不同的 API 路径`)
   }
   ```

4. 添加定期清理策略（可选）：

   ```javascript
   // jobs/monthly-cleanup-old-idempotency-records.js
   module.exports = {
     name: 'monthly-cleanup-old-idempotency-records',
     schedule: '0 3 1 * *', // 每月1号凌晨3点
     async handler() {
       logger.info('开始清理过期幂等记录')

       // 清理90天前的幂等记录
       const cutoffDate = new Date()
       cutoffDate.setDate(cutoffDate.getDate() - 90)

       const [result] = await sequelize.query(
         `DELETE FROM api_idempotency_requests 
          WHERE created_at < ? 
          AND status IN ('completed', 'failed')`,
         {
           replacements: [cutoffDate]
         }
       )

       logger.info('过期幂等记录清理完成', {
         deleted_count: result.affectedRows,
         cutoff_date: cutoffDate
       })
     }
   }
   ```

**预期效果**：

- 历史数据中的旧路径统一迁移到新路径
- 迁移记录保留在 `meta` 字段中，可追溯
- 启动验证可检测路径不一致问题
- 定期清理过期幂等记录，保持表大小可控

---

### 9. 服务获取方式未完全统一（仍有路由/服务直接 require Service 的情况）

**问题位置**：

- `routes/v4/console/marketplace.js` 第455行

**问题现状**：

```javascript
// ❌ 直接 require Service
const MarketListingService = require('../../../services/MarketListingService')

// ✅ 其他地方已统一使用 ServiceManager
const ExchangeService = req.app.locals.services.getService('exchangeMarket')
```

**业务风险**：

- 违背"路由通过 ServiceManager 获取 Service"的架构约束
- 后续依赖会越来越乱，难以追踪服务调用关系
- 无法统一管理服务生命周期（如热重载、依赖注入）

**解决方案**：
把 `MarketListingService` 纳入 `ServiceManager` 注册，并在路由改为 `req.app.locals.services.getService(...)`

**实施步骤**：

1. 检查 `MarketListingService` 是否已在 `ServiceManager` 注册：

   ```bash
   grep -r "MarketListingService" utils/ServiceManager.js app.js
   ```

2. 如果未注册，在 `app.js` 或 `utils/ServiceManager.js` 中添加注册：

   ```javascript
   // app.js 中的服务注册部分
   const MarketListingService = require('./services/MarketListingService')
   serviceManager.registerService('marketListing', MarketListingService)
   ```

3. 修改 `routes/v4/console/marketplace.js`：

   ```javascript
   // 删除直接 require
   - const MarketListingService = require('../../../services/MarketListingService')

   // 改为通过 ServiceManager 获取
   + const MarketListingService = req.app.locals.services.getService('marketListing')
   ```

4. 全局搜索其他直接 require Service 的情况：

   ```bash
   grep -r "require.*Service\.js" routes/ | grep -v "ServiceManager"
   ```

5. 逐个修改为统一的 ServiceManager 获取方式

**预期效果**：

- 所有路由统一通过 `ServiceManager` 获取服务
- 服务依赖关系清晰可追踪
- 为后续服务层优化（如依赖注入、AOP）打下基础

---

## P2级问题（规范/一致性/长期技术债）

### 10. 自动对账与告警闭环

**问题位置**：

- `jobs/hourly-market-listing-monitor.js` 监控任务
- 告警渠道和处理流程

**问题现状**：

当前监控任务可以检测异常（如"冻结>挂牌""挂牌>冻结""长期在售""异常价格"），但：

- 告警渠道不明确（仅日志？还是通知？）
- 告警阈值硬编码或缺失
- 缺少处理 SOP（发现问题后谁处理？怎么处理？）

**业务风险**：

- 异常被检测到但无人处理
- 告警疲劳（阈值不合理导致频繁告警）
- 处理流程不统一（不同人处理方式不同）

**解决方案**：

把"冻结>挂牌""挂牌>冻结""长期在售""异常价格"等监控的告警渠道、阈值、处理 SOP 固化（仍走 DB 配置）

**实施步骤**：

1. 在 `system_settings` 表中添加监控配置：

   ```sql
   -- 监控告警配置
   INSERT INTO system_settings (setting_key, setting_value, value_type, description, created_at)
   VALUES
     ('marketplace/alert_channels', 'admin_message,webhook', 'string', '告警渠道（逗号分隔）', NOW()),
     ('marketplace/long_term_listing_days', '7', 'number', '长期在售告警阈值（天）', NOW()),
     ('marketplace/abnormal_price_ratio', '10', 'number', '异常价格告警比例（倍数）', NOW()),
     ('marketplace/frozen_mismatch_auto_fix', 'true', 'boolean', '冻结不匹配是否自动修复', NOW())
   ON DUPLICATE KEY UPDATE
     setting_value = VALUES(setting_value),
     description = VALUES(description);
   ```

2. 创建统一的告警服务 `services/MarketAlertService.js`：

   ```javascript
   class MarketAlertService {
     /**
      * 发送市场告警
      * @param {string} alertType - 告警类型
      * @param {Object} alertData - 告警数据
      */
     static async sendAlert(alertType, alertData) {
       // 读取告警渠道配置
       const channelsStr = await AdminSystemService.getSettingValue('marketplace', 'alert_channels')
       const channels = channelsStr ? channelsStr.split(',') : ['admin_message']

       logger.info('发送市场告警', { alert_type: alertType, channels })

       // 构造告警消息
       const alertMessage = this._buildAlertMessage(alertType, alertData)

       // 并行发送到所有渠道
       await Promise.allSettled(channels.map(channel => this._sendToChannel(channel, alertMessage)))
     }

     static _buildAlertMessage(alertType, alertData) {
       const templates = {
         frozen_mismatch: `检测到冻结余额不匹配：${alertData.count}条记录`,
         long_term_listing: `检测到长期在售挂牌：${alertData.count}条，超过${alertData.threshold_days}天`,
         abnormal_price: `检测到异常价格挂牌：${alertData.count}条，价格比例超过${alertData.ratio}倍`,
         orphan_frozen: `检测到孤儿冻结余额：${alertData.count}条`
       }

       return {
         type: alertType,
         title: templates[alertType] || '市场异常告警',
         data: alertData,
         timestamp: new Date().toISOString()
       }
     }

     static async _sendToChannel(channel, message) {
       switch (channel) {
         case 'admin_message':
           // 发送站内消息给所有管理员
           await NotificationService.sendToAllAdmins({
             type: 'market_alert',
             title: message.title,
             content: JSON.stringify(message.data),
             priority: 'high'
           })
           break

         case 'webhook':
           // 发送到 Webhook（如钉钉、企业微信）
           await this._sendWebhook(message)
           break

         case 'email':
           // 发送邮件告警
           await this._sendEmail(message)
           break

         default:
           logger.warn('未知告警渠道', { channel })
       }
     }

     static async _sendWebhook(message) {
       const webhookUrl = process.env.MARKET_ALERT_WEBHOOK_URL
       if (!webhookUrl) {
         logger.warn('Webhook URL 未配置')
         return
       }

       try {
         await fetch(webhookUrl, {
           method: 'POST',
           headers: { 'Content-Type': 'application/json' },
           body: JSON.stringify({
             msgtype: 'text',
             text: { content: `【市场告警】${message.title}` }
           })
         })
       } catch (error) {
         logger.error('Webhook 发送失败', { error: error.message })
       }
     }
   }
   ```

3. 修改监控任务使用统一告警服务：

   ```javascript
   // jobs/hourly-market-listing-monitor.js
   async function monitorMarketListings() {
     logger.info('开始市场监控')

     // 1. 检查长期在售挂牌
     const longTermDays =
       parseInt(
         await AdminSystemService.getSettingValue('marketplace', 'long_term_listing_days'),
         10
       ) || 7

     const longTermListings = await this._findLongTermListings(longTermDays)
     if (longTermListings.length > 0) {
       await MarketAlertService.sendAlert('long_term_listing', {
         count: longTermListings.length,
         threshold_days: longTermDays,
         listings: longTermListings.slice(0, 10) // 仅发送前10条
       })
     }

     // 2. 检查冻结余额不匹配
     const frozenMismatches = await this._findFrozenMismatches()
     if (frozenMismatches.length > 0) {
       // 检查是否自动修复
       const autoFix = await AdminSystemService.getSettingValue(
         'marketplace',
         'frozen_mismatch_auto_fix'
       )

       if (autoFix === 'true') {
         // 自动调用清理服务
         const result = await OrphanFrozenCleanupService.detectAndCleanup({
           dryRun: false,
           reason: 'auto_monitor_cleanup'
         })

         await MarketAlertService.sendAlert('frozen_mismatch', {
           count: frozenMismatches.length,
           auto_fixed: true,
           cleaned: result.cleaned
         })
       } else {
         // 仅告警，不自动修复
         await MarketAlertService.sendAlert('frozen_mismatch', {
           count: frozenMismatches.length,
           auto_fixed: false
         })
       }
     }

     // 3. 检查异常价格
     const abnormalPriceRatio =
       parseInt(
         await AdminSystemService.getSettingValue('marketplace', 'abnormal_price_ratio'),
         10
       ) || 10

     const abnormalPriceListings = await this._findAbnormalPriceListings(abnormalPriceRatio)
     if (abnormalPriceListings.length > 0) {
       await MarketAlertService.sendAlert('abnormal_price', {
         count: abnormalPriceListings.length,
         ratio: abnormalPriceRatio,
         listings: abnormalPriceListings.slice(0, 10)
       })
     }

     logger.info('市场监控完成')
   }
   ```

4. 创建告警处理 SOP 文档：

   ````markdown
   # 市场告警处理 SOP

   ## 冻结余额不匹配

   **触发条件**：`account_asset_balances.frozen_amount > 实际挂牌冻结总额`

   **处理流程**：

   1. 如果配置了自动修复（`frozen_mismatch_auto_fix=true`），系统会自动解冻多余部分
   2. 如果未配置自动修复，管理员需手动调用清理接口：
      ```bash
      POST /api/v4/console/orphan-frozen/cleanup
      ```
   ````

   3. 检查告警原因，如果是测试/脚本导致，需修复测试代码

   ## 长期在售挂牌

   **触发条件**：挂牌在售时间超过配置阈值（默认7天）

   **处理流程**：
   1. 检查挂牌是否合理（价格是否过高）
   2. 联系卖家确认是否需要调整价格或撤回
   3. 如果是异常挂牌，管理员可强制撤回：
      ```bash
      POST /api/v4/console/marketplace/force-withdraw
      ```

   ## 异常价格挂牌

   **触发条件**：挂牌价格比例超过配置阈值（默认10倍）

   **处理流程**：
   1. 检查是否为恶意挂牌或操作失误
   2. 联系卖家确认价格
   3. 如果确认为异常，管理员可强制撤回

   ```

   ```

**预期效果**：

- 告警渠道统一（站内消息 + Webhook + 邮件）
- 告警阈值可配置（走 DB `system_settings`）
- 部分异常可自动修复（如孤儿冻结）
- 处理流程标准化（SOP 文档）

---

### 11. 严格路由层规范治理

**问题位置**：

- `routes/v4/**` 所有路由文件

**问题现状**：

虽然已要求"路由通过 ServiceManager 获取服务"、"路由禁止直连 models"、"路由禁止跨表事务"，但可能仍存在违规情况：

```javascript
// ❌ 路由直连 models
const user = await User.findByPk(userId)

// ❌ 路由内跨表事务
const transaction = await sequelize.transaction()
await User.update({...}, { transaction })
await Account.update({...}, { transaction })
await transaction.commit()

// ❌ 直接 require Service
const UserService = require('../../../services/UserService')
```

**业务风险**：

- 违背架构约束，代码难以维护
- 事务边界不清晰，容易出现数据不一致
- 服务依赖混乱，无法追踪调用关系

**解决方案**：

全量检查 `routes/v4/**` 是否都通过 ServiceManager 获取服务、是否存在路由直连 models/跨表事务等，发现即收口到 Service

**实施步骤**：

1. 创建路由规范检查脚本 `scripts/validation/check-route-compliance.js`：

   ```javascript
   const fs = require('fs')
   const path = require('path')
   const glob = require('glob')

   async function checkRouteCompliance() {
     console.log('🔍 检查路由层规范合规性...')

     const routeFiles = glob.sync('routes/v4/**/*.js')
     const violations = []

     for (const file of routeFiles) {
       const content = fs.readFileSync(file, 'utf8')
       const fileViolations = []

       // 1. 检查是否直接 require Service（应该通过 ServiceManager）
       const serviceRequirePattern = /require\(['"].*\/services\/\w+Service['"]\)/g
       if (serviceRequirePattern.test(content)) {
         fileViolations.push({
           type: 'DIRECT_SERVICE_REQUIRE',
           message: '路由直接 require Service，应通过 ServiceManager 获取'
         })
       }

       // 2. 检查是否直接使用 models（应该通过 Service）
       const modelPatterns = [
         /await\s+User\.find/,
         /await\s+Account\.find/,
         /await\s+MarketListing\.find/,
         /await\s+\w+\.create\(/,
         /await\s+\w+\.update\(/,
         /await\s+\w+\.destroy\(/
       ]

       for (const pattern of modelPatterns) {
         if (pattern.test(content)) {
           fileViolations.push({
             type: 'DIRECT_MODEL_ACCESS',
             message: '路由直接访问 models，应通过 Service 封装'
           })
           break
         }
       }

       // 3. 检查是否在路由内创建事务（应该在 Service 内）
       if (content.includes('sequelize.transaction()')) {
         fileViolations.push({
           type: 'TRANSACTION_IN_ROUTE',
           message: '路由内创建事务，应在 Service 内处理'
         })
       }

       if (fileViolations.length > 0) {
         violations.push({
           file: file,
           violations: fileViolations
         })
       }
     }

     // 输出检查结果
     if (violations.length === 0) {
       console.log('✅ 所有路由文件符合规范')
       return
     }

     console.error(`❌ 发现 ${violations.length} 个文件存在规范违规:`)
     violations.forEach(({ file, violations: fileViolations }) => {
       console.error(`\n📁 ${file}:`)
       fileViolations.forEach(v => {
         console.error(`   ❌ ${v.type}: ${v.message}`)
       })
     })

     process.exit(1)
   }

   checkRouteCompliance().catch(console.error)
   ```

2. 将检查脚本加入 CI/CD 流程：

   ```json
   // package.json
   {
     "scripts": {
       "validate:routes": "node scripts/validation/check-route-compliance.js",
       "pretest": "npm run validate:routes"
     }
   }
   ```

3. 逐个修复违规路由（示例）：

   ```javascript
   // ❌ 修复前：routes/v4/console/marketplace.js
   const MarketListingService = require('../../../services/MarketListingService')

   router.post('/force-withdraw', async (req, res) => {
     const { listing_id } = req.body

     // 直接访问 models
     const listing = await MarketListing.findByPk(listing_id)

     // 路由内事务
     const transaction = await sequelize.transaction()
     try {
       await listing.update({ status: 'withdrawn' }, { transaction })
       await AccountAssetBalance.update({...}, { transaction })
       await transaction.commit()
     } catch (error) {
       await transaction.rollback()
       throw error
     }

     return res.apiSuccess(listing)
   })

   // ✅ 修复后
   router.post('/force-withdraw', async (req, res) => {
     const { listing_id } = req.body

     // 通过 ServiceManager 获取服务
     const MarketListingService = req.app.locals.services.getService('marketListing')

     // 调用 Service 方法（事务在 Service 内处理）
     const result = await MarketListingService.adminForceWithdraw(
       listing_id,
       req.user.user_id,
       {
         reason: req.body.reason || 'admin_force_withdraw'
       }
     )

     return res.apiSuccess(result, '强制撤回成功')
   })
   ```

4. 添加 ESLint 规则强制检查（可选）：

   ```javascript
   // .eslintrc.js
   module.exports = {
     rules: {
       'no-restricted-syntax': [
         'error',
         {
           selector: "CallExpression[callee.name='require'][arguments.0.value=/\\/services\\//]",
           message: '路由禁止直接 require Service，请通过 ServiceManager 获取'
         },
         {
           selector:
             'MemberExpression[object.name=/^(User|Account|MarketListing)$/][property.name=/^(find|create|update|destroy)$/]',
           message: '路由禁止直接访问 models，请通过 Service 封装'
         }
       ]
     }
   }
   ```

**预期效果**：

- 所有路由统一通过 ServiceManager 获取服务
- 路由不再直接访问 models
- 事务逻辑全部收口到 Service 层
- CI/CD 流程自动检查规范合规性

---

### 12. 去除非 V4 的残留与无用模块（按你要求：不做向后兼容）

**问题位置**：

- 可能存在的旧版本路由（`routes/v1/`、`routes/v2/`、`routes/v3/`）
- 旧策略文件（如旧抽奖策略）
- 兼容层代码

**问题现状**：

虽然已明确"不做向后兼容"、"只保留 V4"，但可能仍存在：

```javascript
// ❌ 旧版本路由
routes / v3 / lottery.js

// ❌ 旧策略文件
strategies / OldLotteryStrategy.js

// ❌ 兼容层代码
if (req.apiVersion === 'v3') {
  // 兼容旧版本逻辑
}
```

**业务风险**：

- 代码冗余，增加维护成本
- 容易误用旧代码
- 新人不清楚哪些代码是有效的

**解决方案**：

全库扫描旧版本路由/旧策略/兼容层，明确删除或迁移合并到 V4 唯一实现

**实施步骤**：

1. 扫描旧版本路由和策略：

   ```bash
   # 查找旧版本路由
   find routes/ -type d -name "v1" -o -name "v2" -o -name "v3"

   # 查找旧策略文件
   find strategies/ -name "*Old*" -o -name "*Legacy*" -o -name "*Deprecated*"

   # 查找兼容层代码
   grep -r "apiVersion.*v[123]" routes/ services/
   grep -r "backward.*compat" routes/ services/
   ```

2. 创建清理脚本 `scripts/cleanup/remove-legacy-code.sh`：

   ```bash
   #!/bin/bash

   echo "🗑️ 开始清理旧版本代码..."

   # 1. 删除旧版本路由目录
   for version in v1 v2 v3; do
     if [ -d "routes/$version" ]; then
       echo "  删除 routes/$version/"
       rm -rf "routes/$version"
     fi
   done

   # 2. 删除旧策略文件
   find strategies/ -name "*Old*" -o -name "*Legacy*" -delete

   # 3. 查找并报告兼容层代码（需手动处理）
   echo ""
   echo "📋 需要手动清理的兼容层代码:"
   grep -rn "apiVersion.*v[123]" routes/ services/ || echo "  未发现"
   grep -rn "backward.*compat" routes/ services/ || echo "  未发现"

   echo ""
   echo "✅ 旧版本代码清理完成"
   ```

3. 检查 `app.js` 中的路由注册：

   ```javascript
   // ❌ 删除旧版本路由注册
   // app.use('/api/v1', require('./routes/v1'))
   // app.use('/api/v2', require('./routes/v2'))
   // app.use('/api/v3', require('./routes/v3'))

   // ✅ 仅保留 V4
   app.use('/api/v4', require('./routes/v4'))
   ```

4. 更新文档和注释：

   ```javascript
   // ❌ 删除旧版本相关注释
   /**
    * 兼容 V3 版本的旧接口
    * @deprecated 使用 V4 接口替代
    */

   // ✅ 更新为 V4 注释
   /**
    * V4 统一接口
    * @since V4.0.0
    */
   ```

**预期效果**：

- 删除所有旧版本路由（v1/v2/v3）
- 删除所有旧策略和兼容层代码
- 代码库更清晰，仅保留 V4 实现
- 新人快速理解代码结构

---

### 13. 测试环境配置加载链路需要进一步统一

**问题位置**：

- `jest.setup.js` 第13行：`require('dotenv').config()`
- `tests/helpers/test-setup.js` 第9-11行：备用 dotenv 加载逻辑

**问题现状**：

```javascript
// jest.setup.js
require('dotenv').config() // 主入口

// tests/helpers/test-setup.js
if (!process.env.DB_HOST) {
  require('dotenv').config() // 备用入口
}
```

**业务风险**：

- 未来容易出现"谁覆盖谁"的误解
- 调试时难以确定配置来源
- 可能导致测试环境与开发环境配置不一致

**解决方案**：
明确唯一入口（只在 `jest.setup.js` 加载 dotenv），`tests/helpers/test-setup.js` 只做断言工具与非敏感兜底

**实施步骤**：

1. 修改 `tests/helpers/test-setup.js`，移除 dotenv 加载逻辑：

   ```javascript
   // 删除备用加载逻辑
   - if (!process.env.DB_HOST) {
   -   require('dotenv').config()
   - }

   // 添加明确的注释说明
   + /**
   +  * 注意：环境变量由 jest.setup.js 统一加载
   +  * 此文件仅提供测试工具类和非敏感配置兜底
   +  */
   ```

2. 在 `jest.setup.js` 顶部添加注释说明：

   ```javascript
   /**
    * Jest测试环境设置 - 唯一配置入口
    *
    * 职责：
    * 1. 从 .env 加载所有环境变量（单一真相源）
    * 2. 设置测试专用配置（NODE_ENV、超时时间等）
    * 3. 提供非敏感配置的兜底值
    *
    * ⚠️ 其他测试文件不应再加载 dotenv
    */
   require('dotenv').config()
   ```

3. 添加环境变量加载验证：
   ```javascript
   // jest.setup.js 末尾添加
   if (!process.env.DB_HOST || !process.env.DB_NAME) {
     console.error('❌ 环境变量加载失败，请检查 .env 文件是否存在')
     process.exit(1)
   }
   ```

**预期效果**：

- 配置加载链路清晰：`.env` → `jest.setup.js` → 所有测试
- 避免多处加载导致的配置覆盖问题
- 配置缺失时能立即发现并报错

---

### 6. 健康检查返回字段与解析脚本不一致

**问题位置**：

- `/health` 接口返回的数据结构
- 各处健康检查解析脚本

**问题现状**：

```javascript
// 实际返回结构
{
  "data": {
    "status": "healthy",
    "systems": {
      "database": "connected",
      "redis": "connected"
    }
  }
}

// 脚本尝试解析的结构（错误）
checks.database.status  // 实际不存在
checks.redis.status     // 实际不存在
```

**业务风险**：

- 运维脚本/监控误判（显示 unknown）
- CI/CD 流程中的健康检查可能失效
- 告警系统无法正确识别服务状态

**解决方案**：
统一健康检查响应契约，或同步更新所有解析脚本（只保留一种，不做兼容两套）

**实施步骤**：

#### 方案A：修改解析脚本（推荐，不改接口）

```bash
# 1. 查找所有健康检查解析脚本
grep -r "checks.database" scripts/ docs/ .github/

# 2. 统一修改为正确的解析路径
# 旧：d.get('checks',{}).get('database',{}).get('status','unknown')
# 新：d.get('data',{}).get('systems',{}).get('database','unknown')
```

#### 方案B：修改接口响应（如果团队约定需要 checks 字段）

```javascript
// routes/v4/system.js 中的 /health 接口
return res.apiSuccess({
  status: 'healthy',
  systems: { database: 'connected', redis: 'connected' },
  // 添加 checks 字段以兼容旧脚本
  checks: {
    database: { status: 'connected' },
    redis: { status: 'connected' }
  }
})
```

**实施建议**：

- 优先采用方案A（修改脚本），保持接口简洁
- 如果外部系统依赖旧格式，则采用方案B（同时返回两种格式）
- 无论哪种方案，都要在文档中明确健康检查响应契约

**预期效果**：

- 健康检查解析脚本能正确识别服务状态
- 运维监控/告警系统正常工作
- 响应格式统一，便于对接外部系统

---

## 实施计划

### 优先级与时间估算

| 优先级 | 问题编号 | 问题描述                                   | 预计工时 | 依赖关系                |
| ------ | -------- | ------------------------------------------ | -------- | ----------------------- |
| P1     | 6        | ESLint warnings 清理                       | 4小时    | 分三批进行              |
| P1     | 7        | listing_expiry_days 等配置未统一从 DB 读取 | 2小时    | 需修改定时任务          |
| P1     | 8        | 历史幂等记录 api_path 旧值残留             | 1.5小时  | 需要数据库迁移          |
| P1     | 9        | 服务获取方式未完全统一                     | 1小时    | 无                      |
| P2     | 10       | 自动对账与告警闭环                         | 3小时    | 需创建告警服务+SOP文档  |
| P2     | 11       | 严格路由层规范治理                         | 4小时    | 需创建检查脚本+逐个修复 |
| P2     | 12       | 去除非 V4 的残留与无用模块                 | 2小时    | 需扫描并删除旧代码      |
| P2     | 13       | 测试配置加载统一                           | 0.5小时  | 无                      |
| P2     | 14       | 健康检查响应统一                           | 0.5小时  | 无                      |

**总计**：约33-34小时

### 实施顺序建议

6. **问题9：服务获取统一** → 快速修复，架构一致性
7. **问题7：配置统一从 DB 读取** → 修改定时任务读取 system_settings
8. **问题8：api_path 历史数据迁移** → 数据库迁移脚本
9. **问题6：ESLint warnings 清理**（分批进行）
   - 第一批：no-unused-vars
   - 第二批：事务边界告警
   - 第三批：no-await-in-loop

**第三阶段（P2问题，3天内完成）**：

10. **问题11：路由层规范治理** → 创建检查脚本 + 逐个修复违规路由
11. **问题10：自动对账与告警闭环** → 创建 MarketAlertService + SOP 文档
12. **问题12：清理旧版本代码** → 删除 v1/v2/v3 路由和旧策略
13. **问题13：测试配置统一** → 明确唯一入口
14. **问题14：健康检查统一** → 响应格式统一

---

## 质量检查标准

每完成一项问题修复后，必须通过以下检查：

### 代码质量检查

```bash
npm run lint
# 预期：0 errors，warnings 逐步减少
```

### 功能测试

```bash
npm test
# 预期：所有测试通过，无新增失败
```

### 健康检查

```bash
curl -s http://localhost:3000/health | python3 -m json.tool
# 预期：status = healthy，database/redis = connected
```

### 服务运行检查

```bash
npm run pm:status
# 预期：PM2 显示 online 状态
```

##
