### 材料系统（碎片-水晶）方案（基于当前项目代码路线）

### 文档范围（本文件只覆盖这些内容）
- **后端**：Express 路由 / Service / Sequelize Models
- **数据库**：MySQL 表结构与迁移（migrations）
- **Web 管理后台前端**：`public/admin/*` 静态页面（同一 Sealos devbox 内提供）
- **不包含**：微信小程序前端实现细节（小程序可按后端 API 自行对接）

### 1. 目标与边界（只讲本项目当前要落地的）
- **目标**：实现“红水晶碎片/完整红水晶”的**可计数资产系统**，支持：
  - 抽奖获得碎片/水晶
  - 兑换市场按条件消耗碎片/水晶兑换商品
  - 合成/分解/升级：通过**材料转换规则表**配置（支持动态新增类型、动态调整比例、按生效时间版本化）
- **边界**：
  - 继续保持当前项目的技术路线：**单体 Node.js + MySQL + Sequelize + 静态 Service**。
  - 不引入 Repository/DDD/复杂引擎，不新增不必要的抽象层。
  - 复用现有成熟模式：`UserPointsAccount + PointsTransaction + PointsService(事务+幂等+锁)` 的实现风格与落地方式。

#### 1.1 当前业务数据快照（用真实分布校准默认值，避免拍脑袋）
> 数据来源：当前 devbox 所连接的同一套 MySQL 数据库（表行数/字段取值分布）。这不是“需求假设”，而是**现状事实**，用于指导“第一期最小可用落地”的默认值与改造顺序。

- **用户规模（当前库）**：`users` ≈ 18
- **抽奖规模（当前库）**：`lottery_draws` ≈ 2160（近 30 天 ≈ 221）
- **抽奖门票成本（当前库）**：
  - `lottery_draws.cost_points`：最小=100、最大=100（全部为 100）
  - `lottery_prizes.cost_points`：全部为 100
- **预算控奖现状（当前库）**：
  - `lottery_draws.prize_value_points`：全部为 0
  - `lottery_prizes.prize_value_points`：全部为 0
  - `user_points_accounts.remaining_budget_points`：全部为 0
  - 结论：**现阶段预算控奖“不会生效”**（不是代码问题，是数据口径/配置尚未启用）
- **兑换市场定价现状（当前库）**：
  - `exchange_items.price_type`：全部为 `virtual`
  - `exchange_items.virtual_value_price`：全部为 100
  - `exchange_items.points_price`：全部为 0
- **背包虚拟价值现状（当前库）**：
  - `user_inventory.value`：约在 80~100 之间（均值 ≈ 98.75）
- **消费金额分布（当前库）**：
  - `consumption_records.consumption_amount`：25~150（均值 ≈ 89.75；最常见 ≈ 88.50）
  - 系统配置：`system_settings(points).budget_allocation_ratio = 0.24`

**实用主义结论（直接影响本文方案的默认值/顺序）**
- **默认比例保持 100 非“拍脑袋”**：当前系统里“抽奖门票=100、兑换定价=100、虚拟价值约=100”已经形成统一的业务单位，因此把**红系基础规则**默认设为 `red_shard(100) -> red_crystal(1)` 与现有心智模型一致，迁移解释成本最低。
- **第一期不追求“全系统资产大一统”**：先把“兑换支付”从 `virtual_value_price + 背包value` 迁到 `exchange_items.cost_asset_code + cost_amount`（单资产门槛 + 余额扣减），并允许旧字段并行存在一段时间，降低回滚与排障成本。
- **预算控奖属于“数据启用型能力”**：启用预算控奖的第一步是把 `prize_value_points` 配置成非 0 并建立预算发放入口，而不是先做大规模重构（见第 14 节的“启用前置条件”）。

---

### 1.2 方案B定稿（你已确认采用）：通用资产类型 + 余额表 + 转换规则表
> 你要的“未来有红碎片/红水晶/橙碎片/橙水晶…并且可动态新增更高级种类、动态调整兑换比例”，必须采用方案B；否则每加一种材料都要改表结构与代码发版，长期维护成本会持续抬升。

- **资产类型可配置**：新增一种材料=新增一条 `material_asset_types` 记录（可禁用/可排序/可展示）
- **余额按行存储**：用户每种资产一行余额 `user_material_balances`（便于扩展，不需要“加列”）
- **转换规则可版本化**：改比例=新增一条未来生效规则（带 `effective_at`），历史可追溯、争议可解释

---

### 2. 为什么要从“背包 SUM value”切到“材料余额账户”
当前项目的兑换市场实现里，存在“先 SUM 判断足够，再逐条标记 used 扣减”的模式（把背包 `UserInventory.value` 当余额）。这种做法无法自然支持“部分扣减/材料合成”，容易出现：
- **总额足够但仍兑换失败**（例如只有 1 个大额虚拟奖品，需扣一部分时无法扣减）

因此材料系统建议采用与积分一致的底座：
- **余额型资产**：账户一行余额（可部分扣减）
- **流水型审计**：每次变动写交易流水（可对账、可追溯、可风控）

---

### 3. 数据模型设计（方案B：可扩展 + 低维护成本）

#### 3.1 新增表：`material_asset_types`（材料资产类型）
- **定位**：定义系统里存在的“材料种类”（红碎片/红水晶/橙碎片/橙水晶…）
- **建议字段（最小但够用）**：
  - `asset_code` VARCHAR(32) PK  
    - 示例：`red_shard`、`red_crystal`、`orange_shard`、`orange_crystal`
  - `display_name` VARCHAR(64) NOT NULL（展示名）
  - `group_code` VARCHAR(16) NOT NULL（材料组：`red`/`orange`/`purple`…，用于限制“自动拆分”只在同组内发生）
  - `form` ENUM('shard','crystal') NOT NULL（形态：碎片/完整体；用于 UI/逻辑约束）
  - `tier` INT NOT NULL（层级：红=1、橙=2…，用于限制升级方向/避免循环）
  - `sort_order` INT NOT NULL DEFAULT 0
  - `is_enabled` TINYINT(1) NOT NULL DEFAULT 1
  - `created_at / updated_at`
- **关键约束建议**：
  - `asset_code` 全局唯一（PK）
  - (`group_code`,`form`,`tier`) 组合不强制唯一，但建议业务上保持一致（便于运营理解）

#### 3.2 新增表：`user_material_balances`（用户材料余额）
- **定位**：用户在每种材料上的余额（按行扩展）
- **建议字段**：
  - `user_id` INT NOT NULL
  - `asset_code` VARCHAR(32) NOT NULL
  - `balance` BIGINT NOT NULL DEFAULT 0
  - `created_at / updated_at`
- **约束/索引（强烈建议）**：
  - UNIQUE(`user_id`,`asset_code`)（同一用户同一资产只有一行余额）
  - INDEX(`user_id`)
  - INDEX(`asset_code`)

#### 3.3 新增表：`material_conversion_rules`（材料转换规则：比例可配置、可版本化）
- **定位**：定义“从哪种材料按什么比例换到哪种材料”
- **建议字段（最小但必须可追溯）**：
  - `rule_id` BIGINT PK
  - `from_asset_code` VARCHAR(32) NOT NULL
  - `to_asset_code` VARCHAR(32) NOT NULL
  - `from_amount` BIGINT NOT NULL（例如 100）
  - `to_amount` BIGINT NOT NULL（建议固定为 1，减少解释成本）
  - `effective_at` DATETIME NOT NULL（生效时间；用于“改比例后争议/回溯”）
  - `is_enabled` TINYINT(1) NOT NULL DEFAULT 1
  - `created_at / updated_at`
- **约束/索引（强烈建议）**：
  - UNIQUE(`from_asset_code`,`to_asset_code`,`effective_at`)
  - INDEX(`from_asset_code`,`to_asset_code`,`is_enabled`,`effective_at`)

#### 3.4 新增表：`material_transactions`（材料流水：统一使用 asset_code 表达资产类型）
- **定位**：材料变动记录（对账/追溯/反作弊）
- **建议字段（最小集）**：
  - `tx_id` BIGINT PK
  - `user_id` INT NOT NULL
  - `asset_code` VARCHAR(32) NOT NULL
  - `tx_type` ENUM('earn','consume','convert_in','convert_out','admin_adjust') NOT NULL
  - `amount` BIGINT NOT NULL（统一正数，方向由 tx_type 决定）
  - `balance_before` BIGINT NOT NULL
  - `balance_after` BIGINT NOT NULL
  - `business_type` VARCHAR(50~100)
  - `business_id` VARCHAR(100~150) UNIQUE NOT NULL（**幂等键，必填**）
  - `title` VARCHAR(255)
  - `meta` JSON NULL（可选：记录 rule_id、比例快照、order_id 等，降低后续追溯成本）
  - `created_at`

---

### 4. 服务层设计（静态 Service + 事务/幂等/锁）

#### 4.1 新增 `services/MaterialService.js`（静态方法）
- **原则**：所有材料变动必须经由 Service；路由层不直连 models。
- **实现模式**：完全复用 `PointsService` 的关键机制：
  - 支持外部事务：`options.transaction`
  - 自己创建的事务才 commit/rollback
  - 关键余额行使用 `FOR UPDATE`（`transaction.LOCK.UPDATE`）：
    - 扣减/增加某个 `user_id + asset_code` 时锁该行
    - 发生转换时，至少锁 from/to 两行（建议按固定顺序锁，避免死锁）
  - 所有敏感写操作必须使用 `business_id` 幂等

#### 4.2 建议方法清单（最小够用，不扩张）
- `getOrCreateBalance(user_id, asset_code, { transaction })`
- `getUserBalances(user_id, { transaction })`（返回列表或 map）
- `add(user_id, asset_code, amount, { business_id, business_type, title, meta, transaction })`
- `consume(user_id, asset_code, amount, { business_id, business_type, title, meta, transaction })`
- `convertByRule(user_id, rule_id, times = 1, { business_id, business_type, title, transaction })`
  - 一次转换会写两条流水：
    - from：`convert_out`（扣 `from_amount * times`）
    - to：`convert_in`（加 `to_amount * times`）
  - `meta` 里记录：`rule_id`、`from_amount`、`to_amount`、`effective_at`（比例快照）

---

### 5. 抽奖发放对接（把材料发放纳入“强一致 + 可审计”）
在抽奖结果落库的事务内（或抽奖 Service 的事务内）：
- 抽到“红水晶碎片 x8”
  - 调用 `MaterialService.add(user_id, 'red_shard', 8, business_id = lottery_draw_{draw_id}_red_shard, ...)`
- 抽到“完整红水晶 x1”
  - 调用 `MaterialService.add(user_id, 'red_crystal', 1, business_id = lottery_draw_{draw_id}_red_crystal, ...)`

这样材料来源可追溯，重复触发也能靠 `business_id` 幂等兜住。

---

### 6. 合成/分解/升级规则（方案B：由转换规则表驱动）

#### 6.1 核心规则：所有转换都必须落到 `material_conversion_rules`
- **合成/分解只是两条规则**：
  - 合成（示例）：`red_shard (100) -> red_crystal (1)`
  - 分解（示例）：`red_crystal (1) -> red_shard (100)`（你已确认：允许分解、无损耗）
- **升级（跨层）也是规则**：
  - `red_crystal (100) -> orange_shard (1)`
  - `orange_shard (100) -> orange_crystal (1)`

#### 6.2 改比例的方式（实用主义：不覆盖旧规则，新增未来生效规则）
- 管理后台修改比例时：
  - 不要 UPDATE 覆盖旧规则
  - 新增一条 `effective_at` 为未来时间（或即时）的新规则
  - 旧规则保留：用于历史审计、对账回放、用户争议解释

#### 6.3 兑换辅助转换（你已确认：允许自动拆分辅助兑换，但要控制范围）
- **原则**：自动辅助只用于“用户直觉强、争议小”的场景
- **推荐约束**：
  - 只允许 **同一 group_code** 内部转换（例如 `red_crystal -> red_shard`）
  - 禁止跨层自动升级（例如 `red_crystal -> orange_shard` 必须显式操作），避免“我怎么突然少了 100 红水晶？”这类争议

---

### 7. 兑换市场改造（关键：支付从“背包 SUM value”切到“材料余额扣减”）

#### 7.1 商品兑换条件表达（尽量少动现有表）
现有 `exchange_items`/`exchange_market_records` 已存在且在用。建议：
- 在 `exchange_items` 上新增两列（单资产门槛，避免混合争议）：
  - `cost_asset_code` VARCHAR(32) NULL（例如 `red_shard` / `orange_crystal`）
  - `cost_amount` BIGINT NOT NULL DEFAULT 0

示例：
- 兑换条件“8 个红碎片”：`cost_asset_code='red_shard', cost_amount=8`
- 兑换条件“1 个橙水晶”：`cost_asset_code='orange_crystal', cost_amount=1`

#### 7.2 兑换流程（仍为单库事务，一次性完成）
在 `ExchangeMarketService.exchangeItem(...)` 的事务内：
1) 幂等检查：`ExchangeMarketRecord.business_id UNIQUE`
2) 锁商品行（防超卖）
3) 锁用户余额行（`user_material_balances FOR UPDATE`）
4) 校验余额是否足够（shards/crystals）
5) 扣材料：调用 `MaterialService.consume(user_id, cost_asset_code, cost_amount, { transaction })`
6) 创建订单：`ExchangeMarketRecord.create(...)`
7) 扣库存/销量字段
8) 记录审计（建议复用现有审计服务，确保可追溯）

> 这样天然支持“部分扣减”，不会再出现“总额够但扣不动”的问题。

#### 7.3 已确认：允许“自动拆分辅助兑换”（不引入混合门槛）
本方案确认：**允许自动拆分辅助兑换**，用于解决“用户有水晶但碎片不足”的挫败点，同时保持兑换门槛简单：
- **仍不支持混合门槛**：商品只会配置为“只要一种资产”（一个 `cost_asset_code`）。
- **自动拆分触发条件**：
  - 当商品门槛为 `cost_asset_code = red_shard` 且用户 `red_shard` 不足
  - 系统允许在兑换流程中**自动执行同组拆分规则**（例如 `red_crystal -> red_shard`）补足差额（无损耗）
- **推荐实现策略（低复杂度、好审计）**：
  - 在同一事务中按需执行：
    1) 读取当前余额：`current_balance = balance(cost_asset_code)`（例如 `balance('red_shard')`）
    2) 计算缺口 `missing = cost_amount - current_balance`
    2) 找到“同组拆分规则”：`red_crystal (1) -> red_shard (100)` 且当前时间 >= effective_at（取最新生效）
    3) 计算需要拆分次数：`times = ceil(missing / to_amount)`（通常 to_amount=100）
    4) `MaterialService.convertByRule(..., rule_id, times, business_id: <order_business_id>_auto_split, transaction)`
    5) 再执行 `MaterialService.consume(..., business_id: <order_business_id>_consume_cost, transaction)`
  - 审计与对账：自动拆分和兑换扣减分别写流水（或 convert+consume 两类流水），便于追溯“为啥碎片突然变多又变少”。

---

### 8. API 设计（保持现有路由风格，新增最少端点）

#### 8.1 用户端材料接口（建议新增）
- `GET /api/v4/material/balances`：返回用户所有材料余额（列表，含 `asset_code/balance/display_name`）
- `POST /api/v4/material/convert`：按转换规则执行转换
  - body：`rule_id`, `times`(默认1), `business_id`
  - 返回：转换前后余额变化（至少返回 from/to 的 before/after）

#### 8.2 兑换市场接口（尽量不改路径）
- 继续使用现有 `/api/v4/exchange_market/*`
- 只是支付逻辑改为扣 `user_material_balances` 的余额
- 自动拆分辅助兑换在后端内部完成（无需小程序端实现复杂逻辑），但建议在响应中返回：
  - `auto_split_used: true/false`
  - `auto_split_rule_id`（本次自动拆分使用的规则）
  - `auto_split_times`（本次自动拆分执行次数）
  - `remaining`（兑换后关键资产余额）

---

### 9. 幂等、并发与审计（复用你项目已有成熟机制）

#### 9.1 幂等
- **所有材料变动必须携带 `business_id`**（抽奖发放、合成/分解、兑换扣减、管理员调整）。
- 数据库保证：`material_transactions.business_id UNIQUE`。
- Service 保证：先查 `business_id` 是否已存在，存在则返回原结果（必要时做参数一致性校验）。

#### 9.2 并发
- 对用户余额行使用 `FOR UPDATE`：
  - 避免并发扣减导致余额变负
  - 保证“余额扣减/转换/创建订单”等操作在同一事务里强一致

#### 9.3 审计与追溯
- 对“兑换扣减、合成/分解、管理员调整”等敏感操作：
  - 记录可追溯日志（包含 `business_id/user_id/order_no/amount` 等关键字段）
  - 保证出现争议时能回放链路

---

### 10. 迁移落地步骤（最小风险顺序）
1) 新增表（migrations）：`material_asset_types`、`user_material_balances`、`material_conversion_rules`、`material_transactions`
2) 初始化数据：预置红/橙等基础资产类型与基础转换规则（见第 13 节）
3) 新增 `MaterialService`：实现余额行锁、扣增、转换、流水、事务、幂等
4) 抽奖发放对接：抽奖奖励材料走 `MaterialService.add(user_id, asset_code, ...)`
5) 新增材料 API（balances/convert）
6) 兑换市场改造：`ExchangeMarketService.exchangeItem` 从扣背包 value 改为扣材料余额（并按规则支持同组自动拆分）
7) Web 管理后台：补齐“资产类型管理/转换规则管理/材料余额与流水查询”

---

### 11. 产品取舍点（你需要拍板的两个开关）
1) **分解规则（已确认）**：允许“同组内的完整体 → 碎片”无损耗分解（例如 `red_crystal -> red_shard` 的规则启用）
2) **自动拆分辅助兑换（已确认）**：当兑换成本为“碎片”且碎片不足时，允许在兑换流程中自动执行“同组拆分规则”补足（仍不引入“混合门槛”）

只要确定这两个点，方案就可以按上述步骤稳定落地。

---

### 12. Web 管理后台（`public/admin/*`）需要支持的能力（本方案范围内）

#### 12.1 管理后台页面/功能点（建议最小集）
- **材料资产查看（运营/管理员）**
  - 查看单个用户：其所有 `asset_code -> balance` 的列表（并展示 `display_name`）
  - 按 user_id / 手机号搜索（手机号需后端提供查找接口或复用现有用户查询接口）
- **材料流水查询（对账/排查）**
  - 按 user_id / business_id / 时间范围筛选
  - 展示：asset_code、tx_type、amount、before/after、business_type、title、created_at（可选展示 meta.rule_id/比例快照）
- **兑换商品配置（复用现有市场管理页面）**
  - 在现有“兑换市场商品管理”里增加/展示配置字段：
    - `cost_asset_code`、`cost_amount`
  - 明确 UI 约束：必须选择一种资产（下拉来自 `material_asset_types`），且 `cost_amount > 0`（避免混合门槛/争议）

- **材料资产类型管理（新增页面，必要且低维护）**
  - 新增/禁用材料类型：`asset_code/display_name/group_code/form/tier/sort_order/is_enabled`
  - 说明：新增更高级水晶种类只需要在这里新增一条记录（不改表结构）

- **材料转换规则管理（新增页面，必要且低维护）**
  - 新增/禁用转换规则：`from_asset_code -> to_asset_code`、`from_amount/to_amount`、`effective_at`
  - 改比例的正确方式：新增一条未来生效规则，不覆盖旧规则（降低争议与回溯成本）

#### 12.2 管理后台调用的后端接口（建议）
- **读取材料余额/流水（Admin）**
  - `GET /api/v4/admin/material/users/:user_id/balance`
  - `GET /api/v4/admin/material/transactions?user_id=&business_id=&start=&end=&page=&page_size=`
- **资产类型与转换规则（Admin）**
  - `GET /api/v4/admin/material/asset-types`
  - `POST /api/v4/admin/material/asset-types`
  - `PUT /api/v4/admin/material/asset-types/:asset_code`
  - `GET /api/v4/admin/material/conversion-rules`
  - `POST /api/v4/admin/material/conversion-rules`
  - `PUT /api/v4/admin/material/conversion-rules/:rule_id`
- **兑换商品配置（Admin Marketplace）**
  - 继续复用现有：`/api/v4/admin/marketplace/exchange_market/items`（create/update 时携带 cost_* 字段）

> 注：Web 管理后台是静态页面模式（`app.js` 已托管 `/admin`），因此只需要补齐对应页面 JS 调用上述 API 即可。

---

### 13. 初始化数据（方案B必须：预置资产类型与基础转换规则）
为了让系统“开箱可用”，建议通过 migrations 或 seed 初始化：
- **资产类型（示例最小集）**
  - `red_shard`（红水晶碎片）
  - `red_crystal`（完整红水晶）
  - `orange_shard`（橙水晶碎片）
  - `orange_crystal`（完整橙水晶）
- **转换规则（示例）**
  - `red_shard (100) -> red_crystal (1)`（合成）
  - `red_crystal (1) -> red_shard (100)`（分解，无损耗）
  - `red_crystal (100) -> orange_shard (1)`（升级）
  - `orange_shard (100) -> orange_crystal (1)`（合成）

> 注意：比例调整应通过“新增未来生效规则”实现，不建议直接覆盖既有规则，避免后续对账与争议解释成本陡增。

---

### 14. 抽奖双账户模式（可见积分做门票 + 预算账户控出奖）
> 这部分与“材料系统”同属资产体系设计范畴，便于把“抽奖产出材料/水晶/预算”的链路统一到一份文档里。

#### 14.1 业务规则（你已确认的口径）
- **用户可见积分（available_points）决定能不能抽奖**
  - 作用：抽奖资格/门票成本
  - 行为：用户发起抽奖时，按连抽定价扣除可见积分（`PointsService.consumePoints`）
- **预算账户（remaining_budget_points）决定抽中什么奖品**
  - 作用：限制奖池可选范围（控制系统成本）
  - 行为：抽奖选中奖品后，按奖品成本扣减预算，并写入审计字段

#### 14.2 字段职责（数据库层语义）
- **用户积分账户（UserPointsAccount）**
  - `available_points`：用户可见可用积分（抽奖门票/兑换/解锁等）
  - `budget_points / remaining_budget_points / used_budget_points`：系统内部预算账户（用户可见性由产品决定）
- **抽奖记录（LotteryDraw）**
  - `cost_points`：本次抽奖消耗的可见积分（门票成本，用于用户口径统计/对账）
  - `prize_value_points`：本次出奖消耗的预算积分（系统口径成本）
  - `budget_points_before / budget_points_after`：预算扣减审计字段（用于追溯与对账）

#### 14.3 抽奖扣减时机（后端流程约束）
- **扣可见积分（门票）**：抽奖开始时（连抽场景建议一次性扣除总价，使用 batch business_id 幂等）
- **扣预算积分（控出奖）**：奖品确定后（策略层执行），按 `prize_value_points` 从 `remaining_budget_points` 扣减

#### 14.4 奖池筛选逻辑（预算决定可抽奖品范围）
- 只允许从满足条件的奖品中抽取：
  - `prize_value_points <= remaining_budget_points`
- ✅ **已定稿：采用 B（更顺滑）降级策略**
  - 当 `remaining_budget_points` 不足以覆盖任何高价值奖品时：**仍允许抽**，但奖池强制过滤为 `prize_value_points = 0` 的奖品（保持“转盘体验不断”，系统成本可控）
  - 验收口径：预算不足时抽奖请求不报错，但中奖结果的 `prize_value_points` 必须恒等于 0（并保持可见积分门票照常扣减）

#### 14.5 预算的来源（与现有运营配置联动）
- 建议统一由“消费审核通过/活动任务”等入口给用户增加预算：
  - 通过配置项 `budget_allocation_ratio` 计算并分配预算（示例：`budget_points = consumption_amount × ratio`）
- 预算与可见积分分离的价值：
  - 可见积分控制参与频次与门票成本
  - 预算控制系统发奖成本与可中奖品上限

#### 14.6 预算控奖的“启用前置条件”（实用主义：先让它在数据上生效）
> 这部分是为了避免“为了重构而重构”：如果数据口径不启用，预算控奖写得再漂亮也只会变成长期技术债（文档债/解释债/维护债）。

- **当前真实数据现状**（见 1.1）：`prize_value_points` 全为 0、`remaining_budget_points` 全为 0，因此预算控奖目前等同“关闭状态”。
- **要让预算控奖真正生效**，最小前置条件是：
  - **奖品成本口径启用**：运营把高价值奖品配置 `prize_value_points > 0`（否则预算永远不扣）
  - **预算发放口径启用**：消费审核通过/活动任务等入口，给 `remaining_budget_points` 增加余额（否则预算永远为 0）
- **建议的落地顺序（最低维护成本）**：
  - 先做“可见积分门票 + 奖品成本字段配置”（只动配置/运营流程，便于验证）
  - 再做“预算发放与审计”（确保能对账）
  - 最后再逐步把策略层切到“预算筛奖”（避免一次性改动过大导致不可控）

---

### 15.（方案B必选）动态扩展的护栏：防套利/防循环/防争议
> 这部分不是“复杂化”，而是为了长期维护成本：你一旦允许“动态新增资产 + 动态改比例”，没有护栏就会很快堆积成客服争议与对账噩梦。

#### 15.1 防套利（不允许“无损耗双向 + 多路径换算”）
- 同一对资产（A,B）如果同时允许 A→B 与 B→A，必须满足：
  - 比例严格互逆且一致（否则会出现“搬砖套利”）
  - 且后台需要明确标注“是否允许自动辅助”仅限同组内
- 更省事的策略：跨层（tier 上升）的规则只允许“向上”，不允许向下（将“回退/降级”留给运营人工处理）

#### 15.2 防循环（禁止形成闭环）
- 后台新增/启用规则时做校验：从 `from_asset_code` 出发，不允许通过已有规则走回自身
- 这是避免“无限循环兑换”的底线（否则会直接形成经济系统漏洞）

#### 15.3 防争议（比例变更必须可回放）
- 每条规则必须有 `effective_at`
- 每笔转换/自动辅助兑换的流水 `meta` 必须记录：
  - `rule_id`
  - `from_amount/to_amount`
  - `effective_at`
  - （可选）下单/兑换的业务单号


