# 餐厅积分抽奖系统 - 实际业务功能需求

## 📋 项目概述

**系统名称**：餐厅积分抽奖系统  
**业务场景**：餐厅顾客使用积分参与抽奖活动  
**用户规模**：中小型餐厅（日抽奖量 < 100次）  
**核心目标**：简单、稳定、易维护的积分抽奖功能  
**架构原则**：用最简单的方式实现核心功能，避免过度工程化
管理员身份验证只需要检查
---

## 🎯 核心功能需求 (基于主体功能实现.md)

### 功能1：基础积分抽奖
**需求描述**：用户使用积分参与抽奖，根据固定概率获得奖品

**具体要求**：
- **积分消耗**：每次抽奖消耗100积分
- **参与条件**：用户积分 ≥ 100分
- **抽奖次数**：每日最多10次 (测试账号不限)
- **测试账号**：13612227930 可无限抽奖

**奖品配置（固定概率）**：
```
1号奖品：八八折券     - 0%概率   (仅管理员预设)
2号奖品：100积分      - 30%概率
3号奖品：甜品1份      - 20%概率  
4号奖品：青菜1份      - 30%概率
5号奖品：2000积分券   - 1%概率
6号奖品：500积分券    - 18%概率
7号奖品：精品首饰一个 - 1%概率
8号奖品：生腌拼盘158  - 0%概率  (仅管理员预设)
```

**实现方式**：
- 使用简单的概率数组配置
- 随机数对比实现概率抽奖
- 无需复杂的概率计算引擎

**业务逻辑**：
1. 验证用户积分是否足够
2. 检查今日抽奖次数限制
3. 执行固定概率抽奖
4. 扣除积分
5. 记录抽奖结果
6. 返回中奖信息

### 功能2：管理员预设奖品（数据库优先查询机制）
**需求描述**：管理员通过脚本给特定用户预先分配指定奖品，用户抽奖时优先获得

**具体要求**：
- **分配方式**：管理员通过脚本将预设奖品写入数据库
- **优先级**：用户抽奖时首先查询数据库中的预设奖品
- **消耗规则**：预设奖品按顺序发放完毕后，进入正常概率抽奖
- **数据表**：使用现有的 `user_specific_prize_queue` 表
- **状态管理**：'pending' → 'distributed' → 完成

**技术实现机制**：
```javascript
// 1. 管理员设置预设奖品（脚本执行）
await UserSpecificPrizeQueue.createUserQueue(
  13612227930,  // 用户ID
  1,            // 活动ID
  [
    { prize_number: 3, name: '甜品1份', queue_order: 1 },
    { prize_number: 5, name: '2000积分券', queue_order: 2 },
    { prize_number: 7, name: '精品首饰', queue_order: 3 }
  ],
  999,          // 管理员ID
  '特殊奖品分配'
)

// 2. 用户抽奖时优先查询（数据库查询优先级）
const specificPrize = await UserSpecificPrizeQueue.findOne({
  where: { user_id: userId, status: 'pending' },
  order: [['queue_order', 'ASC']]
})
```

**业务逻辑**：
1. 检查用户是否有预设奖品 (status = 'pending')
2. 如有预设奖品，直接返回该奖品
3. 更新预设奖品状态为 'distributed'
4. 如无预设奖品，执行正常概率抽奖

### 功能3：保底机制（可配置次数）
**需求描述**：用户连续抽奖未中奖时，提供保底奖品

**具体要求**：
- **保底次数**：连续10次或20次未中奖（可配置）
- **保底奖品**：九八折券
- **计数规则**：中奖后重置计数器
- **适用范围**：所有用户(包括测试账号)
- **实现方式**：简单计数器判断，无需复杂算法

**配置示例**：
```javascript
const guaranteeConfig = {
  failureCount: 10,        // 保底触发次数
  guaranteePrize: '九八折券'  // 保底奖品
}
```

**业务逻辑**：
1. 查询用户最近的抽奖记录
2. 计算连续未中奖次数
3. 如达到配置次数，强制返回保底奖品
4. 中奖后重置未中奖计数

### 功能4：积分管理（简化事务处理）
**需求描述**：处理抽奖相关的积分扣除和奖励

**具体要求**：
- **扣除积分**：每次抽奖扣除100积分
- **奖励积分**：中奖积分类奖品时增加积分
- **事务安全**：确保积分操作的原子性
- **余额检查**：抽奖前验证积分余额
- **实现方式**：简单的数据库事务，无需复杂的事务管理器

**业务逻辑**：
1. 开启数据库事务
2. 锁定用户积分账户
3. 扣除抽奖消耗积分
4. 如中奖积分类奖品，增加对应积分
5. 提交事务

---

## 🎱 奖品池管理（简化实现）

### 奖品池配置方式
```javascript
// 简单的奖品池配置（无需复杂管理系统）
const prizePools = {
  // 基础奖品池（日常抽奖）
  basic: [
    { id: 2, name: '100积分', probability: 0.30 },
    { id: 3, name: '甜品1份', probability: 0.20 },
    { id: 4, name: '青菜1份', probability: 0.30 },
    { id: 6, name: '500积分券', probability: 0.18 }
  ],
  
  // 稀有奖品池（低概率）
  rare: [
    { id: 5, name: '2000积分券', probability: 0.01 },
    { id: 7, name: '精品首饰一个', probability: 0.01 }
  ],
  
  // 特殊奖品池（管理员专用）
  special: [
    { id: 1, name: '八八折券', probability: 0.0 },
    { id: 8, name: '生腌拼盘158', probability: 0.0 }
  ]
}
```

### 实现说明
- **无需复杂的奖品池管理系统**
- **使用简单的配置文件**
- **支持2-3个奖品池的基本分组**
- **无需动态权重计算**

---

## 🚫 明确不需要的复杂功能 (V4架构的过度设计)

### 删除的企业级功能
- ❌ **复杂权限系统**：5级管理员权限 (super_admin, admin, moderator, viewer)
- ❌ **实时监控系统**：6个性能监控点
- ❌ **用户画像分析**：50+字段的用户分析
- ❌ **智能缓存系统**：复杂的缓存策略
- ❌ **完整日志审计**：详细的操作日志记录
- ❌ **策略决策引擎**：复杂的策略选择算法
- ❌ **动态概率计算**：实时概率调整算法
- ❌ **多维度数据收集**：用户行为分析系统

### 删除的过度抽象组件
- ❌ **DecisionCore**：决策核心引擎 (393行)
- ❌ **ContextBuilder**：上下文构建器 (492行)
- ❌ **ResultGenerator**：结果生成器 (422行)
- ❌ **PerformanceMonitor**：性能监控器 (310行)
- ❌ **DataCollector**：数据收集器 (849行)
- ❌ **CacheManager**：缓存管理器 (131行)

---

## 📊 简化前后对比

### V4复杂架构 (不需要)
```
功能实现代码：5,343行
涉及文件：11个核心文件 + 工具类
依赖关系：复杂的多层依赖
维护成本：高（需要专业团队）
学习成本：高（需要深度学习架构）
故障排查：困难（多层调用链）
适用场景：企业级大型抽奖平台
```

### 实际需求实现 (应该这样)
```
功能实现代码：200-300行
涉及文件：1个核心文件
依赖关系：直接调用数据库和模型
维护成本：低（任何开发者可维护）
学习成本：低（30分钟理解）
故障排查：简单（直接定位问题）
适用场景：中小型餐厅抽奖系统
```

---

## 🛠️ 技术实现要求

### 数据库表使用
```sql
-- 核心使用的表（已存在）
user_points_accounts        -- 用户积分账户
lottery_records            -- 抽奖记录
user_specific_prize_queue   -- 管理员预设奖品（优先查询）
lottery_campaigns          -- 抽奖活动（可选）
```

### API接口设计（RESTful）
```
POST /api/v4/unified-engine/lottery/execute  -- 执行抽奖（核心接口）
GET  /api/lottery/history        -- 抽奖历史
POST /api/admin/assign-prizes    -- 管理员分配预设奖品
GET  /api/admin/queue-status     -- 查看预设奖品队列状态
```

### 核心业务流程（优化后）
```
1. 用户发起抽奖请求
2. 验证积分余额 >= 100
3. 检查今日抽奖次数 <= 10
4. 优先查询预设奖品数据库 (user_specific_prize_queue)
5. 如有预设奖品 → 返回预设奖品，更新状态为'distributed'
6. 如无预设奖品 → 检查保底机制（连续失败次数）
7. 如需保底 → 返回保底奖品
8. 正常情况 → 固定概率抽奖
9. 扣除100积分（数据库事务）
10. 记录抽奖结果
11. 返回中奖信息
```

### 文件结构（极简化）
```
services/
└── RestaurantLottery.js     -- 核心抽奖服务（200-300行）

scripts/
└── assign-specific-prizes.js -- 管理员分配预设奖品脚本

routes/
└── lottery.js               -- API路由定义
```

---

## ✅ 验收标准

### 功能验收
- [ ] 用户可以正常抽奖 (消耗100积分)
- [ ] 固定概率分布符合配置要求
- [ ] 预设奖品优先抽取（数据库优先查询机制）
- [ ] 预设奖品按队列顺序发放
- [ ] 预设奖品状态正确更新（pending → distributed）
- [ ] 保底机制正常触发 (10次或20次未中奖)
- [ ] 测试账号13612227930可无限抽奖
- [ ] 积分扣除和奖励正确
- [ ] 2-3个奖品池配置生效

### 技术验收
- [ ] 单次抽奖响应时间 < 500ms
- [ ] 支持并发抽奖 (10用户同时)
- [ ] 数据库事务正确处理
- [ ] 预设奖品脚本正常执行
- [ ] API接口符合RESTful规范

### 维护性验收
- [ ] 代码总行数 < 300行
- [ ] 单一文件实现核心功能
- [ ] 新人30分钟内理解代码逻辑
- [ ] 修改奖品概率只需修改配置
- [ ] 预设奖品分配操作简单明了
- [ ] 保底次数可配置修改

### 管理功能验收
- [ ] 管理员可通过脚本给用户分配预设奖品
- [ ] 可查看用户的预设奖品队列状态
- [ ] 可查看预设奖品的发放统计
- [ ] 支持批量分配预设奖品

---

## 🎯 项目成功标准

**简单易懂**：任何开发者都能快速理解和维护  
**功能完整**：满足餐厅积分抽奖的所有核心需求  
**性能稳定**：支持餐厅的实际业务负载  
**成本可控**：开发和维护成本最小化  
**易于扩展**：可轻松调整概率、保底次数等配置  

---

## 🔧 实施要点

### 开发原则
1. **简单优于复杂**：能用简单方法实现的绝不用复杂架构
2. **数据库优先**：预设奖品等逻辑直接基于数据库查询
3. **配置驱动**：概率、保底次数等通过配置文件管理
4. **单一职责**：一个文件实现一个完整功能
5. **测试友好**：逻辑简单，易于测试和验证

### 关键决策
- ✅ 使用数据库优先查询机制实现预设奖品
- ✅ 使用简单配置数组管理奖品池
- ✅ 使用固定概率而非动态概率计算
- ✅ 使用简单计数器实现保底机制
- ✅ 避免所有V4架构的复杂组件

---

**总结**：这是一个"餐厅煎饼摊"的需求，不需要"迪士尼乐园管理系统"。保持简单，专注核心业务价值，用最直接的方式实现最实用的功能。 