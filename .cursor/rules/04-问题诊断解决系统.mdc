---
alwaysApply: true
lastUpdated: 2025年10月03日 17:05:11
---

# 🔍 问题诊断解决系统（基于cursor文档混淆案例的标准化解决方案）

## 🔴 **基于实际诊断错误的优化体系**

### **实际诊断效率问题量化统计**
从11个cursor文档分析发现：
- **诊断方向错误率**: 30%的时间浪费在错误方向上
- **症状与根因混淆**: 多次治标不治本，浪费15-20分钟
- **状态检查重复**: 同一状态被检查3-8次
- **诊断时间过长**: 平均15-20分钟（目标：2-5分钟内）

### **典型误诊案例分析**
**案例1 - API缺失误判**（cursor文档多次出现）
- 表面症状: 前端请求失败，认为API不存在
- 错误诊断: 以为后端缺少API实现  
- 实际根因: 认证权限问题，API存在但需要管理员权限
- 时间浪费: 20分钟（应该2分钟定位）

**案例2 - 服务状态误判**（cursor_8.md案例）
- 表面症状: 健康检查失败
- 错误诊断: 认为服务没有启动
- 实际根因: 服务正常，网络配置问题
- 时间浪费: 15分钟（应该1分钟定位）

## ⚡ **2分钟快速诊断系统**

### **超快速问题分类和定位**
```javascript
// 🔴 基于实际案例优化的快速诊断系统（替代5分钟诊断）
const RAPID_DIAGNOSIS_SYSTEM = {
  // 问题分类决策树（30秒内完成分类）
  classifyProblem: (symptoms) => {
    // A类：配置问题（30秒-1分钟解决）
    if (symptoms.includes('404') || symptoms.includes('路径') || symptoms.includes('配置')) {
      return {
        type: 'A_CONFIG',
        priority: 'HIGH',
        timeEstimate: 60,
        diagnostic: RAPID_DIAGNOSIS_SYSTEM.diagnoseConfigProblem
      };
    }
    
    // B类：服务问题（1-3分钟解决）
    if (symptoms.includes('连接') || symptoms.includes('端口') || symptoms.includes('进程')) {
      return {
        type: 'B_SERVICE', 
        priority: 'HIGH',
        timeEstimate: 180,
        diagnostic: RAPID_DIAGNOSIS_SYSTEM.diagnoseServiceProblem
      };
    }
    
    // C类：代码问题（3-5分钟解决）
    if (symptoms.includes('TypeError') || symptoms.includes('逻辑') || symptoms.includes('数据')) {
      return {
        type: 'C_CODE',
        priority: 'MEDIUM', 
        timeEstimate: 300,
        diagnostic: RAPID_DIAGNOSIS_SYSTEM.diagnoseCodeProblem
      };
    }
    
    // D类：环境问题（5-10分钟解决）
    return {
      type: 'D_ENVIRONMENT',
      priority: 'MEDIUM',
      timeEstimate: 600,
      diagnostic: RAPID_DIAGNOSIS_SYSTEM.diagnoseEnvironmentProblem
    };
  },

  // A类配置问题快速诊断（30秒完成）
  diagnoseConfigProblem: async (symptoms) => {
    console.log('🔧 A类配置问题诊断...');
    
    // 并行检查常见配置问题
    const [routeCheck, configCheck] = await Promise.allSettled([
      execAsync('grep -r "POST.*upload\\|GET.*inventory" routes/ 2>/dev/null || echo "路由未找到"'),
      execAsync('test -f .env && echo "配置存在" || echo "配置缺失"')
    ]);

    const diagnosis = {
      type: 'A_CONFIG',
      findings: [],
      rootCause: null,
      solution: null
    };

    // 分析结果
    if (routeCheck.status === 'fulfilled' && routeCheck.value.stdout.includes('未找到')) {
      diagnosis.findings.push('路由定义缺失');
      diagnosis.rootCause = 'MISSING_ROUTE';
      diagnosis.solution = 'add_route_mapping';
    }

    if (configCheck.status === 'fulfilled' && configCheck.value.stdout.includes('缺失')) {
      diagnosis.findings.push('环境配置缺失');
      diagnosis.rootCause = 'MISSING_CONFIG';
      diagnosis.solution = 'create_env_file';
    }

    return diagnosis;
  },

  // B类服务问题快速诊断（1分钟完成）
  diagnoseServiceProblem: async (symptoms) => {
    console.log('🏭 B类服务问题诊断...');
    
    // 🚀 并行执行所有服务状态检查（关键优化）
    const [healthCheck, processCheck, portCheck] = await Promise.allSettled([
      execAsync('timeout 10s curl -s http://localhost:3000/health'),
      execAsync('ps aux | grep node | grep -v grep'),
      execAsync('netstat -tlnp | grep :3000')
    ]);

    const diagnosis = { type: 'B_SERVICE', findings: [], rootCause: null, solution: null };

    // 分析健康检查
    if (healthCheck.status === 'fulfilled') {
      try {
        const healthData = JSON.parse(healthCheck.value.stdout);
        if (healthData.status === 'healthy') {
          diagnosis.findings.push('API健康正常');
        }
      } catch {
        diagnosis.findings.push('API响应异常或格式错误');
        diagnosis.rootCause = 'API_ERROR';
        diagnosis.solution = 'restart_service';
      }
    } else {
      diagnosis.findings.push('API无响应');
      diagnosis.rootCause = 'SERVICE_DOWN';
      diagnosis.solution = 'start_service';
    }

    // 分析进程状态
    if (processCheck.status === 'fulfilled') {
      const processCount = processCheck.value.stdout.split('\n').filter(line => 
        line.includes('node') && line.includes('app.js')).length;
      
      if (processCount === 0) {
        diagnosis.findings.push('无Node.js进程运行');
        diagnosis.rootCause = 'NO_PROCESS';
        diagnosis.solution = 'start_service';
      } else if (processCount > 1) {
        diagnosis.findings.push(`${processCount}个重复进程`);
        diagnosis.rootCause = 'DUPLICATE_PROCESSES';
        diagnosis.solution = 'cleanup_processes';
      }
    }

    return diagnosis;
  },

  // C类代码问题快速诊断（2-3分钟完成）
  diagnoseCodeProblem: async (symptoms) => {
    console.log('💻 C类代码问题诊断...');
    
    const diagnosis = { type: 'C_CODE', findings: [], rootCause: null, solution: null };
    
    // 检查常见代码问题
    if (symptoms.includes('TypeError') && symptoms.includes('is not a function')) {
      diagnosis.findings.push('API方法未定义');
      diagnosis.rootCause = 'MISSING_API_METHOD';
      diagnosis.solution = 'implement_api_method';
    }

    if (symptoms.includes('WebSocket') || symptoms.includes('socket')) {
      diagnosis.findings.push('WebSocket功能问题');
      diagnosis.rootCause = 'WEBSOCKET_ERROR';
      diagnosis.solution = 'fix_websocket_implementation';
    }

    return diagnosis;
  },

  // D类环境问题诊断
  diagnoseEnvironmentProblem: async (symptoms) => {
    console.log('🌍 D类环境问题诊断...');
    
    const diagnosis = { type: 'D_ENVIRONMENT', findings: [], rootCause: null, solution: null };
    
    // 检查环境相关问题
    const [nodeVersion, npmList] = await Promise.allSettled([
      execAsync('node --version'),
      execAsync('npm list --depth=0 2>/dev/null || echo "依赖检查失败"')
    ]);

    if (nodeVersion.status === 'rejected') {
      diagnosis.findings.push('Node.js环境问题');
      diagnosis.rootCause = 'NODE_ENV_ERROR';
      diagnosis.solution = 'fix_node_environment';
    }

    if (npmList.status === 'fulfilled' && npmList.value.stdout.includes('失败')) {
      diagnosis.findings.push('依赖包问题');
      diagnosis.rootCause = 'DEPENDENCY_ERROR';
      diagnosis.solution = 'reinstall_dependencies';
    }

    return diagnosis;
  }
};
```

## 🚀 **快速解决方案执行库**

### **基于问题类型的标准解决方案**
```javascript
// 🔴 基于实际解决经验的快速方案库
const RAPID_SOLUTION_LIBRARY = {
  // A类配置问题解决方案（1-2分钟执行）
  configSolutions: {
    add_route_mapping: async (diagnosis) => {
      console.log('🔧 添加API路径映射...');
      
      // 基于cursor_1.md等发现的路径映射需求
      const routeMappings = [
        "app.use('/api/upload', require('./routes/photo'));",
        "app.use('/admin/chat/sessions', require('./routes/admin-chat'));",
        "app.use('/api/inventory', require('./routes/inventory'));"
      ];

      for (const mapping of routeMappings) {
        try {
          await execAsync(`echo "${mapping}" >> app.js`);
          console.log(`✅ 添加路由映射: ${mapping.split('(')[0]}`);
        } catch (error) {
          console.warn(`⚠️ 路由映射失败: ${error.message}`);
        }
      }

      return { success: true, action: 'route_mapping_added' };
    },

    create_env_file: async (diagnosis) => {
      console.log('📄 创建环境配置文件...');
      
      const envTemplate = `# 基础配置
NODE_ENV=development
PORT=3000
JWT_SECRET=development_secret_key

# 数据库配置  
DB_HOST=localhost
DB_PORT=3306
DB_NAME=restaurant_lottery
DB_USER=root
DB_PASSWORD=your_password

# 第三方服务
REDIS_URL=redis://localhost:6379`;

      await require('fs').promises.writeFile('.env', envTemplate);
      console.log('✅ .env文件已创建');

      return { success: true, action: 'env_file_created' };
    }
  },

  // B类服务问题解决方案（30秒-3分钟执行）
  serviceSolutions: {
    start_service: async (diagnosis) => {
      console.log('🚀 启动服务...');
      
      try {
        // 智能选择启动方式
        const hasPM2 = await execAsync('which pm2').then(() => true).catch(() => false);
        
        if (hasPM2) {
          await execAsync('pm2 start app.js --name restaurant-backend');
          console.log('✅ PM2启动成功');
        } else {
          await execAsync('npm start &');
          console.log('✅ 标准启动成功');
        }

        return { success: true, action: 'service_started' };
      } catch (error) {
        console.error('❌ 服务启动失败:', error.message);
        return { success: false, error: error.message };
      }
    },

    cleanup_processes: async (diagnosis) => {
      console.log('🧹 清理重复进程...');
      
      try {
        // 获取所有Node.js进程
        const result = await execAsync('ps aux | grep -E "(node.*app\.js|npm.*dev)" | grep -v grep');
        const processes = result.stdout.split('\n').filter(line => line.trim());
        
        if (processes.length > 1) {
          // 保留最新的进程，清理其他
          const pids = processes.map(line => line.split(/\s+/)[1]);
          const newestPid = pids[pids.length - 1]; // 最后一个通常是最新的
          
          for (const pid of pids) {
            if (pid !== newestPid) {
              await execAsync(`kill -TERM ${pid}`).catch(() => 
                execAsync(`kill -KILL ${pid}`));
              console.log(`🗑️ 清理进程: PID ${pid}`);
            }
          }
          
          console.log(`✅ 保留进程: PID ${newestPid}`);
        }

        return { success: true, action: 'processes_cleaned' };
      } catch (error) {
        console.error('❌ 进程清理失败:', error.message);
        return { success: false, error: error.message };
      }
    },

    restart_service: async (diagnosis) => {
      console.log('🔄 重启服务...');
      
      try {
        // 先尝试优雅重启
        await execAsync('pm2 restart all').catch(async () => {
          // PM2失败则手动重启
          await execAsync('pkill -f "node.*app.js"');
          await new Promise(resolve => setTimeout(resolve, 2000));
          await execAsync('npm start &');
        });

        // 验证重启效果
        await new Promise(resolve => setTimeout(resolve, 3000));
        const healthCheck = await execAsync('timeout 10s curl -s http://localhost:3000/health');
        
        if (healthCheck.stdout.includes('healthy')) {
          console.log('✅ 服务重启成功');
          return { success: true, action: 'service_restarted' };
        } else {
          throw new Error('重启后健康检查仍然失败');
        }
      } catch (error) {
        console.error('❌ 服务重启失败:', error.message);
        return { success: false, error: error.message };
      }
    }
  },

  // C类代码问题解决方案（3-5分钟执行）
  codeSolutions: {
    implement_api_method: async (diagnosis) => {
      console.log('💻 实现缺失的API方法...');
      
      // 基于cursor_5.md等发现的缺失API方法
      const apiMethods = {
        getUserInventory: {
          url: '/api/v2/inventory/list',
          method: 'GET'
        },
        useInventoryItem: {
          url: '/api/v2/inventory/use', 
          method: 'POST'
        }
      };

      let implementedCount = 0;
      for (const [methodName, config] of Object.entries(apiMethods)) {
        try {
          // 检查方法是否已存在
          const apiFile = await require('fs').promises.readFile('./utils/api.js', 'utf8');
          
          if (!apiFile.includes(methodName)) {
            // 添加缺失的API方法
            const methodImplementation = `
  // ${config.method} ${config.url}
  ${methodName}: async (params = {}) => {
    ${config.method === 'GET' ? 
      `const query = new URLSearchParams(params).toString();
       return await request({ url: '${config.url}?' + query, method: '${config.method}' });` :
      `return await request({ url: '${config.url}', method: '${config.method}', data: params });`
    }
  },`;

            await require('fs').promises.appendFile('./utils/api.js', methodImplementation);
            console.log(`✅ 实现API方法: ${methodName}`);
            implementedCount++;
          }
        } catch (error) {
          console.warn(`⚠️ 实现${methodName}失败: ${error.message}`);
        }
      }

      return { 
        success: implementedCount > 0, 
        action: `implemented_${implementedCount}_methods`,
        count: implementedCount 
      };
    },

    fix_websocket_implementation: async (diagnosis) => {
      console.log('📡 修复WebSocket实现...');
      
      // 基于cursor_3.md发现的WebSocket被注释问题
      try {
        const wsFile = await require('fs').promises.readFile('./services/webSocketService.js', 'utf8');
        
        // 取消注释WebSocket方法调用
        const fixedContent = wsFile.replace(/\/\/ (webSocketService\.\w+)/g, '$1');
        
        await require('fs').promises.writeFile('./services/webSocketService.js', fixedContent);
        console.log('✅ WebSocket方法调用已恢复');

        return { success: true, action: 'websocket_uncommented' };
      } catch (error) {
        console.error('❌ WebSocket修复失败:', error.message);
        return { success: false, error: error.message };
      }
    }
  },

  // D类环境问题解决方案
  environmentSolutions: {
    fix_node_environment: async (diagnosis) => {
      console.log('🌍 修复Node.js环境...');
      
      // 检查并修复Node.js环境问题
      try {
        await execAsync('node --version');
        console.log('✅ Node.js环境正常');
        return { success: true, action: 'node_env_verified' };
      } catch (error) {
        console.error('❌ Node.js环境异常，建议重新安装');
        return { success: false, action: 'node_reinstall_needed' };
      }
    },

    reinstall_dependencies: async (diagnosis) => {
      console.log('📦 重新安装依赖包...');
      
      try {
        await execAsync('rm -rf node_modules package-lock.json');
        await execAsync('npm install');
        console.log('✅ 依赖重装成功');
        return { success: true, action: 'dependencies_reinstalled' };
      } catch (error) {
        console.error('❌ 依赖重装失败:', error.message);
        return { success: false, error: error.message };
      }
    }
  }
};
```

## 🎯 **症状与根因快速区分系统**

### **智能根因分析算法**
```bash
#!/bin/bash
# 🔴 快速根因分析脚本（90秒内完成）

rapid_root_cause_analysis() {
  local symptom="$1"
  local start_time=$(date +%s)
  
  echo "🔍 快速根因分析: $symptom"
  
  # 第1步：症状分类（30秒）
  case "$symptom" in
    *"404"*|*"路径"*)
      PROBLEM_TYPE="A_CONFIG"
      echo "📂 识别为配置问题"
      ;;
    *"连接"*|*"端口"*|*"进程"*)
      PROBLEM_TYPE="B_SERVICE" 
      echo "🏭 识别为服务问题"
      ;;
    *"TypeError"*|*"function"*)
      PROBLEM_TYPE="C_CODE"
      echo "💻 识别为代码问题"
      ;;
    *)
      PROBLEM_TYPE="D_ENVIRONMENT"
      echo "🌍 识别为环境问题"
      ;;
  esac
  
  # 第2步：并行根因检查（60秒）
  echo "🚀 并行执行根因检查..."
  
  case $PROBLEM_TYPE in
    "A_CONFIG")
      {
        grep -r "POST.*upload\|GET.*inventory" routes/ &
        test -f .env && echo "ENV_EXISTS" || echo "ENV_MISSING" &
        curl -I http://localhost:3000/api/upload &
      } | tee /tmp/config_check.log
      wait
      
      if grep -q "ENV_MISSING" /tmp/config_check.log; then
        ROOT_CAUSE="配置文件缺失"
        SOLUTION="create_env_file"
      elif ! grep -q "routes/" /tmp/config_check.log; then
        ROOT_CAUSE="路由定义缺失" 
        SOLUTION="add_route_mapping"
      else
        ROOT_CAUSE="API权限问题"
        SOLUTION="check_permissions"
      fi
      ;;
      
    "B_SERVICE")
      {
        timeout 10s curl -s http://localhost:3000/health &
        ps aux | grep node | grep -v grep &
        netstat -tlnp | grep :3000 &
      } | tee /tmp/service_check.log
      wait
      
      if grep -q '"status":"healthy"' /tmp/service_check.log; then
        ROOT_CAUSE="网络配置问题"
        SOLUTION="check_network_config"
      elif ! grep -q ":3000" /tmp/service_check.log; then
        ROOT_CAUSE="服务未启动"
        SOLUTION="start_service"
      else
        ROOT_CAUSE="进程冲突"
        SOLUTION="cleanup_processes"
      fi
      ;;
      
    *)
      ROOT_CAUSE="需要详细诊断"
      SOLUTION="detailed_analysis"
      ;;
  esac
  
  # 清理临时文件
  rm -f /tmp/*_check.log
  
  local end_time=$(date +%s)
  local duration=$((end_time - start_time))
  
  echo "✅ 根因分析完成 (${duration}秒)"
  echo "🎯 问题类型: $PROBLEM_TYPE"
  echo "🔍 根本原因: $ROOT_CAUSE"
  echo "🔧 解决方案: $SOLUTION"
  
  return 0
}
```

## 📊 **问题解决效果监控**

### **解决方案执行监控和验证**
```javascript
const SOLUTION_MONITOR = {
  // 解决方案执行监控
  executeSolution: async (problemType, solution, diagnosis) => {
    const startTime = Date.now();
    console.log(`🔧 执行解决方案: ${solution} (问题类型: ${problemType})`);
    
    let result;
    try {
      // 根据问题类型选择解决方案
      switch (problemType) {
        case 'A_CONFIG':
          result = await RAPID_SOLUTION_LIBRARY.configSolutions[solution](diagnosis);
          break;
        case 'B_SERVICE':
          result = await RAPID_SOLUTION_LIBRARY.serviceSolutions[solution](diagnosis);
          break;
        case 'C_CODE':
          result = await RAPID_SOLUTION_LIBRARY.codeSolutions[solution](diagnosis);
          break;
        case 'D_ENVIRONMENT':
          result = await RAPID_SOLUTION_LIBRARY.environmentSolutions[solution](diagnosis);
          break;
        default:
          throw new Error(`未知问题类型: ${problemType}`);
      }

      const executionTime = Date.now() - startTime;
      
      // 验证解决效果
      const verification = await SOLUTION_MONITOR.verifySolution(problemType, result);
      
      console.log(`📊 解决方案执行完成:`);
      console.log(`   ⏱️ 执行时间: ${executionTime}ms`);
      console.log(`   ✅ 执行状态: ${result.success ? '成功' : '失败'}`);
      console.log(`   🔍 验证结果: ${verification.verified ? '通过' : '失败'}`);

      return {
        executionTime,
        result,
        verification,
        overallSuccess: result.success && verification.verified
      };
    } catch (error) {
      const executionTime = Date.now() - startTime;
      console.error(`❌ 解决方案执行失败 (${executionTime}ms):`, error.message);
      
      return {
        executionTime,
        result: { success: false, error: error.message },
        verification: { verified: false },
        overallSuccess: false
      };
    }
  },

  // 解决效果验证
  verifySolution: async (problemType, solutionResult) => {
    if (!solutionResult.success) {
      return { verified: false, reason: 'solution_execution_failed' };
    }

    try {
      switch (problemType) {
        case 'A_CONFIG':
        case 'C_CODE':
          // 验证API是否可访问
          const apiCheck = await execAsync('timeout 10s curl -I http://localhost:3000/api/upload');
          return { 
            verified: !apiCheck.stdout.includes('404'), 
            reason: 'api_accessibility_check' 
          };
          
        case 'B_SERVICE':
          // 验证服务是否正常响应
          const healthCheck = await execAsync('timeout 10s curl -s http://localhost:3000/health');
          return { 
            verified: healthCheck.stdout.includes('healthy'), 
            reason: 'service_health_check' 
          };
          
        case 'D_ENVIRONMENT':
          // 验证环境是否就绪
          const envCheck = await execAsync('node --version && npm --version');
          return { 
            verified: envCheck.stdout.includes('v'), 
            reason: 'environment_check' 
          };
          
        default:
          return { verified: true, reason: 'no_verification_needed' };
      }
    } catch (error) {
      return { verified: false, reason: 'verification_failed', error: error.message };
    }
  }
};
```

## 🔄 **问题解决自动化工作流**

### **端到端自动化问题解决脚本**
```bash
#!/bin/bash
# 问题解决自动化工作流脚本

auto_solve_problem() {
  local symptom="$1"
  local start_time=$(date +%s)
  
  echo "🤖 启动自动化问题解决流程..."
  echo "🎯 症状描述: $symptom"
  
  # 第1步：快速根因分析（90秒）
  echo "🔍 第1步：快速根因分析..."
  rapid_root_cause_analysis "$symptom"
  
  # 从分析结果获取解决方案
  local solution=$SOLUTION
  local problem_type=$PROBLEM_TYPE
  
  # 第2步：执行解决方案（30秒-3分钟）
  echo "🔧 第2步：执行解决方案 ($solution)..."
  
  case $solution in
    "create_env_file")
      echo "📄 创建.env配置文件..."
      cat > .env << EOF
NODE_ENV=development
PORT=3000
JWT_SECRET=dev_secret
DB_HOST=localhost
DB_PORT=3306
DB_NAME=restaurant_lottery
EOF
      echo "✅ .env文件已创建"
      ;;
      
    "add_route_mapping")
      echo "🔧 添加路由映射..."
      echo "app.use('/api/upload', require('./routes/photo'));" >> app.js
      echo "✅ 路由映射已添加"
      ;;
      
    "start_service")
      echo "🚀 启动服务..."
      if command -v pm2 &> /dev/null; then
        pm2 start app.js --name restaurant-backend
      else
        npm start &
      fi
      echo "✅ 服务启动完成"
      ;;
      
    "cleanup_processes")
      echo "🧹 清理进程冲突..."
      cleanup_process_conflicts
      ;;
      
    *)
      echo "⚠️ 未识别的解决方案: $solution"
      ;;
  esac
  
  # 第3步：验证解决效果（30秒）
  echo "🔍 第3步：验证解决效果..."
  sleep 3
  
  # 根据问题类型验证效果
  case $problem_type in
    "A_CONFIG"|"C_CODE")
      if timeout 10s curl -I http://localhost:3000/api/upload 2>/dev/null | grep -q "200\|302"; then
        echo "✅ API验证通过"
        VERIFICATION_PASSED=true
      else
        echo "❌ API验证失败"
        VERIFICATION_PASSED=false
      fi
      ;;
      
    "B_SERVICE")
      if timeout 10s curl -s http://localhost:3000/health 2>/dev/null | grep -q "healthy"; then
        echo "✅ 服务验证通过" 
        VERIFICATION_PASSED=true
      else
        echo "❌ 服务验证失败"
        VERIFICATION_PASSED=false
      fi
      ;;
      
    *)
      VERIFICATION_PASSED=true
      ;;
  esac
  
  # 生成结果报告
  local end_time=$(date +%s)
  local total_duration=$((end_time - start_time))
  
  echo ""
  echo "📊 === 问题解决报告 ==="
  echo "🎯 问题类型: $problem_type"
  echo "🔧 解决方案: $solution"
  echo "⏱️ 总耗时: ${total_duration}秒"
  echo "✅ 验证结果: $([ $VERIFICATION_PASSED = true ] && echo "通过" || echo "失败")"
  
  if [ $VERIFICATION_PASSED = true ]; then
    echo "🎉 问题已成功解决"
    return 0
  else
    echo "⚠️ 问题解决不完全，可能需要手工干预"
    return 1
  fi
}
```

## 📈 **问题解决效率统计系统**

### **解决效率监控和改进**
```javascript
const PROBLEM_SOLVING_ANALYTICS = {
  // 问题解决统计数据
  statistics: {
    totalProblems: 0,
    solvedProblems: 0,
    averageTime: 0,
    solutionSuccess: new Map(),
    problemTypes: new Map()
  },

  // 记录问题解决过程
  recordProblemSolution: (problemType, solution, executionTime, success) => {
    const stats = PROBLEM_SOLVING_ANALYTICS.statistics;
    
    stats.totalProblems++;
    if (success) stats.solvedProblems++;
    stats.averageTime = (stats.averageTime * (stats.totalProblems - 1) + executionTime) / stats.totalProblems;
    
    // 记录解决方案成功率
    const solutionKey = `${problemType}_${solution}`;
    const current = stats.solutionSuccess.get(solutionKey) || { attempts: 0, successes: 0 };
    stats.solutionSuccess.set(solutionKey, {
      attempts: current.attempts + 1,
      successes: current.successes + (success ? 1 : 0)
    });

    // 记录问题类型分布
    const typeCount = stats.problemTypes.get(problemType) || 0;
    stats.problemTypes.set(problemType, typeCount + 1);
  },

  // 生成效率报告
  generateEfficiencyReport: () => {
    const stats = PROBLEM_SOLVING_ANALYTICS.statistics;
    
    console.log('\n📊 问题解决效率报告');
    console.log('='.repeat(40));
    console.log(`总问题数: ${stats.totalProblems}`);
    console.log(`解决成功: ${stats.solvedProblems} (${(stats.solvedProblems/stats.totalProblems*100).toFixed(1)}%)`);
    console.log(`平均耗时: ${(stats.averageTime/1000).toFixed(1)}秒`);
    
    // 最成功的解决方案
    let bestSolution = { key: '', rate: 0 };
    stats.solutionSuccess.forEach((data, key) => {
      const rate = data.successes / data.attempts;
      if (rate > bestSolution.rate) {
        bestSolution = { key, rate };
      }
    });
    
    if (bestSolution.key) {
      console.log(`🏆 最佳方案: ${bestSolution.key} (${(bestSolution.rate*100).toFixed(1)}%成功率)`);
    }
    
    // 问题类型分布
    console.log('\n📋 问题类型分布:');
    stats.problemTypes.forEach((count, type) => {
      const percentage = (count / stats.totalProblems * 100).toFixed(1);
      console.log(`   ${type}: ${count}次 (${percentage}%)`);
    });
    
    console.log('='.repeat(40));
  }
};
```

## 📋 **问题诊断系统实施检查清单**

### **每次问题诊断前**
- [ ] 明确记录问题症状和错误信息
- [ ] 估计问题复杂度和预期解决时间
- [ ] 选择适当的诊断策略（2分钟 vs 5分钟）
- [ ] 准备并行诊断工具和命令

### **诊断过程中**
- [ ] 严格按照时间限制执行诊断步骤
- [ ] 优先使用并行检查避免串行等待
- [ ] 准确区分症状和根本原因
- [ ] 选择最匹配的解决方案

### **解决方案执行后**
- [ ] 立即验证解决效果
- [ ] 检查是否引入新问题
- [ ] 记录解决过程和耗时
- [ ] 更新解决方案成功率统计

### **问题解决完成后**
- [ ] 分析根本原因和预防措施
- [ ] 更新解决方案知识库
- [ ] 记录经验教训和改进建议
- [ ] 评估整体解决效率

---

**核心原则**: 快速准确定位、症状根因区分、并行诊断执行、标准解决方案、效果验证确认