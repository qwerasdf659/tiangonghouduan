---
alwaysApply: true
---
# APIæŽ¥å£å…¼å®¹æ€§è§„èŒƒï¼ˆåŸºäºŽå®žé™…cursor_5.mdç­‰é—®é¢˜åˆ†æžç‰ˆï¼‰

## ðŸ”´ åŸºäºŽå®žé™…å‘çŽ°çš„APIæŽ¥å£ä¸åŒ¹é…é—®é¢˜

### å®žé™…é—®é¢˜æ¡ˆä¾‹ç»Ÿè®¡
ä»Ž11ä¸ªcursoræ–‡æ¡£æ·±åº¦åˆ†æžå‘çŽ°ï¼š
- **TypeErroré”™è¯¯**: `API.getUserInventory is not a function` (cursor_5.md)
- **è·¯å¾„ä¸åŒ¹é…**: å‰ç«¯æœŸæœ› `/admin/chat/sessions`ï¼ŒåŽç«¯å®žé™… `/api/v2/admin/chat/sessions` (cursor_1.md)
- **æŽ¥å£ç¼ºå¤±**: å‰ç«¯è°ƒç”¨ä¸å­˜åœ¨çš„APIæŽ¥å£ï¼Œè¿”å›ž404é”™è¯¯ (cursor_3.md)
- **ç‰ˆæœ¬ä¸ä¸€è‡´**: å‰ç«¯åŸºäºŽæ—§ç‰ˆAPIæ–‡æ¡£å¼€å‘ï¼ŒåŽç«¯å·²æ›´æ–°æŽ¥å£ (cursor_7.md)

## APIæŽ¥å£å¼ºåˆ¶ä¸€è‡´æ€§æ£€æŸ¥è§„èŒƒ

### å®žé™…å‘çŽ°çš„APIä¸åŒ¹é…æ¨¡å¼
```javascript
// ðŸ”´ cursor_5.mdä¸­å‘çŽ°çš„å®žé™…é”™è¯¯æ¨¡å¼
const API_MISMATCH_PATTERNS = {
  // å‰ç«¯è°ƒç”¨ vs åŽç«¯å®žé™…æŽ¥å£
  inventory_api: {
    frontend_call: 'API.getUserInventory',
    backend_actual: '/api/v2/inventory/list',
    error: 'TypeError: API.getUserInventory is not a function'
  },
  
  chat_admin_api: {
    frontend_call: '/admin/chat/sessions',
    backend_actual: '/api/v2/admin/chat/sessions', 
    error: '404 Not Found'
  },
  
  upload_api: {
    frontend_call: '/api/upload',
    backend_actual: '/api/photo/upload',
    error: 'API endpoint not found'
  },
  
  auth_verify_api: {
    frontend_call: '/api/auth/verify',
    backend_actual: '/api/v2/auth/verify',
    error: 'Route not implemented'
  }
};
```

### APIæŽ¥å£å¼ºåˆ¶å…¼å®¹æ˜ å°„æœºåˆ¶
```javascript
// å¼ºåˆ¶è¦æ±‚ï¼šæ‰€æœ‰APIè·¯å¾„å¿…é¡»æœ‰å…¼å®¹æ€§æ˜ å°„
const COMPATIBLE_API_PATHS = {
  upload_paths: [
    '/api/upload',        // å‰ç«¯æœŸæœ›è·¯å¾„ - cursor_git4.mdä¸­å‘çŽ°
    '/api/photo/upload'   // åŽç«¯å®žé™…è·¯å¾„
  ],
  
  auth_verify_paths: [
    '/api/auth/verify',   // å‰ç«¯æœŸæœ›è·¯å¾„ - cursor_6.mdä¸­å‘çŽ°
    '/api/v1/auth/verify' // åŽç«¯å®žé™…è·¯å¾„
  ],
  
  exchange_stats_paths: [
    '/api/exchange/statistics', // å‰ç«¯æœŸæœ›è·¯å¾„ - cursor_7.mdä¸­å‘çŽ°
    '/api/merchant/statistics'   // åŽç«¯å®žé™…è·¯å¾„
  ],
  
  admin_chat_paths: [
    '/admin/chat/sessions',      // å‰ç«¯æœŸæœ›è·¯å¾„ - cursor_.mdä¸­å‘çŽ°
    '/api/v2/admin/chat/sessions' // åŽç«¯å®žé™…è·¯å¾„
  ],
  
  inventory_paths: [
    '/api/inventory',           // å‰ç«¯æœŸæœ›è·¯å¾„ - cursor_5.mdä¸­å‘çŽ°  
    '/api/v2/inventory/list'    // åŽç«¯å®žé™…è·¯å¾„
  ]
};

// è‡ªåŠ¨ç”Ÿæˆå…¼å®¹æ€§è·¯ç”±
Object.keys(COMPATIBLE_API_PATHS).forEach(pathGroup => {
  const paths = COMPATIBLE_API_PATHS[pathGroup];
  const [frontendPath, backendPath] = paths;
  
  // ä¸ºå‰ç«¯æœŸæœ›è·¯å¾„åˆ›å»ºé‡å®šå‘è·¯ç”±
  app.all(frontendPath, (req, res, next) => {
    req.url = backendPath;
    next();
  });
});
```

### å‰ç«¯APIæ¨¡å—å¼ºåˆ¶å®Œæ•´æ€§æ£€æŸ¥
```javascript
// åŸºäºŽcursor_5.mdä¸­å‘çŽ°çš„API.getUserInventoryç¼ºå¤±é—®é¢˜
const REQUIRED_API_METHODS = {
  // ðŸ”´ åº“å­˜ç®¡ç†APIæ–¹æ³•ï¼ˆcursor_5.mdä¸­ç¼ºå¤±ï¼‰
  getUserInventory: {
    url: '/api/v2/inventory/list',
    method: 'GET',
    required: true,
    errorType: 'TypeError: API.getUserInventory is not a function'
  },
  
  useInventoryItem: {
    url: '/api/v2/inventory/use', 
    method: 'POST',
    required: true
  },
  
  transferInventoryItem: {
    url: '/api/v2/inventory/transfer',
    method: 'POST', 
    required: true
  },
  
  // ðŸ”´ æƒé™ç®¡ç†APIæ–¹æ³•
  checkPremiumAccess: {
    url: '/api/v2/permissions/check',
    method: 'GET',
    required: true
  },
  
  unlockPremiumSpace: {
    url: '/api/v2/permissions/unlock',
    method: 'POST',
    required: true
  },
  
  // ðŸ”´ äº¤æ˜“è®°å½•APIæ–¹æ³•
  getTransactionHistory: {
    url: '/api/v2/transactions/history',
    method: 'GET', 
    required: true
  },
  
  getTransactionStats: {
    url: '/api/v2/transactions/stats',
    method: 'GET',
    required: true
  }
};

// APIæ–¹æ³•å­˜åœ¨æ€§è‡ªåŠ¨æ£€æŸ¥
function validateAPICompleteness(API) {
  const missing = [];
  
  Object.keys(REQUIRED_API_METHODS).forEach(methodName => {
    if (typeof API[methodName] !== 'function') {
      const config = REQUIRED_API_METHODS[methodName];
      missing.push({
        method: methodName,
        url: config.url,
        error: config.errorType || `TypeError: API.${methodName} is not a function`
      });
    }
  });
  
  if (missing.length > 0) {
    console.error('ðŸ”´ APIæ–¹æ³•ç¼ºå¤±æ£€æµ‹:', missing);
    throw new Error(`ç¼ºå¤±${missing.length}ä¸ªå¿…éœ€çš„APIæ–¹æ³•: ${missing.map(m => m.method).join(', ')}`);
  }
  
  console.log('âœ… APIæ–¹æ³•å®Œæ•´æ€§æ£€æŸ¥é€šè¿‡');
}
```

### æŽ¥å£æ–‡æ¡£è‡ªåŠ¨åŒæ­¥æœºåˆ¶
```javascript
// åŸºäºŽå®žé™…é—®é¢˜å»ºç«‹çš„æŽ¥å£æ–‡æ¡£åŒæ­¥æ£€æŸ¥
const INTERFACE_SYNC_CHECK = {
  // æ£€æŸ¥å‰åŽç«¯æŽ¥å£å®šä¹‰æ˜¯å¦ä¸€è‡´
  checkInterfaceSync: async () => {
    const frontendApis = await extractFrontendAPIs();
    const backendRoutes = await extractBackendRoutes();
    
    const mismatches = [];
    
    frontendApis.forEach(api => {
      const matchingRoute = backendRoutes.find(route => 
        route.path === api.path && route.method === api.method
      );
      
      if (!matchingRoute) {
        mismatches.push({
          type: 'MISSING_BACKEND_ROUTE',
          frontend: api,
          suggestion: `éœ€è¦åœ¨åŽç«¯å®žçŽ° ${api.method} ${api.path}`
        });
      }
    });
    
    backendRoutes.forEach(route => {
      const matchingApi = frontendApis.find(api =>
        api.path === route.path && api.method === route.method  
      );
      
      if (!matchingApi) {
        mismatches.push({
          type: 'UNUSED_BACKEND_ROUTE', 
          backend: route,
          suggestion: `åŽç«¯è·¯ç”± ${route.method} ${route.path} å¯èƒ½æœªè¢«å‰ç«¯ä½¿ç”¨`
        });
      }
    });
    
    return mismatches;
  }
};
```

## æŽ¥å£ç‰ˆæœ¬æŽ§åˆ¶å¼ºåˆ¶è§„èŒƒ

### ç‰ˆæœ¬å…¼å®¹æ€§ä¿è¯æœºåˆ¶
```javascript
// åŸºäºŽå®žé™…ç‰ˆæœ¬ä¸ä¸€è‡´é—®é¢˜çš„è§£å†³æ–¹æ¡ˆ
const API_VERSION_CONTROL = {
  // æŽ¥å£ç‰ˆæœ¬æ˜ å°„
  version_mappings: {
    'v1': {
      '/api/auth/login': '/api/v1/auth/login',
      '/api/user/profile': '/api/v1/user/profile'
    },
    'v2': {
      '/api/auth/login': '/api/v2/auth/login', 
      '/api/user/profile': '/api/v2/user/profile',
      '/api/inventory': '/api/v2/inventory/list',    // cursor_5.mdä¸­çš„å®žé™…æ˜ å°„
      '/api/admin/chat': '/api/v2/admin/chat'        // cursor_.mdä¸­çš„å®žé™…æ˜ å°„
    }
  },
  
  // è‡ªåŠ¨ç‰ˆæœ¬è·¯ç”±ç”Ÿæˆ
  generateVersionRoutes: (app) => {
    Object.keys(API_VERSION_CONTROL.version_mappings).forEach(version => {
      const mappings = API_VERSION_CONTROL.version_mappings[version];
      
      Object.keys(mappings).forEach(oldPath => {
        const newPath = mappings[oldPath];
        
        // ä¸ºæ—§è·¯å¾„åˆ›å»ºé‡å®šå‘åˆ°æ–°è·¯å¾„
        app.all(oldPath, (req, res, next) => {
          console.log(`ðŸ”„ APIç‰ˆæœ¬å…¼å®¹é‡å®šå‘: ${oldPath} â†’ ${newPath}`);
          req.url = newPath;
          next();
        });
      });
    });
  }
};
```

### æŽ¥å£å˜æ›´é€šçŸ¥æœºåˆ¶
```javascript
// é˜²æ­¢cursor_5.mdç±»ä¼¼é—®é¢˜çš„é¢„è­¦æœºåˆ¶
const INTERFACE_CHANGE_NOTIFICATION = {
  // æŽ¥å£å˜æ›´è®°å½•
  change_log: [],
  
  // è®°å½•æŽ¥å£å˜æ›´
  recordChange: (changeType, details) => {
    const change = {
      timestamp: new Date().toISOString(),
      type: changeType, // 'ADD', 'MODIFY', 'REMOVE', 'DEPRECATE'
      details: details,
      affectedFiles: details.affectedFiles || []
    };
    
    INTERFACE_CHANGE_NOTIFICATION.change_log.push(change);
    
    // ç”Ÿæˆå‰ç«¯æ›´æ–°é€šçŸ¥
    if (changeType === 'ADD' || changeType === 'MODIFY') {
      console.log(`ðŸ“¢ æŽ¥å£å˜æ›´é€šçŸ¥: ${changeType} - ${details.path}`);
      console.log(`ðŸ”§ å‰ç«¯éœ€è¦æ›´æ–°: ${details.frontendFiles?.join(', ')}`);
    }
  },
  
  // æ£€æŸ¥å‰ç«¯ä»£ç æ˜¯å¦éœ€è¦æ›´æ–°
  checkFrontendUpdateNeeded: () => {
    const recentChanges = INTERFACE_CHANGE_NOTIFICATION.change_log
      .filter(change => {
        const changeTime = new Date(change.timestamp);
        const dayAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);
        return changeTime > dayAgo;
      });
    
    if (recentChanges.length > 0) {
      console.warn('âš ï¸ æ£€æµ‹åˆ°æœ€è¿‘24å°æ—¶å†…æœ‰æŽ¥å£å˜æ›´ï¼Œè¯·æ£€æŸ¥å‰ç«¯ä»£ç æ˜¯å¦éœ€è¦æ›´æ–°');
      recentChanges.forEach(change => {
        console.log(`   - ${change.type}: ${change.details.path}`);
      });
    }
  }
};
```

## å®žæ—¶æŽ¥å£å¥åº·æ£€æŸ¥è§„èŒƒ

### åŸºäºŽå®žé™…é—®é¢˜çš„å¥åº·æ£€æŸ¥
```javascript
// é’ˆå¯¹cursoræ–‡æ¡£ä¸­å‘çŽ°çš„æŽ¥å£é—®é¢˜çš„å¥åº·æ£€æŸ¥
const INTERFACE_HEALTH_CHECK = {
  // æ£€æŸ¥å…³é”®æŽ¥å£å¯ç”¨æ€§
  checkCriticalInterfaces: async () => {
    const critical_interfaces = [
      // cursor_5.mdä¸­å‘çŽ°çš„å…³é”®æŽ¥å£
      { path: '/api/v2/inventory/list', method: 'GET', name: 'åº“å­˜åˆ—è¡¨' },
      { path: '/api/v2/inventory/use', method: 'POST', name: 'ä½¿ç”¨ç‰©å“' },
      { path: '/api/v2/inventory/transfer', method: 'POST', name: 'è½¬è®©ç‰©å“' },
      
      // cursor_.mdä¸­å‘çŽ°çš„å…³é”®æŽ¥å£  
      { path: '/api/v2/admin/chat/sessions', method: 'GET', name: 'ç®¡ç†å‘˜ä¼šè¯' },
      { path: '/api/v2/admin/chat/stats/today', method: 'GET', name: 'ä»Šæ—¥ç»Ÿè®¡' },
      
      // cursor_3.mdä¸­å‘çŽ°çš„å…³é”®æŽ¥å£
      { path: '/api/v2/chat/session', method: 'POST', name: 'åˆ›å»ºä¼šè¯' },
      { path: '/api/v2/chat/message', method: 'POST', name: 'å‘é€æ¶ˆæ¯' }
    ];
    
    const results = [];
    
    for (const iface of critical_interfaces) {
      try {
        const response = await fetch(`http://localhost:3000${iface.path}`, {
          method: iface.method,
          headers: { 'Content-Type': 'application/json' }
        });
        
        results.push({
          ...iface,
          status: response.status,
          available: response.status !== 404,
          response_time: Date.now() - start_time
        });
      } catch (error) {
        results.push({
          ...iface,
          status: 'ERROR',
          available: false,
          error: error.message
        });
      }
    }
    
    return results;
  },
  
  // ç”ŸæˆæŽ¥å£å¥åº·æŠ¥å‘Š
  generateHealthReport: (results) => {
    const unavailable = results.filter(r => !r.available);
    
    if (unavailable.length > 0) {
      console.error('ðŸ”´ æ£€æµ‹åˆ°ä¸å¯ç”¨çš„å…³é”®æŽ¥å£:');
      unavailable.forEach(iface => {
        console.error(`   âŒ ${iface.name}: ${iface.method} ${iface.path} (${iface.status})`);
      });
      
      // æä¾›ä¿®å¤å»ºè®®
      console.log('\nðŸ”§ ä¿®å¤å»ºè®®:');
      console.log('1. æ£€æŸ¥åŽç«¯è·¯ç”±æ˜¯å¦æ­£ç¡®æ³¨å†Œ');
      console.log('2. ç¡®è®¤æŽ¥å£æƒé™é…ç½®');
      console.log('3. éªŒè¯è¯·æ±‚å‚æ•°æ ¼å¼');
    } else {
      console.log('âœ… æ‰€æœ‰å…³é”®æŽ¥å£å¥åº·æ£€æŸ¥é€šè¿‡');
    }
  }
};
```

## å‰ç«¯APIè°ƒç”¨é”™è¯¯é¢„é˜²æœºåˆ¶

### åŸºäºŽcursor_5.mdé”™è¯¯çš„é¢„é˜²æœºåˆ¶
```javascript
// é˜²æ­¢TypeError: API.xxx is not a functioné”™è¯¯
const API_CALL_SAFETY = {
  // å®‰å…¨çš„APIè°ƒç”¨åŒ…è£…å™¨
  safeApiCall: (apiMethod, ...args) => {
    return new Promise((resolve, reject) => {
      // æ£€æŸ¥APIæ–¹æ³•æ˜¯å¦å­˜åœ¨
      if (typeof apiMethod !== 'function') {
        const error = new Error(`APIæ–¹æ³•ä¸å­˜åœ¨æˆ–ä¸æ˜¯å‡½æ•°: ${apiMethod?.name || 'unknown'}`);
        console.error('ðŸ”´ APIè°ƒç”¨é”™è¯¯:', error.message);
        reject(error);
        return;
      }
      
      // æ‰§è¡ŒAPIè°ƒç”¨
      try {
        const result = apiMethod.apply(null, args);
        
        // å¤„ç†Promiseå’ŒéžPromiseè¿”å›žå€¼
        if (result && typeof result.then === 'function') {
          result.then(resolve).catch(reject);
        } else {
          resolve(result);
        }
      } catch (error) {
        console.error('ðŸ”´ APIæ‰§è¡Œé”™è¯¯:', error.message);
        reject(error);
      }
    });
  },
  
  // APIæ–¹æ³•åŠ¨æ€æ£€æŸ¥å’Œè¡¥å…¨
  ensureApiMethod: (API, methodName, fallbackImplementation) => {
    if (typeof API[methodName] !== 'function') {
      console.warn(`âš ï¸ APIæ–¹æ³• ${methodName} ä¸å­˜åœ¨ï¼Œä½¿ç”¨fallbackå®žçŽ°`);
      
      if (typeof fallbackImplementation === 'function') {
        API[methodName] = fallbackImplementation;
      } else {
        // åˆ›å»ºé»˜è®¤çš„é”™è¯¯å¤„ç†æ–¹æ³•
        API[methodName] = () => {
          throw new Error(`APIæ–¹æ³• ${methodName} æœªå®žçŽ°`);
        };
      }
    }
  }
};

// ä½¿ç”¨ç¤ºä¾‹ï¼ˆåŸºäºŽcursor_5.mdä¸­çš„å®žé™…é—®é¢˜ï¼‰
API_CALL_SAFETY.ensureApiMethod(API, 'getUserInventory', async (params) => {
  const query = new URLSearchParams(params).toString();
  return await request({
    url: `/api/v2/inventory/list?${query}`,
    method: 'GET'
  });
});
```

## APIæ–‡æ¡£è‡ªåŠ¨ç”Ÿæˆå’ŒåŒæ­¥è§„èŒƒ

### å®žæ—¶APIæ–‡æ¡£ç”Ÿæˆ
```javascript
// åŸºäºŽå®žé™…åŽç«¯æŽ¥å£è‡ªåŠ¨ç”Ÿæˆå‰ç«¯APIæ–‡æ¡£
const API_DOC_GENERATOR = {
  // æ‰«æåŽç«¯è·¯ç”±ç”ŸæˆAPIæ–‡æ¡£
  generateFromRoutes: (app) => {
    const routes = [];
    
    // æå–Expressè·¯ç”±ä¿¡æ¯
    app._router.stack.forEach(layer => {
      if (layer.route) {
        const route = layer.route;
        Object.keys(route.methods).forEach(method => {
          routes.push({
            method: method.toUpperCase(),
            path: route.path,
            handlers: route.stack.map(s => s.handle.name).filter(Boolean)
          });
        });
      }
    });
    
    // ç”Ÿæˆå‰ç«¯APIè°ƒç”¨ä»£ç 
    const apiCode = routes.map(route => {
      const methodName = generateMethodName(route.path, route.method);
      
      return `
  // ${route.method} ${route.path}
  ${methodName}: async (params = {}) => {
    ${route.method === 'GET' ? 
      `const query = new URLSearchParams(params).toString();
       return await request({
         url: '${route.path}?' + query,
         method: '${route.method}'
       });` :
      `return await request({
         url: '${route.path}',
         method: '${route.method}',
         data: params
       });`
    }
  },`;
    }).join('\n');
    
    return `// è‡ªåŠ¨ç”Ÿæˆçš„APIè°ƒç”¨æ–¹æ³•
const API = {${apiCode}
};

export default API;`;
  },
  
  // éªŒè¯ç”Ÿæˆçš„APIä»£ç ä¸Žå®žé™…è·¯ç”±çš„ä¸€è‡´æ€§
  validateGeneratedAPI: (generatedAPI, actualRoutes) => {
    const issues = [];
    
    actualRoutes.forEach(route => {
      const expectedMethod = generateMethodName(route.path, route.method);
      
      if (!generatedAPI.includes(expectedMethod)) {
        issues.push({
          type: 'MISSING_METHOD',
          route: route,
          expectedMethod: expectedMethod
        });
      }
    });
    
    return issues;
  }
};

function generateMethodName(path, method) {
  // å°†è·¯å¾„è½¬æ¢ä¸ºé©¼å³°å‘½åçš„æ–¹æ³•å
  // ä¾‹å¦‚: /api/v2/inventory/list GET -> getInventoryList
  const pathParts = path.split('/').filter(Boolean);
  const actionPrefix = method.toLowerCase() === 'get' ? 'get' : 
                      method.toLowerCase() === 'post' ? 'create' :
                      method.toLowerCase() === 'put' ? 'update' :
                      method.toLowerCase() === 'delete' ? 'delete' : 'handle';
  
  const resourceName = pathParts.slice(-2).map(part => 
    part.charAt(0).toUpperCase() + part.slice(1)
  ).join('');
  
  return actionPrefix + resourceName;
}
```

## é”™è¯¯å¤„ç†å’Œé™çº§ç­–ç•¥

### APIè°ƒç”¨å¤±è´¥é™çº§æœºåˆ¶
```javascript
// åŸºäºŽå®žé™…APIä¸åŒ¹é…é—®é¢˜çš„é™çº§ç­–ç•¥
const API_FALLBACK_STRATEGY = {
  // æŽ¥å£é™çº§é…ç½®
  fallback_configs: {
    '/api/v2/inventory/list': {
      fallbacks: ['/api/inventory', '/api/v1/inventory/list'],
      cache_key: 'inventory_list',
      cache_ttl: 300000 // 5åˆ†é’Ÿ
    },
    
    '/api/v2/admin/chat/sessions': {
      fallbacks: ['/admin/chat/sessions', '/api/admin/chat'],
      cache_key: 'admin_chat_sessions', 
      cache_ttl: 60000 // 1åˆ†é’Ÿ
    }
  },
  
  // æ™ºèƒ½APIè°ƒç”¨ä¸Žé™çº§
  smartApiCall: async (primaryUrl, options = {}) => {
    const config = API_FALLBACK_STRATEGY.fallback_configs[primaryUrl];
    const urls = [primaryUrl, ...(config?.fallbacks || [])];
    
    for (let i = 0; i < urls.length; i++) {
      const url = urls[i];
      
      try {
        console.log(`ðŸ”„ å°è¯•APIè°ƒç”¨: ${url} (${i + 1}/${urls.length})`);
        
        const response = await fetch(url, options);
        
        if (response.ok) {
          console.log(`âœ… APIè°ƒç”¨æˆåŠŸ: ${url}`);
          return response;
        } else if (response.status === 404 && i < urls.length - 1) {
          console.warn(`âš ï¸ APIä¸å¯ç”¨ï¼Œå°è¯•é™çº§: ${url} â†’ ä¸‹ä¸€ä¸ªå¤‡é€‰`);
          continue;
        } else {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
      } catch (error) {
        if (i === urls.length - 1) {
          console.error(`ðŸ”´ æ‰€æœ‰APIè·¯å¾„å‡å¤±è´¥: ${urls.join(' â†’ ')}`);
          throw error;
        } else {
          console.warn(`âš ï¸ APIè°ƒç”¨å¤±è´¥ï¼Œå°è¯•é™çº§: ${url} â†’ ${urls[i + 1]}`);
        }
      }
    }
  }
};
```

---

**æ ¸å¿ƒåŽŸåˆ™**: APIæŽ¥å£å¼ºåˆ¶ä¸€è‡´æ€§ã€ç‰ˆæœ¬å…¼å®¹æ€§ä¿è¯ã€å®žæ—¶å¥åº·æ£€æŸ¥ã€æ™ºèƒ½é™çº§ç­–ç•¥
description:
globs:
alwaysApply: false
---
