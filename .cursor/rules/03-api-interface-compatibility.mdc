---
alwaysApply: true
---
# API接口兼容性规范（基于实际cursor_5.md等问题分析版）

## 🔴 基于实际发现的API接口不匹配问题

### 实际问题案例统计
从11个cursor文档深度分析发现：
- **TypeError错误**: `API.getUserInventory is not a function` (cursor_5.md)
- **路径不匹配**: 前端期望 `/admin/chat/sessions`，后端实际 `/api/v2/admin/chat/sessions` (cursor_1.md)
- **接口缺失**: 前端调用不存在的API接口，返回404错误 (cursor_3.md)
- **版本不一致**: 前端基于旧版API文档开发，后端已更新接口 (cursor_7.md)

## API接口强制一致性检查规范

### 实际发现的API不匹配模式
```javascript
// 🔴 cursor_5.md中发现的实际错误模式
const API_MISMATCH_PATTERNS = {
  // 前端调用 vs 后端实际接口
  inventory_api: {
    frontend_call: 'API.getUserInventory',
    backend_actual: '/api/v2/inventory/list',
    error: 'TypeError: API.getUserInventory is not a function'
  },
  
  chat_admin_api: {
    frontend_call: '/admin/chat/sessions',
    backend_actual: '/api/v2/admin/chat/sessions', 
    error: '404 Not Found'
  },
  
  upload_api: {
    frontend_call: '/api/upload',
    backend_actual: '/api/photo/upload',
    error: 'API endpoint not found'
  },
  
  auth_verify_api: {
    frontend_call: '/api/auth/verify',
    backend_actual: '/api/v2/auth/verify',
    error: 'Route not implemented'
  }
};
```

### API接口强制兼容映射机制
```javascript
// 强制要求：所有API路径必须有兼容性映射
const COMPATIBLE_API_PATHS = {
  upload_paths: [
    '/api/upload',        // 前端期望路径 - cursor_git4.md中发现
    '/api/photo/upload'   // 后端实际路径
  ],
  
  auth_verify_paths: [
    '/api/auth/verify',   // 前端期望路径 - cursor_6.md中发现
    '/api/v1/auth/verify' // 后端实际路径
  ],
  
  exchange_stats_paths: [
    '/api/exchange/statistics', // 前端期望路径 - cursor_7.md中发现
    '/api/merchant/statistics'   // 后端实际路径
  ],
  
  admin_chat_paths: [
    '/admin/chat/sessions',      // 前端期望路径 - cursor_.md中发现
    '/api/v2/admin/chat/sessions' // 后端实际路径
  ],
  
  inventory_paths: [
    '/api/inventory',           // 前端期望路径 - cursor_5.md中发现  
    '/api/v2/inventory/list'    // 后端实际路径
  ]
};

// 自动生成兼容性路由
Object.keys(COMPATIBLE_API_PATHS).forEach(pathGroup => {
  const paths = COMPATIBLE_API_PATHS[pathGroup];
  const [frontendPath, backendPath] = paths;
  
  // 为前端期望路径创建重定向路由
  app.all(frontendPath, (req, res, next) => {
    req.url = backendPath;
    next();
  });
});
```

### 前端API模块强制完整性检查
```javascript
// 基于cursor_5.md中发现的API.getUserInventory缺失问题
const REQUIRED_API_METHODS = {
  // 🔴 库存管理API方法（cursor_5.md中缺失）
  getUserInventory: {
    url: '/api/v2/inventory/list',
    method: 'GET',
    required: true,
    errorType: 'TypeError: API.getUserInventory is not a function'
  },
  
  useInventoryItem: {
    url: '/api/v2/inventory/use', 
    method: 'POST',
    required: true
  },
  
  transferInventoryItem: {
    url: '/api/v2/inventory/transfer',
    method: 'POST', 
    required: true
  },
  
  // 🔴 权限管理API方法
  checkPremiumAccess: {
    url: '/api/v2/permissions/check',
    method: 'GET',
    required: true
  },
  
  unlockPremiumSpace: {
    url: '/api/v2/permissions/unlock',
    method: 'POST',
    required: true
  },
  
  // 🔴 交易记录API方法
  getTransactionHistory: {
    url: '/api/v2/transactions/history',
    method: 'GET', 
    required: true
  },
  
  getTransactionStats: {
    url: '/api/v2/transactions/stats',
    method: 'GET',
    required: true
  }
};

// API方法存在性自动检查
function validateAPICompleteness(API) {
  const missing = [];
  
  Object.keys(REQUIRED_API_METHODS).forEach(methodName => {
    if (typeof API[methodName] !== 'function') {
      const config = REQUIRED_API_METHODS[methodName];
      missing.push({
        method: methodName,
        url: config.url,
        error: config.errorType || `TypeError: API.${methodName} is not a function`
      });
    }
  });
  
  if (missing.length > 0) {
    console.error('🔴 API方法缺失检测:', missing);
    throw new Error(`缺失${missing.length}个必需的API方法: ${missing.map(m => m.method).join(', ')}`);
  }
  
  console.log('✅ API方法完整性检查通过');
}
```

### 接口文档自动同步机制
```javascript
// 基于实际问题建立的接口文档同步检查
const INTERFACE_SYNC_CHECK = {
  // 检查前后端接口定义是否一致
  checkInterfaceSync: async () => {
    const frontendApis = await extractFrontendAPIs();
    const backendRoutes = await extractBackendRoutes();
    
    const mismatches = [];
    
    frontendApis.forEach(api => {
      const matchingRoute = backendRoutes.find(route => 
        route.path === api.path && route.method === api.method
      );
      
      if (!matchingRoute) {
        mismatches.push({
          type: 'MISSING_BACKEND_ROUTE',
          frontend: api,
          suggestion: `需要在后端实现 ${api.method} ${api.path}`
        });
      }
    });
    
    backendRoutes.forEach(route => {
      const matchingApi = frontendApis.find(api =>
        api.path === route.path && api.method === route.method  
      );
      
      if (!matchingApi) {
        mismatches.push({
          type: 'UNUSED_BACKEND_ROUTE', 
          backend: route,
          suggestion: `后端路由 ${route.method} ${route.path} 可能未被前端使用`
        });
      }
    });
    
    return mismatches;
  }
};
```

## 接口版本控制强制规范

### 版本兼容性保证机制
```javascript
// 基于实际版本不一致问题的解决方案
const API_VERSION_CONTROL = {
  // 接口版本映射
  version_mappings: {
    'v1': {
      '/api/auth/login': '/api/v1/auth/login',
      '/api/user/profile': '/api/v1/user/profile'
    },
    'v2': {
      '/api/auth/login': '/api/v2/auth/login', 
      '/api/user/profile': '/api/v2/user/profile',
      '/api/inventory': '/api/v2/inventory/list',    // cursor_5.md中的实际映射
      '/api/admin/chat': '/api/v2/admin/chat'        // cursor_.md中的实际映射
    }
  },
  
  // 自动版本路由生成
  generateVersionRoutes: (app) => {
    Object.keys(API_VERSION_CONTROL.version_mappings).forEach(version => {
      const mappings = API_VERSION_CONTROL.version_mappings[version];
      
      Object.keys(mappings).forEach(oldPath => {
        const newPath = mappings[oldPath];
        
        // 为旧路径创建重定向到新路径
        app.all(oldPath, (req, res, next) => {
          console.log(`🔄 API版本兼容重定向: ${oldPath} → ${newPath}`);
          req.url = newPath;
          next();
        });
      });
    });
  }
};
```

### 接口变更通知机制
```javascript
// 防止cursor_5.md类似问题的预警机制
const INTERFACE_CHANGE_NOTIFICATION = {
  // 接口变更记录
  change_log: [],
  
  // 记录接口变更
  recordChange: (changeType, details) => {
    const change = {
      timestamp: new Date().toISOString(),
      type: changeType, // 'ADD', 'MODIFY', 'REMOVE', 'DEPRECATE'
      details: details,
      affectedFiles: details.affectedFiles || []
    };
    
    INTERFACE_CHANGE_NOTIFICATION.change_log.push(change);
    
    // 生成前端更新通知
    if (changeType === 'ADD' || changeType === 'MODIFY') {
      console.log(`📢 接口变更通知: ${changeType} - ${details.path}`);
      console.log(`🔧 前端需要更新: ${details.frontendFiles?.join(', ')}`);
    }
  },
  
  // 检查前端代码是否需要更新
  checkFrontendUpdateNeeded: () => {
    const recentChanges = INTERFACE_CHANGE_NOTIFICATION.change_log
      .filter(change => {
        const changeTime = new Date(change.timestamp);
        const dayAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);
        return changeTime > dayAgo;
      });
    
    if (recentChanges.length > 0) {
      console.warn('⚠️ 检测到最近24小时内有接口变更，请检查前端代码是否需要更新');
      recentChanges.forEach(change => {
        console.log(`   - ${change.type}: ${change.details.path}`);
      });
    }
  }
};
```

## 实时接口健康检查规范

### 基于实际问题的健康检查
```javascript
// 针对cursor文档中发现的接口问题的健康检查
const INTERFACE_HEALTH_CHECK = {
  // 检查关键接口可用性
  checkCriticalInterfaces: async () => {
    const critical_interfaces = [
      // cursor_5.md中发现的关键接口
      { path: '/api/v2/inventory/list', method: 'GET', name: '库存列表' },
      { path: '/api/v2/inventory/use', method: 'POST', name: '使用物品' },
      { path: '/api/v2/inventory/transfer', method: 'POST', name: '转让物品' },
      
      // cursor_.md中发现的关键接口  
      { path: '/api/v2/admin/chat/sessions', method: 'GET', name: '管理员会话' },
      { path: '/api/v2/admin/chat/stats/today', method: 'GET', name: '今日统计' },
      
      // cursor_3.md中发现的关键接口
      { path: '/api/v2/chat/session', method: 'POST', name: '创建会话' },
      { path: '/api/v2/chat/message', method: 'POST', name: '发送消息' }
    ];
    
    const results = [];
    
    for (const iface of critical_interfaces) {
      try {
        const response = await fetch(`http://localhost:3000${iface.path}`, {
          method: iface.method,
          headers: { 'Content-Type': 'application/json' }
        });
        
        results.push({
          ...iface,
          status: response.status,
          available: response.status !== 404,
          response_time: Date.now() - start_time
        });
      } catch (error) {
        results.push({
          ...iface,
          status: 'ERROR',
          available: false,
          error: error.message
        });
      }
    }
    
    return results;
  },
  
  // 生成接口健康报告
  generateHealthReport: (results) => {
    const unavailable = results.filter(r => !r.available);
    
    if (unavailable.length > 0) {
      console.error('🔴 检测到不可用的关键接口:');
      unavailable.forEach(iface => {
        console.error(`   ❌ ${iface.name}: ${iface.method} ${iface.path} (${iface.status})`);
      });
      
      // 提供修复建议
      console.log('\n🔧 修复建议:');
      console.log('1. 检查后端路由是否正确注册');
      console.log('2. 确认接口权限配置');
      console.log('3. 验证请求参数格式');
    } else {
      console.log('✅ 所有关键接口健康检查通过');
    }
  }
};
```

## 前端API调用错误预防机制

### 基于cursor_5.md错误的预防机制
```javascript
// 防止TypeError: API.xxx is not a function错误
const API_CALL_SAFETY = {
  // 安全的API调用包装器
  safeApiCall: (apiMethod, ...args) => {
    return new Promise((resolve, reject) => {
      // 检查API方法是否存在
      if (typeof apiMethod !== 'function') {
        const error = new Error(`API方法不存在或不是函数: ${apiMethod?.name || 'unknown'}`);
        console.error('🔴 API调用错误:', error.message);
        reject(error);
        return;
      }
      
      // 执行API调用
      try {
        const result = apiMethod.apply(null, args);
        
        // 处理Promise和非Promise返回值
        if (result && typeof result.then === 'function') {
          result.then(resolve).catch(reject);
        } else {
          resolve(result);
        }
      } catch (error) {
        console.error('🔴 API执行错误:', error.message);
        reject(error);
      }
    });
  },
  
  // API方法动态检查和补全
  ensureApiMethod: (API, methodName, fallbackImplementation) => {
    if (typeof API[methodName] !== 'function') {
      console.warn(`⚠️ API方法 ${methodName} 不存在，使用fallback实现`);
      
      if (typeof fallbackImplementation === 'function') {
        API[methodName] = fallbackImplementation;
      } else {
        // 创建默认的错误处理方法
        API[methodName] = () => {
          throw new Error(`API方法 ${methodName} 未实现`);
        };
      }
    }
  }
};

// 使用示例（基于cursor_5.md中的实际问题）
API_CALL_SAFETY.ensureApiMethod(API, 'getUserInventory', async (params) => {
  const query = new URLSearchParams(params).toString();
  return await request({
    url: `/api/v2/inventory/list?${query}`,
    method: 'GET'
  });
});
```

## API文档自动生成和同步规范

### 实时API文档生成
```javascript
// 基于实际后端接口自动生成前端API文档
const API_DOC_GENERATOR = {
  // 扫描后端路由生成API文档
  generateFromRoutes: (app) => {
    const routes = [];
    
    // 提取Express路由信息
    app._router.stack.forEach(layer => {
      if (layer.route) {
        const route = layer.route;
        Object.keys(route.methods).forEach(method => {
          routes.push({
            method: method.toUpperCase(),
            path: route.path,
            handlers: route.stack.map(s => s.handle.name).filter(Boolean)
          });
        });
      }
    });
    
    // 生成前端API调用代码
    const apiCode = routes.map(route => {
      const methodName = generateMethodName(route.path, route.method);
      
      return `
  // ${route.method} ${route.path}
  ${methodName}: async (params = {}) => {
    ${route.method === 'GET' ? 
      `const query = new URLSearchParams(params).toString();
       return await request({
         url: '${route.path}?' + query,
         method: '${route.method}'
       });` :
      `return await request({
         url: '${route.path}',
         method: '${route.method}',
         data: params
       });`
    }
  },`;
    }).join('\n');
    
    return `// 自动生成的API调用方法
const API = {${apiCode}
};

export default API;`;
  },
  
  // 验证生成的API代码与实际路由的一致性
  validateGeneratedAPI: (generatedAPI, actualRoutes) => {
    const issues = [];
    
    actualRoutes.forEach(route => {
      const expectedMethod = generateMethodName(route.path, route.method);
      
      if (!generatedAPI.includes(expectedMethod)) {
        issues.push({
          type: 'MISSING_METHOD',
          route: route,
          expectedMethod: expectedMethod
        });
      }
    });
    
    return issues;
  }
};

function generateMethodName(path, method) {
  // 将路径转换为驼峰命名的方法名
  // 例如: /api/v2/inventory/list GET -> getInventoryList
  const pathParts = path.split('/').filter(Boolean);
  const actionPrefix = method.toLowerCase() === 'get' ? 'get' : 
                      method.toLowerCase() === 'post' ? 'create' :
                      method.toLowerCase() === 'put' ? 'update' :
                      method.toLowerCase() === 'delete' ? 'delete' : 'handle';
  
  const resourceName = pathParts.slice(-2).map(part => 
    part.charAt(0).toUpperCase() + part.slice(1)
  ).join('');
  
  return actionPrefix + resourceName;
}
```

## 错误处理和降级策略

### API调用失败降级机制
```javascript
// 基于实际API不匹配问题的降级策略
const API_FALLBACK_STRATEGY = {
  // 接口降级配置
  fallback_configs: {
    '/api/v2/inventory/list': {
      fallbacks: ['/api/inventory', '/api/v1/inventory/list'],
      cache_key: 'inventory_list',
      cache_ttl: 300000 // 5分钟
    },
    
    '/api/v2/admin/chat/sessions': {
      fallbacks: ['/admin/chat/sessions', '/api/admin/chat'],
      cache_key: 'admin_chat_sessions', 
      cache_ttl: 60000 // 1分钟
    }
  },
  
  // 智能API调用与降级
  smartApiCall: async (primaryUrl, options = {}) => {
    const config = API_FALLBACK_STRATEGY.fallback_configs[primaryUrl];
    const urls = [primaryUrl, ...(config?.fallbacks || [])];
    
    for (let i = 0; i < urls.length; i++) {
      const url = urls[i];
      
      try {
        console.log(`🔄 尝试API调用: ${url} (${i + 1}/${urls.length})`);
        
        const response = await fetch(url, options);
        
        if (response.ok) {
          console.log(`✅ API调用成功: ${url}`);
          return response;
        } else if (response.status === 404 && i < urls.length - 1) {
          console.warn(`⚠️ API不可用，尝试降级: ${url} → 下一个备选`);
          continue;
        } else {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
      } catch (error) {
        if (i === urls.length - 1) {
          console.error(`🔴 所有API路径均失败: ${urls.join(' → ')}`);
          throw error;
        } else {
          console.warn(`⚠️ API调用失败，尝试降级: ${url} → ${urls[i + 1]}`);
        }
      }
    }
  }
};
```

---

**核心原则**: API接口强制一致性、版本兼容性保证、实时健康检查、智能降级策略
description:
globs:
alwaysApply: false
---
