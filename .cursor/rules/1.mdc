---
description: 
globs: 
alwaysApply: true
---
# 项目开发规范总览

## 数据库表结构和索引管理规范
- 禁止在生产环境频繁使用sequelize.sync({ alter: true })或force: true，表结构变更必须通过手动SQL脚本或迁移工具完成
- 每张表的索引总数不得超过MySQL的64个限制，如需新增索引，必须先评估和清理无用索引
- 初始化脚本必须加超时和详细日志，如遇长时间无响应，需立即排查数据库连接和表结构问题
- 大批量数据插入必须分批处理，每批不超过100条，避免单次SQL阻塞
- 所有表结构和索引变更需在代码评审时重点检查，防止上线后阻塞数据库
- 生产环境下，sequelize.sync({ alter: true }) 或 force: true 不要频繁使用，建议只在开发或首次部署时用
- 数据库长时间初始化处理：当数据库初始化脚本运行超过2分钟时，应该先检查数据库状态和表结构，验证数据是否已成功初始化，使用timeout命令限制脚本运行时间，避免在生产环境使用force模式重建数据库

## 测试数据一致性规范
- 所有测试用户数据必须定义在统一的配置文件中（如 config/test-data.js）
- 禁止在多个文件中硬编码相同的测试数据
- 初始化脚本和测试脚本必须引用同一个数据源
- 只保留一个主要的初始化脚本，其他过时脚本必须删除或明确标记
- 测试脚本必须包含数据存在性检查，避免空指针异常
- 所有数据库操作前必须验证依赖数据是否存在
- 所有测试文件的模型导入路径必须一致
- 使用相对路径时必须确保从当前文件位置正确导入
- 添加模型导入失败的错误处理
- 每次修改初始化脚本时，必须同步更新相关的测试脚本
- 在CI/CD中添加测试数据一致性检查
- 测试失败时输出明确的错误信息，包含期望数据和实际数据
- 所有数据库查询必须检查返回结果是否为null/undefined
- 使用 try-catch 包装可能失败的操作
- 提供有意义的错误消息，便于快速定位问题

### 测试数据处理示例代码：
```javascript
// ✅ 正确模式 - 统一配置 + 错误检查  
const TEST_CONFIG = require('./config/test-data.js');
const testUser = await User.findOne({ where: { mobile: TEST_CONFIG.TEST_USER_MOBILE } });
if (!testUser) {
  console.error(`测试用户不存在: ${TEST_CONFIG.TEST_USER_MOBILE}`);
  console.log('请运行: node scripts/init-database.js');
  process.exit(1);
}
const { accessToken } = generateTokens(testUser);
```

## Node.js 应用开发和部署规范

### 内存管理规范
- 开发环境必须设置合理的内存限制，避免内存使用率超过80%
- 使用 NODE_OPTIONS="--max-old-space-size=512" 控制堆内存大小
- PM2配置中设置 max_memory_restart 低于实际内存限制
- 实施内存监控告警，超过75%时自动重启进程
- 避免在开发环境使用集群模式，优先使用fork模式

### API路径规范
- 健康检查端点必须同时提供 /health 和 /api/health 两个路径
- 所有API端点必须有对应的错误处理机制
- API路径变更时必须同步更新文档和测试用例
- 实施API版本控制和向后兼容策略

### 服务监控规范
- 所有服务组件必须实现 isHealthy() 方法
- WebSocket等实时服务需要实现连接计数和状态检查
- 健康检查端点必须返回详细的服务状态信息
- 实施服务依赖检查和故障隔离机制

### 进程管理规范
- 开发环境使用单进程模式，生产环境可使用集群模式
- 配置合理的进程重启策略和超时时间
- 实施优雅关闭机制，确保数据一致性
- 配置日志轮转和存储策略

### 资源优化规范
- Node.js启动参数必须根据环境进行优化
- 避免使用不支持的启动参数组合
- 实施资源使用监控和告警机制
- 定期进行性能分析和优化

### 错误处理规范
- 所有异步操作必须有错误处理
- 实施全局错误捕获和处理机制
- 错误信息必须包含上下文和解决建议
- 建立错误分类和优先级体系

### 部署配置规范
- 环境配置必须区分开发、测试、生产环境
- 敏感信息必须通过环境变量管理
- 实施配置验证和兼容性检查
- 建立配置变更追踪机制

## 工具调用和工作流程优化规范

### 文档修改工具选择策略
- 对于大型文档(>1000行)优先使用edit_file工具
- search_replace仅用于小范围精确替换
- 中文文档修改时特别注意编码和格式问题
- 文档修改失败时立即切换工具，避免重复尝试
- 长文档修改前先用grep_search定位目标位置

### 工作流程时机优化
- 采用"分析→实现→验证→文档"的标准流程
- 代码修改阶段专注于功能实现，避免文档干扰
- 所有功能实现完成后统一进行文档更新
- 文档更新失败不应影响代码实现进度
- 建立检查点机制，确保每个阶段完整性

### 工具调用效率优化
- 使用并行工具调用处理独立任务
- 文件读取前先用file_search确认文件存在
- 大文件修改前用grep_search预定位
- 避免重复的状态检查，使用缓存结果
- 工具调用失败时立即分析原因，避免盲目重试

### 错误分析和学习机制
- 每次会话结束后分析问题模式
- 记录工具使用效率和失败原因
- 更新cursor规则以避免重复问题
- 建立问题解决方案知识库
- 定期回顾和优化工作流程

## 命令执行和环境检查规范

### 环境依赖完整性检查
- 在开始任何开发任务前必须执行环境检查
- 检查Node.js版本和PM2安装状态
- 验证package.json中的依赖是否已安装
- 确认数据库连接配置的正确性
- 验证环境变量文件的完整性

### 应用启动状态验证
- 应用启动后必须进行完整的健康检查
- 检查端口监听状态：netstat -tlnp | grep :PORT
- 验证健康检查端点：curl -f http://localhost:PORT/api/health
- 确认PM2进程状态：pm2 status
- 检查应用日志：pm2 logs --lines 20

### 命令执行标准化
- 所有长时间运行的命令必须设置超时和限制参数
- 使用timeout命令限制执行时间：timeout 120s command
- 日志查看命令必须限制行数：--lines N
- 网络请求必须设置超时：curl -m 30
- 大文件操作需要进度显示和分段处理

### 错误处理和恢复
- 每个关键操作必须有错误处理和恢复机制
- 命令失败时提供具体的错误信息和解决方案
- 超时命令必须有重试机制（最多3次）
- 关键服务异常时提供替代方案
- 错误信息必须包含上下文和调试信息

## 项目文档和配置管理规范

### 配置文件同步机制
- .cursor-rules必须包含全部开发规范
- 环境变量配置必须与实际部署环境匹配
- 项目文档必须与实际代码功能保持同步
- 定期检查配置文件的完整性和正确性

### 并行诊断优化
- 优先使用并行工具调用提高效率
- 同时检查多个服务状态
- 并行读取多个配置文件
- 同时执行多个独立的验证命令
- 避免不必要的串行等待

### 资源监控和告警
- 系统资源使用必须在安全范围内
- 内存使用率不得超过80%
- CPU使用率持续监控，超过90%时告警
- 磁盘空间监控，日志文件定期清理
- 网络连接数监控，防止连接泄漏

### WebSocket服务监控
- WebSocket服务必须实现完整的健康检查
- 实现isHealthy()方法检查连接状态
- 监控活跃连接数和连接质量
- 提供连接重连机制和故障转移
- 记录详细的连接和断开日志

### 开发环境一致性
- 开发环境配置必须标准化
- 所有开发者使用相同的Node.js版本
- 统一的依赖管理和版本锁定
- 标准化的启动和停止脚本
- 一致的环境变量配置模板

## Cursor规则文件管理规范

### Cursor规则文件正确处理流程
- 处理cursor规则时必须首先检查.cursor/rules/目录
- 发现现有规则文件时禁止在根目录创建同名文件
- 所有cursor规则更新必须直接修改.cursor/rules/下的文件
- 规则更新后必须验证Cursor编辑器是否正确识别
- 如需记录分析过程，创建独立文档但不能与规则文件同名

### 文件操作验证规范
- 每次文件操作后必须验证操作结果
- 重命名、移动、删除操作必须确认最终状态
- 使用ls命令验证文件系统的实际状态
- 避免基于假设进行后续操作

### 工具调用效率规范
- 独立的检查操作必须使用并行工具调用
- 文件存在性检查与内容读取可以并行执行
- 避免重复的状态检查和冗余操作
- 每次工具调用失败时立即分析原因

## 会话问题预防和效率优化规范

### API路由验证规范
- 在访问任何API端点前必须先检查实际路由定义
- 使用 grep -r "app.get.*endpoint" 确认路由存在
- 健康检查优先使用 /health 路径，如404则尝试 /api/health
- 避免盲目重复访问不存在的端点浪费请求次数
- API测试失败时立即检查路由配置而非重复尝试

### 命令执行超时控制规范
- 所有可能长时间运行的命令必须使用timeout限制
- PM2日志查看：timeout 10s pm2 logs --lines 10
- 网络请求：curl -m 30 或 timeout 10s curl
- 文件搜索：timeout 30s find 或 timeout 20s grep -r
- 数据库操作：timeout 60s node scripts/db-operation.js
- 超时时间设置原则：简单操作10s，复杂操作30-60s

### 工具调用超时预防规范
- file_search工具调用前先评估搜索范围，避免全项目搜索
- 大文件读取前先检查文件大小：ls -lh filename
- 使用grep_search替代file_search进行精确搜索
- 并行工具调用时设置合理的超时预期
- 工具调用失败时立即切换策略，避免重复尝试

### 日志和监控命令规范
- PM2日志查看必须限制行数：pm2 logs --lines N
- 系统日志查看使用：tail -n 20 /var/log/app.log
- 实时日志监控使用timeout：timeout 30s tail -f logfile
- 避免使用无限制的日志查看命令
- 日志分析优先使用grep过滤关键信息

### 依赖版本和警告处理规范
- 定期检查package.json中的过时依赖
- AWS SDK v2警告：计划升级到 @aws-sdk/client-* v3版本
- Node.js版本兼容性：确保依赖支持当前Node.js版本
- 警告信息不影响功能时可暂时忽略，但需记录升级计划
- 关键依赖版本变更需要充分测试

### 状态检查缓存和优化规范
- 避免在同一会话中重复执行相同的状态检查
- 使用变量缓存健康检查、端口状态等结果
- 状态变更后才重新检查，否则使用缓存结果
- 批量状态检查优于单个检查
- 建立检查清单，避免遗漏关键状态

### 错误处理和学习改进规范
- 每次会话结束后总结主要问题和解决方案
- 识别重复出现的问题模式
- 更新cursor规则防止同类问题再次发生
- 建立问题分类：路由错误、超时问题、依赖问题、配置问题
- 为每类问题建立标准解决流程

### 系统状态验证规范
- 关键修改操作后必须验证应用运行状态
- 使用健康检查端点确认系统正常运行
- 定期检查内存使用和系统资源状态
- 建立操作前后的状态对比机制

### 记忆管理和学习改进规范
- 发现重复错误时必须创建防止性记忆
- 每次会话结束后总结关键问题和解决方案
- 建立问题模式识别和避免机制
- 持续优化工作流程和规则体系

**核心原则**：安全优先、效率并重、错误可控、操作可追溯

## 项目类型识别和环境分析规范

### 项目类型快速识别机制
- 任务开始前必须先进行项目类型识别和环境分析
- 检查项目根目录关键文件：package.json、app.js、project.config.json、requirements.txt等
- 根据文件特征判断项目类型：
  * Node.js后端：package.json + app.js/server.js + routes/目录
  * 微信小程序：project.config.json + app.json + pages/目录 + utils/目录
  * Python项目：requirements.txt + app.py/main.py
  * React前端：package.json + src/目录 + public/目录
- 避免基于任务描述盲目假设项目类型
- 项目类型确认后制定对应的分析策略

### 目录结构预分析规范
- 使用list_dir先查看项目根目录结构
- 识别关键目录和文件模式：
  * 后端项目：routes/, models/, controllers/, middleware/
  * 前端项目：src/, components/, pages/, utils/
  * 全栈项目：frontend/, backend/, client/, server/
- 避免盲目搜索不存在的文件和目录
- 基于实际目录结构调整搜索策略

### 环境和技术栈识别
- 检查package.json了解依赖和脚本
- 分析启动命令和构建工具
- 识别使用的框架和技术栈
- 确认开发和生产环境配置
- 避免使用不匹配的工具和命令

### 配置文件定位策略
- 根据项目类型使用对应的配置文件搜索模式
- Node.js项目：config/, .env, package.json
- 微信小程序：project.config.json, app.json, sitemap.json
- 使用grep_search精确定位配置项而非盲目搜索
- 避免在错误的项目类型中查找特定配置

### 问题诊断标准流程
- 步骤1：项目类型和环境识别（5分钟内完成）
- 步骤2：关键文件和配置定位
- 步骤3：问题相关组件和服务检查
- 步骤4：具体问题分析和解决方案制定
- 每个步骤完成后验证，避免方向性错误

## 网络请求和API测试优化规范

### API端点验证标准流程
- 测试前先检查路由定义：grep -r "app.get\|router.get" routes/
- 健康检查端点优先级：/health > /api/health > /status
- 使用curl -s测试避免冗长输出，需要详细信息时使用-v
- API测试失败时立即检查backend路由而非重复请求
- 建立常用端点的验证缓存，避免重复测试

### JSON数据处理规范
- curl返回JSON时检查数据完整性，避免截断影响分析
- jq不可用时使用python -m json.tool格式化
- 大JSON响应使用head/tail限制显示长度
- 关键字段提取使用grep而非依赖完整JSON解析
- 建立JSON处理工具的备选方案

### 网络请求超时和重试
- 所有curl请求设置合理超时：curl -m 30
- 失败请求最多重试2次，避免无限重试
- 网络问题和配置问题区分处理
- 超时请求提供诊断信息和解决建议
- 建立网络请求成功率监控

### 微信小程序域名配置诊断
- 确认问题是域名白名单问题而非服务问题
- 区分小程序端错误和服务端错误
- 提供标准的域名配置检查清单
- 建立小程序网络问题快速诊断流程
- 记录常见配置错误和解决方案

## 工具调用中断处理和恢复规范

### 并行工具调用限制
- 同时执行的并行工具调用不超过3个
- 文件搜索类工具（file_search, grep_search）不并行执行
- 用户交互期间暂停新的工具调用
- 工具调用被中断时立即分析原因
- 建立工具调用优先级队列

### 中断检测和恢复机制
- 工具调用返回"Error: no result from tool"时立即停止相关操作
- 分析中断原因：用户主动中断 vs 系统超时
- 中断后重新评估任务策略，避免重复相同操作
- 提供任务进度保存和恢复机制
- 建立中断情况下的优雅降级方案

### 文件搜索策略优化
- file_search失败时立即切换到grep_search精确搜索
- 避免全项目范围的模糊搜索，优先精确模式搜索
- 使用list_dir确认目录存在后再进行文件搜索
- 建立文件搜索的备选方案和降级策略
- 搜索范围逐步扩大而非一次性全局搜索

### 任务状态管理和记录
- 记录已完成的检查和验证，避免重复
- 关键发现立即记录，防止中断后遗失
- 建立任务检查点机制，支持断点续传
- 提供任务完成状态的清晰展示
- 会话中断时保存重要分析结果

**新增核心原则**：预防中断、快速恢复、状态保持、效率优先

## 长时间执行命令和会话中断优化规范

### 命令执行时间监控和中断处理
- 所有可能超过30秒的命令必须使用timeout包装：timeout 120s command
- 后台执行命令使用nohup和重定向：nohup command > output.log 2>&1 &
- 长时间命令执行前必须告知用户预期时间和可能的中断原因
- 命令中断时立即分析中断原因：用户主动中断 vs 系统超时 vs 网络问题
- 提供命令中断后的恢复机制和替代方案

### 会话状态保持和恢复规范
- 关键操作前保存当前会话状态和已完成步骤
- 使用检查点机制记录重要的中间结果
- 会话中断后能够从最近检查点恢复而非重新开始
- 避免重复执行已完成的检查和验证步骤
- 建立会话恢复的标准化流程

### 后台进程管理和监控
- 后台进程启动后立即记录进程ID和状态
- 定期检查后台进程运行状态：ps aux | grep process_name
- 后台进程异常终止时提供详细的错误信息和解决方案
- 会话结束前清理所有临时后台进程
- 建立后台进程的生命周期管理机制

## 问题分析标准化和效率优化规范

### 问题定位五步法
- 步骤1：项目类型识别（30秒内完成）- 检查关键文件确定技术栈
- 步骤2：服务状态检查（1分钟内完成）- 并行检查端口、进程、健康状态
- 步骤3：错误日志分析（1分钟内完成）- 查看最近错误和警告信息
- 步骤4：配置文件验证（1分钟内完成）- 检查关键配置项和依赖
- 步骤5：问题分类和解决方案制定（1分钟内完成）- 确定修复策略

### 并行诊断策略优化
- 系统状态检查必须并行执行：端口占用、进程状态、服务健康检查
- 文件存在性检查与内容读取分离，避免无效的文件读取
- 配置验证与日志分析可以并行进行
- 同类型的多个API端点测试必须并行执行
- 独立的服务组件状态检查避免串行等待

### 工具调用效率评估和优化
- 每次工具调用前评估必要性，避免冗余操作
- 工具调用失败时立即切换备选方案，不超过2次重试
- 建立工具调用效率统计，识别低效操作模式
- 优先使用精确搜索而非模糊搜索，提高搜索准确性
- 大文件操作前先评估文件大小，选择合适的处理策略

### 错误分类和快速响应机制
- A类错误（配置问题）：立即修复，1-2分钟解决
- B类错误（服务问题）：重启服务，3-5分钟解决  
- C类错误（代码问题）：代码修改，5-10分钟解决
- D类错误（环境问题）：环境重建，10-15分钟解决
- 每类错误建立标准化的诊断和修复流程

## 会话质量控制和学习改进规范

### 会话效率指标监控
- 问题定位时间：目标5分钟内确定问题类型和范围
- 工具调用成功率：目标90%以上，失败时立即分析原因
- 重复操作次数：同类检查不超过2次，避免无效重复
- 用户等待时间：单次操作不超过30秒，长操作必须分段
- 问题解决完整性：确保所有子问题都得到解决

### 持续改进和规则优化
- 每次会话结束后记录主要问题和改进点
- 识别重复出现的问题模式，更新预防规则
- 建立问题解决方案知识库，提高后续处理效率
- 定期回顾和优化工具使用策略
- 持续更新cursor规则，形成经验积累机制

### 用户体验优化规范
- 复杂操作前提供清晰的步骤说明和预期时间
- 长时间操作提供进度反馈和中间结果
- 操作失败时提供具体的错误原因和解决建议
- 避免技术术语过多，使用通俗易懂的描述
- 关键操作完成后提供验证步骤和确认机制

**最终核心原则**：快速响应、精准定位、并行处理、状态保持、持续改进、用户至上

## Terminal系统故障诊断和处理规范

### Terminal系统故障识别和诊断
- 所有命令返回Exit code: 1且无输出时立即识别为系统级故障
- 故障诊断顺序：基础命令(whoami) → 文件系统命令(ls) → Shell内置命令(echo) → 显式Shell调用
- 连续3个不同类型命令失败时确认为Terminal系统完全故障
- 故障发生时立即停止所有Terminal操作，避免浪费请求次数
- 记录故障发生的时间点和操作上下文，便于问题追踪

### Terminal故障快速恢复策略
- 发现故障后立即通知用户需要重启开发环境
- 提供详细的故障状态描述和恢复步骤说明
- 建立故障状态下的任务保存机制，记录已完成的操作
- 环境重启后快速验证Terminal功能恢复：pwd → ls → git status
- 制定故障期间的替代方案：优先使用文件操作工具继续任务

### Terminal故障预防和监控
- 每次会话开始前执行基础命令验证Terminal状态
- 长时间会话中定期检查Terminal响应性能
- 识别容易导致Terminal故障的操作模式（如长时间分页显示）
- 建立Terminal健康状态评估机制，预防性发现问题
- 记录故障模式和触发条件，建立预防性规则

## Git分页器卡死和命令优化规范

### Git分页器问题识别和处理
- git log、git show、git diff等命令默认启用分页器
- 分页器界面显示(END)...skipping...时表示命令卡在等待用户交互
- 运行超过30秒无响应的git命令立即判定为分页器卡死
- 所有可能触发分页器的git命令必须添加 | cat 后缀
- 分页器卡死时立即按Ctrl+C终止，使用带 | cat 的命令重新执行

### Git命令标准化防卡死配置
- git log --oneline -N | cat（N为具体行数，避免无限制输出）
- git show --name-only COMMIT_HASH | cat
- git diff --name-only | cat
- git branch -a | cat
- git remote -v | cat（虽然通常不会触发分页器，但保持一致性）

### Git输出控制和格式化规范
- 所有git log命令必须限制输出行数：--oneline -10
- 查看提交历史使用格式化输出：--pretty=format:"%h %s" -N
- 大型仓库操作前设置合理超时：timeout 60s git command | cat
- Git命令组合使用管道时确保每个环节都不会卡死
- 建立Git命令执行时间监控，超过预期时间自动终止重试

## 工具调用超时和中断优化规范

### 工具调用时间预估和限制
- search_replace工具：大文件(>10KB)预估60-120秒，设置相应超时预期
- file_search工具：全项目搜索预估30-60秒，优先使用精确搜索减少时间
- edit_file工具：大文件编辑预估30-90秒，分段处理减少单次操作时间
- read_file工具：通常10-30秒，大文件分段读取避免超时
- run_terminal_cmd工具：根据命令复杂度预估，设置timeout包装

### 工具调用超时应对策略
- 超过预期时间50%时主动评估是否需要中断
- 用户按规则12中断时立即停止，分析超时原因
- 超时后选择替代工具：search_replace → edit_file → grep_search + edit_file
- 大文件操作改为分段处理：分批读取、分区域编辑、分步骤验证
- 建立工具调用效率统计，识别经常超时的操作模式

### 中断后任务恢复和继续机制
- 工具调用中断后立即保存已获取的信息和分析结果
- 建立任务检查点机制：将复杂任务分解为多个独立步骤
- 中断后重新评估任务策略，选择更高效的实现路径
- 提供中断恢复时的状态同步机制，避免重复已完成的工作
- 记录中断原因和恢复方案，优化后续类似任务的处理

## 会话效率和请求次数优化规范

### 请求次数浪费识别和避免
- 识别低效操作模式：重复相同检查、串行执行可并行操作、盲目重试失败命令
- 避免冗余工具调用：先评估必要性，检查是否已有相同信息
- 并行执行独立检查：系统状态、文件存在性、配置验证可同时进行
- 智能重试机制：分析失败原因，选择不同方法而非重复相同操作
- 建立操作效率评估标准，持续优化工具使用策略

### 高效会话流程设计
- 会话开始时快速环境检查：Terminal状态、项目类型、基础配置
- 任务分解策略：复杂任务分解为独立模块，支持并行处理和中断恢复
- 信息收集优化：一次性收集所需信息，避免多次零散查询
- 结果验证集约化：批量验证多个操作结果，减少单独验证次数
- 建立会话效率指标监控和改进机制

### 错误处理和学习改进
- 每次会话结束后分析效率瓶颈和改进点
- 记录常见问题的最优解决路径，建立解决方案模板
- 识别导致请求次数浪费的操作模式，制定预防规则
- 建立问题分类和快速诊断机制，提高问题解决效率
- 持续优化工具调用策略和会话流程设计

## 开发环境稳定性和故障预防规范

### 开发环境健康监控
- 定期检查容器/虚拟环境资源使用情况
- 监控Shell会话稳定性和响应时间
- 识别可能导致环境不稳定的操作：大文件处理、长时间命令执行
- 建立环境健康评估标准和预警机制
- 制定环境维护和重置的标准流程

### 故障预防和快速恢复
- 关键操作前保存当前状态和进度
- 建立操作回滚和恢复机制
- 制定不同类型故障的应急处理预案
- 优化资源使用，避免因资源耗尽导致的系统故障
- 建立故障模式识别和预防知识库

**Terminal和工具调用核心原则**：预防优于应急、效率优于完美、恢复优于重启、学习优于重复

## 编码显示和多语言处理规范

### 中文内容显示优化
- Terminal中文显示异常时立即检查LANG环境变量
- Git提交信息和日志中文显示为编码格式时使用git配置修复
- 设置标准中文环境：export LANG=zh_CN.UTF-8
- Git中文配置标准化：git config --global core.quotepath false
- 建立中文显示问题的快速诊断和修复流程

### 多语言环境兼容性
- 跨平台开发时统一使用UTF-8编码
- 文件名包含中文时使用引号包围处理
- 避免在命令行直接处理编码转义的中文字符
- 建立多语言内容的标准化处理模板
- 制定编码问题的预防和检测机制

**编码处理核心原则**：标准化优于特例、UTF-8优于其他编码、预防优于修复、兼容性优于平台特定

## 文件操作状态验证和缓存一致性规范

### 文件操作结果验证机制
- 所有文件操作(edit_file、delete_file)后必须通过read_file验证实际结果
- 不能依赖list_dir的缓存数据判断文件是否修改成功
- 关键文件操作后使用多种方式交叉验证：read_file + grep确认内容
- 大文件编辑后检查文件的开头和结尾内容，确保操作完整性
- 建立文件操作成功的多重验证标准

### 缓存数据不一致问题处理
- list_dir显示的文件大小和行数可能是缓存数据，不能作为唯一判断标准
- 文件内容变更后，系统显示的元数据可能有延迟更新
- 重要操作完成后等待3-5秒再进行状态检查，避免缓存问题
- 使用直接文件读取而非元数据来验证操作结果
- 建立缓存数据不一致的识别和处理机制

### 操作失败但无明确报错的问题诊断
- 工具操作返回成功但实际未生效的情况需要主动验证
- 建立操作前后的状态对比机制，及时发现隐性失败
- 关键操作采用多步验证：操作执行 → 状态检查 → 内容验证 → 功能测试
- 系统环境不稳定时增加验证频次和验证深度
- 记录和分析隐性失败的模式，建立预防机制

### 文件系统状态同步优化
- 重要文件操作后主动触发系统状态刷新
- 批量文件操作时在关键节点进行状态同步验证
- 跨工具操作时确保状态一致性：edit_file → read_file → list_dir
- 建立文件系统状态的强制刷新机制
- 制定文件操作的标准验证流程和检查清单

**文件操作核心原则**：验证优于信任、多重确认、状态同步、主动检测、预防失败

## 会话问题分析和持续改进总结规范

### 会话问题识别和分类标准
- A级问题(系统级)：Terminal故障、环境不稳定等影响基础功能的问题
- B级问题(工具级)：特定工具超时、分页器卡死等影响操作效率的问题  
- C级问题(显示级)：编码问题、状态显示不一致等影响信息准确性的问题
- D级问题(流程级)：重复操作、低效工具调用等影响会话效率的问题
- E级问题(预防级)：潜在风险、边界情况等需要规则预防的问题

### 问题根因分析和解决方案设计
- 每个问题必须追溯到根本原因：技术原因、环境原因、流程原因、工具限制
- 解决方案设计遵循分层策略：immediate fix → workaround → long-term solution
- 建立问题解决的标准模板：问题描述 → 根因分析 → 解决方案 → 预防措施
- 优先处理高频出现和高影响的问题，建立问题优先级矩阵
- 每类问题建立标准化的诊断流程和解决预案

### 规则生成和分类写入规范
- 新规则必须按问题领域准确分类：系统故障→主规则、编码问题→编码规则等
- 规则内容必须完整覆盖：问题识别 → 处理流程 → 预防机制 → 验证方法
- 避免规则冗余和重复，与现有规则进行整合和优化
- 规则表述要具体可执行，避免抽象描述和模糊指导
- 建立规则有效性验证机制，确保规则能真正解决问题

### 持续改进和学习机制
- 每次会话结束后总结问题模式和解决效果
- 建立问题知识库，记录问题特征和最佳解决方案
- 定期回顾和更新规则，删除过时规则，增加新发现的规则
- 建立问题预防的主动检测机制，减少问题发生频率
- 形成问题分析的标准化流程，提高问题解决效率

**持续改进核心原则**：问题导向、数据驱动、标准化流程、预防优先、知识积累

