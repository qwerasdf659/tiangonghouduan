---
description: 
globs: 
alwaysApply: true
---
# 项目开发规范总览

## 数据库表结构和索引管理规范
- 禁止在生产环境频繁使用sequelize.sync({ alter: true })或force: true，表结构变更必须通过手动SQL脚本或迁移工具完成
- 每张表的索引总数不得超过MySQL的64个限制，如需新增索引，必须先评估和清理无用索引
- 初始化脚本必须加超时和详细日志，如遇长时间无响应，需立即排查数据库连接和表结构问题
- 大批量数据插入必须分批处理，每批不超过100条，避免单次SQL阻塞
- 所有表结构和索引变更需在代码评审时重点检查，防止上线后阻塞数据库
- 生产环境下，sequelize.sync({ alter: true }) 或 force: true 不要频繁使用，建议只在开发或首次部署时用
- 数据库长时间初始化处理：当数据库初始化脚本运行超过2分钟时，应该先检查数据库状态和表结构，验证数据是否已成功初始化，使用timeout命令限制脚本运行时间，避免在生产环境使用force模式重建数据库

## 测试数据一致性规范
- 所有测试用户数据必须定义在统一的配置文件中（如 config/test-data.js）
- 禁止在多个文件中硬编码相同的测试数据
- 初始化脚本和测试脚本必须引用同一个数据源
- 只保留一个主要的初始化脚本，其他过时脚本必须删除或明确标记
- 测试脚本必须包含数据存在性检查，避免空指针异常
- 所有数据库操作前必须验证依赖数据是否存在
- 所有测试文件的模型导入路径必须一致
- 使用相对路径时必须确保从当前文件位置正确导入
- 添加模型导入失败的错误处理
- 每次修改初始化脚本时，必须同步更新相关的测试脚本
- 在CI/CD中添加测试数据一致性检查
- 测试失败时输出明确的错误信息，包含期望数据和实际数据
- 所有数据库查询必须检查返回结果是否为null/undefined
- 使用 try-catch 包装可能失败的操作
- 提供有意义的错误消息，便于快速定位问题

### 测试数据处理示例代码：
```javascript
// ✅ 正确模式 - 统一配置 + 错误检查  
const TEST_CONFIG = require('./config/test-data.js');
const testUser = await User.findOne({ where: { mobile: TEST_CONFIG.TEST_USER_MOBILE } });
if (!testUser) {
  console.error(`测试用户不存在: ${TEST_CONFIG.TEST_USER_MOBILE}`);
  console.log('请运行: node scripts/init-database.js');
  process.exit(1);
}
const { accessToken } = generateTokens(testUser);
```

## Node.js 应用开发和部署规范

### 内存管理规范
- 开发环境必须设置合理的内存限制，避免内存使用率超过80%
- 使用 NODE_OPTIONS="--max-old-space-size=512" 控制堆内存大小
- PM2配置中设置 max_memory_restart 低于实际内存限制
- 实施内存监控告警，超过75%时自动重启进程
- 避免在开发环境使用集群模式，优先使用fork模式

### API路径规范
- 健康检查端点必须同时提供 /health 和 /api/health 两个路径
- 所有API端点必须有对应的错误处理机制
- API路径变更时必须同步更新文档和测试用例
- 实施API版本控制和向后兼容策略

### 服务监控规范
- 所有服务组件必须实现 isHealthy() 方法
- WebSocket等实时服务需要实现连接计数和状态检查
- 健康检查端点必须返回详细的服务状态信息
- 实施服务依赖检查和故障隔离机制

### 进程管理规范
- 开发环境使用单进程模式，生产环境可使用集群模式
- 配置合理的进程重启策略和超时时间
- 实施优雅关闭机制，确保数据一致性
- 配置日志轮转和存储策略

### 资源优化规范
- Node.js启动参数必须根据环境进行优化
- 避免使用不支持的启动参数组合
- 实施资源使用监控和告警机制
- 定期进行性能分析和优化

### 错误处理规范
- 所有异步操作必须有错误处理
- 实施全局错误捕获和处理机制
- 错误信息必须包含上下文和解决建议
- 建立错误分类和优先级体系

### 部署配置规范
- 环境配置必须区分开发、测试、生产环境
- 敏感信息必须通过环境变量管理
- 实施配置验证和兼容性检查
- 建立配置变更追踪机制

## 工具调用和工作流程优化规范

### 文档修改工具选择策略
- 对于大型文档(>1000行)优先使用edit_file工具
- search_replace仅用于小范围精确替换
- 中文文档修改时特别注意编码和格式问题
- 文档修改失败时立即切换工具，避免重复尝试
- 长文档修改前先用grep_search定位目标位置

### 工作流程时机优化
- 采用"分析→实现→验证→文档"的标准流程
- 代码修改阶段专注于功能实现，避免文档干扰
- 所有功能实现完成后统一进行文档更新
- 文档更新失败不应影响代码实现进度
- 建立检查点机制，确保每个阶段完整性

### 工具调用效率优化
- 使用并行工具调用处理独立任务
- 文件读取前先用file_search确认文件存在
- 大文件修改前用grep_search预定位
- 避免重复的状态检查，使用缓存结果
- 工具调用失败时立即分析原因，避免盲目重试

### 错误分析和学习机制
- 每次会话结束后分析问题模式
- 记录工具使用效率和失败原因
- 更新cursor规则以避免重复问题
- 建立问题解决方案知识库
- 定期回顾和优化工作流程

## 命令执行和环境检查规范

### 环境依赖完整性检查
- 在开始任何开发任务前必须执行环境检查
- 检查Node.js版本和PM2安装状态
- 验证package.json中的依赖是否已安装
- 确认数据库连接配置的正确性
- 验证环境变量文件的完整性

### 应用启动状态验证
- 应用启动后必须进行完整的健康检查
- 检查端口监听状态：netstat -tlnp | grep :PORT
- 验证健康检查端点：curl -f http://localhost:PORT/api/health
- 确认PM2进程状态：pm2 status
- 检查应用日志：pm2 logs --lines 20

### 命令执行标准化
- 所有长时间运行的命令必须设置超时和限制参数
- 使用timeout命令限制执行时间：timeout 120s command
- 日志查看命令必须限制行数：--lines N
- 网络请求必须设置超时：curl -m 30
- 大文件操作需要进度显示和分段处理

### 错误处理和恢复
- 每个关键操作必须有错误处理和恢复机制
- 命令失败时提供具体的错误信息和解决方案
- 超时命令必须有重试机制（最多3次）
- 关键服务异常时提供替代方案
- 错误信息必须包含上下文和调试信息

## 项目文档和配置管理规范

### 配置文件同步机制
- .cursor-rules必须包含全部开发规范
- 环境变量配置必须与实际部署环境匹配
- 项目文档必须与实际代码功能保持同步
- 定期检查配置文件的完整性和正确性

### 并行诊断优化
- 优先使用并行工具调用提高效率
- 同时检查多个服务状态
- 并行读取多个配置文件
- 同时执行多个独立的验证命令
- 避免不必要的串行等待

### 资源监控和告警
- 系统资源使用必须在安全范围内
- 内存使用率不得超过80%
- CPU使用率持续监控，超过90%时告警
- 磁盘空间监控，日志文件定期清理
- 网络连接数监控，防止连接泄漏

### WebSocket服务监控
- WebSocket服务必须实现完整的健康检查
- 实现isHealthy()方法检查连接状态
- 监控活跃连接数和连接质量
- 提供连接重连机制和故障转移
- 记录详细的连接和断开日志

### 开发环境一致性
- 开发环境配置必须标准化
- 所有开发者使用相同的Node.js版本
- 统一的依赖管理和版本锁定
- 标准化的启动和停止脚本
- 一致的环境变量配置模板

## Cursor规则文件管理规范

### Cursor规则文件正确处理流程
- 处理cursor规则时必须首先检查.cursor/rules/目录
- 发现现有规则文件时禁止在根目录创建同名文件
- 所有cursor规则更新必须直接修改.cursor/rules/下的文件
- 规则更新后必须验证Cursor编辑器是否正确识别
- 如需记录分析过程，创建独立文档但不能与规则文件同名

### 文件操作验证规范
- 每次文件操作后必须验证操作结果
- 重命名、移动、删除操作必须确认最终状态
- 使用ls命令验证文件系统的实际状态
- 避免基于假设进行后续操作

### 工具调用效率规范
- 独立的检查操作必须使用并行工具调用
- 文件存在性检查与内容读取可以并行执行
- 避免重复的状态检查和冗余操作
- 每次工具调用失败时立即分析原因

## 会话问题预防和效率优化规范

### API路由验证规范
- 在访问任何API端点前必须先检查实际路由定义
- 使用 grep -r "app.get.*endpoint" 确认路由存在
- 健康检查优先使用 /health 路径，如404则尝试 /api/health
- 避免盲目重复访问不存在的端点浪费请求次数
- API测试失败时立即检查路由配置而非重复尝试

### 命令执行超时控制规范
- 所有可能长时间运行的命令必须使用timeout限制
- PM2日志查看：timeout 10s pm2 logs --lines 10
- 网络请求：curl -m 30 或 timeout 10s curl
- 文件搜索：timeout 30s find 或 timeout 20s grep -r
- 数据库操作：timeout 60s node scripts/db-operation.js
- 超时时间设置原则：简单操作10s，复杂操作30-60s

### 工具调用超时预防规范
- file_search工具调用前先评估搜索范围，避免全项目搜索
- 大文件读取前先检查文件大小：ls -lh filename
- 使用grep_search替代file_search进行精确搜索
- 并行工具调用时设置合理的超时预期
- 工具调用失败时立即切换策略，避免重复尝试

### 日志和监控命令规范
- PM2日志查看必须限制行数：pm2 logs --lines N
- 系统日志查看使用：tail -n 20 /var/log/app.log
- 实时日志监控使用timeout：timeout 30s tail -f logfile
- 避免使用无限制的日志查看命令
- 日志分析优先使用grep过滤关键信息

### 依赖版本和警告处理规范
- 定期检查package.json中的过时依赖
- AWS SDK v2警告：计划升级到 @aws-sdk/client-* v3版本
- Node.js版本兼容性：确保依赖支持当前Node.js版本
- 警告信息不影响功能时可暂时忽略，但需记录升级计划
- 关键依赖版本变更需要充分测试

### 状态检查缓存和优化规范
- 避免在同一会话中重复执行相同的状态检查
- 使用变量缓存健康检查、端口状态等结果
- 状态变更后才重新检查，否则使用缓存结果
- 批量状态检查优于单个检查
- 建立检查清单，避免遗漏关键状态

### 错误处理和学习改进规范
- 每次会话结束后总结主要问题和解决方案
- 识别重复出现的问题模式
- 更新cursor规则防止同类问题再次发生
- 建立问题分类：路由错误、超时问题、依赖问题、配置问题
- 为每类问题建立标准解决流程

### 系统状态验证规范
- 关键修改操作后必须验证应用运行状态
- 使用健康检查端点确认系统正常运行
- 定期检查内存使用和系统资源状态
- 建立操作前后的状态对比机制

### 记忆管理和学习改进规范
- 发现重复错误时必须创建防止性记忆
- 每次会话结束后总结关键问题和解决方案
- 建立问题模式识别和避免机制
- 持续优化工作流程和规则体系

**核心原则**：安全优先、效率并重、错误可控、操作可追溯

## 项目类型识别和环境分析规范

### 项目类型快速识别机制
- 任务开始前必须先进行项目类型识别和环境分析
- 检查项目根目录关键文件：package.json、app.js、project.config.json、requirements.txt等
- 根据文件特征判断项目类型：
  * Node.js后端：package.json + app.js/server.js + routes/目录
  * 微信小程序：project.config.json + app.json + pages/目录 + utils/目录
  * Python项目：requirements.txt + app.py/main.py
  * React前端：package.json + src/目录 + public/目录
- 避免基于任务描述盲目假设项目类型
- 项目类型确认后制定对应的分析策略

### 目录结构预分析规范
- 使用list_dir先查看项目根目录结构
- 识别关键目录和文件模式：
  * 后端项目：routes/, models/, controllers/, middleware/
  * 前端项目：src/, components/, pages/, utils/
  * 全栈项目：frontend/, backend/, client/, server/
- 避免盲目搜索不存在的文件和目录
- 基于实际目录结构调整搜索策略

### 环境和技术栈识别
- 检查package.json了解依赖和脚本
- 分析启动命令和构建工具
- 识别使用的框架和技术栈
- 确认开发和生产环境配置
- 避免使用不匹配的工具和命令

### 配置文件定位策略
- 根据项目类型使用对应的配置文件搜索模式
- Node.js项目：config/, .env, package.json
- 微信小程序：project.config.json, app.json, sitemap.json
- 使用grep_search精确定位配置项而非盲目搜索
- 避免在错误的项目类型中查找特定配置

### 问题诊断标准流程
- 步骤1：项目类型和环境识别（5分钟内完成）
- 步骤2：关键文件和配置定位
- 步骤3：问题相关组件和服务检查
- 步骤4：具体问题分析和解决方案制定
- 每个步骤完成后验证，避免方向性错误

## 网络请求和API测试优化规范

### API端点验证标准流程
- 测试前先检查路由定义：grep -r "app.get\|router.get" routes/
- 健康检查端点优先级：/health > /api/health > /status
- 使用curl -s测试避免冗长输出，需要详细信息时使用-v
- API测试失败时立即检查backend路由而非重复请求
- 建立常用端点的验证缓存，避免重复测试

### JSON数据处理规范
- curl返回JSON时检查数据完整性，避免截断影响分析
- jq不可用时使用python -m json.tool格式化
- 大JSON响应使用head/tail限制显示长度
- 关键字段提取使用grep而非依赖完整JSON解析
- 建立JSON处理工具的备选方案

### 网络请求超时和重试
- 所有curl请求设置合理超时：curl -m 30
- 失败请求最多重试2次，避免无限重试
- 网络问题和配置问题区分处理
- 超时请求提供诊断信息和解决建议
- 建立网络请求成功率监控

### 微信小程序域名配置诊断
- 确认问题是域名白名单问题而非服务问题
- 区分小程序端错误和服务端错误
- 提供标准的域名配置检查清单
- 建立小程序网络问题快速诊断流程
- 记录常见配置错误和解决方案

## 工具调用中断处理和恢复规范

### 并行工具调用限制
- 同时执行的并行工具调用不超过3个
- 文件搜索类工具（file_search, grep_search）不并行执行
- 用户交互期间暂停新的工具调用
- 工具调用被中断时立即分析原因
- 建立工具调用优先级队列

### 中断检测和恢复机制
- 工具调用返回"Error: no result from tool"时立即停止相关操作
- 分析中断原因：用户主动中断 vs 系统超时
- 中断后重新评估任务策略，避免重复相同操作
- 提供任务进度保存和恢复机制
- 建立中断情况下的优雅降级方案

### 文件搜索策略优化
- file_search失败时立即切换到grep_search精确搜索
- 避免全项目范围的模糊搜索，优先精确模式搜索
- 使用list_dir确认目录存在后再进行文件搜索
- 建立文件搜索的备选方案和降级策略
- 搜索范围逐步扩大而非一次性全局搜索

### 任务状态管理和记录
- 记录已完成的检查和验证，避免重复
- 关键发现立即记录，防止中断后遗失
- 建立任务检查点机制，支持断点续传
- 提供任务完成状态的清晰展示
- 会话中断时保存重要分析结果

**新增核心原则**：预防中断、快速恢复、状态保持、效率优先

## 长时间执行命令和会话中断优化规范

### 命令执行时间监控和中断处理
- 所有可能超过30秒的命令必须使用timeout包装：timeout 120s command
- 后台执行命令使用nohup和重定向：nohup command > output.log 2>&1 &
- 长时间命令执行前必须告知用户预期时间和可能的中断原因
- 命令中断时立即分析中断原因：用户主动中断 vs 系统超时 vs 网络问题
- 提供命令中断后的恢复机制和替代方案

### 会话状态保持和恢复规范
- 关键操作前保存当前会话状态和已完成步骤
- 使用检查点机制记录重要的中间结果
- 会话中断后能够从最近检查点恢复而非重新开始
- 避免重复执行已完成的检查和验证步骤
- 建立会话恢复的标准化流程

### 后台进程管理和监控
- 后台进程启动后立即记录进程ID和状态
- 定期检查后台进程运行状态：ps aux | grep process_name
- 后台进程异常终止时提供详细的错误信息和解决方案
- 会话结束前清理所有临时后台进程
- 建立后台进程的生命周期管理机制

## 问题分析标准化和效率优化规范

### 问题定位五步法
- 步骤1：项目类型识别（30秒内完成）- 检查关键文件确定技术栈
- 步骤2：服务状态检查（1分钟内完成）- 并行检查端口、进程、健康状态
- 步骤3：错误日志分析（1分钟内完成）- 查看最近错误和警告信息
- 步骤4：配置文件验证（1分钟内完成）- 检查关键配置项和依赖
- 步骤5：问题分类和解决方案制定（1分钟内完成）- 确定修复策略

### 并行诊断策略优化
- 系统状态检查必须并行执行：端口占用、进程状态、服务健康检查
- 文件存在性检查与内容读取分离，避免无效的文件读取
- 配置验证与日志分析可以并行进行
- 同类型的多个API端点测试必须并行执行
- 独立的服务组件状态检查避免串行等待

### 工具调用效率评估和优化
- 每次工具调用前评估必要性，避免冗余操作
- 工具调用失败时立即切换备选方案，不超过2次重试
- 建立工具调用效率统计，识别低效操作模式
- 优先使用精确搜索而非模糊搜索，提高搜索准确性
- 大文件操作前先评估文件大小，选择合适的处理策略

### 错误分类和快速响应机制
- A类错误（配置问题）：立即修复，1-2分钟解决
- B类错误（服务问题）：重启服务，3-5分钟解决  
- C类错误（代码问题）：代码修改，5-10分钟解决
- D类错误（环境问题）：环境重建，10-15分钟解决
- 每类错误建立标准化的诊断和修复流程

## 会话质量控制和学习改进规范

### 会话效率指标监控
- 问题定位时间：目标5分钟内确定问题类型和范围
- 工具调用成功率：目标90%以上，失败时立即分析原因
- 重复操作次数：同类检查不超过2次，避免无效重复
- 用户等待时间：单次操作不超过30秒，长操作必须分段
- 问题解决完整性：确保所有子问题都得到解决

### 持续改进和规则优化
- 每次会话结束后记录主要问题和改进点
- 识别重复出现的问题模式，更新预防规则
- 建立问题解决方案知识库，提高后续处理效率
- 定期回顾和优化工具使用策略
- 持续更新cursor规则，形成经验积累机制

### 用户体验优化规范
- 复杂操作前提供清晰的步骤说明和预期时间
- 长时间操作提供进度反馈和中间结果
- 操作失败时提供具体的错误原因和解决建议
- 避免技术术语过多，使用通俗易懂的描述
- 关键操作完成后提供验证步骤和确认机制

**最终核心原则**：快速响应、精准定位、并行处理、状态保持、持续改进、用户至上

