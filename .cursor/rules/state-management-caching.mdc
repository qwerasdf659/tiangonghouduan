---
description: 
globs: 
alwaysApply: false
---
# 状态管理和缓存规则
# 解决重复状态检查和验证问题

## 核心问题分析
通过对实际会话的深度分析，发现以下严重的状态管理问题：
- 重复状态检查：同一状态被检查3-5次
- 缺乏状态缓存：已验证的状态信息未被复用
- 状态变更检测不足：不知道何时需要重新检查状态
- 状态检查成本高：每次检查都消耗工具调用次数

## 状态缓存机制设计

### 状态分类和缓存策略
- **静态状态**：项目类型、技术栈、文件结构 - 会话期间缓存
- **半静态状态**：配置文件、环境变量、依赖版本 - 变更后重新检查
- **动态状态**：进程状态、端口占用、服务健康 - 操作后重新检查
- **临时状态**：网络连接、数据库连接 - 每次使用前检查

### 状态检查频率控制
- **一次性检查**：项目类型、技术栈识别只检查一次
- **变更触发**：配置修改后才重新检查相关状态
- **操作触发**：服务操作后才重新检查服务状态
- **定时检查**：长时间会话中定期检查关键状态

### 状态信息结构化存储
```
状态缓存结构：
{
  "project_type": "nodejs_backend",
  "tech_stack": ["express", "sequelize", "mysql"],
  "services": {
    "database": {"status": "running", "last_check": "timestamp"},
    "web_server": {"status": "running", "port": 3000, "last_check": "timestamp"}
  },
  "configurations": {
    "env_vars": {"status": "validated", "last_check": "timestamp"},
    "database_config": {"status": "valid", "last_check": "timestamp"}
  }
}
```

## 重复检查防止机制

### 检查历史记录
- **已检查项目清单**：记录会话中已完成的检查项目
- **检查结果记录**：记录每次检查的结果和时间戳
- **检查依赖关系**：识别检查之间的依赖关系
- **检查有效期**：设定检查结果的有效期

### 智能检查决策
- **检查前评估**：检查前评估是否必要
- **结果复用**：优先复用已有的检查结果
- **批量检查**：将相关检查合并为一次操作
- **条件检查**：只在特定条件下执行检查

### 检查去重算法
```
检查去重流程：
1. 解析检查请求
2. 查找缓存中的相同检查
3. 评估缓存结果的有效性
4. 决定是否需要重新检查
5. 执行检查或返回缓存结果
6. 更新缓存和历史记录
```

## 状态变更检测机制

### 变更事件识别
- **配置文件修改**：监测配置文件的变更
- **服务操作执行**：识别可能影响服务状态的操作
- **环境变更**：检测环境变量或依赖的变更
- **用户操作**：识别用户主动的状态变更操作

### 变更影响分析
- **直接影响**：变更直接影响的状态项
- **间接影响**：变更可能间接影响的状态项
- **影响范围**：评估变更影响的范围和程度
- **优先级**：按影响程度确定重新检查的优先级

### 增量更新策略
- **局部更新**：只更新受影响的状态项
- **依赖更新**：同时更新有依赖关系的状态项
- **批量更新**：合并多个相关的状态更新
- **异步更新**：非关键状态的异步更新

## 状态一致性保证

### 状态同步机制
- **原子操作**：确保状态检查和更新的原子性
- **事务机制**：批量状态更新的事务保证
- **一致性检查**：定期检查状态的一致性
- **冲突解决**：处理状态更新冲突的策略

### 状态验证规则
- **必要性验证**：验证状态检查的必要性
- **有效性验证**：验证状态信息的有效性
- **完整性验证**：验证状态信息的完整性
- **时效性验证**：验证状态信息的时效性

### 状态异常处理
- **检查失败**：状态检查失败时的处理策略
- **状态不一致**：发现状态不一致时的处理方法
- **缓存失效**：缓存失效时的重建策略
- **异常恢复**：状态异常时的恢复机制

## 工具调用优化策略

### 工具调用成本评估
- **成本计算**：计算每次工具调用的成本
- **效益分析**：分析工具调用的效益
- **ROI评估**：评估工具调用的投资回报率
- **优化建议**：提供工具调用优化建议

### 工具调用合并策略
- **批量操作**：将多个独立操作合并为批量操作
- **并行执行**：并行执行独立的工具调用
- **操作优化**：优化工具调用的参数和选项
- **结果复用**：复用工具调用的结果

### 工具调用缓存
- **结果缓存**：缓存工具调用的结果
- **参数缓存**：缓存常用的工具调用参数
- **模板缓存**：缓存常用的工具调用模板
- **策略缓存**：缓存成功的工具调用策略

## 性能监控和优化

### 性能指标监控
- **检查次数**：监控状态检查的次数
- **检查耗时**：监控状态检查的耗时
- **缓存命中率**：监控缓存的命中率
- **重复率**：监控重复检查的比率

### 性能优化策略
- **热点优化**：优化频繁检查的状态项
- **批量优化**：优化批量状态检查的效率
- **并行优化**：优化并行状态检查的性能
- **缓存优化**：优化缓存的存储和检索效率

### 性能报告和分析
- **性能报告**：生成定期的性能报告
- **瓶颈分析**：分析性能瓶颈和优化空间
- **趋势分析**：分析性能趋势和变化
- **优化建议**：提供基于分析的优化建议

## 实施规范和最佳实践

### 状态管理实施规范
- **状态定义**：明确定义各种状态的含义和范围
- **检查标准**：制定状态检查的标准和流程
- **缓存策略**：制定状态缓存的策略和规则
- **更新机制**：制定状态更新的机制和时机

### 最佳实践指导
- **设计原则**：遵循状态管理的设计原则
- **实现模式**：使用经过验证的实现模式
- **测试方法**：采用有效的测试方法
- **运维实践**：遵循运维的最佳实践

### 质量保证措施
- **代码审查**：进行状态管理代码的审查
- **单元测试**：编写状态管理的单元测试
- **集成测试**：进行状态管理的集成测试
- **性能测试**：进行状态管理的性能测试

## 错误处理和恢复

### 错误分类和处理
- **检查错误**：状态检查失败的处理
- **缓存错误**：缓存操作失败的处理
- **同步错误**：状态同步失败的处理
- **一致性错误**：状态一致性问题的处理

### 恢复机制设计
- **自动恢复**：自动恢复机制的设计
- **手动恢复**：手动恢复操作的指导
- **数据恢复**：状态数据的恢复方法
- **服务恢复**：状态管理服务的恢复

### 预防措施
- **预防检查**：预防性的状态检查
- **预警机制**：状态异常的预警机制
- **备份策略**：状态数据的备份策略
- **监控告警**：状态监控的告警机制

## 持续改进机制

### 反馈收集
- **用户反馈**：收集用户对状态管理的反馈
- **系统反馈**：收集系统对状态管理的反馈
- **性能反馈**：收集性能监控的反馈
- **问题反馈**：收集问题和故障的反馈

### 改进实施
- **问题分析**：分析反馈中的问题和建议
- **改进计划**：制定改进计划和时间表
- **实施跟踪**：跟踪改进措施的实施
- **效果评估**：评估改进措施的效果

### 知识积累
- **经验总结**：总结状态管理的经验教训
- **最佳实践**：积累状态管理的最佳实践
- **案例库**：建立状态管理的案例库
- **培训材料**：编写状态管理的培训材料

**核心原则**：避免重复、智能缓存、状态感知、性能优先、持续优化
