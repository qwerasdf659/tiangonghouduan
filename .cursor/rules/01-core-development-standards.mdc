---
name: æ ¸å¿ƒå¼€å‘æ ‡å‡†
---

# æ ¸å¿ƒå¼€å‘æ ‡å‡†ï¼ˆåŸºäºå®é™…cursor_3.mdç­‰é—®é¢˜åˆ†æä¼˜åŒ–ç‰ˆï¼‰

## ğŸ”´ åŸºäºå®é™…å‘ç°çš„å¼€å‘è´¨é‡é—®é¢˜

### å®é™…é—®é¢˜æ¡ˆä¾‹ç»Ÿè®¡
ä»11ä¸ªcursoræ–‡æ¡£æ·±åº¦åˆ†æå‘ç°ï¼š
- **WebSocketåŠŸèƒ½ç¼ºå¤±**: cursor_3.mdä¸­å‘ç°WebSocketæœåŠ¡è¢«æ³¨é‡Š `// webSocketService.notifyNewSession(session)`
- **æ•°æ®åº“äº‹åŠ¡é”™è¯¯**: cursor_5.mdä¸­å‘ç°å¤§é‡äº‹åŠ¡å›æ»šå¤„ç†é—®é¢˜
- **å‰ç«¯APIç¼ºå¤±**: cursor_5.mdä¸­å‘ç° `TypeError: API.getUserInventory is not a function`
- **é…ç½®æ–‡ä»¶é—®é¢˜**: cursor_9.mdä¸­å‘ç°.envé…ç½®ç¼ºå¤±å¯¼è‡´æœåŠ¡å¯åŠ¨å¤±è´¥
- **ä¾èµ–ç‰ˆæœ¬å†²çª**: å¤šä¸ªæ–‡æ¡£ä¸­å‘ç°npmåŒ…ç‰ˆæœ¬ä¸å…¼å®¹é—®é¢˜

## APIæ¥å£å¼€å‘å¼ºåˆ¶è§„èŒƒ

### åŸºäºå®é™…é—®é¢˜çš„APIå®Œæ•´æ€§æ£€æŸ¥
```javascript
// ğŸ”´ åŸºäºcursor_5.mdä¸­å‘ç°çš„APIç¼ºå¤±é—®é¢˜
const API_COMPLETENESS_VALIDATOR = {
  // å¿…éœ€çš„APIç«¯ç‚¹æ£€æŸ¥
  requiredEndpoints: {
    // ç”¨æˆ·ç®¡ç†ç±»API
    user_management: [
      'POST /api/v2/auth/login',
      'POST /api/v2/auth/logout', 
      'GET /api/v2/user/profile',
      'PUT /api/v2/user/profile'
    ],
    
    // åº“å­˜ç®¡ç†ç±»APIï¼ˆcursor_5.mdä¸­ç¼ºå¤±ï¼‰
    inventory_management: [
      'GET /api/v2/inventory/list',        // getUserInventoryå‰ç«¯è°ƒç”¨
      'POST /api/v2/inventory/use',        // useInventoryItemå‰ç«¯è°ƒç”¨
      'POST /api/v2/inventory/transfer',   // transferInventoryItemå‰ç«¯è°ƒç”¨
      'POST /api/v2/inventory/generate-code' // ç”Ÿæˆæ ¸é”€ç 
    ],
    
    // æƒé™ç®¡ç†ç±»APIï¼ˆcursor_10.mdç›¸å…³ï¼‰
    permission_management: [
      'GET /api/v2/permissions/check',
      'POST /api/v2/permissions/unlock',
      'GET /api/v2/permissions/history'
    ],
    
    // èŠå¤©ç³»ç»ŸAPIï¼ˆcursor_3.mdå’Œcursor_.mdç›¸å…³ï¼‰
    chat_system: [
      'POST /api/v2/chat/session',
      'POST /api/v2/chat/message', 
      'GET /api/v2/chat/history',
      'GET /api/v2/admin/chat/sessions',    // cursor_.mdä¸­å®ç°
      'POST /api/v2/admin/chat/sessions/:id/messages'
    ]
  },
  
  // APIç«¯ç‚¹å­˜åœ¨æ€§éªŒè¯
  validateAPICompleteness: async (app) => {
    const missingEndpoints = [];
    const availableRoutes = extractRoutesFromApp(app);
    
    Object.entries(API_COMPLETENESS_VALIDATOR.requiredEndpoints).forEach(([category, endpoints]) => {
      endpoints.forEach(endpoint => {
        const [method, path] = endpoint.split(' ');
        const routeExists = availableRoutes.some(route => 
          route.method.toUpperCase() === method && route.path === path
        );
        
        if (!routeExists) {
          missingEndpoints.push({
            category,
            endpoint,
            priority: getPriority(category),
            suggestion: `éœ€è¦å®ç° ${method} ${path} æ¥å£`
          });
        }
      });
    });
    
    if (missingEndpoints.length > 0) {
      console.error('ğŸ”´ æ£€æµ‹åˆ°ç¼ºå¤±çš„APIç«¯ç‚¹:');
      missingEndpoints.forEach(missing => {
        console.error(`   âŒ [${missing.category}] ${missing.endpoint} (ä¼˜å…ˆçº§: ${missing.priority})`);
      });
      
      // ğŸ”´ åŸºäºcursor_5.mdç±»ä¼¼é—®é¢˜çš„å¤„ç†å»ºè®®
      console.log('\nğŸ”§ ä¿®å¤å»ºè®®:');
      console.log('1. ä¼˜å…ˆå®ç°é«˜ä¼˜å…ˆçº§APIç«¯ç‚¹');
      console.log('2. ç¡®ä¿å‰ç«¯è°ƒç”¨çš„APIæ–¹æ³•éƒ½æœ‰å¯¹åº”çš„åç«¯å®ç°');
      console.log('3. å»ºç«‹APIç«¯ç‚¹çš„è‡ªåŠ¨åŒ–æµ‹è¯•');
      
      return { valid: false, missingEndpoints };
    }
    
    console.log('âœ… APIç«¯ç‚¹å®Œæ•´æ€§æ£€æŸ¥é€šè¿‡');
    return { valid: true, missingEndpoints: [] };
  }
};

function getPriority(category) {
  const priorities = {
    user_management: 'HIGH',
    inventory_management: 'HIGH',
    chat_system: 'MEDIUM', 
    permission_management: 'MEDIUM'
  };
  return priorities[category] || 'LOW';
}
```

### APIæ¥å£ä¸€è‡´æ€§å¼ºåˆ¶è¦æ±‚
```javascript
// åŸºäºcursor_1.mdä¸­å‘ç°çš„è·¯å¾„ä¸åŒ¹é…é—®é¢˜
const API_CONSISTENCY_ENFORCER = {
  // å‰åç«¯è·¯å¾„æ˜ å°„è§„åˆ™
  pathMappings: {
    // cursor_.mdä¸­å‘ç°çš„å®é™…æ˜ å°„éœ€æ±‚
    '/admin/chat/sessions': '/api/v2/admin/chat/sessions',
    '/api/inventory': '/api/v2/inventory/list',
    '/api/upload': '/api/v2/photo/upload',
    '/api/auth/verify': '/api/v2/auth/verify'
  },
  
  // è‡ªåŠ¨ç”Ÿæˆå…¼å®¹è·¯ç”±
  generateCompatibilityRoutes: (app) => {
    Object.entries(API_CONSISTENCY_ENFORCER.pathMappings).forEach(([oldPath, newPath]) => {
      // ä¸ºæ—§è·¯å¾„åˆ›å»ºé‡å®šå‘
      app.all(oldPath, (req, res, next) => {
        console.log(`ğŸ”„ APIå…¼å®¹é‡å®šå‘: ${oldPath} â†’ ${newPath}`);
        req.url = newPath;
        next();
      });
      
      console.log(`âœ… åˆ›å»ºAPIå…¼å®¹è·¯ç”±: ${oldPath} â†’ ${newPath}`);
    });
  },
  
  // å‰ç«¯APIæ–¹æ³•è¡¥å…¨æ£€æŸ¥
  validateFrontendAPIMethod: (apiObject, methodName, expectedUrl) => {
    if (typeof apiObject[methodName] !== 'function') {
      console.error(`ğŸ”´ å‰ç«¯APIæ–¹æ³•ç¼ºå¤±: ${methodName}`);
      console.error(`   æœŸæœ›URL: ${expectedUrl}`);
      
      // åŸºäºcursor_5.mdé—®é¢˜çš„è‡ªåŠ¨è¡¥å…¨
      apiObject[methodName] = async function(params = {}) {
        const isGetRequest = expectedUrl.includes('list') || expectedUrl.includes('check');
        
        if (isGetRequest) {
          const query = new URLSearchParams(params).toString();
          return await request({
            url: `${expectedUrl}?${query}`,
            method: 'GET'
          });
        } else {
          return await request({
            url: expectedUrl,
            method: 'POST',
            data: params
          });
        }
      };
      
      console.log(`âœ… è‡ªåŠ¨è¡¥å…¨APIæ–¹æ³•: ${methodName}`);
    }
  }
};
```

## WebSocketæœåŠ¡å®Œæ•´æ€§è§„èŒƒ

### åŸºäºcursor_3.mdé—®é¢˜çš„WebSocketæ ‡å‡†åŒ–
```javascript
// ğŸ”´ åŸºäºcursor_3.mdä¸­å‘ç°çš„WebSocketè¢«æ³¨é‡Šé—®é¢˜
const WEBSOCKET_COMPLETENESS_VALIDATOR = {
  // å¿…éœ€çš„WebSocketæ–¹æ³•
  requiredMethods: {
    // èŠå¤©ç³»ç»Ÿç›¸å…³ï¼ˆcursor_3.mdä¸­ç¼ºå¤±ï¼‰
    chat_methods: [
      'notifyNewSession',      // é€šçŸ¥æ–°ä¼šè¯ - è¢«æ³¨é‡Šå¯¼è‡´åŠŸèƒ½ç¼ºå¤±
      'forwardChatMessage',    // è½¬å‘èŠå¤©æ¶ˆæ¯
      'broadcastToAdmins',     // å¹¿æ’­ç»™ç®¡ç†å‘˜
      'sendToUser',            // å‘é€ç»™ç”¨æˆ·
      'handleTyping'           // å¤„ç†è¾“å…¥çŠ¶æ€
    ],
    
    // åº“å­˜ç³»ç»Ÿç›¸å…³ï¼ˆcursor_5.mdä¸­ç¼ºå¤±ï¼‰
    inventory_methods: [
      'notifyMerchants',       // é€šçŸ¥å•†æˆ· - cursor_5.mdä¸­å‘ç°ç¼ºå¤±
      'notifyInventoryUpdate', // é€šçŸ¥åº“å­˜æ›´æ–°
      'broadcastSystemMessage' // å¹¿æ’­ç³»ç»Ÿæ¶ˆæ¯
    ],
    
    // æƒé™ç³»ç»Ÿç›¸å…³
    permission_methods: [
      'notifyPermissionChange', // é€šçŸ¥æƒé™å˜æ›´
      'broadcastSpaceUnlock'    // å¹¿æ’­ç©ºé—´è§£é”
    ]
  },
  
  // WebSocketæ–¹æ³•å­˜åœ¨æ€§æ£€æŸ¥
  validateWebSocketMethods: (webSocketService) => {
    const missingMethods = [];
    
    Object.entries(WEBSOCKET_COMPLETENESS_VALIDATOR.requiredMethods).forEach(([category, methods]) => {
      methods.forEach(methodName => {
        if (typeof webSocketService[methodName] !== 'function') {
          missingMethods.push({
            category,
            method: methodName,
            errorExample: getErrorExample(methodName),
            priority: getWebSocketPriority(category)
          });
        }
      });
    });
    
    if (missingMethods.length > 0) {
      console.error('ğŸ”´ æ£€æµ‹åˆ°ç¼ºå¤±çš„WebSocketæ–¹æ³•:');
      missingMethods.forEach(missing => {
        console.error(`   âŒ [${missing.category}] ${missing.method} (ä¼˜å…ˆçº§: ${missing.priority})`);
        if (missing.errorExample) {
          console.error(`      é”™è¯¯ç¤ºä¾‹: ${missing.errorExample}`);
        }
      });
      
      // ğŸ”´ åŸºäºå®é™…é—®é¢˜çš„ä¿®å¤å»ºè®®
      console.log('\nğŸ”§ WebSocketä¿®å¤å»ºè®®:');
      console.log('1. æ£€æŸ¥WebSocketæœåŠ¡ä¸­è¢«æ³¨é‡Šçš„æ–¹æ³•è°ƒç”¨');
      console.log('2. ç¡®ä¿æ‰€æœ‰ä¸šåŠ¡æ¨¡å—éƒ½æœ‰å¯¹åº”çš„WebSocketé€šçŸ¥æ–¹æ³•');
      console.log('3. å®ç°ç¼ºå¤±çš„WebSocketæ–¹æ³•å¹¶è¿›è¡Œæµ‹è¯•');
      
      return { valid: false, missingMethods };
    }
    
    console.log('âœ… WebSocketæ–¹æ³•å®Œæ•´æ€§æ£€æŸ¥é€šè¿‡');
    return { valid: true, missingMethods: [] };
  },
  
  // è‡ªåŠ¨ç”Ÿæˆç¼ºå¤±çš„WebSocketæ–¹æ³•
  generateMissingMethods: (webSocketService, missingMethods) => {
    missingMethods.forEach(missing => {
      const methodName = missing.method;
      
      console.log(`ğŸ”§ è‡ªåŠ¨ç”ŸæˆWebSocketæ–¹æ³•: ${methodName}`);
      
      webSocketService[methodName] = function(...args) {
        console.log(`ğŸ“¡ WebSocketæ–¹æ³•è°ƒç”¨: ${methodName}`, args);
        
        // åŸºäºæ–¹æ³•åè‡ªåŠ¨å®ç°åŸºç¡€åŠŸèƒ½
        if (methodName.startsWith('notify')) {
          // é€šçŸ¥ç±»æ–¹æ³•
          const [target, message] = args;
          return this.sendToConnection(target, {
            type: 'notification',
            data: message,
            timestamp: new Date().toISOString()
          });
        } else if (methodName.startsWith('broadcast')) {
          // å¹¿æ’­ç±»æ–¹æ³•
          const [message] = args;
          return this.broadcastMessage({
            type: 'broadcast',
            data: message,
            timestamp: new Date().toISOString()
          });
        } else {
          // å…¶ä»–æ–¹æ³•
          console.warn(`âš ï¸ ${methodName} éœ€è¦æ‰‹åŠ¨å®ç°å…·ä½“é€»è¾‘`);
          return Promise.resolve();
        }
      };
    });
  }
};

function getErrorExample(methodName) {
  const examples = {
    'notifyMerchants': 'TypeError: webSocketService.notifyMerchants is not a function',
    'notifyNewSession': '// webSocketService.notifyNewSession(session) - è¢«æ³¨é‡Š',
    'forwardChatMessage': 'WebSocketæ¶ˆæ¯è½¬å‘å¤±è´¥',
    'broadcastToAdmins': 'ç®¡ç†å‘˜é€šçŸ¥å‘é€å¤±è´¥'
  };
  return examples[methodName] || null;
}

function getWebSocketPriority(category) {
  const priorities = {
    chat_methods: 'HIGH',
    inventory_methods: 'HIGH',
    permission_methods: 'MEDIUM'
  };
  return priorities[category] || 'LOW';
}
```

## æ•°æ®åº“äº‹åŠ¡å®‰å…¨è§„èŒƒ

### åŸºäºcursor_5.mdäº‹åŠ¡é”™è¯¯çš„å®‰å…¨æ¨¡å¼
```javascript
// ğŸ”´ åŸºäºcursor_5.mdä¸­å‘ç°çš„äº‹åŠ¡å›æ»šé—®é¢˜
const DATABASE_TRANSACTION_SAFETY = {
  // å®‰å…¨äº‹åŠ¡æ‰§è¡Œæ¨¡å¼
  safeTransactionExecute: async (operation, options = {}) => {
    const { 
      maxRetries = 3, 
      timeout = 30000,
      isolationLevel = 'READ_COMMITTED'
    } = options;
    
    let transaction = null;
    let attempt = 0;
    
    while (attempt < maxRetries) {
      try {
        // åˆ›å»ºäº‹åŠ¡
        transaction = await sequelize.transaction({
          isolationLevel: sequelize.Transaction.ISOLATION_LEVELS[isolationLevel]
        });
        
        console.log(`ğŸ”„ å¼€å§‹äº‹åŠ¡ (å°è¯• ${attempt + 1}/${maxRetries})`);
        
        // è®¾ç½®äº‹åŠ¡è¶…æ—¶
        const timeoutPromise = new Promise((_, reject) => {
          setTimeout(() => reject(new Error('Transaction timeout')), timeout);
        });
        
        // æ‰§è¡Œä¸šåŠ¡æ“ä½œ
        const operationPromise = operation(transaction);
        
        const result = await Promise.race([operationPromise, timeoutPromise]);
        
        // ğŸ”´ æ£€æŸ¥äº‹åŠ¡çŠ¶æ€ï¼Œé¿å…cursor_5.mdä¸­çš„é‡å¤æäº¤é—®é¢˜
        if (transaction.finished) {
          console.warn('âš ï¸ äº‹åŠ¡å·²å®Œæˆï¼Œè·³è¿‡æäº¤æ“ä½œ');
          return result;
        }
        
        // æäº¤äº‹åŠ¡
        await transaction.commit();
        console.log('âœ… äº‹åŠ¡æäº¤æˆåŠŸ');
        
        return result;
        
      } catch (error) {
        attempt++;
        
        // ğŸ”´ å®‰å…¨çš„äº‹åŠ¡å›æ»šï¼Œé¿å…"å·²å®Œæˆäº‹åŠ¡"é”™è¯¯
        if (transaction && !transaction.finished) {
          try {
            await transaction.rollback();
            console.log('ğŸ”„ äº‹åŠ¡å·²å›æ»š');
          } catch (rollbackError) {
            console.error('âŒ äº‹åŠ¡å›æ»šå¤±è´¥:', rollbackError.message);
          }
        } else if (transaction && transaction.finished) {
          console.log('â„¹ï¸ äº‹åŠ¡å·²å®Œæˆï¼Œæ— éœ€å›æ»š');
        }
        
        // åˆ†æé”™è¯¯ç±»å‹
        const errorType = analyzeTransactionError(error);
        
        if (errorType.retryable && attempt < maxRetries) {
          const delay = Math.min(1000 * Math.pow(2, attempt), 5000);
          console.log(`â° äº‹åŠ¡å¤±è´¥ï¼Œ${delay}msåé‡è¯• (${errorType.reason})`);
          await new Promise(resolve => setTimeout(resolve, delay));
          continue;
        } else {
          console.error(`âŒ äº‹åŠ¡æœ€ç»ˆå¤±è´¥: ${error.message}`);
          throw new Error(`äº‹åŠ¡æ‰§è¡Œå¤±è´¥ (å°è¯•${attempt}æ¬¡): ${error.message}`);
        }
      }
    }
  },
  
  // äº‹åŠ¡çŠ¶æ€æ£€æŸ¥åŒ…è£…å™¨
  withTransactionCheck: (operation) => {
    return async (transaction) => {
      // æ£€æŸ¥äº‹åŠ¡æ˜¯å¦ä»ç„¶æœ‰æ•ˆ
      if (transaction.finished) {
        throw new Error('Transaction has already been committed or rolled back');
      }
      
      // æ‰§è¡Œæ“ä½œ
      const result = await operation(transaction);
      
      // å†æ¬¡æ£€æŸ¥äº‹åŠ¡çŠ¶æ€
      if (transaction.finished) {
        console.warn('âš ï¸ æ“ä½œæ‰§è¡ŒæœŸé—´äº‹åŠ¡å·²å®Œæˆ');
      }
      
      return result;
    };
  }
};

// äº‹åŠ¡é”™è¯¯åˆ†æå™¨
function analyzeTransactionError(error) {
  const errorMessage = error.message.toLowerCase();
  
  // åŸºäºcursor_5.mdä¸­å®é™…å‘ç°çš„é”™è¯¯æ¨¡å¼
  if (errorMessage.includes('transaction cannot be rolled back') || 
      errorMessage.includes('has been finished')) {
    return { 
      retryable: false, 
      reason: 'transaction_already_finished',
      solution: 'æ£€æŸ¥ä»£ç ä¸­æ˜¯å¦æœ‰é‡å¤çš„äº‹åŠ¡æ“ä½œ'
    };
  }
  
  if (errorMessage.includes('deadlock') || errorMessage.includes('lock')) {
    return { 
      retryable: true, 
      reason: 'database_deadlock',
      solution: 'å®æ–½æŒ‡æ•°é€€é¿é‡è¯•'
    };
  }
  
  if (errorMessage.includes('timeout') || errorMessage.includes('connection')) {
    return { 
      retryable: true, 
      reason: 'connection_timeout',
      solution: 'æ£€æŸ¥ç½‘ç»œè¿æ¥å’Œæ•°æ®åº“çŠ¶æ€'
    };
  }
  
  if (errorMessage.includes('constraint') || errorMessage.includes('duplicate')) {
    return { 
      retryable: false, 
      reason: 'data_constraint_violation',
      solution: 'æ£€æŸ¥æ•°æ®å®Œæ•´æ€§çº¦æŸ'
    };
  }
  
  return { 
    retryable: true, 
    reason: 'unknown_error',
    solution: 'é€šç”¨é‡è¯•ç­–ç•¥'
  };
}
```

### æ•°æ®åº“æ¨¡å‹å…³è”æ ‡å‡†åŒ–
```javascript
// åŸºäºcursor_3.mdä¸­å‘ç°çš„æ¨¡å‹å…³è”é—®é¢˜
const MODEL_ASSOCIATION_VALIDATOR = {
  // æ ‡å‡†å…³è”é…ç½®
  standardAssociations: {
    User: {
      hasMany: [
        { model: 'UserInventory', as: 'inventoryItems', foreignKey: 'user_id' },
        { model: 'CustomerSession', as: 'chatSessions', foreignKey: 'user_id' },
        { model: 'ChatMessage', as: 'sentMessages', foreignKey: 'sender_id' }
      ],
      belongsTo: []
    },
    
    CustomerSession: {
      belongsTo: [
        { model: 'User', as: 'user', foreignKey: 'user_id' },
        { model: 'User', as: 'admin', foreignKey: 'admin_id' }
      ],
      hasMany: [
        { model: 'ChatMessage', as: 'messages', foreignKey: 'session_id' }
      ]
    },
    
    ChatMessage: {
      belongsTo: [
        { model: 'CustomerSession', as: 'session', foreignKey: 'session_id' },
        { model: 'User', as: 'sender', foreignKey: 'sender_id' }
      ]
    }
  },
  
  // éªŒè¯æ¨¡å‹å…³è”é…ç½®
  validateAssociations: (models) => {
    const issues = [];
    
    Object.entries(MODEL_ASSOCIATION_VALIDATOR.standardAssociations).forEach(([modelName, associations]) => {
      const model = models[modelName];
      
      if (!model) {
        issues.push({
          type: 'MISSING_MODEL',
          model: modelName,
          message: `æ¨¡å‹ ${modelName} ä¸å­˜åœ¨`
        });
        return;
      }
      
      // æ£€æŸ¥hasManyå…³è”
      associations.hasMany?.forEach(assoc => {
        const associationExists = model.associations[assoc.as];
        if (!associationExists) {
          issues.push({
            type: 'MISSING_ASSOCIATION',
            model: modelName,
            association: assoc,
            message: `ç¼ºå°‘ hasMany å…³è”: ${modelName}.${assoc.as} -> ${assoc.model}`
          });
        }
      });
      
      // æ£€æŸ¥belongsToå…³è”
      associations.belongsTo?.forEach(assoc => {
        const associationExists = model.associations[assoc.as];
        if (!associationExists) {
          issues.push({
            type: 'MISSING_ASSOCIATION',
            model: modelName,
            association: assoc,
            message: `ç¼ºå°‘ belongsTo å…³è”: ${modelName}.${assoc.as} -> ${assoc.model}`
          });
        }
      });
    });
    
    if (issues.length > 0) {
      console.error('ğŸ”´ æ£€æµ‹åˆ°æ¨¡å‹å…³è”é—®é¢˜:');
      issues.forEach(issue => {
        console.error(`   âŒ ${issue.message}`);
      });
      
      return { valid: false, issues };
    }
    
    console.log('âœ… æ¨¡å‹å…³è”éªŒè¯é€šè¿‡');
    return { valid: true, issues: [] };
  }
};
```

## é…ç½®ç®¡ç†å’Œç¯å¢ƒå˜é‡è§„èŒƒ

### åŸºäºcursor_9.mdçš„é…ç½®å®Œæ•´æ€§æ£€æŸ¥
```javascript
// ğŸ”´ åŸºäºcursor_9.mdä¸­å‘ç°çš„.envé…ç½®ç¼ºå¤±é—®é¢˜
const CONFIG_COMPLETENESS_VALIDATOR = {
  // å¿…éœ€çš„ç¯å¢ƒå˜é‡
  requiredEnvVars: {
    // æ•°æ®åº“é…ç½®
    database: [
      'DB_HOST',
      'DB_PORT', 
      'DB_NAME',
      'DB_USER',
      'DB_PASSWORD'
    ],
    
    // æœåŠ¡é…ç½®
    server: [
      'PORT',
      'NODE_ENV',
      'JWT_SECRET'
    ],
    
    // ç¬¬ä¸‰æ–¹æœåŠ¡é…ç½®
    external_services: [
      'REDIS_URL',
      'SEALOS_ACCESS_KEY',
      'SEALOS_SECRET_KEY'
    ],
    
    // WebSocketé…ç½®
    websocket: [
      'WS_PORT',
      'WS_PATH'
    ]
  },
  
  // ç¯å¢ƒå˜é‡å­˜åœ¨æ€§æ£€æŸ¥
  validateEnvironmentVariables: () => {
    const missingVars = [];
    
    Object.entries(CONFIG_COMPLETENESS_VALIDATOR.requiredEnvVars).forEach(([category, vars]) => {
      vars.forEach(varName => {
        if (!process.env[varName]) {
          missingVars.push({
            category,
            variable: varName,
            priority: getEnvVarPriority(varName)
          });
        }
      });
    });
    
    if (missingVars.length > 0) {
      console.error('ğŸ”´ æ£€æµ‹åˆ°ç¼ºå¤±çš„ç¯å¢ƒå˜é‡:');
      missingVars.forEach(missing => {
        console.error(`   âŒ [${missing.category}] ${missing.variable} (ä¼˜å…ˆçº§: ${missing.priority})`);
      });
      
      // ğŸ”´ åŸºäºcursor_9.mdé—®é¢˜çš„ä¿®å¤å»ºè®®
      console.log('\nğŸ”§ ç¯å¢ƒå˜é‡ä¿®å¤å»ºè®®:');
      console.log('1. æ£€æŸ¥ .env æ–‡ä»¶æ˜¯å¦å­˜åœ¨');
      console.log('2. ä» .env.example å¤åˆ¶æ¨¡æ¿é…ç½®');
      console.log('3. è®¾ç½®æ­£ç¡®çš„æ•°æ®åº“è¿æ¥ä¿¡æ¯');
      console.log('4. é…ç½®å¿…è¦çš„ç¬¬ä¸‰æ–¹æœåŠ¡å¯†é’¥');
      
      return { valid: false, missingVars };
    }
    
    console.log('âœ… ç¯å¢ƒå˜é‡å®Œæ•´æ€§æ£€æŸ¥é€šè¿‡');
    return { valid: true, missingVars: [] };
  },
  
  // è‡ªåŠ¨ç”Ÿæˆ.envæ¨¡æ¿
  generateEnvTemplate: () => {
    const template = `# æ•°æ®åº“é…ç½®
DB_HOST=localhost
DB_PORT=3306
DB_NAME=restaurant_lottery
DB_USER=root
DB_PASSWORD=your_password

# æœåŠ¡é…ç½®
PORT=3000
NODE_ENV=development
JWT_SECRET=your_jwt_secret_here

# Redisé…ç½®
REDIS_URL=redis://localhost:6379

# Sealoså¯¹è±¡å­˜å‚¨é…ç½®
SEALOS_ACCESS_KEY=your_access_key
SEALOS_SECRET_KEY=your_secret_key

# WebSocketé…ç½®
WS_PORT=3000
WS_PATH=/ws
`;
    
    console.log('ğŸ“„ .env é…ç½®æ¨¡æ¿:');
    console.log(template);
    
    return template;
  }
};

function getEnvVarPriority(varName) {
  const highPriority = ['DB_HOST', 'DB_PASSWORD', 'JWT_SECRET', 'PORT'];
  const mediumPriority = ['NODE_ENV', 'REDIS_URL', 'WS_PORT'];
  
  if (highPriority.includes(varName)) return 'HIGH';
  if (mediumPriority.includes(varName)) return 'MEDIUM';
  return 'LOW';
}
```

## ä¾èµ–ç®¡ç†å’Œç‰ˆæœ¬æ§åˆ¶è§„èŒƒ

### package.jsonå®Œæ•´æ€§å’Œç‰ˆæœ¬å…¼å®¹æ€§æ£€æŸ¥
```javascript
// åŸºäºå¤šä¸ªcursoræ–‡æ¡£ä¸­å‘ç°çš„ä¾èµ–é—®é¢˜
const DEPENDENCY_VALIDATOR = {
  // æ ¸å¿ƒä¾èµ–ç‰ˆæœ¬è¦æ±‚
  coreDependencies: {
    production: {
      'express': '^4.18.0',
      'sequelize': '^6.35.0',
      'mysql2': '^3.6.0',
      'socket.io': '^4.7.0',
      'jsonwebtoken': '^9.0.0',
      'bcryptjs': '^2.4.3',
      'cors': '^2.8.5',
      'dotenv': '^16.3.0'
    },
    
    development: {
      'nodemon': '^3.0.0',
      'jest': '^29.7.0',
      'supertest': '^6.3.0',
      'eslint': '^8.50.0',
      'prettier': '^3.0.0'
    }
  },
  
  // æ£€æŸ¥ä¾èµ–å®Œæ•´æ€§
  validateDependencies: (packageJson) => {
    const issues = [];
    
    // æ£€æŸ¥ç”Ÿäº§ä¾èµ–
    Object.entries(DEPENDENCY_VALIDATOR.coreDependencies.production).forEach(([pkg, requiredVersion]) => {
      const installedVersion = packageJson.dependencies?.[pkg];
      
      if (!installedVersion) {
        issues.push({
          type: 'MISSING_DEPENDENCY',
          package: pkg,
          requiredVersion,
          category: 'production'
        });
      } else if (!isVersionCompatible(installedVersion, requiredVersion)) {
        issues.push({
          type: 'VERSION_INCOMPATIBLE',
          package: pkg,
          installedVersion,
          requiredVersion,
          category: 'production'
        });
      }
    });
    
    // æ£€æŸ¥å¼€å‘ä¾èµ–
    Object.entries(DEPENDENCY_VALIDATOR.coreDependencies.development).forEach(([pkg, requiredVersion]) => {
      const installedVersion = packageJson.devDependencies?.[pkg];
      
      if (!installedVersion) {
        issues.push({
          type: 'MISSING_DEV_DEPENDENCY',
          package: pkg,
          requiredVersion,
          category: 'development'
        });
      }
    });
    
    if (issues.length > 0) {
      console.error('ğŸ”´ æ£€æµ‹åˆ°ä¾èµ–é—®é¢˜:');
      issues.forEach(issue => {
        console.error(`   âŒ ${issue.type}: ${issue.package} (${issue.category})`);
        if (issue.requiredVersion) {
          console.error(`      éœ€è¦: ${issue.requiredVersion}, å½“å‰: ${issue.installedVersion || 'æœªå®‰è£…'}`);
        }
      });
      
      return { valid: false, issues };
    }
    
    console.log('âœ… ä¾èµ–å®Œæ•´æ€§æ£€æŸ¥é€šè¿‡');
    return { valid: true, issues: [] };
  }
};

function isVersionCompatible(installed, required) {
  // ç®€åŒ–çš„ç‰ˆæœ¬å…¼å®¹æ€§æ£€æŸ¥
  const installedClean = installed.replace(/[\^~]/, '');
  const requiredClean = required.replace(/[\^~]/, '');
  
  return installedClean >= requiredClean;
}
```

## ç»¼åˆå¼€å‘è´¨é‡æ£€æŸ¥å™¨

### é›†æˆæ‰€æœ‰æ£€æŸ¥é¡¹çš„ç»Ÿä¸€éªŒè¯å™¨
```javascript
// åŸºäºæ‰€æœ‰cursoræ–‡æ¡£é—®é¢˜çš„ç»¼åˆæ£€æŸ¥å™¨
const COMPREHENSIVE_QUALITY_CHECKER = {
  // æ‰§è¡Œæ‰€æœ‰è´¨é‡æ£€æŸ¥
  runAllChecks: async (context) => {
    console.log('ğŸ” å¼€å§‹æ‰§è¡Œç»¼åˆå¼€å‘è´¨é‡æ£€æŸ¥...');
    
    const results = {
      timestamp: new Date().toISOString(),
      checks: {},
      overallScore: 0,
      issues: [],
      recommendations: []
    };
    
    // 1. APIå®Œæ•´æ€§æ£€æŸ¥
    try {
      const apiCheck = await API_COMPLETENESS_VALIDATOR.validateAPICompleteness(context.app);
      results.checks.api_completeness = apiCheck;
      if (!apiCheck.valid) {
        results.issues.push(...apiCheck.missingEndpoints.map(e => ({
          type: 'API_MISSING',
          severity: 'HIGH',
          message: `ç¼ºå¤±APIç«¯ç‚¹: ${e.endpoint}`
        })));
      }
    } catch (error) {
      results.checks.api_completeness = { error: error.message };
    }
    
    // 2. WebSocketå®Œæ•´æ€§æ£€æŸ¥
    try {
      const wsCheck = WEBSOCKET_COMPLETENESS_VALIDATOR.validateWebSocketMethods(context.webSocketService);
      results.checks.websocket_completeness = wsCheck;
      if (!wsCheck.valid) {
        results.issues.push(...wsCheck.missingMethods.map(m => ({
          type: 'WEBSOCKET_MISSING',
          severity: 'HIGH',
          message: `ç¼ºå¤±WebSocketæ–¹æ³•: ${m.method}`
        })));
      }
    } catch (error) {
      results.checks.websocket_completeness = { error: error.message };
    }
    
    // 3. ç¯å¢ƒå˜é‡æ£€æŸ¥
    try {
      const envCheck = CONFIG_COMPLETENESS_VALIDATOR.validateEnvironmentVariables();
      results.checks.environment_variables = envCheck;
      if (!envCheck.valid) {
        results.issues.push(...envCheck.missingVars.map(v => ({
          type: 'ENV_VAR_MISSING',
          severity: v.priority === 'HIGH' ? 'HIGH' : 'MEDIUM',
          message: `ç¼ºå¤±ç¯å¢ƒå˜é‡: ${v.variable}`
        })));
      }
    } catch (error) {
      results.checks.environment_variables = { error: error.message };
    }
    
    // 4. ä¾èµ–æ£€æŸ¥
    try {
      const depCheck = DEPENDENCY_VALIDATOR.validateDependencies(context.packageJson);
      results.checks.dependencies = depCheck;
      if (!depCheck.valid) {
        results.issues.push(...depCheck.issues.map(i => ({
          type: 'DEPENDENCY_ISSUE',
          severity: i.category === 'production' ? 'HIGH' : 'MEDIUM',
          message: `ä¾èµ–é—®é¢˜: ${i.package} - ${i.type}`
        })));
      }
    } catch (error) {
      results.checks.dependencies = { error: error.message };
    }
    
    // è®¡ç®—ç»¼åˆè¯„åˆ†
    const totalChecks = Object.keys(results.checks).length;
    const passedChecks = Object.values(results.checks).filter(check => check.valid).length;
    results.overallScore = Math.round((passedChecks / totalChecks) * 100);
    
    // ç”Ÿæˆå»ºè®®
    results.recommendations = generateQualityRecommendations(results);
    
    // è¾“å‡ºæŠ¥å‘Š
    COMPREHENSIVE_QUALITY_CHECKER.generateQualityReport(results);
    
    return results;
  },
  
  // ç”Ÿæˆè´¨é‡æŠ¥å‘Š
  generateQualityReport: (results) => {
    console.log('\nğŸ“Š === å¼€å‘è´¨é‡æ£€æŸ¥æŠ¥å‘Š ===');
    console.log(`æ€»ä½“è¯„åˆ†: ${results.overallScore}/100`);
    console.log(`æ£€æŸ¥æ—¶é—´: ${results.timestamp}`);
    
    // æŒ‰ä¸¥é‡ç¨‹åº¦åˆ†ç»„æ˜¾ç¤ºé—®é¢˜
    const issuesBySeverity = groupBy(results.issues, 'severity');
    
    if (issuesBySeverity.HIGH?.length > 0) {
      console.log('\nğŸ”´ é«˜ä¸¥é‡ç¨‹åº¦é—®é¢˜:');
      issuesBySeverity.HIGH.forEach(issue => {
        console.log(`   âŒ ${issue.message}`);
      });
    }
    
    if (issuesBySeverity.MEDIUM?.length > 0) {
      console.log('\nğŸŸ¡ ä¸­ç­‰ä¸¥é‡ç¨‹åº¦é—®é¢˜:');
      issuesBySeverity.MEDIUM.forEach(issue => {
        console.log(`   âš ï¸ ${issue.message}`);
      });
    }
    
    if (results.recommendations.length > 0) {
      console.log('\nğŸ’¡ æ”¹è¿›å»ºè®®:');
      results.recommendations.forEach((rec, index) => {
        console.log(`   ${index + 1}. ${rec}`);
      });
    }
    
    // è¯„çº§
    let grade = 'F';
    if (results.overallScore >= 90) grade = 'A';
    else if (results.overallScore >= 80) grade = 'B';
    else if (results.overallScore >= 70) grade = 'C';
    else if (results.overallScore >= 60) grade = 'D';
    
    console.log(`\nğŸ† è´¨é‡è¯„çº§: ${grade}`);
  }
};

function generateQualityRecommendations(results) {
  const recommendations = [];
  
  if (results.overallScore < 70) {
    recommendations.push('ä»£ç è´¨é‡éœ€è¦æ˜¾è‘—æ”¹è¿›ï¼Œå»ºè®®ä¼˜å…ˆè§£å†³é«˜ä¸¥é‡ç¨‹åº¦é—®é¢˜');
  }
  
  const apiIssues = results.issues.filter(i => i.type === 'API_MISSING');
  if (apiIssues.length > 0) {
    recommendations.push('ä¼˜å…ˆå®ç°ç¼ºå¤±çš„APIç«¯ç‚¹ï¼Œç¡®ä¿å‰åç«¯æ¥å£ä¸€è‡´æ€§');
  }
  
  const wsIssues = results.issues.filter(i => i.type === 'WEBSOCKET_MISSING');
  if (wsIssues.length > 0) {
    recommendations.push('å®ç°ç¼ºå¤±çš„WebSocketæ–¹æ³•ï¼Œç¡®ä¿å®æ—¶é€šä¿¡åŠŸèƒ½å®Œæ•´');
  }
  
  const envIssues = results.issues.filter(i => i.type === 'ENV_VAR_MISSING');
  if (envIssues.length > 0) {
    recommendations.push('é…ç½®ç¼ºå¤±çš„ç¯å¢ƒå˜é‡ï¼Œå»ºç«‹å®Œæ•´çš„é…ç½®ç®¡ç†');
  }
  
  return recommendations;
}

function groupBy(array, key) {
  return array.reduce((groups, item) => {
    const group = item[key];
    groups[group] = groups[group] || [];
    groups[group].push(item);
    return groups;
  }, {});
}
