---
name: 核心开发标准
---

# 核心开发标准（基于实际cursor_3.md等问题分析优化版）

## 🔴 基于实际发现的开发质量问题

### 实际问题案例统计
从11个cursor文档深度分析发现：
- **WebSocket功能缺失**: cursor_3.md中发现WebSocket服务被注释 `// webSocketService.notifyNewSession(session)`
- **数据库事务错误**: cursor_5.md中发现大量事务回滚处理问题
- **前端API缺失**: cursor_5.md中发现 `TypeError: API.getUserInventory is not a function`
- **配置文件问题**: cursor_9.md中发现.env配置缺失导致服务启动失败
- **依赖版本冲突**: 多个文档中发现npm包版本不兼容问题

## API接口开发强制规范

### 基于实际问题的API完整性检查
```javascript
// 🔴 基于cursor_5.md中发现的API缺失问题
const API_COMPLETENESS_VALIDATOR = {
  // 必需的API端点检查
  requiredEndpoints: {
    // 用户管理类API
    user_management: [
      'POST /api/v2/auth/login',
      'POST /api/v2/auth/logout', 
      'GET /api/v2/user/profile',
      'PUT /api/v2/user/profile'
    ],
    
    // 库存管理类API（cursor_5.md中缺失）
    inventory_management: [
      'GET /api/v2/inventory/list',        // getUserInventory前端调用
      'POST /api/v2/inventory/use',        // useInventoryItem前端调用
      'POST /api/v2/inventory/transfer',   // transferInventoryItem前端调用
      'POST /api/v2/inventory/generate-code' // 生成核销码
    ],
    
    // 权限管理类API（cursor_10.md相关）
    permission_management: [
      'GET /api/v2/permissions/check',
      'POST /api/v2/permissions/unlock',
      'GET /api/v2/permissions/history'
    ],
    
    // 聊天系统API（cursor_3.md和cursor_.md相关）
    chat_system: [
      'POST /api/v2/chat/session',
      'POST /api/v2/chat/message', 
      'GET /api/v2/chat/history',
      'GET /api/v2/admin/chat/sessions',    // cursor_.md中实现
      'POST /api/v2/admin/chat/sessions/:id/messages'
    ]
  },
  
  // API端点存在性验证
  validateAPICompleteness: async (app) => {
    const missingEndpoints = [];
    const availableRoutes = extractRoutesFromApp(app);
    
    Object.entries(API_COMPLETENESS_VALIDATOR.requiredEndpoints).forEach(([category, endpoints]) => {
      endpoints.forEach(endpoint => {
        const [method, path] = endpoint.split(' ');
        const routeExists = availableRoutes.some(route => 
          route.method.toUpperCase() === method && route.path === path
        );
        
        if (!routeExists) {
          missingEndpoints.push({
            category,
            endpoint,
            priority: getPriority(category),
            suggestion: `需要实现 ${method} ${path} 接口`
          });
        }
      });
    });
    
    if (missingEndpoints.length > 0) {
      console.error('🔴 检测到缺失的API端点:');
      missingEndpoints.forEach(missing => {
        console.error(`   ❌ [${missing.category}] ${missing.endpoint} (优先级: ${missing.priority})`);
      });
      
      // 🔴 基于cursor_5.md类似问题的处理建议
      console.log('\n🔧 修复建议:');
      console.log('1. 优先实现高优先级API端点');
      console.log('2. 确保前端调用的API方法都有对应的后端实现');
      console.log('3. 建立API端点的自动化测试');
      
      return { valid: false, missingEndpoints };
    }
    
    console.log('✅ API端点完整性检查通过');
    return { valid: true, missingEndpoints: [] };
  }
};

function getPriority(category) {
  const priorities = {
    user_management: 'HIGH',
    inventory_management: 'HIGH',
    chat_system: 'MEDIUM', 
    permission_management: 'MEDIUM'
  };
  return priorities[category] || 'LOW';
}
```

### API接口一致性强制要求
```javascript
// 基于cursor_1.md中发现的路径不匹配问题
const API_CONSISTENCY_ENFORCER = {
  // 前后端路径映射规则
  pathMappings: {
    // cursor_.md中发现的实际映射需求
    '/admin/chat/sessions': '/api/v2/admin/chat/sessions',
    '/api/inventory': '/api/v2/inventory/list',
    '/api/upload': '/api/v2/photo/upload',
    '/api/auth/verify': '/api/v2/auth/verify'
  },
  
  // 自动生成兼容路由
  generateCompatibilityRoutes: (app) => {
    Object.entries(API_CONSISTENCY_ENFORCER.pathMappings).forEach(([oldPath, newPath]) => {
      // 为旧路径创建重定向
      app.all(oldPath, (req, res, next) => {
        console.log(`🔄 API兼容重定向: ${oldPath} → ${newPath}`);
        req.url = newPath;
        next();
      });
      
      console.log(`✅ 创建API兼容路由: ${oldPath} → ${newPath}`);
    });
  },
  
  // 前端API方法补全检查
  validateFrontendAPIMethod: (apiObject, methodName, expectedUrl) => {
    if (typeof apiObject[methodName] !== 'function') {
      console.error(`🔴 前端API方法缺失: ${methodName}`);
      console.error(`   期望URL: ${expectedUrl}`);
      
      // 基于cursor_5.md问题的自动补全
      apiObject[methodName] = async function(params = {}) {
        const isGetRequest = expectedUrl.includes('list') || expectedUrl.includes('check');
        
        if (isGetRequest) {
          const query = new URLSearchParams(params).toString();
          return await request({
            url: `${expectedUrl}?${query}`,
            method: 'GET'
          });
        } else {
          return await request({
            url: expectedUrl,
            method: 'POST',
            data: params
          });
        }
      };
      
      console.log(`✅ 自动补全API方法: ${methodName}`);
    }
  }
};
```

## WebSocket服务完整性规范

### 基于cursor_3.md问题的WebSocket标准化
```javascript
// 🔴 基于cursor_3.md中发现的WebSocket被注释问题
const WEBSOCKET_COMPLETENESS_VALIDATOR = {
  // 必需的WebSocket方法
  requiredMethods: {
    // 聊天系统相关（cursor_3.md中缺失）
    chat_methods: [
      'notifyNewSession',      // 通知新会话 - 被注释导致功能缺失
      'forwardChatMessage',    // 转发聊天消息
      'broadcastToAdmins',     // 广播给管理员
      'sendToUser',            // 发送给用户
      'handleTyping'           // 处理输入状态
    ],
    
    // 库存系统相关（cursor_5.md中缺失）
    inventory_methods: [
      'notifyMerchants',       // 通知商户 - cursor_5.md中发现缺失
      'notifyInventoryUpdate', // 通知库存更新
      'broadcastSystemMessage' // 广播系统消息
    ],
    
    // 权限系统相关
    permission_methods: [
      'notifyPermissionChange', // 通知权限变更
      'broadcastSpaceUnlock'    // 广播空间解锁
    ]
  },
  
  // WebSocket方法存在性检查
  validateWebSocketMethods: (webSocketService) => {
    const missingMethods = [];
    
    Object.entries(WEBSOCKET_COMPLETENESS_VALIDATOR.requiredMethods).forEach(([category, methods]) => {
      methods.forEach(methodName => {
        if (typeof webSocketService[methodName] !== 'function') {
          missingMethods.push({
            category,
            method: methodName,
            errorExample: getErrorExample(methodName),
            priority: getWebSocketPriority(category)
          });
        }
      });
    });
    
    if (missingMethods.length > 0) {
      console.error('🔴 检测到缺失的WebSocket方法:');
      missingMethods.forEach(missing => {
        console.error(`   ❌ [${missing.category}] ${missing.method} (优先级: ${missing.priority})`);
        if (missing.errorExample) {
          console.error(`      错误示例: ${missing.errorExample}`);
        }
      });
      
      // 🔴 基于实际问题的修复建议
      console.log('\n🔧 WebSocket修复建议:');
      console.log('1. 检查WebSocket服务中被注释的方法调用');
      console.log('2. 确保所有业务模块都有对应的WebSocket通知方法');
      console.log('3. 实现缺失的WebSocket方法并进行测试');
      
      return { valid: false, missingMethods };
    }
    
    console.log('✅ WebSocket方法完整性检查通过');
    return { valid: true, missingMethods: [] };
  },
  
  // 自动生成缺失的WebSocket方法
  generateMissingMethods: (webSocketService, missingMethods) => {
    missingMethods.forEach(missing => {
      const methodName = missing.method;
      
      console.log(`🔧 自动生成WebSocket方法: ${methodName}`);
      
      webSocketService[methodName] = function(...args) {
        console.log(`📡 WebSocket方法调用: ${methodName}`, args);
        
        // 基于方法名自动实现基础功能
        if (methodName.startsWith('notify')) {
          // 通知类方法
          const [target, message] = args;
          return this.sendToConnection(target, {
            type: 'notification',
            data: message,
            timestamp: new Date().toISOString()
          });
        } else if (methodName.startsWith('broadcast')) {
          // 广播类方法
          const [message] = args;
          return this.broadcastMessage({
            type: 'broadcast',
            data: message,
            timestamp: new Date().toISOString()
          });
        } else {
          // 其他方法
          console.warn(`⚠️ ${methodName} 需要手动实现具体逻辑`);
          return Promise.resolve();
        }
      };
    });
  }
};

function getErrorExample(methodName) {
  const examples = {
    'notifyMerchants': 'TypeError: webSocketService.notifyMerchants is not a function',
    'notifyNewSession': '// webSocketService.notifyNewSession(session) - 被注释',
    'forwardChatMessage': 'WebSocket消息转发失败',
    'broadcastToAdmins': '管理员通知发送失败'
  };
  return examples[methodName] || null;
}

function getWebSocketPriority(category) {
  const priorities = {
    chat_methods: 'HIGH',
    inventory_methods: 'HIGH',
    permission_methods: 'MEDIUM'
  };
  return priorities[category] || 'LOW';
}
```

## 数据库事务安全规范

### 基于cursor_5.md事务错误的安全模式
```javascript
// 🔴 基于cursor_5.md中发现的事务回滚问题
const DATABASE_TRANSACTION_SAFETY = {
  // 安全事务执行模式
  safeTransactionExecute: async (operation, options = {}) => {
    const { 
      maxRetries = 3, 
      timeout = 30000,
      isolationLevel = 'READ_COMMITTED'
    } = options;
    
    let transaction = null;
    let attempt = 0;
    
    while (attempt < maxRetries) {
      try {
        // 创建事务
        transaction = await sequelize.transaction({
          isolationLevel: sequelize.Transaction.ISOLATION_LEVELS[isolationLevel]
        });
        
        console.log(`🔄 开始事务 (尝试 ${attempt + 1}/${maxRetries})`);
        
        // 设置事务超时
        const timeoutPromise = new Promise((_, reject) => {
          setTimeout(() => reject(new Error('Transaction timeout')), timeout);
        });
        
        // 执行业务操作
        const operationPromise = operation(transaction);
        
        const result = await Promise.race([operationPromise, timeoutPromise]);
        
        // 🔴 检查事务状态，避免cursor_5.md中的重复提交问题
        if (transaction.finished) {
          console.warn('⚠️ 事务已完成，跳过提交操作');
          return result;
        }
        
        // 提交事务
        await transaction.commit();
        console.log('✅ 事务提交成功');
        
        return result;
        
      } catch (error) {
        attempt++;
        
        // 🔴 安全的事务回滚，避免"已完成事务"错误
        if (transaction && !transaction.finished) {
          try {
            await transaction.rollback();
            console.log('🔄 事务已回滚');
          } catch (rollbackError) {
            console.error('❌ 事务回滚失败:', rollbackError.message);
          }
        } else if (transaction && transaction.finished) {
          console.log('ℹ️ 事务已完成，无需回滚');
        }
        
        // 分析错误类型
        const errorType = analyzeTransactionError(error);
        
        if (errorType.retryable && attempt < maxRetries) {
          const delay = Math.min(1000 * Math.pow(2, attempt), 5000);
          console.log(`⏰ 事务失败，${delay}ms后重试 (${errorType.reason})`);
          await new Promise(resolve => setTimeout(resolve, delay));
          continue;
        } else {
          console.error(`❌ 事务最终失败: ${error.message}`);
          throw new Error(`事务执行失败 (尝试${attempt}次): ${error.message}`);
        }
      }
    }
  },
  
  // 事务状态检查包装器
  withTransactionCheck: (operation) => {
    return async (transaction) => {
      // 检查事务是否仍然有效
      if (transaction.finished) {
        throw new Error('Transaction has already been committed or rolled back');
      }
      
      // 执行操作
      const result = await operation(transaction);
      
      // 再次检查事务状态
      if (transaction.finished) {
        console.warn('⚠️ 操作执行期间事务已完成');
      }
      
      return result;
    };
  }
};

// 事务错误分析器
function analyzeTransactionError(error) {
  const errorMessage = error.message.toLowerCase();
  
  // 基于cursor_5.md中实际发现的错误模式
  if (errorMessage.includes('transaction cannot be rolled back') || 
      errorMessage.includes('has been finished')) {
    return { 
      retryable: false, 
      reason: 'transaction_already_finished',
      solution: '检查代码中是否有重复的事务操作'
    };
  }
  
  if (errorMessage.includes('deadlock') || errorMessage.includes('lock')) {
    return { 
      retryable: true, 
      reason: 'database_deadlock',
      solution: '实施指数退避重试'
    };
  }
  
  if (errorMessage.includes('timeout') || errorMessage.includes('connection')) {
    return { 
      retryable: true, 
      reason: 'connection_timeout',
      solution: '检查网络连接和数据库状态'
    };
  }
  
  if (errorMessage.includes('constraint') || errorMessage.includes('duplicate')) {
    return { 
      retryable: false, 
      reason: 'data_constraint_violation',
      solution: '检查数据完整性约束'
    };
  }
  
  return { 
    retryable: true, 
    reason: 'unknown_error',
    solution: '通用重试策略'
  };
}
```

### 数据库模型关联标准化
```javascript
// 基于cursor_3.md中发现的模型关联问题
const MODEL_ASSOCIATION_VALIDATOR = {
  // 标准关联配置
  standardAssociations: {
    User: {
      hasMany: [
        { model: 'UserInventory', as: 'inventoryItems', foreignKey: 'user_id' },
        { model: 'CustomerSession', as: 'chatSessions', foreignKey: 'user_id' },
        { model: 'ChatMessage', as: 'sentMessages', foreignKey: 'sender_id' }
      ],
      belongsTo: []
    },
    
    CustomerSession: {
      belongsTo: [
        { model: 'User', as: 'user', foreignKey: 'user_id' },
        { model: 'User', as: 'admin', foreignKey: 'admin_id' }
      ],
      hasMany: [
        { model: 'ChatMessage', as: 'messages', foreignKey: 'session_id' }
      ]
    },
    
    ChatMessage: {
      belongsTo: [
        { model: 'CustomerSession', as: 'session', foreignKey: 'session_id' },
        { model: 'User', as: 'sender', foreignKey: 'sender_id' }
      ]
    }
  },
  
  // 验证模型关联配置
  validateAssociations: (models) => {
    const issues = [];
    
    Object.entries(MODEL_ASSOCIATION_VALIDATOR.standardAssociations).forEach(([modelName, associations]) => {
      const model = models[modelName];
      
      if (!model) {
        issues.push({
          type: 'MISSING_MODEL',
          model: modelName,
          message: `模型 ${modelName} 不存在`
        });
        return;
      }
      
      // 检查hasMany关联
      associations.hasMany?.forEach(assoc => {
        const associationExists = model.associations[assoc.as];
        if (!associationExists) {
          issues.push({
            type: 'MISSING_ASSOCIATION',
            model: modelName,
            association: assoc,
            message: `缺少 hasMany 关联: ${modelName}.${assoc.as} -> ${assoc.model}`
          });
        }
      });
      
      // 检查belongsTo关联
      associations.belongsTo?.forEach(assoc => {
        const associationExists = model.associations[assoc.as];
        if (!associationExists) {
          issues.push({
            type: 'MISSING_ASSOCIATION',
            model: modelName,
            association: assoc,
            message: `缺少 belongsTo 关联: ${modelName}.${assoc.as} -> ${assoc.model}`
          });
        }
      });
    });
    
    if (issues.length > 0) {
      console.error('🔴 检测到模型关联问题:');
      issues.forEach(issue => {
        console.error(`   ❌ ${issue.message}`);
      });
      
      return { valid: false, issues };
    }
    
    console.log('✅ 模型关联验证通过');
    return { valid: true, issues: [] };
  }
};
```

## 配置管理和环境变量规范

### 基于cursor_9.md的配置完整性检查
```javascript
// 🔴 基于cursor_9.md中发现的.env配置缺失问题
const CONFIG_COMPLETENESS_VALIDATOR = {
  // 必需的环境变量
  requiredEnvVars: {
    // 数据库配置
    database: [
      'DB_HOST',
      'DB_PORT', 
      'DB_NAME',
      'DB_USER',
      'DB_PASSWORD'
    ],
    
    // 服务配置
    server: [
      'PORT',
      'NODE_ENV',
      'JWT_SECRET'
    ],
    
    // 第三方服务配置
    external_services: [
      'REDIS_URL',
      'SEALOS_ACCESS_KEY',
      'SEALOS_SECRET_KEY'
    ],
    
    // WebSocket配置
    websocket: [
      'WS_PORT',
      'WS_PATH'
    ]
  },
  
  // 环境变量存在性检查
  validateEnvironmentVariables: () => {
    const missingVars = [];
    
    Object.entries(CONFIG_COMPLETENESS_VALIDATOR.requiredEnvVars).forEach(([category, vars]) => {
      vars.forEach(varName => {
        if (!process.env[varName]) {
          missingVars.push({
            category,
            variable: varName,
            priority: getEnvVarPriority(varName)
          });
        }
      });
    });
    
    if (missingVars.length > 0) {
      console.error('🔴 检测到缺失的环境变量:');
      missingVars.forEach(missing => {
        console.error(`   ❌ [${missing.category}] ${missing.variable} (优先级: ${missing.priority})`);
      });
      
      // 🔴 基于cursor_9.md问题的修复建议
      console.log('\n🔧 环境变量修复建议:');
      console.log('1. 检查 .env 文件是否存在');
      console.log('2. 从 .env.example 复制模板配置');
      console.log('3. 设置正确的数据库连接信息');
      console.log('4. 配置必要的第三方服务密钥');
      
      return { valid: false, missingVars };
    }
    
    console.log('✅ 环境变量完整性检查通过');
    return { valid: true, missingVars: [] };
  },
  
  // 自动生成.env模板
  generateEnvTemplate: () => {
    const template = `# 数据库配置
DB_HOST=localhost
DB_PORT=3306
DB_NAME=restaurant_lottery
DB_USER=root
DB_PASSWORD=your_password

# 服务配置
PORT=3000
NODE_ENV=development
JWT_SECRET=your_jwt_secret_here

# Redis配置
REDIS_URL=redis://localhost:6379

# Sealos对象存储配置
SEALOS_ACCESS_KEY=your_access_key
SEALOS_SECRET_KEY=your_secret_key

# WebSocket配置
WS_PORT=3000
WS_PATH=/ws
`;
    
    console.log('📄 .env 配置模板:');
    console.log(template);
    
    return template;
  }
};

function getEnvVarPriority(varName) {
  const highPriority = ['DB_HOST', 'DB_PASSWORD', 'JWT_SECRET', 'PORT'];
  const mediumPriority = ['NODE_ENV', 'REDIS_URL', 'WS_PORT'];
  
  if (highPriority.includes(varName)) return 'HIGH';
  if (mediumPriority.includes(varName)) return 'MEDIUM';
  return 'LOW';
}
```

## 依赖管理和版本控制规范

### package.json完整性和版本兼容性检查
```javascript
// 基于多个cursor文档中发现的依赖问题
const DEPENDENCY_VALIDATOR = {
  // 核心依赖版本要求
  coreDependencies: {
    production: {
      'express': '^4.18.0',
      'sequelize': '^6.35.0',
      'mysql2': '^3.6.0',
      'socket.io': '^4.7.0',
      'jsonwebtoken': '^9.0.0',
      'bcryptjs': '^2.4.3',
      'cors': '^2.8.5',
      'dotenv': '^16.3.0'
    },
    
    development: {
      'nodemon': '^3.0.0',
      'jest': '^29.7.0',
      'supertest': '^6.3.0',
      'eslint': '^8.50.0',
      'prettier': '^3.0.0'
    }
  },
  
  // 检查依赖完整性
  validateDependencies: (packageJson) => {
    const issues = [];
    
    // 检查生产依赖
    Object.entries(DEPENDENCY_VALIDATOR.coreDependencies.production).forEach(([pkg, requiredVersion]) => {
      const installedVersion = packageJson.dependencies?.[pkg];
      
      if (!installedVersion) {
        issues.push({
          type: 'MISSING_DEPENDENCY',
          package: pkg,
          requiredVersion,
          category: 'production'
        });
      } else if (!isVersionCompatible(installedVersion, requiredVersion)) {
        issues.push({
          type: 'VERSION_INCOMPATIBLE',
          package: pkg,
          installedVersion,
          requiredVersion,
          category: 'production'
        });
      }
    });
    
    // 检查开发依赖
    Object.entries(DEPENDENCY_VALIDATOR.coreDependencies.development).forEach(([pkg, requiredVersion]) => {
      const installedVersion = packageJson.devDependencies?.[pkg];
      
      if (!installedVersion) {
        issues.push({
          type: 'MISSING_DEV_DEPENDENCY',
          package: pkg,
          requiredVersion,
          category: 'development'
        });
      }
    });
    
    if (issues.length > 0) {
      console.error('🔴 检测到依赖问题:');
      issues.forEach(issue => {
        console.error(`   ❌ ${issue.type}: ${issue.package} (${issue.category})`);
        if (issue.requiredVersion) {
          console.error(`      需要: ${issue.requiredVersion}, 当前: ${issue.installedVersion || '未安装'}`);
        }
      });
      
      return { valid: false, issues };
    }
    
    console.log('✅ 依赖完整性检查通过');
    return { valid: true, issues: [] };
  }
};

function isVersionCompatible(installed, required) {
  // 简化的版本兼容性检查
  const installedClean = installed.replace(/[\^~]/, '');
  const requiredClean = required.replace(/[\^~]/, '');
  
  return installedClean >= requiredClean;
}
```

## 综合开发质量检查器

### 集成所有检查项的统一验证器
```javascript
// 基于所有cursor文档问题的综合检查器
const COMPREHENSIVE_QUALITY_CHECKER = {
  // 执行所有质量检查
  runAllChecks: async (context) => {
    console.log('🔍 开始执行综合开发质量检查...');
    
    const results = {
      timestamp: new Date().toISOString(),
      checks: {},
      overallScore: 0,
      issues: [],
      recommendations: []
    };
    
    // 1. API完整性检查
    try {
      const apiCheck = await API_COMPLETENESS_VALIDATOR.validateAPICompleteness(context.app);
      results.checks.api_completeness = apiCheck;
      if (!apiCheck.valid) {
        results.issues.push(...apiCheck.missingEndpoints.map(e => ({
          type: 'API_MISSING',
          severity: 'HIGH',
          message: `缺失API端点: ${e.endpoint}`
        })));
      }
    } catch (error) {
      results.checks.api_completeness = { error: error.message };
    }
    
    // 2. WebSocket完整性检查
    try {
      const wsCheck = WEBSOCKET_COMPLETENESS_VALIDATOR.validateWebSocketMethods(context.webSocketService);
      results.checks.websocket_completeness = wsCheck;
      if (!wsCheck.valid) {
        results.issues.push(...wsCheck.missingMethods.map(m => ({
          type: 'WEBSOCKET_MISSING',
          severity: 'HIGH',
          message: `缺失WebSocket方法: ${m.method}`
        })));
      }
    } catch (error) {
      results.checks.websocket_completeness = { error: error.message };
    }
    
    // 3. 环境变量检查
    try {
      const envCheck = CONFIG_COMPLETENESS_VALIDATOR.validateEnvironmentVariables();
      results.checks.environment_variables = envCheck;
      if (!envCheck.valid) {
        results.issues.push(...envCheck.missingVars.map(v => ({
          type: 'ENV_VAR_MISSING',
          severity: v.priority === 'HIGH' ? 'HIGH' : 'MEDIUM',
          message: `缺失环境变量: ${v.variable}`
        })));
      }
    } catch (error) {
      results.checks.environment_variables = { error: error.message };
    }
    
    // 4. 依赖检查
    try {
      const depCheck = DEPENDENCY_VALIDATOR.validateDependencies(context.packageJson);
      results.checks.dependencies = depCheck;
      if (!depCheck.valid) {
        results.issues.push(...depCheck.issues.map(i => ({
          type: 'DEPENDENCY_ISSUE',
          severity: i.category === 'production' ? 'HIGH' : 'MEDIUM',
          message: `依赖问题: ${i.package} - ${i.type}`
        })));
      }
    } catch (error) {
      results.checks.dependencies = { error: error.message };
    }
    
    // 计算综合评分
    const totalChecks = Object.keys(results.checks).length;
    const passedChecks = Object.values(results.checks).filter(check => check.valid).length;
    results.overallScore = Math.round((passedChecks / totalChecks) * 100);
    
    // 生成建议
    results.recommendations = generateQualityRecommendations(results);
    
    // 输出报告
    COMPREHENSIVE_QUALITY_CHECKER.generateQualityReport(results);
    
    return results;
  },
  
  // 生成质量报告
  generateQualityReport: (results) => {
    console.log('\n📊 === 开发质量检查报告 ===');
    console.log(`总体评分: ${results.overallScore}/100`);
    console.log(`检查时间: ${results.timestamp}`);
    
    // 按严重程度分组显示问题
    const issuesBySeverity = groupBy(results.issues, 'severity');
    
    if (issuesBySeverity.HIGH?.length > 0) {
      console.log('\n🔴 高严重程度问题:');
      issuesBySeverity.HIGH.forEach(issue => {
        console.log(`   ❌ ${issue.message}`);
      });
    }
    
    if (issuesBySeverity.MEDIUM?.length > 0) {
      console.log('\n🟡 中等严重程度问题:');
      issuesBySeverity.MEDIUM.forEach(issue => {
        console.log(`   ⚠️ ${issue.message}`);
      });
    }
    
    if (results.recommendations.length > 0) {
      console.log('\n💡 改进建议:');
      results.recommendations.forEach((rec, index) => {
        console.log(`   ${index + 1}. ${rec}`);
      });
    }
    
    // 评级
    let grade = 'F';
    if (results.overallScore >= 90) grade = 'A';
    else if (results.overallScore >= 80) grade = 'B';
    else if (results.overallScore >= 70) grade = 'C';
    else if (results.overallScore >= 60) grade = 'D';
    
    console.log(`\n🏆 质量评级: ${grade}`);
  }
};

function generateQualityRecommendations(results) {
  const recommendations = [];
  
  if (results.overallScore < 70) {
    recommendations.push('代码质量需要显著改进，建议优先解决高严重程度问题');
  }
  
  const apiIssues = results.issues.filter(i => i.type === 'API_MISSING');
  if (apiIssues.length > 0) {
    recommendations.push('优先实现缺失的API端点，确保前后端接口一致性');
  }
  
  const wsIssues = results.issues.filter(i => i.type === 'WEBSOCKET_MISSING');
  if (wsIssues.length > 0) {
    recommendations.push('实现缺失的WebSocket方法，确保实时通信功能完整');
  }
  
  const envIssues = results.issues.filter(i => i.type === 'ENV_VAR_MISSING');
  if (envIssues.length > 0) {
    recommendations.push('配置缺失的环境变量，建立完整的配置管理');
  }
  
  return recommendations;
}

function groupBy(array, key) {
  return array.reduce((groups, item) => {
    const group = item[key];
    groups[group] = groups[group] || [];
    groups[group].push(item);
    return groups;
  }, {});
}
