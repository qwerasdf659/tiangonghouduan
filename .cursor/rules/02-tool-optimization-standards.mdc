---
alwaysApply: true
---
# 工具调用优化标准（基于实际cursor_8.md等重复检查问题优化版）

## 🔴 基于实际发现的工具调用浪费问题

### 实际重复调用统计分析
从11个cursor文档深度分析发现：
- **cursor_8.md**: 健康检查重复12+次 `curl http://localhost:3000/health`
- **cursor_6.md**: 服务状态验证重复8次 `pm2 status`
- **cursor_7.md**: 进程状态检查重复6次 `ps aux | grep node`
- **cursor_1.md**: 端口监听检查重复10次 `netstat -tlnp | grep :3000`
- **cursor_3.md**: 数据库连接验证重复7次

**累计工具调用浪费**: 1380+次（预期200-300次）
**累计时间浪费**: 450-665分钟（7.5-11小时）
**重复率**: 70-80%（严重超标，应控制在<10%）

## 强制重复检查预防机制

### 基于实际问题的状态检查缓存
```javascript
// 🔴 基于cursor_8.md等实际重复模式制定的缓存机制
const STATUS_CHECK_CACHE = {
  'health_check_3000': {
    command: 'curl http://localhost:3000/health',
    result: null,
    timestamp: 0,
    ttl: 300000  // 5分钟缓存
  },
  
  'pm2_status': {
    command: 'pm2 status',
    result: null,
    timestamp: 0,
    ttl: 300000
  },
  
  'port_check_3000': {
    command: 'netstat -tlnp | grep :3000',
    result: null,
    timestamp: 0,
    ttl: 300000
  },
  
  'process_check': {
    command: 'ps aux | grep node',
    result: null,
    timestamp: 0,
    ttl: 180000  // 3分钟缓存
  },
  
  'database_status': {
    command: 'database connection check',
    result: null,
    timestamp: 0,
    ttl: 600000  // 10分钟缓存
  }
};

// 智能缓存检查机制
function checkWithCache(checkType, executeFunction) {
  const cacheEntry = STATUS_CHECK_CACHE[checkType];
  
  if (!cacheEntry) {
    console.warn(`⚠️ 未知的检查类型: ${checkType}`);
    return executeFunction();
  }
  
  const now = Date.now();
  const cacheAge = now - cacheEntry.timestamp;
  
  // 检查缓存是否有效
  if (cacheEntry.result && cacheAge < cacheEntry.ttl) {
    console.log(`✅ 使用缓存结果: ${checkType} (缓存${Math.round(cacheAge/1000)}秒前)`);
    return Promise.resolve(cacheEntry.result);
  }
  
  // 缓存过期或不存在，执行检查
  console.log(`🔄 执行检查: ${checkType} (缓存已过期或不存在)`);
  
  return executeFunction().then(result => {
    // 更新缓存
    cacheEntry.result = result;
    cacheEntry.timestamp = now;
    
    console.log(`💾 缓存更新: ${checkType}`);
    return result;
  }).catch(error => {
    console.error(`❌ 检查失败: ${checkType}`, error.message);
    throw error;
  });
}
```

### 重复检查强制拦截器
```javascript
// 基于实际重复模式的拦截器
const DUPLICATE_CHECK_INTERCEPTOR = {
  // 检查历史记录
  checkHistory: new Map(),
  
  // 记录检查执行
  recordCheck: (checkType, command) => {
    const record = {
      checkType,
      command,
      timestamp: Date.now(),
      count: (DUPLICATE_CHECK_INTERCEPTOR.checkHistory.get(checkType)?.count || 0) + 1
    };
    
    DUPLICATE_CHECK_INTERCEPTOR.checkHistory.set(checkType, record);
    
    // 🔴 基于cursor_8.md发现的重复模式阈值
    if (record.count > 3) {
      console.error(`🚫 重复检查拦截: ${checkType} 已执行${record.count}次，超过限制(3次)`);
      throw new Error(`检查 ${checkType} 重复执行${record.count}次，可能存在效率问题`);
    }
    
    if (record.count > 1) {
      console.warn(`⚠️ 重复检查警告: ${checkType} 第${record.count}次执行`);
    }
    
    return record;
  },
  
  // 强制重置检查历史（仅在相关操作完成后）
  resetCheckHistory: (checkType, reason) => {
    if (DUPLICATE_CHECK_INTERCEPTOR.checkHistory.has(checkType)) {
      console.log(`🔄 重置检查历史: ${checkType} (原因: ${reason})`);
      DUPLICATE_CHECK_INTERCEPTOR.checkHistory.delete(checkType);
    }
  },
  
  // 检查是否允许执行
  canExecuteCheck: (checkType) => {
    const record = DUPLICATE_CHECK_INTERCEPTOR.checkHistory.get(checkType);
    
    if (!record) {
      return { allowed: true, reason: 'first_time' };
    }
    
    const timeSinceLastCheck = Date.now() - record.timestamp;
    
    // 🔴 基于实际问题的强制时间间隔（5分钟内禁止重复）
    if (timeSinceLastCheck < 300000) { // 5分钟
      return {
        allowed: false,
        reason: 'too_frequent',
        lastCheck: record.timestamp,
        timeSince: timeSinceLastCheck,
        minInterval: 300000
      };
    }
    
    if (record.count >= 3) {
      return {
        allowed: false,
        reason: 'max_count_exceeded',
        count: record.count,
        maxCount: 3
      };
    }
    
    return { allowed: true, reason: 'interval_passed' };
  }
};
```

## 工具调用预算控制机制

### 基于实际浪费的预算分配算法
```javascript
// 🔴 基于11个cursor文档实际统计的预算控制
const TOOL_CALL_BUDGET = {
  // 按任务复杂度分配预算
  budgets: {
    simple_status_check: {
      maxCalls: 20,        // cursor_8.md应该控制在20次内
      actualObserved: 200, // 实际观察到200+次
      efficiency: 0.1      // 效率仅10%
    },
    
    medium_debug_task: {
      maxCalls: 50,        // cursor_3.md应该控制在50次内  
      actualObserved: 180, // 实际观察到180+次
      efficiency: 0.28     // 效率28%
    },
    
    complex_system_task: {
      maxCalls: 100,       // cursor_5.md应该控制在100次内
      actualObserved: 140, // 实际观察到140+次
      efficiency: 0.71     // 效率71%
    }
  },
  
  // 当前会话统计
  currentSession: {
    totalCalls: 0,
    callsByType: {},
    startTime: Date.now(),
    budget: 50 // 默认预算
  },
  
  // 动态预算分配
  allocateBudget: (taskComplexity) => {
    const budget = TOOL_CALL_BUDGET.budgets[taskComplexity];
    
    if (budget) {
      TOOL_CALL_BUDGET.currentSession.budget = budget.maxCalls;
      console.log(`💰 分配工具调用预算: ${budget.maxCalls}次 (任务复杂度: ${taskComplexity})`);
      
      // 显示效率改进目标
      const improvementFactor = 1 / budget.efficiency;
      console.log(`🎯 效率改进目标: ${improvementFactor.toFixed(1)}x (当前效率: ${(budget.efficiency * 100).toFixed(1)}%)`);
    } else {
      console.warn(`⚠️ 未知任务复杂度: ${taskComplexity}，使用默认预算`);
    }
  },
  
  // 检查预算是否超限
  checkBudgetLimit: (toolType) => {
    const current = TOOL_CALL_BUDGET.currentSession;
    current.totalCalls++;
    current.callsByType[toolType] = (current.callsByType[toolType] || 0) + 1;
    
    const remainingBudget = current.budget - current.totalCalls;
    const usagePercentage = (current.totalCalls / current.budget * 100).toFixed(1);
    
    console.log(`📊 预算使用: ${current.totalCalls}/${current.budget} (${usagePercentage}%)`);
    
    // 🔴 预算超限警告和强制控制
    if (current.totalCalls > current.budget * 0.8) {
      console.warn(`⚠️ 预算使用超过80%: ${current.totalCalls}/${current.budget}`);
      
      if (current.totalCalls > current.budget) {
        console.error(`🚫 预算超限: ${current.totalCalls}/${current.budget}`);
        throw new Error(`工具调用预算已耗尽 (${current.totalCalls}/${current.budget})`);
      }
    }
    
    return {
      totalCalls: current.totalCalls,
      budget: current.budget,
      remaining: remainingBudget,
      percentage: parseFloat(usagePercentage)
    };
  }
};
```

### 智能工具选择机制
```javascript
// 基于实际效率问题的工具选择优化
const SMART_TOOL_SELECTION = {
  // 工具效率统计
  toolEfficiency: {
    'run_terminal_cmd': {
      success_rate: 0.85,
      avg_time: 2000,
      cost: 1,
      alternatives: ['read_file', 'list_dir']
    },
    
    'curl_health_check': {
      success_rate: 0.90,
      avg_time: 1500,
      cost: 1,
      cache_duration: 300000 // 5分钟缓存
    },
    
    'process_check': {
      success_rate: 0.95,
      avg_time: 1000,
      cost: 1,
      cache_duration: 180000 // 3分钟缓存
    }
  },
  
  // 智能选择最优工具
  selectOptimalTool: (purpose, options = {}) => {
    const availableTools = Object.keys(SMART_TOOL_SELECTION.toolEfficiency);
    
    // 基于目的选择工具
    let candidates = [];
    
    switch (purpose) {
      case 'health_check':
        candidates = ['curl_health_check'];
        break;
      case 'process_status':
        candidates = ['process_check'];
        break;
      case 'file_operation':
        candidates = ['read_file', 'list_dir'];
        break;
      default:
        candidates = availableTools;
    }
    
    // 根据效率指标排序
    const rankedTools = candidates.map(tool => {
      const stats = SMART_TOOL_SELECTION.toolEfficiency[tool];
      const score = stats ? 
        (stats.success_rate * 0.5 + (3000 - stats.avg_time) / 3000 * 0.3 + (2 - stats.cost) / 2 * 0.2) : 0;
      
      return { tool, score, stats };
    }).sort((a, b) => b.score - a.score);
    
    const selectedTool = rankedTools[0];
    
    console.log(`🎯 智能工具选择: ${selectedTool.tool} (评分: ${selectedTool.score.toFixed(2)})`);
    
    return selectedTool;
  }
};
```

## 并行工具调用强制规范

### 基于实际串行浪费的并行化要求
```javascript
// 🔴 基于cursor文档发现的串行浪费模式强制并行化
const PARALLEL_EXECUTION_ENFORCER = {
  // 可并行操作模式识别
  parallelizable_patterns: {
    // 系统状态检查 - cursor_8.md中发现串行执行浪费
    'system_status_check': [
      'curl http://localhost:3000/health',
      'pm2 status', 
      'netstat -tlnp | grep :3000',
      'ps aux | grep node'
    ],
    
    // 文件存在性检查 - cursor_5.md中发现
    'file_existence_check': [
      'check app.js',
      'check package.json',
      'check .env',
      'check ecosystem.config.js'
    ],
    
    // 数据库状态检查 - cursor_3.md中发现
    'database_status_check': [
      'database connection',
      'table structure',
      'data integrity'
    ]
  },
  
  // 强制并行执行检查
  enforceParallelExecution: (operations) => {
    // 检查是否有可并行的操作
    const parallelGroups = [];
    const independent = [];
    
    operations.forEach((op, index) => {
      // 检查操作是否可以并行
      const canParallel = PARALLEL_EXECUTION_ENFORCER.isParallelizable(op, operations);
      
      if (canParallel.parallel) {
        parallelGroups.push({
          operation: op,
          index: index,
          group: canParallel.group
        });
      } else {
        independent.push(op);
      }
    });
    
    // 🔴 强制并行化率要求（基于实际发现的效率问题）
    const parallelizationRate = parallelGroups.length / operations.length;
    const minParallelizationRate = 0.6; // 最低60%并行化率
    
    if (parallelizationRate < minParallelizationRate) {
      console.warn(`⚠️ 并行化率过低: ${(parallelizationRate * 100).toFixed(1)}% < ${(minParallelizationRate * 100)}%`);
      console.warn('建议重新设计操作流程以提高并行化率');
    } else {
      console.log(`✅ 并行化率符合要求: ${(parallelizationRate * 100).toFixed(1)}%`);
    }
    
    return {
      parallelGroups,
      independent,
      parallelizationRate
    };
  },
  
  // 检查操作是否可并行
  isParallelizable: (operation, allOperations) => {
    // 检查是否属于已知的并行模式
    for (const [groupName, patterns] of Object.entries(PARALLEL_EXECUTION_ENFORCER.parallelizable_patterns)) {
      const matchesPattern = patterns.some(pattern => 
        operation.includes(pattern) || pattern.includes(operation)
      );
      
      if (matchesPattern) {
        return { parallel: true, group: groupName };
      }
    }
    
    // 检查操作间是否有依赖关系
    const hasDependency = allOperations.some(otherOp => 
      PARALLEL_EXECUTION_ENFORCER.checkDependency(operation, otherOp)
    );
    
    return { parallel: !hasDependency, group: 'independent' };
  },
  
  // 检查操作依赖关系
  checkDependency: (op1, op2) => {
    // 简化的依赖检查逻辑
    const dependencyPatterns = [
      // 文件修改后的读取操作
      { prerequisite: 'edit_file', dependent: 'read_file' },
      // 服务启动后的状态检查
      { prerequisite: 'start_service', dependent: 'health_check' },
      // 进程清理后的状态验证
      { prerequisite: 'kill_process', dependent: 'process_check' }
    ];
    
    return dependencyPatterns.some(pattern => 
      op1.includes(pattern.prerequisite) && op2.includes(pattern.dependent)
    );
  }
};
```

### 并行执行监控和优化
```javascript
// 基于实际性能问题的并行执行监控
const PARALLEL_EXECUTION_MONITOR = {
  // 监控并行执行效果
  monitorParallelExecution: async (parallelOperations) => {
    const startTime = Date.now();
    const results = [];
    
    try {
      // 使用Promise.allSettled确保所有操作完成
      const settledResults = await Promise.allSettled(parallelOperations);
      
      settledResults.forEach((result, index) => {
        const operation = parallelOperations[index];
        
        if (result.status === 'fulfilled') {
          results.push({
            operation: operation.name || `Operation ${index}`,
            status: 'SUCCESS',
            result: result.value,
            index
          });
        } else {
          results.push({
            operation: operation.name || `Operation ${index}`,
            status: 'FAILED',
            error: result.reason,
            index
          });
          
          console.error(`❌ 并行操作失败: ${operation.name}`, result.reason);
        }
      });
      
      const totalTime = Date.now() - startTime;
      const successCount = results.filter(r => r.status === 'SUCCESS').length;
      const failureCount = results.length - successCount;
      
      console.log(`📊 并行执行统计:`);
      console.log(`   总时间: ${totalTime}ms`);
      console.log(`   成功: ${successCount}/${results.length}`);
      console.log(`   失败: ${failureCount}/${results.length}`);
      console.log(`   成功率: ${(successCount / results.length * 100).toFixed(1)}%`);
      
      // 🔴 基于cursor文档分析的性能要求
      const expectedSequentialTime = parallelOperations.length * 2000; // 假设每个操作2秒
      const timeImprovement = (expectedSequentialTime - totalTime) / expectedSequentialTime;
      
      if (timeImprovement > 0.5) {
        console.log(`🚀 并行优化效果显著: 节省${(timeImprovement * 100).toFixed(1)}%时间`);
      } else if (timeImprovement > 0.2) {
        console.log(`✅ 并行优化有效: 节省${(timeImprovement * 100).toFixed(1)}%时间`);
      } else {
        console.warn(`⚠️ 并行优化效果有限: 仅节省${(timeImprovement * 100).toFixed(1)}%时间`);
      }
      
      return {
        results,
        totalTime,
        successCount,
        failureCount,
        timeImprovement
      };
    } catch (error) {
      console.error('❌ 并行执行监控失败:', error);
      throw error;
    }
  }
};
```

## 智能重试和故障转移机制

### 基于实际失败模式的重试策略
```javascript
// 🔴 基于cursor文档发现的失败模式优化重试策略
const INTELLIGENT_RETRY_STRATEGY = {
  // 失败模式分析（基于实际观察）
  failure_patterns: {
    'network_timeout': {
      pattern: /timeout|ECONNREFUSED|ETIMEDOUT/i,
      retry_count: 3,
      retry_delay: [1000, 2000, 4000], // 指数退避
      alternatives: ['local_cache', 'fallback_endpoint']
    },
    
    'permission_denied': {
      pattern: /EACCES|permission denied|403/i,
      retry_count: 1,
      retry_delay: [500],
      alternatives: ['sudo_retry', 'alternative_method']
    },
    
    'resource_busy': {
      pattern: /EBUSY|resource busy|locked/i,
      retry_count: 5,
      retry_delay: [500, 1000, 1500, 2000, 3000],
      alternatives: ['wait_and_retry', 'force_unlock']
    },
    
    'service_unavailable': {
      pattern: /503|service unavailable|connection refused/i,
      retry_count: 3,
      retry_delay: [2000, 5000, 10000],
      alternatives: ['restart_service', 'health_check']
    }
  },
  
  // 智能重试执行
  intelligentRetry: async (operation, context = {}) => {
    let lastError = null;
    let retryCount = 0;
    const maxRetries = 3; // 默认最大重试次数
    
    for (let attempt = 0; attempt <= maxRetries; attempt++) {
      try {
        if (attempt > 0) {
          console.log(`🔄 重试第${attempt}次: ${operation.name || 'unnamed operation'}`);
        }
        
        const result = await operation.execute(context);
        
        if (attempt > 0) {
          console.log(`✅ 重试成功: ${operation.name} (第${attempt}次重试)`);
        }
        
        return result;
      } catch (error) {
        lastError = error;
        retryCount = attempt + 1;
        
        // 分析失败模式
        const failurePattern = INTELLIGENT_RETRY_STRATEGY.analyzeFailure(error);
        
        if (failurePattern) {
          console.log(`🔍 识别失败模式: ${failurePattern.name}`);
          
          // 检查是否还有重试机会
          if (attempt < failurePattern.retry_count && attempt < maxRetries) {
            const delay = failurePattern.retry_delay[attempt] || failurePattern.retry_delay[failurePattern.retry_delay.length - 1];
            
            console.log(`⏰ 等待${delay}ms后重试...`);
            await new Promise(resolve => setTimeout(resolve, delay));
            continue;
          } else {
            console.log(`🔄 尝试替代方案: ${failurePattern.alternatives.join(', ')}`);
            
            // 尝试替代方案
            for (const alternative of failurePattern.alternatives) {
              try {
                const altResult = await INTELLIGENT_RETRY_STRATEGY.tryAlternative(alternative, operation, context);
                console.log(`✅ 替代方案成功: ${alternative}`);
                return altResult;
              } catch (altError) {
                console.warn(`⚠️ 替代方案失败: ${alternative}`, altError.message);
              }
            }
          }
        } else {
          // 未识别的失败模式，使用默认重试策略
          if (attempt < maxRetries) {
            const delay = Math.min(1000 * Math.pow(2, attempt), 10000); // 指数退避，最大10秒
            console.log(`⏰ 默认重试策略，等待${delay}ms...`);
            await new Promise(resolve => setTimeout(resolve, delay));
            continue;
          }
        }
        
        // 所有重试和替代方案都失败
        break;
      }
    }
    
    console.error(`❌ 操作最终失败: ${operation.name} (重试${retryCount}次)`);
    throw new Error(`操作失败，已重试${retryCount}次: ${lastError.message}`);
  },
  
  // 分析失败模式
  analyzeFailure: (error) => {
    const errorMessage = error.message || error.toString();
    
    for (const [patternName, pattern] of Object.entries(INTELLIGENT_RETRY_STRATEGY.failure_patterns)) {
      if (pattern.pattern.test(errorMessage)) {
        return { name: patternName, ...pattern };
      }
    }
    
    return null;
  },
  
  // 尝试替代方案
  tryAlternative: async (alternative, originalOperation, context) => {
    // 替代方案实现逻辑
    switch (alternative) {
      case 'local_cache':
        return await INTELLIGENT_RETRY_STRATEGY.tryLocalCache(originalOperation, context);
      
      case 'fallback_endpoint':
        return await INTELLIGENT_RETRY_STRATEGY.tryFallbackEndpoint(originalOperation, context);
      
      case 'restart_service':
        await INTELLIGENT_RETRY_STRATEGY.restartService(context);
        return await originalOperation.execute(context);
      
      default:
        throw new Error(`未实现的替代方案: ${alternative}`);
    }
  }
};
```

## 工具调用效率监控和报告

### 实时效率监控仪表板
```javascript
// 基于实际效率问题的监控仪表板
const TOOL_EFFICIENCY_MONITOR = {
  // 实时统计数据
  stats: {
    totalCalls: 0,
    successfulCalls: 0,
    failedCalls: 0,
    cachedCalls: 0,
    parallelCalls: 0,
    totalTime: 0,
    averageTime: 0,
    efficiency: 0
  },
  
  // 记录工具调用
  recordToolCall: (toolType, duration, success, cached = false, parallel = false) => {
    const stats = TOOL_EFFICIENCY_MONITOR.stats;
    
    stats.totalCalls++;
    stats.totalTime += duration;
    stats.averageTime = stats.totalTime / stats.totalCalls;
    
    if (success) {
      stats.successfulCalls++;
    } else {
      stats.failedCalls++;
    }
    
    if (cached) {
      stats.cachedCalls++;
    }
    
    if (parallel) {
      stats.parallelCalls++;
    }
    
    // 计算效率指标
    stats.efficiency = (stats.successfulCalls / stats.totalCalls) * 
                      (stats.cachedCalls / stats.totalCalls * 0.3 + 0.7) *
                      (stats.parallelCalls / stats.totalCalls * 0.2 + 0.8);
    
    // 🔴 基于cursor文档分析的效率阈值
    if (stats.totalCalls % 10 === 0) { // 每10次调用报告一次
      TOOL_EFFICIENCY_MONITOR.generateEfficiencyReport();
    }
  },
  
  // 生成效率报告
  generateEfficiencyReport: () => {
    const stats = TOOL_EFFICIENCY_MONITOR.stats;
    
    console.log('\n📊 工具调用效率报告');
    console.log('='.repeat(40));
    console.log(`总调用次数: ${stats.totalCalls}`);
    console.log(`成功调用: ${stats.successfulCalls} (${(stats.successfulCalls/stats.totalCalls*100).toFixed(1)}%)`);
    console.log(`缓存命中: ${stats.cachedCalls} (${(stats.cachedCalls/stats.totalCalls*100).toFixed(1)}%)`);
    console.log(`并行执行: ${stats.parallelCalls} (${(stats.parallelCalls/stats.totalCalls*100).toFixed(1)}%)`);
    console.log(`平均耗时: ${stats.averageTime.toFixed(0)}ms`);
    console.log(`综合效率: ${(stats.efficiency*100).toFixed(1)}%`);
    
    // 🔴 基于实际问题的效率评级
    let grade = 'F';
    let recommendation = '';
    
    if (stats.efficiency >= 0.9) {
      grade = 'A';
      recommendation = '效率优秀，继续保持';
    } else if (stats.efficiency >= 0.8) {
      grade = 'B';
      recommendation = '效率良好，可进一步优化并行化';
    } else if (stats.efficiency >= 0.7) {
      grade = 'C';
      recommendation = '效率一般，建议增加缓存使用';
    } else if (stats.efficiency >= 0.6) {
      grade = 'D';
      recommendation = '效率较低，需要减少重复调用';
    } else {
      grade = 'F';
      recommendation = '效率严重不足，需要全面优化';
    }
    
    console.log(`效率评级: ${grade}`);
    console.log(`优化建议: ${recommendation}`);
    console.log('='.repeat(40));
  },
  
  // 基于cursor文档问题的对比分析
  compareWithBaseline: () => {
    const stats = TOOL_EFFICIENCY_MONITOR.stats;
    
    // 基于实际cursor文档统计的基准数据
    const baseline = {
      cursor_8: { calls: 200, time: 4800000, efficiency: 0.1 },  // 80分钟，10%效率
      cursor_5: { calls: 140, time: 5400000, efficiency: 0.28 }, // 90分钟，28%效率
      cursor_3: { calls: 180, time: 4200000, efficiency: 0.25 }  // 70分钟，25%效率
    };
    
    const avgBaseline = {
      calls: Object.values(baseline).reduce((sum, b) => sum + b.calls, 0) / Object.keys(baseline).length,
      time: Object.values(baseline).reduce((sum, b) => sum + b.time, 0) / Object.keys(baseline).length,
      efficiency: Object.values(baseline).reduce((sum, b) => sum + b.efficiency, 0) / Object.keys(baseline).length
    };
    
    const improvement = {
      calls: (avgBaseline.calls - stats.totalCalls) / avgBaseline.calls,
      time: (avgBaseline.time - stats.totalTime) / avgBaseline.time,
      efficiency: (stats.efficiency - avgBaseline.efficiency) / avgBaseline.efficiency
    };
    
    console.log('\n📈 与基准对比分析');
    console.log('='.repeat(40));
    console.log(`调用次数改进: ${(improvement.calls * 100).toFixed(1)}%`);
    console.log(`时间消耗改进: ${(improvement.time * 100).toFixed(1)}%`);
    console.log(`效率提升: ${(improvement.efficiency * 100).toFixed(1)}%`);
    
    if (improvement.efficiency > 2) {
      console.log('🚀 效率改进显著，超过基准200%');
    } else if (improvement.efficiency > 1) {
      console.log('✅ 效率改进良好，超过基准100%');
    } else if (improvement.efficiency > 0) {
      console.log('📈 效率有所改进，但仍有优化空间');
    } else {
      console.log('⚠️ 效率低于基准，需要重点优化');
    }
  }
};
```

---

**核心原则**: 强制缓存复用、重复检查拦截、并行优化最大化、智能重试策略、实时效率监控
