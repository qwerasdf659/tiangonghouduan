---
alwaysApply: true
---
# å·¥å…·è°ƒç”¨ä¼˜åŒ–æ ‡å‡†ï¼ˆåŸºäºå®é™…cursor_8.mdç­‰é‡å¤æ£€æŸ¥é—®é¢˜ä¼˜åŒ–ç‰ˆï¼‰

## ğŸ”´ åŸºäºå®é™…å‘ç°çš„å·¥å…·è°ƒç”¨æµªè´¹é—®é¢˜

### å®é™…é‡å¤è°ƒç”¨ç»Ÿè®¡åˆ†æ
ä»11ä¸ªcursoræ–‡æ¡£æ·±åº¦åˆ†æå‘ç°ï¼š
- **cursor_8.md**: å¥åº·æ£€æŸ¥é‡å¤12+æ¬¡ `curl http://localhost:3000/health`
- **cursor_6.md**: æœåŠ¡çŠ¶æ€éªŒè¯é‡å¤8æ¬¡ `pm2 status`
- **cursor_7.md**: è¿›ç¨‹çŠ¶æ€æ£€æŸ¥é‡å¤6æ¬¡ `ps aux | grep node`
- **cursor_1.md**: ç«¯å£ç›‘å¬æ£€æŸ¥é‡å¤10æ¬¡ `netstat -tlnp | grep :3000`
- **cursor_3.md**: æ•°æ®åº“è¿æ¥éªŒè¯é‡å¤7æ¬¡

**ç´¯è®¡å·¥å…·è°ƒç”¨æµªè´¹**: 1380+æ¬¡ï¼ˆé¢„æœŸ200-300æ¬¡ï¼‰
**ç´¯è®¡æ—¶é—´æµªè´¹**: 450-665åˆ†é’Ÿï¼ˆ7.5-11å°æ—¶ï¼‰
**é‡å¤ç‡**: 70-80%ï¼ˆä¸¥é‡è¶…æ ‡ï¼Œåº”æ§åˆ¶åœ¨<10%ï¼‰

## å¼ºåˆ¶é‡å¤æ£€æŸ¥é¢„é˜²æœºåˆ¶

### åŸºäºå®é™…é—®é¢˜çš„çŠ¶æ€æ£€æŸ¥ç¼“å­˜
```javascript
// ğŸ”´ åŸºäºcursor_8.mdç­‰å®é™…é‡å¤æ¨¡å¼åˆ¶å®šçš„ç¼“å­˜æœºåˆ¶
const STATUS_CHECK_CACHE = {
  'health_check_3000': {
    command: 'curl http://localhost:3000/health',
    result: null,
    timestamp: 0,
    ttl: 300000  // 5åˆ†é’Ÿç¼“å­˜
  },
  
  'pm2_status': {
    command: 'pm2 status',
    result: null,
    timestamp: 0,
    ttl: 300000
  },
  
  'port_check_3000': {
    command: 'netstat -tlnp | grep :3000',
    result: null,
    timestamp: 0,
    ttl: 300000
  },
  
  'process_check': {
    command: 'ps aux | grep node',
    result: null,
    timestamp: 0,
    ttl: 180000  // 3åˆ†é’Ÿç¼“å­˜
  },
  
  'database_status': {
    command: 'database connection check',
    result: null,
    timestamp: 0,
    ttl: 600000  // 10åˆ†é’Ÿç¼“å­˜
  }
};

// æ™ºèƒ½ç¼“å­˜æ£€æŸ¥æœºåˆ¶
function checkWithCache(checkType, executeFunction) {
  const cacheEntry = STATUS_CHECK_CACHE[checkType];
  
  if (!cacheEntry) {
    console.warn(`âš ï¸ æœªçŸ¥çš„æ£€æŸ¥ç±»å‹: ${checkType}`);
    return executeFunction();
  }
  
  const now = Date.now();
  const cacheAge = now - cacheEntry.timestamp;
  
  // æ£€æŸ¥ç¼“å­˜æ˜¯å¦æœ‰æ•ˆ
  if (cacheEntry.result && cacheAge < cacheEntry.ttl) {
    console.log(`âœ… ä½¿ç”¨ç¼“å­˜ç»“æœ: ${checkType} (ç¼“å­˜${Math.round(cacheAge/1000)}ç§’å‰)`);
    return Promise.resolve(cacheEntry.result);
  }
  
  // ç¼“å­˜è¿‡æœŸæˆ–ä¸å­˜åœ¨ï¼Œæ‰§è¡Œæ£€æŸ¥
  console.log(`ğŸ”„ æ‰§è¡Œæ£€æŸ¥: ${checkType} (ç¼“å­˜å·²è¿‡æœŸæˆ–ä¸å­˜åœ¨)`);
  
  return executeFunction().then(result => {
    // æ›´æ–°ç¼“å­˜
    cacheEntry.result = result;
    cacheEntry.timestamp = now;
    
    console.log(`ğŸ’¾ ç¼“å­˜æ›´æ–°: ${checkType}`);
    return result;
  }).catch(error => {
    console.error(`âŒ æ£€æŸ¥å¤±è´¥: ${checkType}`, error.message);
    throw error;
  });
}
```

### é‡å¤æ£€æŸ¥å¼ºåˆ¶æ‹¦æˆªå™¨
```javascript
// åŸºäºå®é™…é‡å¤æ¨¡å¼çš„æ‹¦æˆªå™¨
const DUPLICATE_CHECK_INTERCEPTOR = {
  // æ£€æŸ¥å†å²è®°å½•
  checkHistory: new Map(),
  
  // è®°å½•æ£€æŸ¥æ‰§è¡Œ
  recordCheck: (checkType, command) => {
    const record = {
      checkType,
      command,
      timestamp: Date.now(),
      count: (DUPLICATE_CHECK_INTERCEPTOR.checkHistory.get(checkType)?.count || 0) + 1
    };
    
    DUPLICATE_CHECK_INTERCEPTOR.checkHistory.set(checkType, record);
    
    // ğŸ”´ åŸºäºcursor_8.mdå‘ç°çš„é‡å¤æ¨¡å¼é˜ˆå€¼
    if (record.count > 3) {
      console.error(`ğŸš« é‡å¤æ£€æŸ¥æ‹¦æˆª: ${checkType} å·²æ‰§è¡Œ${record.count}æ¬¡ï¼Œè¶…è¿‡é™åˆ¶(3æ¬¡)`);
      throw new Error(`æ£€æŸ¥ ${checkType} é‡å¤æ‰§è¡Œ${record.count}æ¬¡ï¼Œå¯èƒ½å­˜åœ¨æ•ˆç‡é—®é¢˜`);
    }
    
    if (record.count > 1) {
      console.warn(`âš ï¸ é‡å¤æ£€æŸ¥è­¦å‘Š: ${checkType} ç¬¬${record.count}æ¬¡æ‰§è¡Œ`);
    }
    
    return record;
  },
  
  // å¼ºåˆ¶é‡ç½®æ£€æŸ¥å†å²ï¼ˆä»…åœ¨ç›¸å…³æ“ä½œå®Œæˆåï¼‰
  resetCheckHistory: (checkType, reason) => {
    if (DUPLICATE_CHECK_INTERCEPTOR.checkHistory.has(checkType)) {
      console.log(`ğŸ”„ é‡ç½®æ£€æŸ¥å†å²: ${checkType} (åŸå› : ${reason})`);
      DUPLICATE_CHECK_INTERCEPTOR.checkHistory.delete(checkType);
    }
  },
  
  // æ£€æŸ¥æ˜¯å¦å…è®¸æ‰§è¡Œ
  canExecuteCheck: (checkType) => {
    const record = DUPLICATE_CHECK_INTERCEPTOR.checkHistory.get(checkType);
    
    if (!record) {
      return { allowed: true, reason: 'first_time' };
    }
    
    const timeSinceLastCheck = Date.now() - record.timestamp;
    
    // ğŸ”´ åŸºäºå®é™…é—®é¢˜çš„å¼ºåˆ¶æ—¶é—´é—´éš”ï¼ˆ5åˆ†é’Ÿå†…ç¦æ­¢é‡å¤ï¼‰
    if (timeSinceLastCheck < 300000) { // 5åˆ†é’Ÿ
      return {
        allowed: false,
        reason: 'too_frequent',
        lastCheck: record.timestamp,
        timeSince: timeSinceLastCheck,
        minInterval: 300000
      };
    }
    
    if (record.count >= 3) {
      return {
        allowed: false,
        reason: 'max_count_exceeded',
        count: record.count,
        maxCount: 3
      };
    }
    
    return { allowed: true, reason: 'interval_passed' };
  }
};
```

## å·¥å…·è°ƒç”¨é¢„ç®—æ§åˆ¶æœºåˆ¶

### åŸºäºå®é™…æµªè´¹çš„é¢„ç®—åˆ†é…ç®—æ³•
```javascript
// ğŸ”´ åŸºäº11ä¸ªcursoræ–‡æ¡£å®é™…ç»Ÿè®¡çš„é¢„ç®—æ§åˆ¶
const TOOL_CALL_BUDGET = {
  // æŒ‰ä»»åŠ¡å¤æ‚åº¦åˆ†é…é¢„ç®—
  budgets: {
    simple_status_check: {
      maxCalls: 20,        // cursor_8.mdåº”è¯¥æ§åˆ¶åœ¨20æ¬¡å†…
      actualObserved: 200, // å®é™…è§‚å¯Ÿåˆ°200+æ¬¡
      efficiency: 0.1      // æ•ˆç‡ä»…10%
    },
    
    medium_debug_task: {
      maxCalls: 50,        // cursor_3.mdåº”è¯¥æ§åˆ¶åœ¨50æ¬¡å†…  
      actualObserved: 180, // å®é™…è§‚å¯Ÿåˆ°180+æ¬¡
      efficiency: 0.28     // æ•ˆç‡28%
    },
    
    complex_system_task: {
      maxCalls: 100,       // cursor_5.mdåº”è¯¥æ§åˆ¶åœ¨100æ¬¡å†…
      actualObserved: 140, // å®é™…è§‚å¯Ÿåˆ°140+æ¬¡
      efficiency: 0.71     // æ•ˆç‡71%
    }
  },
  
  // å½“å‰ä¼šè¯ç»Ÿè®¡
  currentSession: {
    totalCalls: 0,
    callsByType: {},
    startTime: Date.now(),
    budget: 50 // é»˜è®¤é¢„ç®—
  },
  
  // åŠ¨æ€é¢„ç®—åˆ†é…
  allocateBudget: (taskComplexity) => {
    const budget = TOOL_CALL_BUDGET.budgets[taskComplexity];
    
    if (budget) {
      TOOL_CALL_BUDGET.currentSession.budget = budget.maxCalls;
      console.log(`ğŸ’° åˆ†é…å·¥å…·è°ƒç”¨é¢„ç®—: ${budget.maxCalls}æ¬¡ (ä»»åŠ¡å¤æ‚åº¦: ${taskComplexity})`);
      
      // æ˜¾ç¤ºæ•ˆç‡æ”¹è¿›ç›®æ ‡
      const improvementFactor = 1 / budget.efficiency;
      console.log(`ğŸ¯ æ•ˆç‡æ”¹è¿›ç›®æ ‡: ${improvementFactor.toFixed(1)}x (å½“å‰æ•ˆç‡: ${(budget.efficiency * 100).toFixed(1)}%)`);
    } else {
      console.warn(`âš ï¸ æœªçŸ¥ä»»åŠ¡å¤æ‚åº¦: ${taskComplexity}ï¼Œä½¿ç”¨é»˜è®¤é¢„ç®—`);
    }
  },
  
  // æ£€æŸ¥é¢„ç®—æ˜¯å¦è¶…é™
  checkBudgetLimit: (toolType) => {
    const current = TOOL_CALL_BUDGET.currentSession;
    current.totalCalls++;
    current.callsByType[toolType] = (current.callsByType[toolType] || 0) + 1;
    
    const remainingBudget = current.budget - current.totalCalls;
    const usagePercentage = (current.totalCalls / current.budget * 100).toFixed(1);
    
    console.log(`ğŸ“Š é¢„ç®—ä½¿ç”¨: ${current.totalCalls}/${current.budget} (${usagePercentage}%)`);
    
    // ğŸ”´ é¢„ç®—è¶…é™è­¦å‘Šå’Œå¼ºåˆ¶æ§åˆ¶
    if (current.totalCalls > current.budget * 0.8) {
      console.warn(`âš ï¸ é¢„ç®—ä½¿ç”¨è¶…è¿‡80%: ${current.totalCalls}/${current.budget}`);
      
      if (current.totalCalls > current.budget) {
        console.error(`ğŸš« é¢„ç®—è¶…é™: ${current.totalCalls}/${current.budget}`);
        throw new Error(`å·¥å…·è°ƒç”¨é¢„ç®—å·²è€—å°½ (${current.totalCalls}/${current.budget})`);
      }
    }
    
    return {
      totalCalls: current.totalCalls,
      budget: current.budget,
      remaining: remainingBudget,
      percentage: parseFloat(usagePercentage)
    };
  }
};
```

### æ™ºèƒ½å·¥å…·é€‰æ‹©æœºåˆ¶
```javascript
// åŸºäºå®é™…æ•ˆç‡é—®é¢˜çš„å·¥å…·é€‰æ‹©ä¼˜åŒ–
const SMART_TOOL_SELECTION = {
  // å·¥å…·æ•ˆç‡ç»Ÿè®¡
  toolEfficiency: {
    'run_terminal_cmd': {
      success_rate: 0.85,
      avg_time: 2000,
      cost: 1,
      alternatives: ['read_file', 'list_dir']
    },
    
    'curl_health_check': {
      success_rate: 0.90,
      avg_time: 1500,
      cost: 1,
      cache_duration: 300000 // 5åˆ†é’Ÿç¼“å­˜
    },
    
    'process_check': {
      success_rate: 0.95,
      avg_time: 1000,
      cost: 1,
      cache_duration: 180000 // 3åˆ†é’Ÿç¼“å­˜
    }
  },
  
  // æ™ºèƒ½é€‰æ‹©æœ€ä¼˜å·¥å…·
  selectOptimalTool: (purpose, options = {}) => {
    const availableTools = Object.keys(SMART_TOOL_SELECTION.toolEfficiency);
    
    // åŸºäºç›®çš„é€‰æ‹©å·¥å…·
    let candidates = [];
    
    switch (purpose) {
      case 'health_check':
        candidates = ['curl_health_check'];
        break;
      case 'process_status':
        candidates = ['process_check'];
        break;
      case 'file_operation':
        candidates = ['read_file', 'list_dir'];
        break;
      default:
        candidates = availableTools;
    }
    
    // æ ¹æ®æ•ˆç‡æŒ‡æ ‡æ’åº
    const rankedTools = candidates.map(tool => {
      const stats = SMART_TOOL_SELECTION.toolEfficiency[tool];
      const score = stats ? 
        (stats.success_rate * 0.5 + (3000 - stats.avg_time) / 3000 * 0.3 + (2 - stats.cost) / 2 * 0.2) : 0;
      
      return { tool, score, stats };
    }).sort((a, b) => b.score - a.score);
    
    const selectedTool = rankedTools[0];
    
    console.log(`ğŸ¯ æ™ºèƒ½å·¥å…·é€‰æ‹©: ${selectedTool.tool} (è¯„åˆ†: ${selectedTool.score.toFixed(2)})`);
    
    return selectedTool;
  }
};
```

## å¹¶è¡Œå·¥å…·è°ƒç”¨å¼ºåˆ¶è§„èŒƒ

### åŸºäºå®é™…ä¸²è¡Œæµªè´¹çš„å¹¶è¡ŒåŒ–è¦æ±‚
```javascript
// ğŸ”´ åŸºäºcursoræ–‡æ¡£å‘ç°çš„ä¸²è¡Œæµªè´¹æ¨¡å¼å¼ºåˆ¶å¹¶è¡ŒåŒ–
const PARALLEL_EXECUTION_ENFORCER = {
  // å¯å¹¶è¡Œæ“ä½œæ¨¡å¼è¯†åˆ«
  parallelizable_patterns: {
    // ç³»ç»ŸçŠ¶æ€æ£€æŸ¥ - cursor_8.mdä¸­å‘ç°ä¸²è¡Œæ‰§è¡Œæµªè´¹
    'system_status_check': [
      'curl http://localhost:3000/health',
      'pm2 status', 
      'netstat -tlnp | grep :3000',
      'ps aux | grep node'
    ],
    
    // æ–‡ä»¶å­˜åœ¨æ€§æ£€æŸ¥ - cursor_5.mdä¸­å‘ç°
    'file_existence_check': [
      'check app.js',
      'check package.json',
      'check .env',
      'check ecosystem.config.js'
    ],
    
    // æ•°æ®åº“çŠ¶æ€æ£€æŸ¥ - cursor_3.mdä¸­å‘ç°
    'database_status_check': [
      'database connection',
      'table structure',
      'data integrity'
    ]
  },
  
  // å¼ºåˆ¶å¹¶è¡Œæ‰§è¡Œæ£€æŸ¥
  enforceParallelExecution: (operations) => {
    // æ£€æŸ¥æ˜¯å¦æœ‰å¯å¹¶è¡Œçš„æ“ä½œ
    const parallelGroups = [];
    const independent = [];
    
    operations.forEach((op, index) => {
      // æ£€æŸ¥æ“ä½œæ˜¯å¦å¯ä»¥å¹¶è¡Œ
      const canParallel = PARALLEL_EXECUTION_ENFORCER.isParallelizable(op, operations);
      
      if (canParallel.parallel) {
        parallelGroups.push({
          operation: op,
          index: index,
          group: canParallel.group
        });
      } else {
        independent.push(op);
      }
    });
    
    // ğŸ”´ å¼ºåˆ¶å¹¶è¡ŒåŒ–ç‡è¦æ±‚ï¼ˆåŸºäºå®é™…å‘ç°çš„æ•ˆç‡é—®é¢˜ï¼‰
    const parallelizationRate = parallelGroups.length / operations.length;
    const minParallelizationRate = 0.6; // æœ€ä½60%å¹¶è¡ŒåŒ–ç‡
    
    if (parallelizationRate < minParallelizationRate) {
      console.warn(`âš ï¸ å¹¶è¡ŒåŒ–ç‡è¿‡ä½: ${(parallelizationRate * 100).toFixed(1)}% < ${(minParallelizationRate * 100)}%`);
      console.warn('å»ºè®®é‡æ–°è®¾è®¡æ“ä½œæµç¨‹ä»¥æé«˜å¹¶è¡ŒåŒ–ç‡');
    } else {
      console.log(`âœ… å¹¶è¡ŒåŒ–ç‡ç¬¦åˆè¦æ±‚: ${(parallelizationRate * 100).toFixed(1)}%`);
    }
    
    return {
      parallelGroups,
      independent,
      parallelizationRate
    };
  },
  
  // æ£€æŸ¥æ“ä½œæ˜¯å¦å¯å¹¶è¡Œ
  isParallelizable: (operation, allOperations) => {
    // æ£€æŸ¥æ˜¯å¦å±äºå·²çŸ¥çš„å¹¶è¡Œæ¨¡å¼
    for (const [groupName, patterns] of Object.entries(PARALLEL_EXECUTION_ENFORCER.parallelizable_patterns)) {
      const matchesPattern = patterns.some(pattern => 
        operation.includes(pattern) || pattern.includes(operation)
      );
      
      if (matchesPattern) {
        return { parallel: true, group: groupName };
      }
    }
    
    // æ£€æŸ¥æ“ä½œé—´æ˜¯å¦æœ‰ä¾èµ–å…³ç³»
    const hasDependency = allOperations.some(otherOp => 
      PARALLEL_EXECUTION_ENFORCER.checkDependency(operation, otherOp)
    );
    
    return { parallel: !hasDependency, group: 'independent' };
  },
  
  // æ£€æŸ¥æ“ä½œä¾èµ–å…³ç³»
  checkDependency: (op1, op2) => {
    // ç®€åŒ–çš„ä¾èµ–æ£€æŸ¥é€»è¾‘
    const dependencyPatterns = [
      // æ–‡ä»¶ä¿®æ”¹åçš„è¯»å–æ“ä½œ
      { prerequisite: 'edit_file', dependent: 'read_file' },
      // æœåŠ¡å¯åŠ¨åçš„çŠ¶æ€æ£€æŸ¥
      { prerequisite: 'start_service', dependent: 'health_check' },
      // è¿›ç¨‹æ¸…ç†åçš„çŠ¶æ€éªŒè¯
      { prerequisite: 'kill_process', dependent: 'process_check' }
    ];
    
    return dependencyPatterns.some(pattern => 
      op1.includes(pattern.prerequisite) && op2.includes(pattern.dependent)
    );
  }
};
```

### å¹¶è¡Œæ‰§è¡Œç›‘æ§å’Œä¼˜åŒ–
```javascript
// åŸºäºå®é™…æ€§èƒ½é—®é¢˜çš„å¹¶è¡Œæ‰§è¡Œç›‘æ§
const PARALLEL_EXECUTION_MONITOR = {
  // ç›‘æ§å¹¶è¡Œæ‰§è¡Œæ•ˆæœ
  monitorParallelExecution: async (parallelOperations) => {
    const startTime = Date.now();
    const results = [];
    
    try {
      // ä½¿ç”¨Promise.allSettledç¡®ä¿æ‰€æœ‰æ“ä½œå®Œæˆ
      const settledResults = await Promise.allSettled(parallelOperations);
      
      settledResults.forEach((result, index) => {
        const operation = parallelOperations[index];
        
        if (result.status === 'fulfilled') {
          results.push({
            operation: operation.name || `Operation ${index}`,
            status: 'SUCCESS',
            result: result.value,
            index
          });
        } else {
          results.push({
            operation: operation.name || `Operation ${index}`,
            status: 'FAILED',
            error: result.reason,
            index
          });
          
          console.error(`âŒ å¹¶è¡Œæ“ä½œå¤±è´¥: ${operation.name}`, result.reason);
        }
      });
      
      const totalTime = Date.now() - startTime;
      const successCount = results.filter(r => r.status === 'SUCCESS').length;
      const failureCount = results.length - successCount;
      
      console.log(`ğŸ“Š å¹¶è¡Œæ‰§è¡Œç»Ÿè®¡:`);
      console.log(`   æ€»æ—¶é—´: ${totalTime}ms`);
      console.log(`   æˆåŠŸ: ${successCount}/${results.length}`);
      console.log(`   å¤±è´¥: ${failureCount}/${results.length}`);
      console.log(`   æˆåŠŸç‡: ${(successCount / results.length * 100).toFixed(1)}%`);
      
      // ğŸ”´ åŸºäºcursoræ–‡æ¡£åˆ†æçš„æ€§èƒ½è¦æ±‚
      const expectedSequentialTime = parallelOperations.length * 2000; // å‡è®¾æ¯ä¸ªæ“ä½œ2ç§’
      const timeImprovement = (expectedSequentialTime - totalTime) / expectedSequentialTime;
      
      if (timeImprovement > 0.5) {
        console.log(`ğŸš€ å¹¶è¡Œä¼˜åŒ–æ•ˆæœæ˜¾è‘—: èŠ‚çœ${(timeImprovement * 100).toFixed(1)}%æ—¶é—´`);
      } else if (timeImprovement > 0.2) {
        console.log(`âœ… å¹¶è¡Œä¼˜åŒ–æœ‰æ•ˆ: èŠ‚çœ${(timeImprovement * 100).toFixed(1)}%æ—¶é—´`);
      } else {
        console.warn(`âš ï¸ å¹¶è¡Œä¼˜åŒ–æ•ˆæœæœ‰é™: ä»…èŠ‚çœ${(timeImprovement * 100).toFixed(1)}%æ—¶é—´`);
      }
      
      return {
        results,
        totalTime,
        successCount,
        failureCount,
        timeImprovement
      };
    } catch (error) {
      console.error('âŒ å¹¶è¡Œæ‰§è¡Œç›‘æ§å¤±è´¥:', error);
      throw error;
    }
  }
};
```

## æ™ºèƒ½é‡è¯•å’Œæ•…éšœè½¬ç§»æœºåˆ¶

### åŸºäºå®é™…å¤±è´¥æ¨¡å¼çš„é‡è¯•ç­–ç•¥
```javascript
// ğŸ”´ åŸºäºcursoræ–‡æ¡£å‘ç°çš„å¤±è´¥æ¨¡å¼ä¼˜åŒ–é‡è¯•ç­–ç•¥
const INTELLIGENT_RETRY_STRATEGY = {
  // å¤±è´¥æ¨¡å¼åˆ†æï¼ˆåŸºäºå®é™…è§‚å¯Ÿï¼‰
  failure_patterns: {
    'network_timeout': {
      pattern: /timeout|ECONNREFUSED|ETIMEDOUT/i,
      retry_count: 3,
      retry_delay: [1000, 2000, 4000], // æŒ‡æ•°é€€é¿
      alternatives: ['local_cache', 'fallback_endpoint']
    },
    
    'permission_denied': {
      pattern: /EACCES|permission denied|403/i,
      retry_count: 1,
      retry_delay: [500],
      alternatives: ['sudo_retry', 'alternative_method']
    },
    
    'resource_busy': {
      pattern: /EBUSY|resource busy|locked/i,
      retry_count: 5,
      retry_delay: [500, 1000, 1500, 2000, 3000],
      alternatives: ['wait_and_retry', 'force_unlock']
    },
    
    'service_unavailable': {
      pattern: /503|service unavailable|connection refused/i,
      retry_count: 3,
      retry_delay: [2000, 5000, 10000],
      alternatives: ['restart_service', 'health_check']
    }
  },
  
  // æ™ºèƒ½é‡è¯•æ‰§è¡Œ
  intelligentRetry: async (operation, context = {}) => {
    let lastError = null;
    let retryCount = 0;
    const maxRetries = 3; // é»˜è®¤æœ€å¤§é‡è¯•æ¬¡æ•°
    
    for (let attempt = 0; attempt <= maxRetries; attempt++) {
      try {
        if (attempt > 0) {
          console.log(`ğŸ”„ é‡è¯•ç¬¬${attempt}æ¬¡: ${operation.name || 'unnamed operation'}`);
        }
        
        const result = await operation.execute(context);
        
        if (attempt > 0) {
          console.log(`âœ… é‡è¯•æˆåŠŸ: ${operation.name} (ç¬¬${attempt}æ¬¡é‡è¯•)`);
        }
        
        return result;
      } catch (error) {
        lastError = error;
        retryCount = attempt + 1;
        
        // åˆ†æå¤±è´¥æ¨¡å¼
        const failurePattern = INTELLIGENT_RETRY_STRATEGY.analyzeFailure(error);
        
        if (failurePattern) {
          console.log(`ğŸ” è¯†åˆ«å¤±è´¥æ¨¡å¼: ${failurePattern.name}`);
          
          // æ£€æŸ¥æ˜¯å¦è¿˜æœ‰é‡è¯•æœºä¼š
          if (attempt < failurePattern.retry_count && attempt < maxRetries) {
            const delay = failurePattern.retry_delay[attempt] || failurePattern.retry_delay[failurePattern.retry_delay.length - 1];
            
            console.log(`â° ç­‰å¾…${delay}msåé‡è¯•...`);
            await new Promise(resolve => setTimeout(resolve, delay));
            continue;
          } else {
            console.log(`ğŸ”„ å°è¯•æ›¿ä»£æ–¹æ¡ˆ: ${failurePattern.alternatives.join(', ')}`);
            
            // å°è¯•æ›¿ä»£æ–¹æ¡ˆ
            for (const alternative of failurePattern.alternatives) {
              try {
                const altResult = await INTELLIGENT_RETRY_STRATEGY.tryAlternative(alternative, operation, context);
                console.log(`âœ… æ›¿ä»£æ–¹æ¡ˆæˆåŠŸ: ${alternative}`);
                return altResult;
              } catch (altError) {
                console.warn(`âš ï¸ æ›¿ä»£æ–¹æ¡ˆå¤±è´¥: ${alternative}`, altError.message);
              }
            }
          }
        } else {
          // æœªè¯†åˆ«çš„å¤±è´¥æ¨¡å¼ï¼Œä½¿ç”¨é»˜è®¤é‡è¯•ç­–ç•¥
          if (attempt < maxRetries) {
            const delay = Math.min(1000 * Math.pow(2, attempt), 10000); // æŒ‡æ•°é€€é¿ï¼Œæœ€å¤§10ç§’
            console.log(`â° é»˜è®¤é‡è¯•ç­–ç•¥ï¼Œç­‰å¾…${delay}ms...`);
            await new Promise(resolve => setTimeout(resolve, delay));
            continue;
          }
        }
        
        // æ‰€æœ‰é‡è¯•å’Œæ›¿ä»£æ–¹æ¡ˆéƒ½å¤±è´¥
        break;
      }
    }
    
    console.error(`âŒ æ“ä½œæœ€ç»ˆå¤±è´¥: ${operation.name} (é‡è¯•${retryCount}æ¬¡)`);
    throw new Error(`æ“ä½œå¤±è´¥ï¼Œå·²é‡è¯•${retryCount}æ¬¡: ${lastError.message}`);
  },
  
  // åˆ†æå¤±è´¥æ¨¡å¼
  analyzeFailure: (error) => {
    const errorMessage = error.message || error.toString();
    
    for (const [patternName, pattern] of Object.entries(INTELLIGENT_RETRY_STRATEGY.failure_patterns)) {
      if (pattern.pattern.test(errorMessage)) {
        return { name: patternName, ...pattern };
      }
    }
    
    return null;
  },
  
  // å°è¯•æ›¿ä»£æ–¹æ¡ˆ
  tryAlternative: async (alternative, originalOperation, context) => {
    // æ›¿ä»£æ–¹æ¡ˆå®ç°é€»è¾‘
    switch (alternative) {
      case 'local_cache':
        return await INTELLIGENT_RETRY_STRATEGY.tryLocalCache(originalOperation, context);
      
      case 'fallback_endpoint':
        return await INTELLIGENT_RETRY_STRATEGY.tryFallbackEndpoint(originalOperation, context);
      
      case 'restart_service':
        await INTELLIGENT_RETRY_STRATEGY.restartService(context);
        return await originalOperation.execute(context);
      
      default:
        throw new Error(`æœªå®ç°çš„æ›¿ä»£æ–¹æ¡ˆ: ${alternative}`);
    }
  }
};
```

## å·¥å…·è°ƒç”¨æ•ˆç‡ç›‘æ§å’ŒæŠ¥å‘Š

### å®æ—¶æ•ˆç‡ç›‘æ§ä»ªè¡¨æ¿
```javascript
// åŸºäºå®é™…æ•ˆç‡é—®é¢˜çš„ç›‘æ§ä»ªè¡¨æ¿
const TOOL_EFFICIENCY_MONITOR = {
  // å®æ—¶ç»Ÿè®¡æ•°æ®
  stats: {
    totalCalls: 0,
    successfulCalls: 0,
    failedCalls: 0,
    cachedCalls: 0,
    parallelCalls: 0,
    totalTime: 0,
    averageTime: 0,
    efficiency: 0
  },
  
  // è®°å½•å·¥å…·è°ƒç”¨
  recordToolCall: (toolType, duration, success, cached = false, parallel = false) => {
    const stats = TOOL_EFFICIENCY_MONITOR.stats;
    
    stats.totalCalls++;
    stats.totalTime += duration;
    stats.averageTime = stats.totalTime / stats.totalCalls;
    
    if (success) {
      stats.successfulCalls++;
    } else {
      stats.failedCalls++;
    }
    
    if (cached) {
      stats.cachedCalls++;
    }
    
    if (parallel) {
      stats.parallelCalls++;
    }
    
    // è®¡ç®—æ•ˆç‡æŒ‡æ ‡
    stats.efficiency = (stats.successfulCalls / stats.totalCalls) * 
                      (stats.cachedCalls / stats.totalCalls * 0.3 + 0.7) *
                      (stats.parallelCalls / stats.totalCalls * 0.2 + 0.8);
    
    // ğŸ”´ åŸºäºcursoræ–‡æ¡£åˆ†æçš„æ•ˆç‡é˜ˆå€¼
    if (stats.totalCalls % 10 === 0) { // æ¯10æ¬¡è°ƒç”¨æŠ¥å‘Šä¸€æ¬¡
      TOOL_EFFICIENCY_MONITOR.generateEfficiencyReport();
    }
  },
  
  // ç”Ÿæˆæ•ˆç‡æŠ¥å‘Š
  generateEfficiencyReport: () => {
    const stats = TOOL_EFFICIENCY_MONITOR.stats;
    
    console.log('\nğŸ“Š å·¥å…·è°ƒç”¨æ•ˆç‡æŠ¥å‘Š');
    console.log('='.repeat(40));
    console.log(`æ€»è°ƒç”¨æ¬¡æ•°: ${stats.totalCalls}`);
    console.log(`æˆåŠŸè°ƒç”¨: ${stats.successfulCalls} (${(stats.successfulCalls/stats.totalCalls*100).toFixed(1)}%)`);
    console.log(`ç¼“å­˜å‘½ä¸­: ${stats.cachedCalls} (${(stats.cachedCalls/stats.totalCalls*100).toFixed(1)}%)`);
    console.log(`å¹¶è¡Œæ‰§è¡Œ: ${stats.parallelCalls} (${(stats.parallelCalls/stats.totalCalls*100).toFixed(1)}%)`);
    console.log(`å¹³å‡è€—æ—¶: ${stats.averageTime.toFixed(0)}ms`);
    console.log(`ç»¼åˆæ•ˆç‡: ${(stats.efficiency*100).toFixed(1)}%`);
    
    // ğŸ”´ åŸºäºå®é™…é—®é¢˜çš„æ•ˆç‡è¯„çº§
    let grade = 'F';
    let recommendation = '';
    
    if (stats.efficiency >= 0.9) {
      grade = 'A';
      recommendation = 'æ•ˆç‡ä¼˜ç§€ï¼Œç»§ç»­ä¿æŒ';
    } else if (stats.efficiency >= 0.8) {
      grade = 'B';
      recommendation = 'æ•ˆç‡è‰¯å¥½ï¼Œå¯è¿›ä¸€æ­¥ä¼˜åŒ–å¹¶è¡ŒåŒ–';
    } else if (stats.efficiency >= 0.7) {
      grade = 'C';
      recommendation = 'æ•ˆç‡ä¸€èˆ¬ï¼Œå»ºè®®å¢åŠ ç¼“å­˜ä½¿ç”¨';
    } else if (stats.efficiency >= 0.6) {
      grade = 'D';
      recommendation = 'æ•ˆç‡è¾ƒä½ï¼Œéœ€è¦å‡å°‘é‡å¤è°ƒç”¨';
    } else {
      grade = 'F';
      recommendation = 'æ•ˆç‡ä¸¥é‡ä¸è¶³ï¼Œéœ€è¦å…¨é¢ä¼˜åŒ–';
    }
    
    console.log(`æ•ˆç‡è¯„çº§: ${grade}`);
    console.log(`ä¼˜åŒ–å»ºè®®: ${recommendation}`);
    console.log('='.repeat(40));
  },
  
  // åŸºäºcursoræ–‡æ¡£é—®é¢˜çš„å¯¹æ¯”åˆ†æ
  compareWithBaseline: () => {
    const stats = TOOL_EFFICIENCY_MONITOR.stats;
    
    // åŸºäºå®é™…cursoræ–‡æ¡£ç»Ÿè®¡çš„åŸºå‡†æ•°æ®
    const baseline = {
      cursor_8: { calls: 200, time: 4800000, efficiency: 0.1 },  // 80åˆ†é’Ÿï¼Œ10%æ•ˆç‡
      cursor_5: { calls: 140, time: 5400000, efficiency: 0.28 }, // 90åˆ†é’Ÿï¼Œ28%æ•ˆç‡
      cursor_3: { calls: 180, time: 4200000, efficiency: 0.25 }  // 70åˆ†é’Ÿï¼Œ25%æ•ˆç‡
    };
    
    const avgBaseline = {
      calls: Object.values(baseline).reduce((sum, b) => sum + b.calls, 0) / Object.keys(baseline).length,
      time: Object.values(baseline).reduce((sum, b) => sum + b.time, 0) / Object.keys(baseline).length,
      efficiency: Object.values(baseline).reduce((sum, b) => sum + b.efficiency, 0) / Object.keys(baseline).length
    };
    
    const improvement = {
      calls: (avgBaseline.calls - stats.totalCalls) / avgBaseline.calls,
      time: (avgBaseline.time - stats.totalTime) / avgBaseline.time,
      efficiency: (stats.efficiency - avgBaseline.efficiency) / avgBaseline.efficiency
    };
    
    console.log('\nğŸ“ˆ ä¸åŸºå‡†å¯¹æ¯”åˆ†æ');
    console.log('='.repeat(40));
    console.log(`è°ƒç”¨æ¬¡æ•°æ”¹è¿›: ${(improvement.calls * 100).toFixed(1)}%`);
    console.log(`æ—¶é—´æ¶ˆè€—æ”¹è¿›: ${(improvement.time * 100).toFixed(1)}%`);
    console.log(`æ•ˆç‡æå‡: ${(improvement.efficiency * 100).toFixed(1)}%`);
    
    if (improvement.efficiency > 2) {
      console.log('ğŸš€ æ•ˆç‡æ”¹è¿›æ˜¾è‘—ï¼Œè¶…è¿‡åŸºå‡†200%');
    } else if (improvement.efficiency > 1) {
      console.log('âœ… æ•ˆç‡æ”¹è¿›è‰¯å¥½ï¼Œè¶…è¿‡åŸºå‡†100%');
    } else if (improvement.efficiency > 0) {
      console.log('ğŸ“ˆ æ•ˆç‡æœ‰æ‰€æ”¹è¿›ï¼Œä½†ä»æœ‰ä¼˜åŒ–ç©ºé—´');
    } else {
      console.log('âš ï¸ æ•ˆç‡ä½äºåŸºå‡†ï¼Œéœ€è¦é‡ç‚¹ä¼˜åŒ–');
    }
  }
};
```

---

**æ ¸å¿ƒåŸåˆ™**: å¼ºåˆ¶ç¼“å­˜å¤ç”¨ã€é‡å¤æ£€æŸ¥æ‹¦æˆªã€å¹¶è¡Œä¼˜åŒ–æœ€å¤§åŒ–ã€æ™ºèƒ½é‡è¯•ç­–ç•¥ã€å®æ—¶æ•ˆç‡ç›‘æ§
