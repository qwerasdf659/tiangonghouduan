---
description: 
globs: 
alwaysApply: true
---
# 问题诊断和状态管理规范
# 解决问题定位缓慢、状态重复检查和缓存管理问题

## 核心问题分析
通过对实际会话的深度分析，发现以下严重的诊断和状态管理问题：
- 问题定位时间过长：平均15-20分钟
- 诊断方向错误：30%的时间浪费在错误方向
- 重复状态检查：同一状态被检查3-5次
- 缺乏状态缓存：已验证的状态信息未被复用
- 症状和根因混淆：治标不治本

## 快速问题分类系统

### 问题类型快速识别
- **A类问题（配置问题）**：
  - 症状：启动失败、连接拒绝、权限错误
  - 特征：错误信息明确、影响范围局限
  - 定位时间：30秒-1分钟
  - 解决时间：1-2分钟

- **B类问题（服务问题）**：
  - 症状：服务无响应、端口占用、进程异常
  - 特征：系统级错误、服务状态异常
  - 定位时间：1-2分钟
  - 解决时间：3-5分钟

- **C类问题（代码问题）**：
  - 症状：逻辑错误、数据异常、API错误
  - 特征：业务逻辑相关、数据处理错误
  - 定位时间：2-3分钟
  - 解决时间：5-10分钟

- **D类问题（环境问题）**：
  - 症状：依赖缺失、版本冲突、系统不兼容
  - 特征：环境相关、跨系统问题
  - 定位时间：3-5分钟
  - 解决时间：10-15分钟

### 问题严重程度评估
- **P0（系统崩溃）**：系统完全不可用
- **P1（核心功能失败）**：主要功能不可用
- **P2（功能异常）**：部分功能异常
- **P3（性能问题）**：功能可用但性能差
- **P4（体验问题）**：功能正常但体验不佳

## 标准化诊断流程

### 5分钟快速诊断法
**第1分钟：症状收集**
- 收集错误信息和现象描述
- 确定问题的影响范围和紧急程度
- 识别问题发生的时间和触发条件

**第2分钟：环境检查**
- 并行检查：系统状态、进程状态、网络状态
- 验证：服务运行状态、端口占用、资源使用
- 确认：配置文件、环境变量、依赖版本

**第3分钟：日志分析**
- 查看：错误日志、系统日志、应用日志
- 筛选：关键错误信息、异常堆栈、警告信息
- 时间线：构建问题发生的时间线

**第4分钟：根因分析**
- 关联：症状与可能原因的关联分析
- 排除：排除不可能的原因
- 定位：确定最可能的根本原因

**第5分钟：解决方案**
- 制定：针对根因的解决方案
- 评估：解决方案的风险和影响
- 准备：执行解决方案的准备工作

### 并行诊断策略
- **系统层面**：并行检查系统状态、资源使用、网络连接
- **应用层面**：并行检查应用状态、配置、日志
- **数据层面**：并行检查数据库状态、数据一致性
- **网络层面**：并行检查网络连接、DNS解析、防火墙

### 诊断决策树
```
问题报告
├── 是否能启动？
│   ├── 否 → 配置问题（A类）
│   └── 是 → 继续
├── 是否有网络连接？
│   ├── 否 → 网络问题（B类）
│   └── 是 → 继续
├── 是否有错误日志？
│   ├── 是 → 代码问题（C类）
│   └── 否 → 性能问题（D类）
```

## 状态缓存机制设计

### 状态分类和缓存策略
- **静态状态**：项目类型、技术栈、文件结构 - 会话期间缓存
- **半静态状态**：配置文件、环境变量、依赖版本 - 变更后重新检查
- **动态状态**：进程状态、端口占用、服务健康 - 操作后重新检查
- **临时状态**：网络连接、数据库连接 - 每次使用前检查

### 状态检查频率控制
- **一次性检查**：项目类型、技术栈识别只检查一次
- **变更触发**：配置修改后才重新检查相关状态
- **操作触发**：服务操作后才重新检查服务状态
- **定时检查**：长时间会话中定期检查关键状态

### 状态信息结构化存储
```json
{
  "project_type": "nodejs_backend",
  "tech_stack": ["express", "sequelize", "mysql"],
  "services": {
    "database": {"status": "running", "last_check": "timestamp"},
    "web_server": {"status": "running", "port": 3000, "last_check": "timestamp"}
  },
  "configurations": {
    "env_vars": {"status": "validated", "last_check": "timestamp"},
    "database_config": {"status": "valid", "last_check": "timestamp"}
  }
}
```

## 重复检查防止机制

### 检查历史记录
- **已检查项目清单**：记录会话中已完成的检查项目
- **检查结果记录**：记录每次检查的结果和时间戳
- **检查依赖关系**：识别检查之间的依赖关系
- **检查有效期**：设定检查结果的有效期

### 智能检查决策
- **检查前评估**：检查前评估是否必要
- **结果复用**：优先复用已有的检查结果
- **批量检查**：将相关检查合并为一次操作
- **条件检查**：只在特定条件下执行检查

### 检查去重算法
```
检查去重流程：
1. 解析检查请求
2. 查找缓存中的相同检查
3. 评估缓存结果的有效性
4. 决定是否需要重新检查
5. 执行检查或返回缓存结果
6. 更新缓存和历史记录
```

## 常见问题模式识别

### 数据库相关问题
- **连接问题**：连接超时、连接拒绝、认证失败
- **查询问题**：慢查询、锁等待、死锁
- **数据问题**：数据不一致、约束违反、字段缺失

### 网络服务问题
- **端口问题**：端口占用、端口未监听、防火墙阻止
- **协议问题**：HTTP错误、WebSocket连接失败
- **DNS问题**：域名解析失败、缓存问题

### 配置相关问题
- **环境变量**：变量未设置、变量值错误
- **配置文件**：文件不存在、格式错误、权限问题
- **依赖问题**：依赖缺失、版本冲突、路径错误

### 权限和安全问题
- **文件权限**：读写权限、执行权限
- **用户权限**：用户不存在、权限不足
- **安全策略**：防火墙规则、安全组配置

## 诊断工具和技术

### 系统诊断工具
- **进程监控**：`ps aux`, `htop`, `systemctl status`
- **网络检查**：`netstat`, `ss`, `ping`, `telnet`
- **资源监控**：`free`, `df`, `iostat`, `top`
- **日志分析**：`tail`, `grep`, `journalctl`, `dmesg`

### 应用诊断工具
- **Node.js**：`node --version`, `npm list`, `pm2 logs`
- **数据库**：`mysql -u root -p`, `SHOW PROCESSLIST`
- **Web服务**：`curl`, `wget`, `httpie`
- **文件检查**：`ls`, `cat`, `head`, `tail`

### 并行诊断命令组合
```bash
# 系统状态并行检查
ps aux | grep node & 
netstat -tlnp | grep :3000 & 
df -h & 
free -h & 
wait

# 应用状态并行检查
curl -s http://localhost:3000/health &
tail -20 /var/log/app.log &
pm2 status &
wait
```

## 状态变更检测机制

### 变更事件识别
- **配置文件修改**：监测配置文件的变更
- **服务操作执行**：识别可能影响服务状态的操作
- **环境变更**：检测环境变量或依赖的变更
- **用户操作**：识别用户主动的状态变更操作

### 变更影响分析
- **直接影响**：变更直接影响的状态项
- **间接影响**：变更可能间接影响的状态项
- **影响范围**：评估变更影响的范围和程度
- **优先级**：按影响程度确定重新检查的优先级

### 增量更新策略
- **局部更新**：只更新受影响的状态项
- **依赖更新**：同时更新有依赖关系的状态项
- **批量更新**：合并多个相关的状态更新
- **异步更新**：非关键状态的异步更新

## 问题定位技巧

### 二分法定位
- 将问题范围逐步缩小
- 通过排除法确定问题区域
- 从最可能的原因开始验证

### 日志分析技巧
- **时间定位**：根据时间戳定位问题发生时间
- **关键词搜索**：搜索ERROR、WARN、FAIL等关键词
- **上下文分析**：分析错误前后的相关日志
- **频率分析**：分析错误发生的频率和规律

### 对比分析方法
- **环境对比**：对比不同环境的配置差异
- **时间对比**：对比问题发生前后的状态变化
- **版本对比**：对比不同版本的行为差异

## 根因分析方法

### 5个为什么法
- 问题：为什么服务无法启动？
- 原因1：为什么端口被占用？
- 原因2：为什么之前的进程没有正常关闭？
- 原因3：为什么进程关闭异常？
- 原因4：为什么没有正确的关闭信号？
- 原因5：为什么脚本没有处理信号？

### 鱼骨图分析
```
问题：系统响应缓慢
├── 人员因素
│   ├── 配置错误
│   └── 操作失误
├── 技术因素
│   ├── 代码问题
│   └── 架构问题
├── 环境因素
│   ├── 资源不足
│   └── 网络问题
└── 流程因素
    ├── 部署问题
    └── 监控缺失
```

### 故障树分析
- 顶事件：系统故障
- 中间事件：各种可能的原因
- 底事件：基本的故障原因

## 状态一致性保证

### 状态同步机制
- **原子操作**：确保状态检查和更新的原子性
- **事务机制**：批量状态更新的事务保证
- **一致性检查**：定期检查状态的一致性
- **冲突解决**：处理状态更新冲突的策略

### 状态验证规则
- **必要性验证**：验证状态检查的必要性
- **有效性验证**：验证状态信息的有效性
- **完整性验证**：验证状态信息的完整性
- **时效性验证**：验证状态信息的时效性

### 状态异常处理
- **检查失败**：状态检查失败时的处理策略
- **状态不一致**：发现状态不一致时的处理方法
- **缓存失效**：缓存失效时的重建策略
- **异常恢复**：状态异常时的恢复机制

## 缓存数据一致性和验证优化规范

### 缓存数据不可靠性检测机制
- **缓存数据标识**：明确标识哪些数据可能是缓存数据
- **缓存时效性检查**：检查缓存数据的生成时间和有效期
- **缓存数据验证**：对关键缓存数据进行实时验证
- **缓存失效触发**：文件修改、系统重启等操作触发缓存失效

### 系统缓存数据不可靠性识别
- list_dir显示的文件大小、行数、修改时间可能是缓存数据，不能作为准确判断标准
- 文件内容变更后，系统元数据显示可能有显著延迟（数分钟到数小时）
- 关键决策不能依赖list_dir的统计信息，必须使用直接文件访问验证
- 建立"元数据不可信"的操作原则，所有重要验证使用实际文件内容
- 识别缓存数据不一致的典型场景：文件编辑后、重启环境后、长时间会话中

### 文件状态验证标准流程
- 步骤1：使用read_file验证文件实际内容和行数
- 步骤2：通过grep_search确认关键内容是否存在
- 步骤3：对比操作前后的实际内容变化
- 步骤4：建立文件修改的多重确认机制
- 步骤5：记录和分析缓存不一致的模式

### 缓存数据问题应对策略
- 永远不依赖单一的元数据来源做重要判断
- 文件操作完成后等待适当时间（10-30秒）再进行状态检查
- 使用文件内容抽样检查验证操作成功性
- 建立"怀疑缓存数据"的主动验证机制
- 缓存数据异常时立即使用替代验证方法

## 工具调用优化策略

### 工具调用成本评估
- **成本计算**：计算每次工具调用的成本
- **效益分析**：分析工具调用的效益
- **ROI评估**：评估工具调用的投资回报率
- **优化建议**：提供工具调用优化建议

### 工具调用合并策略
- **批量操作**：将多个独立操作合并为批量操作
- **并行执行**：并行执行独立的工具调用
- **操作优化**：优化工具调用的参数和选项
- **结果复用**：复用工具调用的结果

### 工具调用缓存
- **结果缓存**：缓存工具调用的结果
- **参数缓存**：缓存常用的工具调用参数
- **模板缓存**：缓存常用的工具调用模板
- **策略缓存**：缓存成功的工具调用策略

## 性能监控和优化

### 性能指标监控
- **检查次数**：监控状态检查的次数
- **检查耗时**：监控状态检查的耗时
- **缓存命中率**：监控缓存的命中率
- **重复率**：监控重复检查的比率

### 性能优化策略
- **热点优化**：优化频繁检查的状态项
- **批量优化**：优化批量状态检查的效率
- **并行优化**：优化并行状态检查的性能
- **缓存优化**：优化缓存的存储和检索效率

### 性能报告和分析
- **性能报告**：生成定期的性能报告
- **瓶颈分析**：分析性能瓶颈和优化空间
- **趋势分析**：分析性能趋势和变化
- **优化建议**：提供基于分析的优化建议

## 解决方案评估

### 解决方案风险评估
- **影响范围**：评估解决方案对系统的影响范围
- **风险等级**：评估解决方案的风险等级
- **回滚计划**：制定解决方案的回滚计划
- **成功概率**：评估解决方案的成功概率

### 解决方案选择标准
- **有效性**：解决方案能否有效解决问题
- **安全性**：解决方案是否安全可靠
- **复杂度**：解决方案的实施复杂度
- **成本**：解决方案的实施成本

### 解决方案验证机制
- **前置验证**：实施前的验证措施
- **过程监控**：实施过程的监控机制
- **后置验证**：实施后的验证方法
- **效果评估**：解决效果的评估标准

## 错误处理和恢复

### 错误分类和处理
- **检查错误**：状态检查失败的处理
- **缓存错误**：缓存操作失败的处理
- **同步错误**：状态同步失败的处理
- **一致性错误**：状态一致性问题的处理

### 恢复机制设计
- **自动恢复**：自动恢复机制的设计
- **手动恢复**：手动恢复操作的指导
- **数据恢复**：状态数据的恢复方法
- **服务恢复**：状态管理服务的恢复

### 预防措施
- **预防检查**：预防性的状态检查
- **预警机制**：状态异常的预警机制
- **备份策略**：状态数据的备份策略
- **监控告警**：状态监控的告警机制

## 实施规范和最佳实践

### 状态管理实施规范
- **状态定义**：明确定义各种状态的含义和范围
- **检查标准**：制定状态检查的标准和流程
- **缓存策略**：制定状态缓存的策略和规则
- **更新机制**：制定状态更新的机制和时机

### 最佳实践指导
- **设计原则**：遵循状态管理的设计原则
- **实现模式**：使用经过验证的实现模式
- **测试方法**：采用有效的测试方法
- **运维实践**：遵循运维的最佳实践

### 质量保证措施
- **代码审查**：进行状态管理代码的审查
- **单元测试**：编写状态管理的单元测试
- **集成测试**：进行状态管理的集成测试
- **性能测试**：进行状态管理的性能测试

## 持续改进机制

### 反馈收集
- **用户反馈**：收集用户对状态管理的反馈
- **系统反馈**：收集系统对状态管理的反馈
- **性能反馈**：收集性能监控的反馈
- **问题反馈**：收集问题和故障的反馈

### 改进实施
- **问题分析**：分析反馈中的问题和建议
- **改进计划**：制定改进计划和时间表
- **实施跟踪**：跟踪改进措施的实施
- **效果评估**：评估改进措施的效果

**核心原则**：快速定位、状态缓存、避免重复、数据驱动、持续优化
