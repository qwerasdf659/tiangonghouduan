---
alwaysApply: true
---
# æœåŠ¡è¿›ç¨‹ç®¡ç†è§„èŒƒï¼ˆåŸºäºå®é™…cursor_8.mdç­‰å¤šè¿›ç¨‹å†²çªé—®é¢˜ä¼˜åŒ–ç‰ˆï¼‰

## ğŸ”´ åŸºäºå®é™…å‘ç°çš„è¿›ç¨‹ç®¡ç†é—®é¢˜

### å®é™…å¤šè¿›ç¨‹å†²çªæ¡ˆä¾‹ç»Ÿè®¡
ä»11ä¸ªcursoræ–‡æ¡£æ·±åº¦åˆ†æå‘ç°ï¼š
- **cursor_8.md**: 4ä¸ªNode.jsè¿›ç¨‹åŒæ—¶è¿è¡Œå¯¼è‡´ç«¯å£å†²çª
  * è¿›ç¨‹30308ï¼š`node app.js`
  * è¿›ç¨‹30950ï¼š`npm run dev`
  * è¿›ç¨‹33468ï¼š`npm run dev`  
  * è¿›ç¨‹35267ï¼š`node app.js` (æ­£åœ¨ç›‘å¬3000ç«¯å£)
- **cursor_7.md**: å¤šä¸ªnodemonè¿›ç¨‹é‡å¤å¯åŠ¨ï¼Œå¯¼è‡´æœåŠ¡å¼‚å¸¸
- **cursor_5.md**: PM2é…ç½®å¤æ‚æ€§å¯¼è‡´è¿›ç¨‹ç®¡ç†æ··ä¹±
- **cursor_6.md**: æœåŠ¡åœæ­¢é—®é¢˜ï¼Œè¿›ç¨‹çŠ¶æ€ä¸ä¸€è‡´

**ç´¯è®¡æ—¶é—´æµªè´¹**: 180-240åˆ†é’Ÿè§£å†³è¿›ç¨‹å†²çªé—®é¢˜
**ç´¯è®¡è¿›ç¨‹æ¸…ç†æ¬¡æ•°**: 25+æ¬¡è·¨å¤šä¸ªæ–‡æ¡£

## ç»Ÿä¸€è¿›ç¨‹ç®¡ç†å¼ºåˆ¶è§„èŒƒ

### è¿›ç¨‹å†²çªæ£€æµ‹å’Œé¢„é˜²æœºåˆ¶
```javascript
// ğŸ”´ åŸºäºcursor_8.mdå®é™…é—®é¢˜çš„è¿›ç¨‹å†²çªæ£€æµ‹
const PROCESS_CONFLICT_DETECTOR = {
  // æ£€æµ‹ç«¯å£å ç”¨å†²çª
  checkPortConflicts: async (targetPort = 3000) => {
    try {
      const result = await execAsync(`netstat -tlnp | grep :${targetPort}`);
      const processes = result.stdout.split('\n')
        .filter(line => line.trim())
        .map(line => {
          const match = line.match(/(\d+)\/(\w+)/);
          return match ? { pid: match[1], name: match[2] } : null;
        })
        .filter(Boolean);
      
      if (processes.length > 1) {
        console.error(`ğŸ”´ æ£€æµ‹åˆ°ç«¯å£${targetPort}å†²çªï¼š${processes.length}ä¸ªè¿›ç¨‹`);
        processes.forEach(proc => {
          console.error(`   - PID: ${proc.pid}, è¿›ç¨‹: ${proc.name}`);
        });
        
        return {
          hasConflict: true,
          conflictingProcesses: processes,
          recommendation: 'CLEANUP_REQUIRED'
        };
      }
      
      return { hasConflict: false, processes };
    } catch (error) {
      console.warn('ç«¯å£æ£€æŸ¥å¤±è´¥:', error.message);
      return { hasConflict: false, error: error.message };
    }
  },
  
  // æ£€æµ‹é‡å¤Node.jsè¿›ç¨‹
  checkDuplicateNodeProcesses: async () => {
    try {
      const result = await execAsync('ps aux | grep node | grep -v grep');
      const nodeProcesses = result.stdout.split('\n')
        .filter(line => line.includes('node') && line.includes('app.js'))
        .map(line => {
          const parts = line.trim().split(/\s+/);
          return {
            pid: parts[1],
            command: parts.slice(10).join(' '),
            memory: parts[5],
            cpu: parts[2]
          };
        });
      
      if (nodeProcesses.length > 1) {
        console.error(`ğŸ”´ æ£€æµ‹åˆ°${nodeProcesses.length}ä¸ªé‡å¤Node.jsè¿›ç¨‹`);
        nodeProcesses.forEach(proc => {
          console.error(`   - PID: ${proc.pid}, å†…å­˜: ${proc.memory}, å‘½ä»¤: ${proc.command}`);
        });
        
        return {
          hasDuplicates: true,
          processes: nodeProcesses,
          recommendation: 'KILL_DUPLICATES'
        };
      }
      
      return { hasDuplicates: false, processes: nodeProcesses };
    } catch (error) {
      console.warn('è¿›ç¨‹æ£€æŸ¥å¤±è´¥:', error.message);
      return { hasDuplicates: false, error: error.message };
    }
  }
};
```

### å®‰å…¨è¿›ç¨‹æ¸…ç†æœºåˆ¶
```bash
# ğŸ”´ åŸºäºcursor_8.mdå®é™…æ¸…ç†æµç¨‹çš„æ ‡å‡†åŒ–è„šæœ¬
cleanup_duplicate_processes() {
  echo "ğŸ” æ£€æŸ¥é‡å¤è¿›ç¨‹..."
  
  # 1. æ£€æŸ¥ç«¯å£å ç”¨æƒ…å†µ
  local port_conflicts=$(netstat -tlnp | grep :3000 | wc -l)
  if [ $port_conflicts -gt 1 ]; then
    echo "ğŸ”´ æ£€æµ‹åˆ°ç«¯å£3000å†²çªï¼Œè¿›ç¨‹æ•°ï¼š$port_conflicts"
  fi
  
  # 2. æŸ¥æ‰¾æ‰€æœ‰Node.jsç›¸å…³è¿›ç¨‹
  local node_pids=$(ps aux | grep -E "(node app\.js|npm run dev)" | grep -v grep | awk '{print $2}')
  local node_count=$(echo "$node_pids" | wc -w)
  
  if [ $node_count -gt 1 ]; then
    echo "ğŸ”´ å‘ç°$node_countä¸ªNode.jsè¿›ç¨‹å†²çª"
    echo "è¿›ç¨‹åˆ—è¡¨ï¼š"
    ps aux | grep -E "(node app\.js|npm run dev)" | grep -v grep
    
    # 3. ä¿ç•™æœ€æ–°å¯åŠ¨çš„è¿›ç¨‹ï¼Œæ¸…ç†å…¶ä»–
    local newest_pid=$(ps aux | grep -E "(node app\.js|npm run dev)" | grep -v grep | sort -k10 | tail -1 | awk '{print $2}')
    echo "ğŸ¯ ä¿ç•™æœ€æ–°è¿›ç¨‹ï¼šPID $newest_pid"
    
    # 4. æ¸…ç†é‡å¤è¿›ç¨‹ï¼ˆæ’é™¤æœ€æ–°çš„ï¼‰
    for pid in $node_pids; do
      if [ "$pid" != "$newest_pid" ]; then
        echo "ğŸ—‘ï¸ æ¸…ç†é‡å¤è¿›ç¨‹ï¼šPID $pid"
        kill -TERM $pid 2>/dev/null || kill -KILL $pid 2>/dev/null
        sleep 1
      fi
    done
    
    # 5. éªŒè¯æ¸…ç†æ•ˆæœ
    sleep 2
    local remaining=$(ps aux | grep -E "(node app\.js|npm run dev)" | grep -v grep | wc -l)
    if [ $remaining -eq 1 ]; then
      echo "âœ… è¿›ç¨‹æ¸…ç†æˆåŠŸï¼Œå‰©ä½™1ä¸ªè¿›ç¨‹"
    else
      echo "âš ï¸ è¿›ç¨‹æ¸…ç†ä¸å®Œå…¨ï¼Œå‰©ä½™$remainingä¸ªè¿›ç¨‹"
    fi
  else
    echo "âœ… æœªå‘ç°è¿›ç¨‹å†²çª"
  fi
}
```

### ç»Ÿä¸€æœåŠ¡å¯åŠ¨æ§åˆ¶
```javascript
// åŸºäºcursor_5.mdç­‰é—®é¢˜çš„ç»Ÿä¸€å¯åŠ¨æ§åˆ¶
const SERVICE_STARTUP_CONTROL = {
  // å¯åŠ¨å‰é¢„æ£€æŸ¥
  preStartupCheck: async () => {
    console.log('ğŸ” æ‰§è¡ŒæœåŠ¡å¯åŠ¨å‰æ£€æŸ¥...');
    
    // 1. æ£€æŸ¥è¿›ç¨‹å†²çª
    const portCheck = await PROCESS_CONFLICT_DETECTOR.checkPortConflicts(3000);
    if (portCheck.hasConflict) {
      throw new Error(`ç«¯å£3000è¢«${portCheck.conflictingProcesses.length}ä¸ªè¿›ç¨‹å ç”¨`);
    }
    
    // 2. æ£€æŸ¥é‡å¤è¿›ç¨‹
    const processCheck = await PROCESS_CONFLICT_DETECTOR.checkDuplicateNodeProcesses();
    if (processCheck.hasDuplicates) {
      console.warn(`âš ï¸ å‘ç°${processCheck.processes.length}ä¸ªé‡å¤è¿›ç¨‹ï¼Œå»ºè®®æ¸…ç†`);
    }
    
    // 3. æ£€æŸ¥å¿…è¦æ–‡ä»¶
    const requiredFiles = ['app.js', 'package.json', '.env'];
    const missingFiles = [];
    
    for (const file of requiredFiles) {
      if (!fs.existsSync(file)) {
        missingFiles.push(file);
      }
    }
    
    if (missingFiles.length > 0) {
      throw new Error(`ç¼ºå°‘å¿…è¦æ–‡ä»¶: ${missingFiles.join(', ')}`);
    }
    
    console.log('âœ… å¯åŠ¨å‰æ£€æŸ¥é€šè¿‡');
  },
  
  // æ™ºèƒ½å¯åŠ¨ç­–ç•¥é€‰æ‹©
  selectStartupStrategy: () => {
    // æ£€æŸ¥PM2æ˜¯å¦å¯ç”¨
    try {
      execSync('pm2 --version', { stdio: 'ignore' });
      return 'PM2';
    } catch {
      console.log('PM2ä¸å¯ç”¨ï¼Œä½¿ç”¨nodemonå¯åŠ¨');
      return 'NODEMON';
    }
  },
  
  // ç»Ÿä¸€å¯åŠ¨å…¥å£
  startService: async (strategy = null) => {
    try {
      await SERVICE_STARTUP_CONTROL.preStartupCheck();
      
      const selectedStrategy = strategy || SERVICE_STARTUP_CONTROL.selectStartupStrategy();
      
      console.log(`ğŸš€ ä½¿ç”¨${selectedStrategy}å¯åŠ¨æœåŠ¡...`);
      
      switch (selectedStrategy) {
        case 'PM2':
          return await SERVICE_STARTUP_CONTROL.startWithPM2();
        case 'NODEMON':
          return await SERVICE_STARTUP_CONTROL.startWithNodemon();
        default:
          throw new Error(`æœªçŸ¥çš„å¯åŠ¨ç­–ç•¥: ${selectedStrategy}`);
      }
    } catch (error) {
      console.error('ğŸ”´ æœåŠ¡å¯åŠ¨å¤±è´¥:', error.message);
      throw error;
    }
  }
};
```

## PM2ç»Ÿä¸€é…ç½®è§„èŒƒ

### åŸºäºå®é™…é—®é¢˜ä¼˜åŒ–çš„PM2é…ç½®
```javascript
// åŸºäºcursor_5.mdä¸­PM2é…ç½®ç»éªŒçš„ä¼˜åŒ–ç‰ˆæœ¬
const PM2_UNIFIED_CONFIG = {
  // ecosystem.config.jsæ ‡å‡†é…ç½®
  generateEcosystemConfig: () => ({
    apps: [{
      // åŸºç¡€é…ç½®
      name: 'restaurant-lottery-backend',
      script: 'app.js',
      cwd: process.cwd(),
      
      // è¿è¡Œæ¨¡å¼é…ç½®
      exec_mode: 'fork',        // å•è¿›ç¨‹æ¨¡å¼ï¼Œé¿å…å¤šè¿›ç¨‹å†²çª
      instances: 1,             // å¼ºåˆ¶å•å®ä¾‹
      
      // ç¯å¢ƒå˜é‡
      env: {
        NODE_ENV: 'development',
        PORT: 3000
      },
      
      env_production: {
        NODE_ENV: 'production',
        PORT: 3000
      },
      
      // ğŸ”´ åŸºäºå®é™…é—®é¢˜çš„å…³é”®é…ç½®
      watch: false,             // ç¦ç”¨æ–‡ä»¶ç›‘æ§ï¼Œé¿å…é¢‘ç¹é‡å¯
      ignore_watch: [
        'node_modules',
        'logs',
        '*.log',
        '.git'
      ],
      
      // é‡å¯æ§åˆ¶ï¼ˆè§£å†³cursor_8.mdä¸­çš„é‡å¯é—®é¢˜ï¼‰
      autorestart: true,
      max_restarts: 5,          // é™åˆ¶æœ€å¤§é‡å¯æ¬¡æ•°
      min_uptime: '10s',        // æœ€å°è¿è¡Œæ—¶é—´
      restart_delay: 1000,      // é‡å¯å»¶è¿Ÿ
      
      // å†…å­˜ç®¡ç†
      max_memory_restart: '512M',
      
      // æ—¥å¿—é…ç½®
      log_file: './logs/combined.log',
      out_file: './logs/out.log',
      error_file: './logs/error.log',
      log_date_format: 'YYYY-MM-DD HH:mm:ss Z',
      merge_logs: true,
      
      // é”™è¯¯å¤„ç†
      kill_timeout: 5000,
      listen_timeout: 3000,
      
      // Node.jsä¼˜åŒ–
      node_args: '--max-old-space-size=512'
    }]
  }),
  
  // PM2çŠ¶æ€æ£€æŸ¥
  checkPM2Status: async () => {
    try {
      const result = await execAsync('pm2 jlist');
      const processes = JSON.parse(result.stdout);
      
      const appProcess = processes.find(p => p.name === 'restaurant-lottery-backend');
      
      if (appProcess) {
        return {
          status: appProcess.pm2_env.status,
          pid: appProcess.pid,
          restarts: appProcess.pm2_env.restart_time,
          uptime: appProcess.pm2_env.pm_uptime,
          memory: appProcess.memory,
          cpu: appProcess.cpu
        };
      }
      
      return { status: 'stopped' };
    } catch (error) {
      console.warn('PM2çŠ¶æ€æ£€æŸ¥å¤±è´¥:', error.message);
      return { status: 'unknown', error: error.message };
    }
  }
};
```

### PM2æ“ä½œå®‰å…¨åŒ…è£…
```javascript
// åŸºäºå®é™…PM2æ“ä½œé—®é¢˜çš„å®‰å…¨åŒ…è£…
const PM2_SAFE_OPERATIONS = {
  // å®‰å…¨å¯åŠ¨
  safeStart: async () => {
    try {
      // 1. æ£€æŸ¥æ˜¯å¦å·²è¿è¡Œ
      const status = await PM2_UNIFIED_CONFIG.checkPM2Status();
      if (status.status === 'online') {
        console.log('âœ… æœåŠ¡å·²åœ¨è¿è¡Œï¼Œæ— éœ€é‡æ–°å¯åŠ¨');
        return status;
      }
      
      // 2. ç¡®ä¿ç”Ÿæ€ç³»ç»Ÿé…ç½®å­˜åœ¨
      const configPath = './ecosystem.config.js';
      if (!fs.existsSync(configPath)) {
        const config = PM2_UNIFIED_CONFIG.generateEcosystemConfig();
        fs.writeFileSync(configPath, `module.exports = ${JSON.stringify(config, null, 2)};`);
        console.log('ğŸ“„ ç”ŸæˆPM2é…ç½®æ–‡ä»¶: ecosystem.config.js');
      }
      
      // 3. å¯åŠ¨æœåŠ¡
      console.log('ğŸš€ PM2å¯åŠ¨æœåŠ¡...');
      await execAsync('pm2 start ecosystem.config.js');
      
      // 4. éªŒè¯å¯åŠ¨ç»“æœ
      await new Promise(resolve => setTimeout(resolve, 3000));
      const newStatus = await PM2_UNIFIED_CONFIG.checkPM2Status();
      
      if (newStatus.status === 'online') {
        console.log('âœ… PM2æœåŠ¡å¯åŠ¨æˆåŠŸ');
        return newStatus;
      } else {
        throw new Error(`PM2å¯åŠ¨å¤±è´¥ï¼Œå½“å‰çŠ¶æ€: ${newStatus.status}`);
      }
    } catch (error) {
      console.error('ğŸ”´ PM2å¯åŠ¨å¤±è´¥:', error.message);
      throw error;
    }
  },
  
  // å®‰å…¨é‡å¯
  safeRestart: async () => {
    try {
      console.log('ğŸ”„ PM2é‡å¯æœåŠ¡...');
      
      await execAsync('pm2 restart restaurant-lottery-backend');
      
      // ç­‰å¾…é‡å¯å®Œæˆ
      await new Promise(resolve => setTimeout(resolve, 5000));
      
      const status = await PM2_UNIFIED_CONFIG.checkPM2Status();
      
      if (status.status === 'online') {
        console.log('âœ… PM2æœåŠ¡é‡å¯æˆåŠŸ');
        return status;
      } else {
        throw new Error(`PM2é‡å¯å¤±è´¥ï¼Œå½“å‰çŠ¶æ€: ${status.status}`);
      }
    } catch (error) {
      console.error('ğŸ”´ PM2é‡å¯å¤±è´¥:', error.message);
      throw error;
    }
  },
  
  // å®‰å…¨åœæ­¢
  safeStop: async () => {
    try {
      console.log('ğŸ›‘ PM2åœæ­¢æœåŠ¡...');
      
      const status = await PM2_UNIFIED_CONFIG.checkPM2Status();
      if (status.status === 'stopped') {
        console.log('âœ… æœåŠ¡å·²å¤„äºåœæ­¢çŠ¶æ€');
        return status;
      }
      
      await execAsync('pm2 stop restaurant-lottery-backend');
      
      // éªŒè¯åœæ­¢ç»“æœ
      await new Promise(resolve => setTimeout(resolve, 2000));
      const newStatus = await PM2_UNIFIED_CONFIG.checkPM2Status();
      
      console.log(`âœ… PM2æœåŠ¡å·²åœæ­¢ï¼ŒçŠ¶æ€: ${newStatus.status}`);
      return newStatus;
    } catch (error) {
      console.error('ğŸ”´ PM2åœæ­¢å¤±è´¥:', error.message);
      throw error;
    }
  }
};
```

## å¼€å‘ç¯å¢ƒå¯åŠ¨è§„èŒƒ

### Nodemoné…ç½®ä¼˜åŒ–
```javascript
// åŸºäºcursor_7.mdç­‰é—®é¢˜çš„nodemoné…ç½®ä¼˜åŒ–
const NODEMON_CONFIG = {
  // nodemon.jsonæ ‡å‡†é…ç½®
  generateNodemonConfig: () => ({
    watch: [
      'app.js',
      'routes/',
      'models/',
      'services/',
      'middleware/',
      'config/'
    ],
    ignore: [
      'node_modules/',
      'logs/',
      '*.log',
      '.git/',
      'public/',
      'uploads/'
    ],
    ext: 'js,json',
    exec: 'node app.js',
    env: {
      NODE_ENV: 'development',
      PORT: 3000
    },
    delay: 1000,              // å»¶è¿Ÿé‡å¯ï¼Œé¿å…é¢‘ç¹é‡å¯
    restartable: 'rs',        // æ‰‹åŠ¨é‡å¯å‘½ä»¤
    verbose: true,            // è¯¦ç»†æ—¥å¿—
    colours: true             // å½©è‰²è¾“å‡º
  }),
  
  // å®‰å…¨å¯åŠ¨nodemon
  safeStart: async () => {
    try {
      // 1. æ£€æŸ¥ç«¯å£å†²çª
      const portCheck = await PROCESS_CONFLICT_DETECTOR.checkPortConflicts(3000);
      if (portCheck.hasConflict) {
        console.error('ğŸ”´ ç«¯å£å†²çªï¼Œæ­£åœ¨æ¸…ç†...');
        await cleanup_duplicate_processes();
      }
      
      // 2. ç”Ÿæˆnodemoné…ç½®
      const configPath = './nodemon.json';
      if (!fs.existsSync(configPath)) {
        const config = NODEMON_CONFIG.generateNodemonConfig();
        fs.writeFileSync(configPath, JSON.stringify(config, null, 2));
        console.log('ğŸ“„ ç”Ÿæˆnodemoné…ç½®æ–‡ä»¶: nodemon.json');
      }
      
      // 3. å¯åŠ¨nodemon
      console.log('ğŸš€ Nodemonå¯åŠ¨æœåŠ¡...');
      const child = spawn('npx', ['nodemon'], {
        stdio: 'inherit',
        detached: false
      });
      
      // 4. ç›‘å¬è¿›ç¨‹äº‹ä»¶
      child.on('error', (error) => {
        console.error('ğŸ”´ Nodemonå¯åŠ¨å¤±è´¥:', error.message);
      });
      
      child.on('exit', (code) => {
        if (code !== 0) {
          console.error(`ğŸ”´ Nodemonå¼‚å¸¸é€€å‡ºï¼Œä»£ç : ${code}`);
        }
      });
      
      return child;
    } catch (error) {
      console.error('ğŸ”´ Nodemonå¯åŠ¨å¤±è´¥:', error.message);
      throw error;
    }
  }
};
```

## æœåŠ¡å¥åº·ç›‘æ§è§„èŒƒ

### å®æ—¶å¥åº·æ£€æŸ¥æœºåˆ¶
```javascript
// åŸºäºå®é™…æœåŠ¡é—®é¢˜çš„å¥åº·ç›‘æ§
const SERVICE_HEALTH_MONITOR = {
  // ç»¼åˆå¥åº·æ£€æŸ¥
  performHealthCheck: async () => {
    const results = {
      timestamp: new Date().toISOString(),
      checks: {}
    };
    
    // 1. è¿›ç¨‹çŠ¶æ€æ£€æŸ¥
    try {
      const processCheck = await PROCESS_CONFLICT_DETECTOR.checkDuplicateNodeProcesses();
      results.checks.process = {
        status: processCheck.hasDuplicates ? 'WARNING' : 'HEALTHY',
        processes: processCheck.processes,
        message: processCheck.hasDuplicates ? 
          `å‘ç°${processCheck.processes.length}ä¸ªé‡å¤è¿›ç¨‹` : 'è¿›ç¨‹çŠ¶æ€æ­£å¸¸'
      };
    } catch (error) {
      results.checks.process = {
        status: 'ERROR',
        error: error.message
      };
    }
    
    // 2. ç«¯å£ç›‘å¬æ£€æŸ¥
    try {
      const portCheck = await PROCESS_CONFLICT_DETECTOR.checkPortConflicts(3000);
      results.checks.port = {
        status: portCheck.hasConflict ? 'ERROR' : 'HEALTHY',
        conflicts: portCheck.conflictingProcesses || [],
        message: portCheck.hasConflict ? 
          `ç«¯å£3000è¢«${portCheck.conflictingProcesses.length}ä¸ªè¿›ç¨‹å ç”¨` : 'ç«¯å£ç›‘å¬æ­£å¸¸'
      };
    } catch (error) {
      results.checks.port = {
        status: 'ERROR',
        error: error.message
      };
    }
    
    // 3. APIå“åº”æ£€æŸ¥
    try {
      const startTime = Date.now();
      const response = await fetch('http://localhost:3000/health', {
        timeout: 5000
      });
      const responseTime = Date.now() - startTime;
      
      results.checks.api = {
        status: response.ok ? 'HEALTHY' : 'ERROR',
        responseTime: responseTime,
        statusCode: response.status,
        message: response.ok ? `APIå“åº”æ­£å¸¸ (${responseTime}ms)` : `APIå“åº”å¼‚å¸¸ (HTTP ${response.status})`
      };
    } catch (error) {
      results.checks.api = {
        status: 'ERROR',
        error: error.message,
        message: 'APIæ— å“åº”æˆ–è¿æ¥å¤±è´¥'
      };
    }
    
    // 4. æ€»ä½“å¥åº·çŠ¶æ€
    const allChecks = Object.values(results.checks);
    const hasError = allChecks.some(check => check.status === 'ERROR');
    const hasWarning = allChecks.some(check => check.status === 'WARNING');
    
    results.overallStatus = hasError ? 'UNHEALTHY' : 
                           hasWarning ? 'WARNING' : 'HEALTHY';
    
    return results;
  },
  
  // ç”Ÿæˆå¥åº·æŠ¥å‘Š
  generateHealthReport: (healthData) => {
    console.log(`\nğŸ¥ æœåŠ¡å¥åº·æ£€æŸ¥æŠ¥å‘Š (${healthData.timestamp})`);
    console.log(`ğŸ“Š æ€»ä½“çŠ¶æ€: ${getStatusEmoji(healthData.overallStatus)} ${healthData.overallStatus}`);
    console.log('');
    
    Object.entries(healthData.checks).forEach(([checkName, result]) => {
      const emoji = getStatusEmoji(result.status);
      console.log(`${emoji} ${checkName.toUpperCase()}: ${result.message}`);
      
      if (result.responseTime) {
        console.log(`   å“åº”æ—¶é—´: ${result.responseTime}ms`);
      }
      
      if (result.processes && result.processes.length > 0) {
        console.log(`   è¿›ç¨‹åˆ—è¡¨: ${result.processes.length}ä¸ªè¿›ç¨‹`);
      }
      
      if (result.conflicts && result.conflicts.length > 0) {
        console.log(`   å†²çªè¿›ç¨‹: ${result.conflicts.map(p => `PID ${p.pid}`).join(', ')}`);
      }
    });
    
    // æä¾›ä¿®å¤å»ºè®®
    if (healthData.overallStatus !== 'HEALTHY') {
      console.log('\nğŸ”§ ä¿®å¤å»ºè®®:');
      
      if (healthData.checks.process?.status === 'WARNING') {
        console.log('1. æ¸…ç†é‡å¤è¿›ç¨‹: cleanup_duplicate_processes()');
      }
      
      if (healthData.checks.port?.status === 'ERROR') {
        console.log('2. è§£å†³ç«¯å£å†²çª: åœæ­¢å†²çªè¿›ç¨‹æˆ–æ›´æ¢ç«¯å£');
      }
      
      if (healthData.checks.api?.status === 'ERROR') {
        console.log('3. é‡å¯æœåŠ¡: PM2_SAFE_OPERATIONS.safeRestart()');
      }
    }
  }
};

function getStatusEmoji(status) {
  switch (status) {
    case 'HEALTHY': return 'âœ…';
    case 'WARNING': return 'âš ï¸';
    case 'ERROR': return 'ğŸ”´';
    case 'UNHEALTHY': return 'âŒ';
    default: return 'â“';
  }
}
```

## æœåŠ¡å¯åŠ¨è„šæœ¬æ ‡å‡†åŒ–

### ä¸€é”®å¯åŠ¨ç®¡ç†è„šæœ¬
```bash
#!/bin/bash
# åŸºäºå®é™…é—®é¢˜çš„ç»Ÿä¸€æœåŠ¡ç®¡ç†è„šæœ¬

# æœåŠ¡ç®¡ç†ä¸»å‡½æ•°
manage_service() {
  local action=$1
  local strategy=${2:-"auto"}
  
  case $action in
    "start")
      start_service $strategy
      ;;
    "stop") 
      stop_service
      ;;
    "restart")
      restart_service $strategy
      ;;
    "status")
      check_service_status
      ;;
    "health")
      perform_health_check
      ;;
    "cleanup")
      cleanup_duplicate_processes
      ;;
    *)
      echo "ä½¿ç”¨æ–¹æ³•: $0 {start|stop|restart|status|health|cleanup} [pm2|nodemon]"
      exit 1
      ;;
  esac
}

# æ™ºèƒ½å¯åŠ¨æœåŠ¡
start_service() {
  local strategy=$1
  
  echo "ğŸš€ å¯åŠ¨æœåŠ¡ (ç­–ç•¥: $strategy)"
  
  # å¯åŠ¨å‰æ£€æŸ¥
  cleanup_duplicate_processes
  
  # é€‰æ‹©å¯åŠ¨ç­–ç•¥
  if [ "$strategy" = "auto" ]; then
    if command -v pm2 &> /dev/null; then
      strategy="pm2"
    else
      strategy="nodemon"
    fi
  fi
  
  case $strategy in
    "pm2")
      echo "ä½¿ç”¨PM2å¯åŠ¨..."
      if [ ! -f "ecosystem.config.js" ]; then
        echo "ç”ŸæˆPM2é…ç½®æ–‡ä»¶..."
        # ç”Ÿæˆé…ç½®æ–‡ä»¶çš„é€»è¾‘
      fi
      pm2 start ecosystem.config.js
      ;;
    "nodemon")
      echo "ä½¿ç”¨Nodemonå¯åŠ¨..."
      if [ ! -f "nodemon.json" ]; then
        echo "ç”ŸæˆNodemoné…ç½®æ–‡ä»¶..."
        # ç”Ÿæˆé…ç½®æ–‡ä»¶çš„é€»è¾‘
      fi
      npm run dev
      ;;
    *)
      echo "âŒ æœªçŸ¥çš„å¯åŠ¨ç­–ç•¥: $strategy"
      exit 1
      ;;
  esac
  
  # éªŒè¯å¯åŠ¨ç»“æœ
  sleep 3
  check_service_status
}

# ä¸»ç¨‹åºå…¥å£
if [ $# -eq 0 ]; then
  echo "ä½¿ç”¨æ–¹æ³•: $0 {start|stop|restart|status|health|cleanup} [pm2|nodemon]"
  exit 1
fi

manage_service "$@"
```

---

**æ ¸å¿ƒåŸåˆ™**: ç»Ÿä¸€è¿›ç¨‹ç®¡ç†ã€å†²çªæ£€æµ‹é¢„é˜²ã€å®‰å…¨æ“ä½œåŒ…è£…ã€å®æ—¶å¥åº·ç›‘æ§
description:
globs:
alwaysApply: false
---
