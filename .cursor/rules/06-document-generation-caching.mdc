---
description: 
globs: 
alwaysApply: true
---
# 文档生成和缓存管理规范
# 解决文档冗余、信息过载和工具调用效率问题

## 核心问题分析
通过对实际会话的深度分析，发现以下严重的文档和缓存管理问题：
- 文档冗余度：300-500%的信息重复
- 简单问题复杂化：50行问题生成1000+行文档
- 重点信息掩盖：关键信息被大量细节掩盖
- 工具调用浪费：重复工具调用次数30-40次
- 缓存利用率低：重复状态检查浪费大量请求

## 文档长度控制规范

### 按问题复杂度分级控制
- **简单问题（查询、配置）**：
  - 文档长度：30-50行
  - 核心信息占比：>80%
  - 阅读时间：<2分钟

- **中等问题（调试、修复）**：
  - 文档长度：100-200行
  - 核心信息占比：>60%
  - 阅读时间：<5分钟

- **复杂问题（系统性改造）**：
  - 文档长度：300-500行
  - 核心信息占比：>40%
  - 阅读时间：<10分钟

### 文档结构强制要求
- **执行摘要**（必须）：3-5行概述
- **问题描述**（必须）：简洁描述问题现象
- **解决方案**（必须）：具体操作步骤
- **验证结果**（必须）：修复效果确认
- **技术细节**（可选）：详细技术信息，可折叠
- **相关信息**（可选）：补充信息，可删减

### 信息密度要求
- **信息密度**：每行至少包含1个有效信息点
- **冗余率控制**：重复信息不超过10%
- **空白率控制**：空白行不超过20%
- **有效信息率**：核心信息占比>50%

## 内容精简策略

### 信息重要性分级
- **P0级（必须保留）**：解决问题必需的信息
- **P1级（高度相关）**：有助于理解和操作的信息
- **P2级（一般相关）**：提供背景和扩展的信息
- **P3级（低度相关）**：可有可无的补充信息

### 内容删减原则
- **删除重复**：合并相同或相似的信息
- **删除冗余**：删除不影响理解的重复表述
- **删除无关**：删除与解决问题无关的信息
- **删除过程**：简化详细的操作过程描述

### 信息压缩技术
- **列表化**：将长段落转换为简洁列表
- **表格化**：使用表格整理结构化信息
- **代码块**：将操作步骤整理为代码块
- **关键词提取**：提取关键信息点

## 结构化文档模板

### 问题解决文档模板
```markdown
# 问题：[一句话描述]

## 解决方案
[核心解决步骤，3-5步]

## 验证结果
[验证效果的具体方法]

## 预防建议
[防止再次发生的建议]

---
<details>
<summary>技术细节（点击展开）</summary>
[详细的技术分析和背景信息]
</details>
```

### 配置修改文档模板
```markdown
# 配置：[配置项名称]

## 修改内容
- 文件：`path/to/file`
- 原值：`old_value`
- 新值：`new_value`

## 生效方法
[使配置生效的操作]

## 验证方法
[验证配置是否生效]
```

### 功能实现文档模板
```markdown
# 功能：[功能名称]

## 实现概述
[功能实现的核心逻辑]

## 关键代码
```language
[核心代码片段]
```

## 测试验证
[功能测试的方法和结果]
```

## 信息呈现优化

### 视觉层次优化
- **标题层次**：最多使用3级标题
- **重点标记**：使用粗体标记关键信息
- **代码突出**：使用代码块突出命令和配置
- **列表简化**：使用简洁的列表格式

### 阅读顺序优化
- **重要信息前置**：将最重要的信息放在前面
- **操作步骤序号**：为操作步骤添加清晰序号
- **结果验证分离**：将验证步骤单独成段
- **补充信息后置**：将详细信息放在文档后部

### 信息分层展示
- **核心信息**：直接显示在主文档中
- **详细信息**：使用折叠区域隐藏
- **技术细节**：使用详情标签包装
- **历史信息**：移至文档末尾或删除

## 重复信息检测

### 自动检测机制
- **文本相似度检测**：检测相似度>70%的文本块
- **关键词频率分析**：分析关键词出现频率
- **段落重复检测**：检测完全重复的段落
- **结构重复识别**：识别相似的文档结构

### 重复信息处理策略
- **合并处理**：将重复信息合并为一处
- **引用处理**：使用引用替代重复描述
- **删除处理**：直接删除冗余的重复信息
- **链接处理**：使用内部链接减少重复

### 信息去重算法
```
去重流程：
1. 识别候选重复块
2. 计算文本相似度
3. 分析信息价值
4. 选择保留版本
5. 处理其他重复版本
6. 更新文档索引
```

## 工具调用效率优化规范

### 工具调用次数控制规范
- **严禁重复工具调用**：同一会话中避免对相同内容进行重复的状态检查、文件读取、命令执行
- **关键系统状态检查结果应缓存使用**：避免在同一会话中重复验证
- **工具调用前评估必要性**：确保不是重复或冗余操作
- **限制验证频率**：同类验证操作在单个会话中不超过2次，除非确实需要验证变更结果

### 状态检查去重机制
- **建立检查清单**：会话开始时建立已完成检查项目清单，避免重复验证
- **状态变更触发**：仅在相关操作完成后重新检查状态，而非每次操作前都检查
- **集中状态验证**：将多个相关状态检查集中在一次工具调用中完成
- **避免冗余确认**：对已确认正常的服务状态，除非有错误发生否则不重复检查

### 工具调用效率监控
- **效率指标跟踪**：跟踪工具调用成功率、重复率、并行化率等关键指标
- **失败分析机制**：工具调用失败时立即分析原因，制定针对性的替代方案
- **时间效率要求**：单次工具调用操作时间不超过30秒，长操作必须分段或后台执行
- **请求次数预算**：为每类任务设定合理的工具调用次数预算，超出时进行优化

## 并行工具调用最大化规范

### 并行处理强制要求
- **系统状态检查并行化**：端口占用、进程状态、健康检查等独立检查必须并行执行
- **文件操作并行化**：存在性检查与内容读取、多个配置文件读取可以并行进行
- **网络请求并行化**：多个API端点测试、多个服务健康检查必须并行执行
- **数据库操作并行化**：不相关的数据库查询可以并行执行
- **信息收集并行化**：所有独立的信息收集任务必须并行执行

### 并行处理执行规范
- **默认并行原则**：除非有明确的依赖关系，否则所有工具调用都应并行执行
- **串行限制条件**：只有当工具B的输入确实需要工具A的输出时，才能串行执行
- **并行调用限制**：同时执行的并行工具调用建议不超过5个，避免系统资源耗尽
- **错误处理并行**：并行工具调用中的错误处理不应影响其他并行任务的执行

### 并行效率优化策略
- **批量操作优化**：多个独立的检查操作必须使用并行工具调用，避免串行等待
- **预分析策略**：在工具调用前分析所有需要的信息，一次性并行获取
- **避免假并行**：确保声称的并行操作确实是真正的并行，而不是顺序包装
- **并行化率目标**：独立操作的并行化率应达到80%以上

## 智能重试策略规范

### 重试逻辑优化
- **智能重试机制**：工具调用失败时分析失败原因，避免盲目重试浪费请求次数
- **重试次数限制**：同类操作重试不超过2次，不同方法重试不超过3次
- **替代方案机制**：重试失败时立即切换到替代方案，而非无限重试
- **错误类型分类**：根据错误类型选择重试策略或直接切换方案

### 故障转移机制
- **工具切换策略**：主工具失败时立即切换到备用工具（如file_search → grep_search）
- **方法降级策略**：复杂操作失败时降级到简单操作（如并行 → 串行）
- **用户提示机制**：无法自动恢复时及时提示用户介入

## 缓存管理规范

### 缓存策略分类
- **会话级缓存**：项目信息、技术栈、配置文件内容
- **操作级缓存**：状态检查结果、系统信息、网络连接状态
- **临时缓存**：命令执行结果、文件读取内容
- **长期缓存**：项目结构、依赖关系、环境配置

### 缓存有效期管理
- **静态信息缓存**：整个会话期间有效
- **动态信息缓存**：5-10分钟有效期
- **状态信息缓存**：操作前后失效
- **文件内容缓存**：文件修改后失效

### 缓存失效策略
- **主动失效**：关键操作后主动清除相关缓存
- **时间失效**：到达有效期后自动失效
- **依赖失效**：依赖项变更后连带失效
- **手动失效**：用户要求或检测到不一致时失效

## 用户体验优化

### 阅读体验提升
- **扫描友好**：支持快速扫描查找信息
- **跳跃阅读**：支持跳跃式阅读关键信息
- **渐进披露**：按需展示详细信息
- **快速定位**：提供快速定位机制

### 操作便利性
- **复制友好**：命令和代码易于复制
- **执行顺序**：操作步骤按执行顺序排列
- **错误处理**：包含常见错误的处理方法
- **回滚指导**：提供操作回滚的指导

### 理解辅助
- **上下文提供**：提供必要的背景信息
- **术语解释**：解释关键技术术语
- **示例说明**：使用具体示例说明抽象概念
- **图示补充**：必要时使用图示辅助理解

## 效率测量和优化指标

### 关键效率指标
- **工具调用效率**：成功率 >90%，重复率 <10%，并行化率 >80%
- **会话完成时间**：问题定位时间 <5分钟，总解决时间目标
- **成本控制指标**：单次会话工具调用次数控制在合理范围内
- **文档质量指标**：完整性、准确性、简洁性、可操作性

### 持续优化机制
- **效率分析记录**：记录工具调用模式和效率指标
- **问题模式识别**：识别重复出现的低效模式
- **优化策略更新**：定期更新优化策略和最佳实践
- **知识库建设**：建立高效工具调用的知识库和模板

## 质量控制机制

### 文档质量指标
- **完整性**：包含解决问题的完整信息
- **准确性**：信息的准确性和时效性
- **简洁性**：信息表达的简洁性
- **可操作性**：操作指导的可执行性

### 质量检查清单
- [ ] 核心问题是否清晰描述？
- [ ] 解决方案是否具体可行？
- [ ] 验证方法是否明确有效？
- [ ] 文档长度是否合理控制？
- [ ] 重复信息是否已经清理？
- [ ] 用户是否能够快速理解？

### 文档评审机制
- **自我评审**：作者自我检查文档质量
- **同行评审**：其他专家评审文档内容
- **用户反馈**：收集用户对文档的反馈
- **迭代改进**：基于反馈持续改进文档质量

## 文档生成自动化

### 模板自动化
- **模板识别**：自动识别适用的文档模板
- **内容填充**：自动填充模板的固定内容
- **格式标准化**：自动应用标准格式和样式
- **结构优化**：自动优化文档结构和层次

### 内容生成优化
- **信息提取**：从原始数据中提取关键信息
- **内容组织**：按重要性和逻辑顺序组织内容
- **语言优化**：使用简洁明了的语言表达
- **格式统一**：统一文档格式和风格

### 质量保证自动化
- **重复检测**：自动检测和标记重复内容
- **完整性检查**：自动检查文档完整性
- **准确性验证**：自动验证关键信息的准确性
- **可读性分析**：自动分析文档可读性

## 缓存一致性保证

### 一致性检测
- **版本控制**：为缓存数据建立版本控制
- **完整性检查**：定期检查缓存数据完整性
- **时效性验证**：验证缓存数据的时效性
- **依赖关系验证**：验证缓存数据间的依赖关系

### 不一致处理
- **冲突检测**：检测缓存数据的冲突
- **冲突解决**：制定冲突解决策略
- **数据修复**：修复不一致的缓存数据
- **预防措施**：制定预防不一致的措施

### 同步机制
- **实时同步**：关键数据的实时同步
- **批量同步**：非关键数据的批量同步
- **异步同步**：长时间操作的异步同步
- **优先级同步**：按优先级进行同步

## 实施检查清单

### 每次会话开始前
- [ ] 明确会话目标和所需信息
- [ ] 分析哪些操作可以并行执行
- [ ] 建立已完成检查项目清单
- [ ] 设定工具调用次数预算

### 每次工具调用前
- [ ] 检查是否为重复调用
- [ ] 评估是否可以并行执行
- [ ] 确认调用的必要性
- [ ] 预估调用时间和成本

### 每次文档生成时
- [ ] 确认文档长度合理
- [ ] 检查信息密度符合要求
- [ ] 验证内容结构标准化
- [ ] 删除重复和冗余信息

### 每次会话结束后
- [ ] 统计工具调用次数和效率
- [ ] 分析是否存在重复或冗余调用
- [ ] 识别可以并行化的操作
- [ ] 记录优化建议和改进点

## 技术实现建议

### 缓存存储结构
```json
{
  "session_id": "unique_session_id",
  "cache_data": {
    "project_info": {
      "type": "nodejs_backend",
      "framework": "express",
      "timestamp": "2024-01-01T00:00:00Z",
      "ttl": 3600
    },
    "system_status": {
      "services": ["mysql", "redis", "nginx"],
      "timestamp": "2024-01-01T00:00:00Z",
      "ttl": 300
    }
  }
}
```

### 工具调用优化算法
```python
def optimize_tool_calls(operations):
    # 分析操作依赖关系
    dependencies = analyze_dependencies(operations)
    
    # 识别可并行操作
    parallel_groups = identify_parallel_groups(operations, dependencies)
    
    # 优化执行顺序
    optimized_plan = optimize_execution_order(parallel_groups)
    
    return optimized_plan
```

### 文档生成工作流
```
1. 收集原始信息
2. 分析信息重要性
3. 选择合适模板
4. 生成初始文档
5. 检测重复内容
6. 精简和优化
7. 格式化输出
8. 质量检查
```

**核心原则**：效率优先、避免重复、并行最大化、成本控制、质量保证、用户体验
