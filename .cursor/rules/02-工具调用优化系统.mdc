---
alwaysApply: true
lastUpdated: 2025å¹´10æœˆ03æ—¥ 17:05:11
---

# âš¡ å·¥å…·è°ƒç”¨ä¼˜åŒ–ç³»ç»Ÿï¼ˆåŸºäºcursoræ–‡æ¡£é‡å¤æ£€æŸ¥é—®é¢˜çš„ç³»ç»ŸåŒ–è§£å†³æ–¹æ¡ˆï¼‰

## ğŸ”´ **åŸºäºå®é™…æµªè´¹çš„æ•ˆç‡ä¼˜åŒ–ä½“ç³»**

### **å®é™…æ•ˆç‡æŸå¤±é‡åŒ–åˆ†æ**
ä»11ä¸ªcursoræ–‡æ¡£æ·±åº¦ç»Ÿè®¡å‘ç°ï¼š
- **ç´¯è®¡å·¥å…·è°ƒç”¨æµªè´¹**: 1380+æ¬¡ï¼ˆé¢„æœŸ200-300æ¬¡ï¼‰
- **ç´¯è®¡æ—¶é—´æµªè´¹**: 450-665åˆ†é’Ÿï¼ˆ7.5-11å°æ—¶ï¼‰
- **é‡å¤æ£€æŸ¥ç‡**: 70-80%ï¼ˆä¸¥é‡è¶…æ ‡ï¼Œåº”æ§åˆ¶åœ¨<10%ï¼‰
- **æœ€ä¸¥é‡æ¡ˆä¾‹**: cursor_8.mdå¥åº·æ£€æŸ¥é‡å¤12+æ¬¡

### **å…¸å‹é‡å¤æ¨¡å¼ç»Ÿè®¡**
- **å¥åº·æ£€æŸ¥é‡å¤**: cursor_8.md (12æ¬¡), cursor_6.md (8æ¬¡)
- **æœåŠ¡çŠ¶æ€éªŒè¯é‡å¤**: cursor_7.md (6æ¬¡), cursor_1.md (10æ¬¡)  
- **è¿›ç¨‹çŠ¶æ€æ£€æŸ¥é‡å¤**: cursor_3.md (7æ¬¡), cursor_5.md (5æ¬¡)
- **æ•°æ®åº“è¿æ¥éªŒè¯é‡å¤**: å¤šä¸ªæ–‡æ¡£å…±25+æ¬¡

## ğŸƒâ€â™‚ï¸ **æ™ºèƒ½çŠ¶æ€æ£€æŸ¥ç¼“å­˜ç³»ç»Ÿ**

### **ç»Ÿä¸€ç¼“å­˜æœºåˆ¶ï¼ˆè§£å†³é‡å¤æ£€æŸ¥æ ¸å¿ƒé—®é¢˜ï¼‰**
```javascript
// ğŸ”´ åŸºäºcursor_8.mdç­‰å®é™…é‡å¤æ¨¡å¼çš„ç»Ÿä¸€ç¼“å­˜ç³»ç»Ÿ
const UNIFIED_STATUS_CACHE_SYSTEM = {
  // çŠ¶æ€ç¼“å­˜é…ç½®ï¼ˆåŸºäºå®é™…æ£€æŸ¥é¢‘ç‡ä¼˜åŒ–ï¼‰
  cacheConfigs: {
    'health_check_3000': {
      command: 'curl http://localhost:3000/health',
      ttl: 300000,  // 5åˆ†é’Ÿç¼“å­˜
      maxRetries: 3
    },
    'pm2_status': {
      command: 'pm2 status', 
      ttl: 300000,  // 5åˆ†é’Ÿç¼“å­˜
      maxRetries: 2
    },
    'port_check_3000': {
      command: 'netstat -tlnp | grep :3000',
      ttl: 300000,  // 5åˆ†é’Ÿç¼“å­˜
      maxRetries: 2
    },
    'process_check': {
      command: 'ps aux | grep node',
      ttl: 180000,  // 3åˆ†é’Ÿç¼“å­˜
      maxRetries: 2
    },
    'database_status': {
      command: 'database connection check',
      ttl: 600000,  // 10åˆ†é’Ÿç¼“å­˜
      maxRetries: 1
    }
  },

  // ç¼“å­˜å­˜å‚¨
  cache: new Map(),

  // æ™ºèƒ½ç¼“å­˜æ£€æŸ¥ï¼ˆé¢„é˜²é‡å¤è°ƒç”¨çš„æ ¸å¿ƒæœºåˆ¶ï¼‰
  checkWithCache: async (checkType, executeFunction) => {
    const config = UNIFIED_STATUS_CACHE_SYSTEM.cacheConfigs[checkType];
    if (!config) {
      console.warn(`âš ï¸ æœªçŸ¥æ£€æŸ¥ç±»å‹: ${checkType}ï¼Œç›´æ¥æ‰§è¡Œ`);
      return await executeFunction();
    }

    const now = Date.now();
    const cached = UNIFIED_STATUS_CACHE_SYSTEM.cache.get(checkType);
    
    // æ£€æŸ¥ç¼“å­˜æœ‰æ•ˆæ€§
    if (cached && (now - cached.timestamp) < config.ttl) {
      console.log(`âœ… ä½¿ç”¨ç¼“å­˜ç»“æœ: ${checkType} (${Math.round((now-cached.timestamp)/1000)}ç§’å‰)`);
      return cached.result;
    }

    // æ‰§è¡Œæ£€æŸ¥å¹¶æ›´æ–°ç¼“å­˜
    console.log(`ğŸ”„ æ‰§è¡Œæ£€æŸ¥: ${checkType}`);
    try {
      const result = await executeFunction();
      UNIFIED_STATUS_CACHE_SYSTEM.cache.set(checkType, {
        result: result,
        timestamp: now,
        command: config.command
      });
      
      console.log(`ğŸ’¾ ç¼“å­˜å·²æ›´æ–°: ${checkType}`);
      return result;
    } catch (error) {
      console.error(`âŒ æ£€æŸ¥å¤±è´¥: ${checkType}`, error.message);
      throw error;
    }
  },

  // å¼ºåˆ¶æ¸…é™¤ç¼“å­˜ï¼ˆä»…åœ¨çŠ¶æ€ç¡®å®å˜æ›´åï¼‰
  invalidateCache: (checkTypes, reason = 'çŠ¶æ€å˜æ›´') => {
    checkTypes.forEach(checkType => {
      if (UNIFIED_STATUS_CACHE_SYSTEM.cache.has(checkType)) {
        UNIFIED_STATUS_CACHE_SYSTEM.cache.delete(checkType);
        console.log(`ğŸ—‘ï¸ æ¸…é™¤ç¼“å­˜: ${checkType} (åŸå› : ${reason})`);
      }
    });
  }
};
```

## ğŸš« **é‡å¤æ£€æŸ¥å¼ºåˆ¶æ‹¦æˆªå™¨**

### **åŸºäºå®é™…é‡å¤æ¨¡å¼çš„æ‹¦æˆªæœºåˆ¶**
```javascript
// ğŸ”´ é˜²æ­¢cursor_8.mdä¸­12æ¬¡é‡å¤å¥åº·æ£€æŸ¥çš„æ‹¦æˆªå™¨
const DUPLICATE_CHECK_INTERCEPTOR = {
  // æ£€æŸ¥æ‰§è¡Œå†å²
  checkHistory: new Map(),
  
  // æ£€æŸ¥å‰æ‹¦æˆªéªŒè¯
  beforeCheck: (checkType, command) => {
    const record = DUPLICATE_CHECK_INTERCEPTOR.checkHistory.get(checkType) || { count: 0, lastTime: 0 };
    const now = Date.now();
    const timeSinceLastCheck = now - record.lastTime;
    
    // ğŸ”´ å¼ºåˆ¶æ—¶é—´é—´éš”é™åˆ¶ï¼ˆ5åˆ†é’Ÿå†…ç¦æ­¢é‡å¤ï¼‰
    if (timeSinceLastCheck < 300000 && record.count > 0) {
      throw new Error(`ğŸš« é‡å¤æ£€æŸ¥æ‹¦æˆª: ${checkType} è·ç¦»ä¸Šæ¬¡æ£€æŸ¥ä»…${Math.round(timeSinceLastCheck/1000)}ç§’`);
    }
    
    // ğŸ”´ å¼ºåˆ¶æ¬¡æ•°é™åˆ¶ï¼ˆå•æ¬¡ä¼šè¯æœ€å¤š3æ¬¡ï¼‰
    if (record.count >= 3) {
      throw new Error(`ğŸš« æ£€æŸ¥æ¬¡æ•°è¶…é™: ${checkType} å·²æ‰§è¡Œ${record.count}æ¬¡ï¼Œè¶…è¿‡é™åˆ¶(3æ¬¡)`);
    }

    // è®°å½•æœ¬æ¬¡æ£€æŸ¥
    DUPLICATE_CHECK_INTERCEPTOR.checkHistory.set(checkType, {
      count: record.count + 1,
      lastTime: now,
      command: command
    });

    if (record.count > 0) {
      console.warn(`âš ï¸ é‡å¤æ£€æŸ¥è­¦å‘Š: ${checkType} ç¬¬${record.count + 1}æ¬¡æ‰§è¡Œ`);
    }

    return { allowed: true, count: record.count + 1 };
  },

  // é‡ç½®æ£€æŸ¥å†å²ï¼ˆä»…åœ¨ç¡®å®éœ€è¦æ—¶ï¼‰
  reset: (checkType, reason) => {
    DUPLICATE_CHECK_INTERCEPTOR.checkHistory.delete(checkType);
    console.log(`ğŸ”„ é‡ç½®æ£€æŸ¥å†å²: ${checkType} (${reason})`);
  }
};
```

## ğŸ¯ **å·¥å…·è°ƒç”¨é¢„ç®—æ§åˆ¶ç³»ç»Ÿ**

### **åŸºäºå®é™…æµªè´¹çš„æ™ºèƒ½é¢„ç®—åˆ†é…**
```javascript
// ğŸ”´ åŸºäº11ä¸ªcursoræ–‡æ¡£å®é™…ç»Ÿè®¡çš„é¢„ç®—æ§åˆ¶ç³»ç»Ÿ
const TOOL_CALL_BUDGET_SYSTEM = {
  // ä»»åŠ¡å¤æ‚åº¦é¢„ç®—é…ç½®ï¼ˆåŸºäºå®é™…è§‚å¯Ÿæ•°æ®ï¼‰
  budgetConfigs: {
    simple_status_check: {
      maxCalls: 20,        // cursor_8.mdå®é™…200+æ¬¡ï¼Œæ•ˆç‡ä»…10%
      timeLimit: 300000,   // 5åˆ†é’Ÿé™åˆ¶
      description: 'ç®€å•çŠ¶æ€æ£€æŸ¥å’Œé…ç½®ä¿®å¤'
    },
    medium_debug_task: {
      maxCalls: 50,        // cursor_3.mdå®é™…180+æ¬¡ï¼Œæ•ˆç‡28%
      timeLimit: 900000,   // 15åˆ†é’Ÿé™åˆ¶  
      description: 'ä¸­ç­‰å¤æ‚åº¦è°ƒè¯•å’ŒåŠŸèƒ½ä¿®å¤'
    },
    complex_system_task: {
      maxCalls: 100,       // cursor_5.mdå®é™…140+æ¬¡ï¼Œæ•ˆç‡71%
      timeLimit: 1800000,  // 30åˆ†é’Ÿé™åˆ¶
      description: 'å¤æ‚ç³»ç»Ÿæ”¹é€ å’Œæ¶æ„è°ƒæ•´'
    }
  },

  // å½“å‰ä¼šè¯ç»Ÿè®¡
  currentSession: {
    totalCalls: 0,
    callsByType: new Map(),
    startTime: Date.now(),
    allocatedBudget: 50,
    allocatedTime: 600000  // é»˜è®¤10åˆ†é’Ÿ
  },

  // åŠ¨æ€é¢„ç®—åˆ†é…
  allocate: (taskComplexity) => {
    const config = TOOL_CALL_BUDGET_SYSTEM.budgetConfigs[taskComplexity];
    if (config) {
      TOOL_CALL_BUDGET_SYSTEM.currentSession.allocatedBudget = config.maxCalls;
      TOOL_CALL_BUDGET_SYSTEM.currentSession.allocatedTime = config.timeLimit;
      
      console.log(`ğŸ’° åˆ†é…é¢„ç®—: ${config.maxCalls}æ¬¡è°ƒç”¨, ${config.timeLimit/60000}åˆ†é’Ÿ (${taskComplexity})`);
    }
  },

  // é¢„ç®—ä½¿ç”¨æ£€æŸ¥ï¼ˆè¶…é™è‡ªåŠ¨ä¸­æ–­ï¼‰
  checkBudget: (toolType) => {
    const session = TOOL_CALL_BUDGET_SYSTEM.currentSession;
    session.totalCalls++;
    session.callsByType.set(toolType, (session.callsByType.get(toolType) || 0) + 1);

    const usagePercentage = (session.totalCalls / session.allocatedBudget * 100).toFixed(1);
    const timeUsed = Date.now() - session.startTime;
    const timePercentage = (timeUsed / session.allocatedTime * 100).toFixed(1);

    console.log(`ğŸ“Š é¢„ç®—ä½¿ç”¨: ${session.totalCalls}/${session.allocatedBudget} (${usagePercentage}%), æ—¶é—´: ${timePercentage}%`);

    // ğŸ”´ é¢„ç®—è¶…é™å¼ºåˆ¶æ§åˆ¶
    if (session.totalCalls > session.allocatedBudget) {
      throw new Error(`ğŸš« å·¥å…·è°ƒç”¨é¢„ç®—è€—å°½ (${session.totalCalls}/${session.allocatedBudget})`);
    }

    if (timeUsed > session.allocatedTime) {
      throw new Error(`ğŸš« æ—¶é—´é¢„ç®—è€—å°½ (${timeUsed/60000}/${session.allocatedTime/60000}åˆ†é’Ÿ)`);
    }

    return { 
      remaining: session.allocatedBudget - session.totalCalls,
      percentage: parseFloat(usagePercentage)
    };
  }
};
```

## ğŸ”€ **å¹¶è¡Œå·¥å…·è°ƒç”¨å¼ºåˆ¶ä¼˜åŒ–ç³»ç»Ÿ**

### **æœ€å¤§åŒ–å¹¶è¡Œæ‰§è¡Œçš„æ™ºèƒ½è°ƒåº¦å™¨**
```javascript
// ğŸ”´ åŸºäºä¸²è¡Œæµªè´¹æ¨¡å¼çš„å¼ºåˆ¶å¹¶è¡ŒåŒ–ç³»ç»Ÿ
const PARALLEL_EXECUTION_OPTIMIZER = {
  // å¯å¹¶è¡Œæ“ä½œæ¨¡å¼åº“ï¼ˆåŸºäºå®é™…å‘ç°çš„æµªè´¹æ¨¡å¼ï¼‰
  parallelPatterns: {
    system_status_check: [
      'curl http://localhost:3000/health',
      'pm2 status',
      'netstat -tlnp | grep :3000', 
      'ps aux | grep node'
    ],
    file_operations: [
      'read package.json',
      'read app.js',
      'read .env',
      'check file existence'
    ],
    database_operations: [
      'connection check',
      'table structure',
      'data integrity'
    ]
  },

  // æ™ºèƒ½å¹¶è¡Œåˆ†ç»„å’Œæ‰§è¡Œ
  optimizeExecution: async (operations) => {
    const parallelGroups = PARALLEL_EXECUTION_OPTIMIZER.groupOperations(operations);
    const results = [];

    for (const group of parallelGroups) {
      if (group.type === 'parallel') {
        // å¹¶è¡Œæ‰§è¡Œ
        console.log(`ğŸš€ å¹¶è¡Œæ‰§è¡Œ ${group.operations.length} ä¸ªæ“ä½œ...`);
        const startTime = Date.now();
        
        const parallelResults = await Promise.allSettled(
          group.operations.map(op => op.execute())
        );

        const successCount = parallelResults.filter(r => r.status === 'fulfilled').length;
        const totalTime = Date.now() - startTime;
        
        console.log(`ğŸ“Š å¹¶è¡Œæ‰§è¡Œå®Œæˆ: ${successCount}/${group.operations.length} æˆåŠŸ, è€—æ—¶ ${totalTime}ms`);
        
        results.push(...parallelResults);
      } else {
        // ä¸²è¡Œæ‰§è¡Œï¼ˆä»…åœ¨æœ‰ä¾èµ–å…³ç³»æ—¶ï¼‰
        console.log(`ğŸ”— ä¸²è¡Œæ‰§è¡Œ ${group.operations.length} ä¸ªç›¸å…³æ“ä½œ...`);
        for (const operation of group.operations) {
          const result = await operation.execute();
          results.push({ status: 'fulfilled', value: result });
        }
      }
    }

    return results;
  },

  // æ“ä½œåˆ†ç»„ç®—æ³•
  groupOperations: (operations) => {
    const groups = [];
    const processed = new Set();

    operations.forEach((op, index) => {
      if (processed.has(index)) return;

      const relatedOps = [op];
      processed.add(index);

      // æŸ¥æ‰¾å¯å¹¶è¡Œçš„æ“ä½œ
      for (let i = index + 1; i < operations.length; i++) {
        if (processed.has(i)) continue;
        
        if (PARALLEL_EXECUTION_OPTIMIZER.canParallel(op, operations[i])) {
          relatedOps.push(operations[i]);
          processed.add(i);
        }
      }

      groups.push({
        type: relatedOps.length > 1 ? 'parallel' : 'sequential',
        operations: relatedOps,
        estimatedTime: relatedOps.length > 1 ? 
          Math.max(...relatedOps.map(o => o.estimatedTime || 2000)) :
          relatedOps.reduce((sum, o) => sum + (o.estimatedTime || 2000), 0)
      });
    });

    // å¹¶è¡ŒåŒ–ç‡ç»Ÿè®¡
    const parallelOps = groups.filter(g => g.type === 'parallel').reduce((sum, g) => sum + g.operations.length, 0);
    const parallelizationRate = parallelOps / operations.length;
    
    if (parallelizationRate < 0.6) {
      console.warn(`âš ï¸ å¹¶è¡ŒåŒ–ç‡è¿‡ä½: ${(parallelizationRate * 100).toFixed(1)}% < 60%`);
    } else {
      console.log(`âœ… å¹¶è¡ŒåŒ–ç‡: ${(parallelizationRate * 100).toFixed(1)}%`);
    }

    return groups;
  },

  // åˆ¤æ–­ä¸¤ä¸ªæ“ä½œæ˜¯å¦å¯ä»¥å¹¶è¡Œ
  canParallel: (op1, op2) => {
    // æ£€æŸ¥æ˜¯å¦å±äºåŒä¸€å¹¶è¡Œæ¨¡å¼
    for (const [pattern, commands] of Object.entries(PARALLEL_EXECUTION_OPTIMIZER.parallelPatterns)) {
      const op1Match = commands.some(cmd => op1.command?.includes(cmd) || cmd.includes(op1.type || ''));
      const op2Match = commands.some(cmd => op2.command?.includes(cmd) || cmd.includes(op2.type || ''));
      
      if (op1Match && op2Match) {
        return true;
      }
    }

    // æ£€æŸ¥æ“ä½œé—´æ˜¯å¦æœ‰ä¾èµ–å…³ç³»
    return !PARALLEL_EXECUTION_OPTIMIZER.hasDependency(op1, op2);
  },

  // ä¾èµ–å…³ç³»æ£€æŸ¥
  hasDependency: (op1, op2) => {
    const dependencies = [
      { pre: 'file_edit', post: 'file_read' },
      { pre: 'service_start', post: 'health_check' },
      { pre: 'process_kill', post: 'process_check' }
    ];

    return dependencies.some(dep => 
      (op1.type?.includes(dep.pre) && op2.type?.includes(dep.post)) ||
      (op2.type?.includes(dep.pre) && op1.type?.includes(dep.post))
    );
  }
};
```

## ğŸ”„ **æ™ºèƒ½é‡è¯•å’Œæ•…éšœè½¬ç§»ç³»ç»Ÿ**

### **åŸºäºå®é™…å¤±è´¥æ¨¡å¼çš„é‡è¯•ç­–ç•¥**
```javascript
// ğŸ”´ åŸºäºcursoræ–‡æ¡£å‘ç°çš„å¤±è´¥æ¨¡å¼ä¼˜åŒ–é‡è¯•ç³»ç»Ÿ
const INTELLIGENT_RETRY_SYSTEM = {
  // å¤±è´¥æ¨¡å¼åˆ†æåº“ï¼ˆåŸºäºå®é™…è§‚å¯Ÿæ•°æ®ï¼‰
  failurePatterns: {
    network_timeout: {
      pattern: /timeout|ECONNREFUSED|ETIMEDOUT/i,
      retryCount: 3,
      retryDelays: [1000, 2000, 4000], // æŒ‡æ•°é€€é¿
      alternatives: ['local_cache', 'fallback_endpoint']
    },
    permission_denied: {
      pattern: /EACCES|permission denied|403/i,
      retryCount: 1,
      retryDelays: [500],
      alternatives: ['alternative_method']
    },
    resource_busy: {
      pattern: /EBUSY|resource busy|locked/i,
      retryCount: 5,
      retryDelays: [500, 1000, 1500, 2000, 3000],
      alternatives: ['wait_and_retry', 'force_unlock']
    },
    service_unavailable: {
      pattern: /503|service unavailable|connection refused/i,
      retryCount: 3,
      retryDelays: [2000, 5000, 10000],
      alternatives: ['restart_service']
    }
  },

  // æ™ºèƒ½é‡è¯•æ‰§è¡Œå™¨
  executeWithRetry: async (operation, context = {}) => {
    let lastError = null;
    
    for (let attempt = 0; attempt <= 3; attempt++) {
      try {
        if (attempt > 0) {
          console.log(`ğŸ”„ é‡è¯•ç¬¬${attempt}æ¬¡: ${operation.name}`);
        }
        
        const result = await operation.execute(context);
        
        if (attempt > 0) {
          console.log(`âœ… é‡è¯•æˆåŠŸ: ${operation.name} (ç¬¬${attempt}æ¬¡é‡è¯•)`);
        }
        
        return result;
      } catch (error) {
        lastError = error;
        
        const failurePattern = INTELLIGENT_RETRY_SYSTEM.analyzeFailure(error);
        
        if (failurePattern && attempt < failurePattern.retryCount) {
          const delay = failurePattern.retryDelays[attempt] || 1000;
          console.log(`â° è¯†åˆ«å¤±è´¥æ¨¡å¼: ${failurePattern.name}ï¼Œ${delay}msåé‡è¯•...`);
          await new Promise(resolve => setTimeout(resolve, delay));
          continue;
        }
        
        // å°è¯•æ›¿ä»£æ–¹æ¡ˆ
        if (failurePattern?.alternatives?.length > 0) {
          for (const alternative of failurePattern.alternatives) {
            try {
              console.log(`ğŸ”„ å°è¯•æ›¿ä»£æ–¹æ¡ˆ: ${alternative}`);
              const result = await INTELLIGENT_RETRY_SYSTEM.tryAlternative(alternative, operation, context);
              console.log(`âœ… æ›¿ä»£æ–¹æ¡ˆæˆåŠŸ: ${alternative}`);
              return result;
            } catch (altError) {
              console.warn(`âš ï¸ æ›¿ä»£æ–¹æ¡ˆå¤±è´¥: ${alternative}`);
            }
          }
        }
        
        break;
      }
    }
    
    throw new Error(`æ“ä½œæœ€ç»ˆå¤±è´¥: ${lastError.message}`);
  },

  // å¤±è´¥æ¨¡å¼åˆ†æ
  analyzeFailure: (error) => {
    const errorMessage = error.message || error.toString();
    
    for (const [name, pattern] of Object.entries(INTELLIGENT_RETRY_SYSTEM.failurePatterns)) {
      if (pattern.pattern.test(errorMessage)) {
        return { name, ...pattern };
      }
    }
    
    return null;
  },

  // æ›¿ä»£æ–¹æ¡ˆæ‰§è¡Œ
  tryAlternative: async (alternative, originalOperation, context) => {
    switch (alternative) {
      case 'local_cache':
        return await UNIFIED_STATUS_CACHE_SYSTEM.checkWithCache(
          originalOperation.type, 
          () => { throw new Error('Using cached fallback'); }
        );
      
      case 'restart_service':
        console.log('ğŸ”„ é‡å¯æœåŠ¡ä½œä¸ºæ›¿ä»£æ–¹æ¡ˆ...');
        await context.restartService?.();
        return await originalOperation.execute(context);
      
      default:
        throw new Error(`æœªå®ç°çš„æ›¿ä»£æ–¹æ¡ˆ: ${alternative}`);
    }
  }
};
```

## ğŸ“Š **å·¥å…·è°ƒç”¨æ•ˆç‡ç›‘æ§ä»ªè¡¨æ¿**

### **å®æ—¶æ•ˆç‡ç›‘æ§å’Œåˆ†æ**
```javascript
// åŸºäºå®é™…æ•ˆç‡é—®é¢˜çš„ç›‘æ§ä»ªè¡¨æ¿
const EFFICIENCY_MONITOR_DASHBOARD = {
  // å®æ—¶ç»Ÿè®¡æŒ‡æ ‡
  metrics: {
    totalCalls: 0,
    successfulCalls: 0,
    cachedCalls: 0,
    parallelCalls: 0,
    totalTime: 0,
    efficiency: 0
  },

  // è®°å½•å·¥å…·è°ƒç”¨
  recordCall: (toolType, duration, success, cached = false, parallel = false) => {
    const m = EFFICIENCY_MONITOR_DASHBOARD.metrics;
    
    m.totalCalls++;
    m.totalTime += duration;
    
    if (success) m.successfulCalls++;
    if (cached) m.cachedCalls++;
    if (parallel) m.parallelCalls++;

    // è®¡ç®—ç»¼åˆæ•ˆç‡æŒ‡æ ‡
    m.efficiency = (m.successfulCalls / m.totalCalls) * 
                  (m.cachedCalls / m.totalCalls * 0.3 + 0.7) *
                  (m.parallelCalls / m.totalCalls * 0.2 + 0.8);

    // æ¯10æ¬¡è°ƒç”¨æŠ¥å‘Šä¸€æ¬¡
    if (m.totalCalls % 10 === 0) {
      EFFICIENCY_MONITOR_DASHBOARD.generateReport();
    }
  },

  // æ•ˆç‡æŠ¥å‘Šç”Ÿæˆ
  generateReport: () => {
    const m = EFFICIENCY_MONITOR_DASHBOARD.metrics;
    const avgTime = m.totalTime / m.totalCalls;
    
    console.log('\nğŸ“Š å·¥å…·è°ƒç”¨æ•ˆç‡æŠ¥å‘Š');
    console.log('='.repeat(40));
    console.log(`æ€»è°ƒç”¨: ${m.totalCalls}, æˆåŠŸç‡: ${(m.successfulCalls/m.totalCalls*100).toFixed(1)}%`);
    console.log(`ç¼“å­˜ç‡: ${(m.cachedCalls/m.totalCalls*100).toFixed(1)}%, å¹¶è¡Œç‡: ${(m.parallelCalls/m.totalCalls*100).toFixed(1)}%`);
    console.log(`å¹³å‡è€—æ—¶: ${avgTime.toFixed(0)}ms, ç»¼åˆæ•ˆç‡: ${(m.efficiency*100).toFixed(1)}%`);
    
    // æ•ˆç‡è¯„çº§
    let grade = 'F', suggestion = '';
    if (m.efficiency >= 0.9) { grade = 'A'; suggestion = 'æ•ˆç‡ä¼˜ç§€ï¼Œç»§ç»­ä¿æŒ'; }
    else if (m.efficiency >= 0.8) { grade = 'B'; suggestion = 'æ•ˆç‡è‰¯å¥½ï¼Œå¯ä¼˜åŒ–å¹¶è¡ŒåŒ–'; }
    else if (m.efficiency >= 0.7) { grade = 'C'; suggestion = 'æ•ˆç‡ä¸€èˆ¬ï¼Œéœ€å¢åŠ ç¼“å­˜'; }
    else if (m.efficiency >= 0.6) { grade = 'D'; suggestion = 'æ•ˆç‡è¾ƒä½ï¼Œå‡å°‘é‡å¤è°ƒç”¨'; }
    else { grade = 'F'; suggestion = 'æ•ˆç‡ä¸¥é‡ä¸è¶³ï¼Œå…¨é¢ä¼˜åŒ–'; }
    
    console.log(`è¯„çº§: ${grade} | å»ºè®®: ${suggestion}`);
    console.log('='.repeat(40));
  },

  // ä¸cursoråŸºå‡†æ•°æ®å¯¹æ¯”
  compareWithBaseline: () => {
    const m = EFFICIENCY_MONITOR_DASHBOARD.metrics;
    
    // åŸºäºå®é™…cursoræ–‡æ¡£çš„åŸºå‡†æ•°æ®
    const baseline = { calls: 173, time: 4800000, efficiency: 0.21 }; // å¹³å‡å€¼
    
    const improvement = {
      calls: (baseline.calls - m.totalCalls) / baseline.calls,
      time: (baseline.time - m.totalTime) / baseline.time,  
      efficiency: (m.efficiency - baseline.efficiency) / baseline.efficiency
    };

    console.log('\nğŸ“ˆ ä¸cursoråŸºå‡†å¯¹æ¯”');
    console.log(`è°ƒç”¨ä¼˜åŒ–: ${(improvement.calls * 100).toFixed(1)}%`);
    console.log(`æ—¶é—´ä¼˜åŒ–: ${(improvement.time * 100).toFixed(1)}%`);
    console.log(`æ•ˆç‡æå‡: ${(improvement.efficiency * 100).toFixed(1)}%`);
  }
};
```

## ğŸ› ï¸ **å·¥å…·é€‰æ‹©æ™ºèƒ½ä¼˜åŒ–**

### **åŸºäºæ•ˆç‡æ•°æ®çš„æœ€ä¼˜å·¥å…·é€‰æ‹©**
```javascript
const SMART_TOOL_SELECTOR = {
  // å·¥å…·æ•ˆç‡ç»Ÿè®¡æ•°æ®åº“
  toolStats: {
    'curl_health_check': { successRate: 0.90, avgTime: 1500, cacheability: 'HIGH' },
    'pm2_status': { successRate: 0.95, avgTime: 1000, cacheability: 'HIGH' },
    'process_check': { successRate: 0.95, avgTime: 1000, cacheability: 'MEDIUM' },
    'file_read': { successRate: 0.99, avgTime: 500, cacheability: 'LOW' },
    'database_check': { successRate: 0.85, avgTime: 3000, cacheability: 'HIGH' }
  },

  // æ™ºèƒ½å·¥å…·é€‰æ‹©ç®—æ³•
  selectOptimal: (purpose, constraints = {}) => {
    const candidates = Object.entries(SMART_TOOL_SELECTOR.toolStats)
      .filter(([tool, stats]) => {
        // æ ¹æ®ç”¨é€”è¿‡æ»¤å·¥å…·
        if (purpose === 'health_check' && !tool.includes('health')) return false;
        if (purpose === 'process_status' && !tool.includes('process')) return false;
        return true;
      })
      .map(([tool, stats]) => {
        // è®¡ç®—ç»¼åˆè¯„åˆ†
        const score = stats.successRate * 0.5 + 
                     (4000 - stats.avgTime) / 4000 * 0.3 +
                     (stats.cacheability === 'HIGH' ? 0.2 : stats.cacheability === 'MEDIUM' ? 0.1 : 0);
        
        return { tool, stats, score };
      })
      .sort((a, b) => b.score - a.score);

    const selected = candidates[0];
    console.log(`ğŸ¯ æœ€ä¼˜å·¥å…·é€‰æ‹©: ${selected.tool} (è¯„åˆ†: ${selected.score.toFixed(2)})`);
    
    return selected;
  }
};
```

## ğŸ“ˆ **å·¥å…·è°ƒç”¨æ•ˆç‡è‡ªåŠ¨åŒ–è„šæœ¬**

### **ä¸€é”®æ•ˆç‡ä¼˜åŒ–æ‰§è¡Œè„šæœ¬**
```bash
#!/bin/bash
# å·¥å…·è°ƒç”¨æ•ˆç‡ä¼˜åŒ–è‡ªåŠ¨æ‰§è¡Œè„šæœ¬

echo "âš¡ å¯åŠ¨å·¥å…·è°ƒç”¨æ•ˆç‡ä¼˜åŒ–..."

# 1. è®¾ç½®ä¼šè¯é¢„ç®—ï¼ˆæ ¹æ®ä»»åŠ¡å¤æ‚åº¦ï¼‰
TASK_COMPLEXITY=${1:-"medium_debug_task"}
echo "ğŸ’° è®¾ç½®é¢„ç®—: $TASK_COMPLEXITY"

# 2. å¯åŠ¨å¹¶è¡ŒçŠ¶æ€æ£€æŸ¥ï¼ˆæ›¿ä»£ä¸²è¡Œæ£€æŸ¥ï¼‰
echo "ğŸš€ æ‰§è¡Œå¹¶è¡ŒçŠ¶æ€æ£€æŸ¥..."
{
  timeout 30s curl -s http://localhost:3000/health &
  timeout 10s pm2 status &
  timeout 10s netstat -tlnp | grep :3000 &
  timeout 10s ps aux | grep node &
} | tee parallel_check_results.log
wait

# 3. åˆ†ææ£€æŸ¥ç»“æœå¹¶ç¼“å­˜
echo "ğŸ’¾ ç¼“å­˜æ£€æŸ¥ç»“æœ..."
HEALTH_STATUS=$(grep '"status"' parallel_check_results.log | head -1)
PM2_STATUS=$(grep -E "(online|stopped)" parallel_check_results.log | head -1)

# 4. åŸºäºç»“æœæ™ºèƒ½å†³ç­–ï¼ˆé¿å…é¢å¤–å·¥å…·è°ƒç”¨ï¼‰
if [[ $HEALTH_STATUS =~ "healthy" && $PM2_STATUS =~ "online" ]]; then
  echo "âœ… ç³»ç»ŸçŠ¶æ€æ­£å¸¸ï¼Œæ— éœ€é¢å¤–æ£€æŸ¥"
  NEED_REPAIR=false
else
  echo "âš ï¸ æ£€æµ‹åˆ°é—®é¢˜ï¼Œéœ€è¦ä¿®å¤"
  NEED_REPAIR=true
fi

# 5. æ¸…ç†ä¸´æ—¶æ–‡ä»¶
rm -f parallel_check_results.log

echo "ğŸ“Š æ•ˆç‡ä¼˜åŒ–å®Œæˆï¼Œå·²é¿å…é‡å¤æ£€æŸ¥"
```

## ğŸ›ï¸ **æ•ˆç‡æ§åˆ¶å‚æ•°é…ç½®**

### **å…³é”®æ•ˆç‡æŒ‡æ ‡å’Œé˜ˆå€¼è®¾å®š**
```javascript
const EFFICIENCY_CONTROL_CONFIG = {
  // æ•ˆç‡æŒ‡æ ‡é˜ˆå€¼
  thresholds: {
    maxToolCalls: {
      simple: 20,      // ç®€å•ä»»åŠ¡æœ€å¤š20æ¬¡è°ƒç”¨
      medium: 50,      // ä¸­ç­‰ä»»åŠ¡æœ€å¤š50æ¬¡è°ƒç”¨  
      complex: 100     // å¤æ‚ä»»åŠ¡æœ€å¤š100æ¬¡è°ƒç”¨
    },
    maxRepeatRate: 0.1,        // é‡å¤ç‡ä¸è¶…è¿‡10%
    minParallelRate: 0.6,      // å¹¶è¡Œç‡ä¸ä½äº60%
    minCacheHitRate: 0.3,      // ç¼“å­˜å‘½ä¸­ç‡ä¸ä½äº30%
    maxSingleCallTime: 30000   // å•æ¬¡è°ƒç”¨ä¸è¶…è¿‡30ç§’
  },

  // å®æ—¶ç›‘æ§å’Œå‘Šè­¦
  monitor: () => {
    const m = EFFICIENCY_MONITOR_DASHBOARD.metrics;
    const config = EFFICIENCY_CONTROL_CONFIG.thresholds;
    
    // æ£€æŸ¥å„é¡¹æŒ‡æ ‡
    const alerts = [];
    
    if (m.totalCalls > config.maxToolCalls.medium) {
      alerts.push(`âš ï¸ å·¥å…·è°ƒç”¨æ¬¡æ•°è¶…æ ‡: ${m.totalCalls} > ${config.maxToolCalls.medium}`);
    }
    
    const repeatRate = 1 - (m.cachedCalls / m.totalCalls);
    if (repeatRate > config.maxRepeatRate) {
      alerts.push(`âš ï¸ é‡å¤ç‡è¿‡é«˜: ${(repeatRate*100).toFixed(1)}% > ${config.maxRepeatRate*100}%`);
    }

    const parallelRate = m.parallelCalls / m.totalCalls;
    if (parallelRate < config.minParallelRate) {
      alerts.push(`âš ï¸ å¹¶è¡Œç‡è¿‡ä½: ${(parallelRate*100).toFixed(1)}% < ${config.minParallelRate*100}%`);
    }

    // è¾“å‡ºå‘Šè­¦ä¿¡æ¯
    if (alerts.length > 0) {
      console.warn('ğŸš¨ æ•ˆç‡å‘Šè­¦:');
      alerts.forEach(alert => console.warn(`   ${alert}`));
    }

    return alerts;
  }
};
```

## ğŸ“‹ **å·¥å…·è°ƒç”¨ä¼˜åŒ–å®æ–½æ£€æŸ¥æ¸…å•**

### **æ¯æ¬¡ä¼šè¯å¼€å§‹å‰**
- [ ] æ ¹æ®ä»»åŠ¡å¤æ‚åº¦åˆ†é…å·¥å…·è°ƒç”¨é¢„ç®—
- [ ] å¯ç”¨çŠ¶æ€æ£€æŸ¥ç¼“å­˜ç³»ç»Ÿ
- [ ] è¯†åˆ«å¯å¹¶è¡Œæ‰§è¡Œçš„æ“ä½œç±»å‹
- [ ] è®¾ç½®æ•ˆç‡ç›‘æ§æŒ‡æ ‡é˜ˆå€¼

### **æ¯æ¬¡å·¥å…·è°ƒç”¨å‰**  
- [ ] æ£€æŸ¥æ˜¯å¦æœ‰ç¼“å­˜ç»“æœå¯ç”¨
- [ ] è¯„ä¼°æ˜¯å¦å¯ä¸å…¶ä»–æ“ä½œå¹¶è¡Œ
- [ ] éªŒè¯è°ƒç”¨çš„å¿…è¦æ€§å’Œå”¯ä¸€æ€§
- [ ] è®¾ç½®åˆç†çš„è¶…æ—¶é™åˆ¶

### **æ¯æ¬¡å·¥å…·è°ƒç”¨å**
- [ ] è®°å½•è°ƒç”¨ç»“æœå’Œæ€§èƒ½æ•°æ®
- [ ] æ›´æ–°ç›¸å…³ç¼“å­˜ä¿¡æ¯
- [ ] æ£€æŸ¥é¢„ç®—ä½¿ç”¨æƒ…å†µ
- [ ] åˆ†ææ˜¯å¦éœ€è¦ä¼˜åŒ–ç­–ç•¥

### **æ¯æ¬¡ä¼šè¯ç»“æŸå**
- [ ] ç”Ÿæˆæ•ˆç‡æŠ¥å‘Šå’Œå¯¹æ¯”åˆ†æ
- [ ] è¯†åˆ«é‡å¤å’Œä½æ•ˆè°ƒç”¨æ¨¡å¼
- [ ] è®°å½•ä¼˜åŒ–å»ºè®®å’Œæ”¹è¿›æœºä¼š
- [ ] æ›´æ–°å·¥å…·æ•ˆç‡ç»Ÿè®¡æ•°æ®

---

**æ ¸å¿ƒåŸåˆ™**: ç¼“å­˜ä¼˜å…ˆå¤ç”¨ã€å¹¶è¡Œæ‰§è¡Œæœ€å¤§åŒ–ã€æ™ºèƒ½é‡è¯•ç­–ç•¥ã€æ•ˆç‡å®æ—¶ç›‘æ§ã€é¢„ç®—ä¸¥æ ¼æ§åˆ¶